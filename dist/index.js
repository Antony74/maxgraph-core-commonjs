"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const fsp = require("fs/promises");
const require$$1 = require("path");
class ImageBox {
  constructor(src, width, height) {
    this.src = src;
    this.width = width;
    this.height = height;
  }
}
class EventObject {
  constructor(name = "", ...args) {
    this.consumed = false;
    this.name = name;
    this.properties = {};
    if (!!args[0] && args[0].constructor === Object) {
      for (const [key, value] of Object.entries(args[0])) {
        this.properties[key] = value;
      }
    } else {
      for (let i = 0; i < args.length; i += 2) {
        if (args[i + 1] !== null) {
          this.properties[args[i]] = args[i + 1];
        }
      }
    }
  }
  /**
   * Returns <name>.
   */
  getName() {
    return this.name;
  }
  /**
   * Returns <properties>.
   */
  getProperties() {
    return this.properties;
  }
  /**
   * Returns the property for the given key.
   */
  getProperty(key) {
    return this.properties[key];
  }
  /**
   * Returns true if the event has been consumed.
   */
  isConsumed() {
    return this.consumed;
  }
  /**
   * Consumes the event.
   */
  consume() {
    this.consumed = true;
  }
}
class EventSource {
  constructor(eventSource = null) {
    this.eventListeners = [];
    this.eventsEnabled = true;
    this.eventSource = null;
    this.eventSource = eventSource;
  }
  /**
   * Returns <eventsEnabled>.
   */
  isEventsEnabled() {
    return this.eventsEnabled;
  }
  /**
   * Sets <eventsEnabled>.
   */
  setEventsEnabled(value) {
    this.eventsEnabled = value;
  }
  /**
   * Returns <eventSource>.
   */
  getEventSource() {
    return this.eventSource;
  }
  /**
   * Sets <eventSource>.
   */
  setEventSource(value) {
    this.eventSource = value;
  }
  /**
   * Binds the specified function to the given event name. If no event name
   * is given, then the listener is registered for all events.
   *
   * The parameters of the listener are the sender and an {@link EventObject}.
   */
  addListener(name, funct) {
    this.eventListeners.push({ name, funct });
  }
  /**
   * Removes all occurrences of the given listener from <eventListeners>.
   */
  removeListener(funct) {
    let i = 0;
    while (i < this.eventListeners.length) {
      if (this.eventListeners[i].funct === funct) {
        this.eventListeners.splice(i, 1);
      } else {
        i += 1;
      }
    }
  }
  /**
   * Dispatches the given event to the listeners which are registered for
   * the event. The sender argument is optional. The current execution scope
   * ("this") is used for the listener invocation (see {@link Utils#bind}).
   *
   * Example:
   *
   * ```javascript
   * fireEvent(new mxEventObject("eventName", key1, val1, .., keyN, valN))
   * ```
   *
   * @param evt {@link EventObject} that represents the event.
   * @param sender Optional sender to be passed to the listener. Default value is
   * the return value of <getEventSource>.
   */
  fireEvent(evt, sender = null) {
    if (this.isEventsEnabled()) {
      if (!evt) {
        evt = new EventObject("");
      }
      if (!sender) {
        sender = this.getEventSource();
      }
      if (!sender) {
        sender = this;
      }
      for (const eventListener of this.eventListeners) {
        if (eventListener.name === null || eventListener.name === evt.getName()) {
          eventListener.funct.apply(this, [sender, evt]);
        }
      }
    }
  }
}
const VERSION = "0.17.0";
const DEFAULT_HOTSPOT = 0.3;
const MIN_HOTSPOT_SIZE = 8;
const MAX_HOTSPOT_SIZE = 0;
var RENDERING_HINT;
(function(RENDERING_HINT2) {
  RENDERING_HINT2["EXACT"] = "exact";
  RENDERING_HINT2["FASTER"] = "faster";
  RENDERING_HINT2["FASTEST"] = "fastest";
})(RENDERING_HINT || (RENDERING_HINT = {}));
var DIALECT;
(function(DIALECT2) {
  DIALECT2["SVG"] = "svg";
  DIALECT2["MIXEDHTML"] = "mixedHtml";
  DIALECT2["PREFERHTML"] = "preferHtml";
  DIALECT2["STRICTHTML"] = "strictHtml";
})(DIALECT || (DIALECT = {}));
const IDENTITY_FIELD_NAME = "mxObjectId";
const NS_SVG = "http://www.w3.org/2000/svg";
const NS_XLINK = "http://www.w3.org/1999/xlink";
const SHADOWCOLOR = "gray";
const SHADOW_OFFSET_X = 2;
const SHADOW_OFFSET_Y = 3;
const SHADOW_OPACITY = 1;
var NODETYPE;
(function(NODETYPE2) {
  NODETYPE2[NODETYPE2["ELEMENT"] = 1] = "ELEMENT";
  NODETYPE2[NODETYPE2["ATTRIBUTE"] = 2] = "ATTRIBUTE";
  NODETYPE2[NODETYPE2["TEXT"] = 3] = "TEXT";
  NODETYPE2[NODETYPE2["CDATA"] = 4] = "CDATA";
  NODETYPE2[NODETYPE2["ENTITY_REFERENCE"] = 5] = "ENTITY_REFERENCE";
  NODETYPE2[NODETYPE2["ENTITY"] = 6] = "ENTITY";
  NODETYPE2[NODETYPE2["PROCESSING_INSTRUCTION"] = 7] = "PROCESSING_INSTRUCTION";
  NODETYPE2[NODETYPE2["COMMENT"] = 8] = "COMMENT";
  NODETYPE2[NODETYPE2["DOCUMENT"] = 9] = "DOCUMENT";
  NODETYPE2[NODETYPE2["DOCUMENTTYPE"] = 10] = "DOCUMENTTYPE";
  NODETYPE2[NODETYPE2["DOCUMENT_FRAGMENT"] = 11] = "DOCUMENT_FRAGMENT";
  NODETYPE2[NODETYPE2["NOTATION"] = 12] = "NOTATION";
})(NODETYPE || (NODETYPE = {}));
const TOOLTIP_VERTICAL_OFFSET = 16;
const DEFAULT_VALID_COLOR = "#00FF00";
const DEFAULT_INVALID_COLOR = "#FF0000";
const OUTLINE_HIGHLIGHT_COLOR = "#00FF00";
const OUTLINE_HIGHLIGHT_STROKEWIDTH = 5;
const HIGHLIGHT_STROKEWIDTH = 3;
const HIGHLIGHT_SIZE = 2;
const HIGHLIGHT_OPACITY = 100;
var CURSOR;
(function(CURSOR2) {
  CURSOR2["MOVABLE_VERTEX"] = "move";
  CURSOR2["MOVABLE_EDGE"] = "move";
  CURSOR2["LABEL_HANDLE"] = "default";
  CURSOR2["TERMINAL_HANDLE"] = "pointer";
  CURSOR2["BEND_HANDLE"] = "crosshair";
  CURSOR2["VIRTUAL_BEND_HANDLE"] = "crosshair";
  CURSOR2["CONNECT"] = "pointer";
})(CURSOR || (CURSOR = {}));
const HIGHLIGHT_COLOR = "#00FF00";
const CONNECT_TARGET_COLOR = "#0000FF";
const INVALID_CONNECT_TARGET_COLOR = "#FF0000";
const DROP_TARGET_COLOR = "#0000FF";
const VALID_COLOR = "#00FF00";
const INVALID_COLOR = "#FF0000";
const EDGE_SELECTION_COLOR = "#00FF00";
const VERTEX_SELECTION_COLOR = "#00FF00";
const VERTEX_SELECTION_STROKEWIDTH = 1;
const EDGE_SELECTION_STROKEWIDTH = 1;
const VERTEX_SELECTION_DASHED = true;
const EDGE_SELECTION_DASHED = true;
const GUIDE_COLOR = "#FF0000";
const GUIDE_STROKEWIDTH = 1;
const OUTLINE_COLOR = "#0099FF";
const OUTLINE_STROKEWIDTH = 3;
const HANDLE_SIZE = 6;
const LABEL_HANDLE_SIZE = 4;
const HANDLE_FILLCOLOR = "#00FF00";
const HANDLE_STROKECOLOR = "black";
const LABEL_HANDLE_FILLCOLOR = "yellow";
const CONNECT_HANDLE_FILLCOLOR = "#0000FF";
const LOCKED_HANDLE_FILLCOLOR = "#FF0000";
const OUTLINE_HANDLE_FILLCOLOR = "#00FFFF";
const OUTLINE_HANDLE_STROKECOLOR = "#0033FF";
const DEFAULT_FONTFAMILY = "Arial,Helvetica";
const DEFAULT_FONTSIZE = 11;
const DEFAULT_TEXT_DIRECTION = "";
const LINE_HEIGHT = 1.2;
const WORD_WRAP = "normal";
const ABSOLUTE_LINE_HEIGHT = false;
const DEFAULT_FONTSTYLE = 0;
const DEFAULT_STARTSIZE = 40;
const DEFAULT_MARKERSIZE = 6;
const DEFAULT_IMAGESIZE = 24;
const ENTITY_SEGMENT = 30;
const RECTANGLE_ROUNDING_FACTOR = 0.15;
const LINE_ARCSIZE = 20;
const ARROW_SPACING = 0;
const ARROW_WIDTH = 30;
const ARROW_SIZE = 30;
const PAGE_FORMAT_A4_PORTRAIT = [0, 0, 827, 1169];
const PAGE_FORMAT_A4_LANDSCAPE = [0, 0, 1169, 827];
const PAGE_FORMAT_LETTER_PORTRAIT = [0, 0, 850, 1100];
const PAGE_FORMAT_LETTER_LANDSCAPE = [0, 0, 1100, 850];
const NONE = "none";
var FONT;
(function(FONT2) {
  FONT2[FONT2["BOLD"] = 1] = "BOLD";
  FONT2[FONT2["ITALIC"] = 2] = "ITALIC";
  FONT2[FONT2["UNDERLINE"] = 4] = "UNDERLINE";
  FONT2[FONT2["STRIKETHROUGH"] = 8] = "STRIKETHROUGH";
})(FONT || (FONT = {}));
var ARROW;
(function(ARROW2) {
  ARROW2["CLASSIC"] = "classic";
  ARROW2["CLASSIC_THIN"] = "classicThin";
  ARROW2["BLOCK"] = "block";
  ARROW2["BLOCK_THIN"] = "blockThin";
  ARROW2["OPEN"] = "open";
  ARROW2["OPEN_THIN"] = "openThin";
  ARROW2["OVAL"] = "oval";
  ARROW2["DIAMOND"] = "diamond";
  ARROW2["DIAMOND_THIN"] = "diamondThin";
})(ARROW || (ARROW = {}));
var ALIGN;
(function(ALIGN2) {
  ALIGN2["LEFT"] = "left";
  ALIGN2["CENTER"] = "center";
  ALIGN2["RIGHT"] = "right";
  ALIGN2["TOP"] = "top";
  ALIGN2["MIDDLE"] = "middle";
  ALIGN2["BOTTOM"] = "bottom";
})(ALIGN || (ALIGN = {}));
var DIRECTION;
(function(DIRECTION2) {
  DIRECTION2["NORTH"] = "north";
  DIRECTION2["SOUTH"] = "south";
  DIRECTION2["EAST"] = "east";
  DIRECTION2["WEST"] = "west";
})(DIRECTION || (DIRECTION = {}));
var TEXT_DIRECTION;
(function(TEXT_DIRECTION2) {
  TEXT_DIRECTION2["DEFAULT"] = "";
  TEXT_DIRECTION2["AUTO"] = "auto";
  TEXT_DIRECTION2["LTR"] = "ltr";
  TEXT_DIRECTION2["RTL"] = "rtl";
})(TEXT_DIRECTION || (TEXT_DIRECTION = {}));
const DIRECTION_MASK = {
  /** No direction. */
  NONE: 0,
  WEST: 1,
  NORTH: 2,
  SOUTH: 4,
  EAST: 8,
  /** All directions. */
  ALL: 15
};
var ELBOW;
(function(ELBOW2) {
  ELBOW2["VERTICAL"] = "vertical";
  ELBOW2["HORIZONTAL"] = "horizontal";
})(ELBOW || (ELBOW = {}));
var EDGESTYLE;
(function(EDGESTYLE2) {
  EDGESTYLE2["ELBOW"] = "elbowEdgeStyle";
  EDGESTYLE2["ENTITY_RELATION"] = "entityRelationEdgeStyle";
  EDGESTYLE2["LOOP"] = "loopEdgeStyle";
  EDGESTYLE2["SIDETOSIDE"] = "sideToSideEdgeStyle";
  EDGESTYLE2["TOPTOBOTTOM"] = "topToBottomEdgeStyle";
  EDGESTYLE2["ORTHOGONAL"] = "orthogonalEdgeStyle";
  EDGESTYLE2["SEGMENT"] = "segmentEdgeStyle";
  EDGESTYLE2["MANHATTAN"] = "manhattanEdgeStyle";
})(EDGESTYLE || (EDGESTYLE = {}));
var PERIMETER;
(function(PERIMETER2) {
  PERIMETER2["ELLIPSE"] = "ellipsePerimeter";
  PERIMETER2["RECTANGLE"] = "rectanglePerimeter";
  PERIMETER2["RHOMBUS"] = "rhombusPerimeter";
  PERIMETER2["HEXAGON"] = "hexagonPerimeter";
  PERIMETER2["TRIANGLE"] = "trianglePerimeter";
})(PERIMETER || (PERIMETER = {}));
var SHAPE;
(function(SHAPE2) {
  SHAPE2["RECTANGLE"] = "rectangle";
  SHAPE2["ELLIPSE"] = "ellipse";
  SHAPE2["DOUBLE_ELLIPSE"] = "doubleEllipse";
  SHAPE2["RHOMBUS"] = "rhombus";
  SHAPE2["LINE"] = "line";
  SHAPE2["IMAGE"] = "image";
  SHAPE2["ARROW"] = "arrow";
  SHAPE2["ARROW_CONNECTOR"] = "arrowConnector";
  SHAPE2["LABEL"] = "label";
  SHAPE2["CYLINDER"] = "cylinder";
  SHAPE2["SWIMLANE"] = "swimlane";
  SHAPE2["CONNECTOR"] = "connector";
  SHAPE2["ACTOR"] = "actor";
  SHAPE2["CLOUD"] = "cloud";
  SHAPE2["TRIANGLE"] = "triangle";
  SHAPE2["HEXAGON"] = "hexagon";
})(SHAPE || (SHAPE = {}));
const Constants = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ABSOLUTE_LINE_HEIGHT,
  get ALIGN() {
    return ALIGN;
  },
  get ARROW() {
    return ARROW;
  },
  ARROW_SIZE,
  ARROW_SPACING,
  ARROW_WIDTH,
  CONNECT_HANDLE_FILLCOLOR,
  CONNECT_TARGET_COLOR,
  get CURSOR() {
    return CURSOR;
  },
  DEFAULT_FONTFAMILY,
  DEFAULT_FONTSIZE,
  DEFAULT_FONTSTYLE,
  DEFAULT_HOTSPOT,
  DEFAULT_IMAGESIZE,
  DEFAULT_INVALID_COLOR,
  DEFAULT_MARKERSIZE,
  DEFAULT_STARTSIZE,
  DEFAULT_TEXT_DIRECTION,
  DEFAULT_VALID_COLOR,
  get DIALECT() {
    return DIALECT;
  },
  get DIRECTION() {
    return DIRECTION;
  },
  DIRECTION_MASK,
  DROP_TARGET_COLOR,
  get EDGESTYLE() {
    return EDGESTYLE;
  },
  EDGE_SELECTION_COLOR,
  EDGE_SELECTION_DASHED,
  EDGE_SELECTION_STROKEWIDTH,
  get ELBOW() {
    return ELBOW;
  },
  ENTITY_SEGMENT,
  get FONT() {
    return FONT;
  },
  GUIDE_COLOR,
  GUIDE_STROKEWIDTH,
  HANDLE_FILLCOLOR,
  HANDLE_SIZE,
  HANDLE_STROKECOLOR,
  HIGHLIGHT_COLOR,
  HIGHLIGHT_OPACITY,
  HIGHLIGHT_SIZE,
  HIGHLIGHT_STROKEWIDTH,
  IDENTITY_FIELD_NAME,
  INVALID_COLOR,
  INVALID_CONNECT_TARGET_COLOR,
  LABEL_HANDLE_FILLCOLOR,
  LABEL_HANDLE_SIZE,
  LINE_ARCSIZE,
  LINE_HEIGHT,
  LOCKED_HANDLE_FILLCOLOR,
  MAX_HOTSPOT_SIZE,
  MIN_HOTSPOT_SIZE,
  get NODETYPE() {
    return NODETYPE;
  },
  NONE,
  NS_SVG,
  NS_XLINK,
  OUTLINE_COLOR,
  OUTLINE_HANDLE_FILLCOLOR,
  OUTLINE_HANDLE_STROKECOLOR,
  OUTLINE_HIGHLIGHT_COLOR,
  OUTLINE_HIGHLIGHT_STROKEWIDTH,
  OUTLINE_STROKEWIDTH,
  PAGE_FORMAT_A4_LANDSCAPE,
  PAGE_FORMAT_A4_PORTRAIT,
  PAGE_FORMAT_LETTER_LANDSCAPE,
  PAGE_FORMAT_LETTER_PORTRAIT,
  get PERIMETER() {
    return PERIMETER;
  },
  RECTANGLE_ROUNDING_FACTOR,
  get RENDERING_HINT() {
    return RENDERING_HINT;
  },
  SHADOWCOLOR,
  SHADOW_OFFSET_X,
  SHADOW_OFFSET_Y,
  SHADOW_OPACITY,
  get SHAPE() {
    return SHAPE;
  },
  get TEXT_DIRECTION() {
    return TEXT_DIRECTION;
  },
  TOOLTIP_VERTICAL_OFFSET,
  VALID_COLOR,
  VERSION,
  VERTEX_SELECTION_COLOR,
  VERTEX_SELECTION_DASHED,
  VERTEX_SELECTION_STROKEWIDTH,
  WORD_WRAP
}, Symbol.toStringTag, { value: "Module" }));
class Client {
}
Client.basePath = ".";
Client.setBasePath = (value) => {
  if (typeof value !== "undefined" && value.length > 0) {
    if (value.substring(value.length - 1) === "/") {
      value = value.substring(0, value.length - 1);
    }
    Client.basePath = value;
  } else {
    Client.basePath = ".";
  }
};
Client.imageBasePath = ".";
Client.setImageBasePath = (value) => {
  if (typeof value !== "undefined" && value.length > 0) {
    if (value.substring(value.length - 1) === "/") {
      value = value.substring(0, value.length - 1);
    }
    Client.imageBasePath = value;
  } else {
    Client.imageBasePath = `${Client.basePath}/images`;
  }
};
Client.IS_EDGE = typeof window !== "undefined" && navigator.userAgent != null && !!navigator.userAgent.match(/Edge\//);
Client.IS_NS = typeof window !== "undefined" && navigator.userAgent != null && navigator.userAgent.indexOf("Mozilla/") >= 0 && navigator.userAgent.indexOf("MSIE") < 0 && navigator.userAgent.indexOf("Edge/") < 0;
Client.IS_SF = typeof window !== "undefined" && /Apple Computer, Inc/.test(navigator.vendor);
Client.IS_ANDROID = typeof window !== "undefined" && navigator.appVersion.indexOf("Android") >= 0;
Client.IS_IOS = typeof window !== "undefined" && /iP(hone|od|ad)/.test(navigator.platform);
Client.IS_GC = typeof window !== "undefined" && /Google Inc/.test(navigator.vendor);
Client.IS_CHROMEAPP = typeof window !== "undefined" && // @ts-ignore
window.chrome != null && // @ts-ignore
chrome.app != null && // @ts-ignore
chrome.app.runtime != null;
Client.IS_FF = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
Client.IS_MT = typeof window !== "undefined" && (navigator.userAgent.indexOf("Firefox/") >= 0 && navigator.userAgent.indexOf("Firefox/1.") < 0 && navigator.userAgent.indexOf("Firefox/2.") < 0 || navigator.userAgent.indexOf("Iceweasel/") >= 0 && navigator.userAgent.indexOf("Iceweasel/1.") < 0 && navigator.userAgent.indexOf("Iceweasel/2.") < 0 || navigator.userAgent.indexOf("SeaMonkey/") >= 0 && navigator.userAgent.indexOf("SeaMonkey/1.") < 0 || navigator.userAgent.indexOf("Iceape/") >= 0 && navigator.userAgent.indexOf("Iceape/1.") < 0);
Client.IS_SVG = typeof window !== "undefined" && navigator.appName.toUpperCase() !== "MICROSOFT INTERNET EXPLORER";
Client.NO_FO = typeof window !== "undefined" && (!document.createElementNS || document.createElementNS(NS_SVG, "foreignObject").toString() !== "[object SVGForeignObjectElement]" || navigator.userAgent.indexOf("Opera/") >= 0);
Client.IS_WIN = typeof window !== "undefined" && navigator.appVersion.indexOf("Win") > 0;
Client.IS_MAC = typeof window !== "undefined" && navigator.appVersion.indexOf("Mac") > 0;
Client.IS_CHROMEOS = typeof window !== "undefined" && /\bCrOS\b/.test(navigator.appVersion);
Client.IS_TOUCH = typeof window !== "undefined" && "ontouchstart" in document.documentElement;
Client.IS_POINTER = typeof window !== "undefined" && window.PointerEvent != null && !(navigator.appVersion.indexOf("Mac") > 0);
Client.IS_LOCAL = typeof window !== "undefined" && document.location.href.indexOf("http://") < 0 && document.location.href.indexOf("https://") < 0;
const getMainEvent = (evt) => {
  let t = evt;
  if ((t.type === "touchstart" || t.type === "touchmove") && t.touches && t.touches[0]) {
    t = t.touches[0];
  } else if (t.type === "touchend" && t.changedTouches && t.changedTouches[0]) {
    t = t.changedTouches[0];
  }
  return t;
};
const getClientX = (evt) => {
  return getMainEvent(evt).clientX;
};
const getClientY = (evt) => {
  return getMainEvent(evt).clientY;
};
const getSource = (evt) => {
  return evt.target;
};
const isConsumed = (evt) => {
  const t = evt;
  return t.isConsumed !== void 0 && t.isConsumed;
};
const isTouchEvent = (evt) => {
  const t = evt;
  return t.pointerType ? t.pointerType === "touch" || t.pointerType === t.MSPOINTER_TYPE_TOUCH : t.mozInputSource !== void 0 ? t.mozInputSource === 5 : t.type.indexOf("touch") === 0;
};
const isPenEvent = (evt) => {
  const t = evt;
  return t.pointerType ? t.pointerType == "pen" || t.pointerType === t.MSPOINTER_TYPE_PEN : t.mozInputSource !== void 0 ? t.mozInputSource === 2 : t.type.indexOf("pen") === 0;
};
const isMultiTouchEvent = (evt) => {
  const t = evt;
  return t.type && t.type.indexOf("touch") == 0 && t.touches !== void 0 && t.touches.length > 1;
};
const isMouseEvent = (evt) => {
  const t = evt;
  return t.pointerType ? t.pointerType == "mouse" || t.pointerType === t.MSPOINTER_TYPE_MOUSE : t.mozInputSource !== void 0 ? t.mozInputSource === 1 : t.type.indexOf("mouse") === 0;
};
const isLeftMouseButton = (evt) => {
  if ("buttons" in evt && (evt.type === "mousedown" || evt.type === "mousemove")) {
    return evt.buttons === 1;
  }
  if (evt.which !== void 0) {
    return evt.which === 1;
  }
  return evt.button === 1;
};
const isMiddleMouseButton = (evt) => {
  return evt.button === 4;
};
const isRightMouseButton = (evt) => {
  return evt.button === 2;
};
const isPopupTrigger = (evt) => {
  return isRightMouseButton(evt) || Client.IS_MAC && isControlDown(evt) && !isShiftDown(evt) && !isMetaDown(evt) && !isAltDown(evt);
};
const isShiftDown = (evt) => {
  return evt.shiftKey;
};
const isAltDown = (evt) => {
  return evt.altKey;
};
const isControlDown = (evt) => {
  return evt.ctrlKey;
};
const isMetaDown = (evt) => {
  return evt.metaKey;
};
const EventUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getClientX,
  getClientY,
  getMainEvent,
  getSource,
  isAltDown,
  isConsumed,
  isControlDown,
  isLeftMouseButton,
  isMetaDown,
  isMiddleMouseButton,
  isMouseEvent,
  isMultiTouchEvent,
  isPenEvent,
  isPopupTrigger,
  isRightMouseButton,
  isShiftDown,
  isTouchEvent
}, Symbol.toStringTag, { value: "Module" }));
const extractTextWithWhitespace = (elems) => {
  const blocks = [
    "BLOCKQUOTE",
    "DIV",
    "H1",
    "H2",
    "H3",
    "H4",
    "H5",
    "H6",
    "OL",
    "P",
    "PRE",
    "TABLE",
    "UL"
  ];
  const ret = [];
  function doExtract(elts) {
    if (elts.length == 1 && (elts[0].nodeName == "BR" || elts[0].innerHTML == "\n")) {
      return;
    }
    for (let i = 0; i < elts.length; i += 1) {
      const elem = elts[i];
      if (elem.nodeName == "BR" || elem.innerHTML == "\n" || (elts.length == 1 || i == 0) && elem.nodeName == "DIV" && elem.innerHTML.toLowerCase() == "<br>") {
        ret.push("\n");
      } else {
        if (elem.nodeType === 3 || elem.nodeType === 4) {
          if (elem.nodeValue && elem.nodeValue.length > 0) {
            ret.push(elem.nodeValue);
          }
        } else if (elem.nodeType !== 8 && elem.childNodes.length > 0) {
          doExtract(Array.from(elem.childNodes));
        }
        if (i < elts.length - 1 && blocks.indexOf(elts[i + 1].nodeName) >= 0) {
          ret.push("\n");
        }
      }
    }
  }
  doExtract(elems);
  return ret.join("");
};
const getTextContent = (node) => {
  return (node == null ? void 0 : node.textContent) ?? "";
};
const setTextContent = (node, text) => {
  if ("innerText" in node) {
    node.innerText = text;
  } else {
    node.textContent = text;
  }
};
const getInnerHtml = (node) => {
  if (node != null) {
    const serializer = new XMLSerializer();
    return serializer.serializeToString(node);
  }
  return "";
};
const getOuterHtml = (node) => {
  if (node != null) {
    const serializer = new XMLSerializer();
    return serializer.serializeToString(node);
  }
  return "";
};
const write = (parent, text) => {
  const doc = parent.ownerDocument;
  const node = doc.createTextNode(text);
  if (parent != null) {
    parent.appendChild(node);
  }
  return node;
};
const writeln = (parent, text) => {
  const doc = parent.ownerDocument;
  const node = doc.createTextNode(text);
  if (parent != null) {
    parent.appendChild(node);
    parent.appendChild(document.createElement("br"));
  }
  return node;
};
const br = (parent, count = 1) => {
  let br2 = null;
  for (let i = 0; i < count; i += 1) {
    if (parent != null) {
      br2 = parent.ownerDocument.createElement("br");
      parent.appendChild(br2);
    }
  }
  return br2;
};
const para = (parent, text) => {
  const p = document.createElement("p");
  write(p, text);
  if (parent != null) {
    parent.appendChild(p);
  }
  return p;
};
const isNode = (value, nodeName = null, attributeName, attributeValue) => {
  if (value != null && !isNaN(value.nodeType) && (nodeName == null || value.nodeName.toLowerCase() == nodeName.toLowerCase())) {
    return attributeName == null || value.getAttribute(attributeName) == attributeValue;
  }
  return false;
};
const isAncestorNode = (ancestor, child) => {
  let parent = child;
  while (parent != null) {
    if (parent === ancestor) {
      return true;
    }
    parent = parent.parentNode;
  }
  return false;
};
const getChildNodes = (node, nodeType = NODETYPE.ELEMENT) => {
  nodeType = nodeType || NODETYPE.ELEMENT;
  const children = [];
  let tmp = node.firstChild;
  while (tmp != null) {
    if (tmp.nodeType === nodeType) {
      children.push(tmp);
    }
    tmp = tmp.nextSibling;
  }
  return children;
};
const importNode = (doc, node, allChildren) => {
  return doc.importNode(node, allChildren);
};
const clearSelection = () => {
  const sel = window.getSelection ? window.getSelection() : document.selection;
  if (sel) {
    if (sel.removeAllRanges) {
      sel.removeAllRanges();
    } else if (sel.empty) {
      sel.empty();
    }
  }
};
const createImage = (src) => {
  let imageNode = null;
  imageNode = document.createElement("img");
  imageNode.setAttribute("src", src);
  imageNode.setAttribute("border", "0");
  return imageNode;
};
const addLinkToHead = (rel, href, doc = null, id = null) => {
  doc = doc || document;
  const link2 = doc.createElement("link");
  link2.setAttribute("rel", rel);
  link2.setAttribute("href", href);
  link2.setAttribute("charset", "UTF-8");
  link2.setAttribute("type", "text/css");
  if (id) {
    link2.setAttribute("id", id);
  }
  const head = doc.getElementsByTagName("head")[0];
  head.appendChild(link2);
};
const domUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addLinkToHead,
  br,
  clearSelection,
  createImage,
  extractTextWithWhitespace,
  getChildNodes,
  getInnerHtml,
  getOuterHtml,
  getTextContent,
  importNode,
  isAncestorNode,
  isNode,
  para,
  setTextContent,
  write,
  writeln
}, Symbol.toStringTag, { value: "Module" }));
class InternalMouseEvent {
  constructor(evt, state = null) {
    this.consumed = false;
    this.evt = evt;
    this.state = state;
    this.sourceState = state;
    this.graphX = 0;
    this.graphY = 0;
  }
  /**
   * Returns <evt>.
   */
  getEvent() {
    return this.evt;
  }
  /**
   * Returns the target DOM element using {@link Event#getSource} for <evt>.
   */
  getSource() {
    return getSource(this.evt);
  }
  /**
   * Returns true if the given {@link Shape} is the source of <evt>.
   */
  isSource(shape) {
    return shape ? isAncestorNode(shape.node, this.getSource()) : false;
  }
  /**
   * Returns <evt.clientX>.
   */
  getX() {
    return getClientX(this.getEvent());
  }
  /**
   * Returns <evt.clientY>.
   */
  getY() {
    return getClientY(this.getEvent());
  }
  /**
   * Returns <graphX>.
   */
  getGraphX() {
    return this.graphX;
  }
  /**
   * Returns <graphY>.
   */
  getGraphY() {
    return this.graphY;
  }
  /**
   * Returns <state>.
   */
  getState() {
    return this.state;
  }
  /**
   * Returns the <Cell> in <state> is not null.
   */
  getCell() {
    const state = this.getState();
    return state ? state.cell : null;
  }
  /**
   * Returns true if the event is a popup trigger.
   */
  isPopupTrigger() {
    return isPopupTrigger(this.getEvent());
  }
  /**
   * Returns <consumed>.
   */
  isConsumed() {
    return this.consumed;
  }
  /**
   * Sets <consumed> to true and invokes preventDefault on the native event
   * if such a method is defined. This is used mainly to avoid the cursor from
   * being changed to a text cursor in Webkit. You can use the preventDefault
   * flag to disable this functionality.
   *
   * @param preventDefault Specifies if the native event should be canceled. Default
   * is true.
   */
  consume(preventDefault) {
    preventDefault = preventDefault ? preventDefault : window.TouchEvent && this.evt instanceof TouchEvent || isMouseEvent(this.evt);
    if (preventDefault && this.evt.preventDefault) {
      this.evt.preventDefault();
    }
    this.consumed = true;
  }
}
let supportsPassive = false;
try {
  document.addEventListener("test", () => {
    return;
  }, Object.defineProperty && Object.defineProperty({}, "passive", {
    get: () => {
      supportsPassive = true;
    }
  }));
} catch (e) {
}
class InternalEvent {
  /**
   * Binds the function to the specified event on the given element. Use
   * {@link mxUtils.bind} in order to bind the "this" keyword inside the function
   * to a given execution scope.
   */
  static addListener(element, eventName, funct) {
    element.addEventListener(eventName, funct, supportsPassive ? { passive: false } : false);
    if (!element.mxListenerList) {
      element.mxListenerList = [];
    }
    const entry = { name: eventName, f: funct };
    element.mxListenerList.push(entry);
  }
  /**
   * Removes the specified listener from the given element.
   */
  static removeListener(element, eventName, funct) {
    element.removeEventListener(eventName, funct, false);
    if (element.mxListenerList) {
      const listenerCount = element.mxListenerList.length;
      for (let i = 0; i < listenerCount; i += 1) {
        const entry = element.mxListenerList[i];
        if (entry.f === funct) {
          element.mxListenerList.splice(i, 1);
          break;
        }
      }
    }
  }
  /**
   * Removes all listeners from the given element.
   */
  static removeAllListeners(element) {
    const list = element.mxListenerList;
    if (list) {
      while (list.length > 0) {
        const entry = list[0];
        InternalEvent.removeListener(element, entry.name, entry.f);
      }
    }
  }
  /**
   * Adds the given listeners for touch, mouse and/or pointer events. If
   * <Client.IS_POINTER> is true then pointer events will be registered,
   * else the respective mouse events will be registered. If <Client.IS_POINTER>
   * is false and <Client.IS_TOUCH> is true then the respective touch events
   * will be registered as well as the mouse events.
   */
  static addGestureListeners(node, startListener = null, moveListener = null, endListener = null) {
    if (startListener) {
      InternalEvent.addListener(node, Client.IS_POINTER ? "pointerdown" : "mousedown", startListener);
    }
    if (moveListener) {
      InternalEvent.addListener(node, Client.IS_POINTER ? "pointermove" : "mousemove", moveListener);
    }
    if (endListener) {
      InternalEvent.addListener(node, Client.IS_POINTER ? "pointerup" : "mouseup", endListener);
    }
    if (!Client.IS_POINTER && Client.IS_TOUCH) {
      if (startListener) {
        InternalEvent.addListener(node, "touchstart", startListener);
      }
      if (moveListener) {
        InternalEvent.addListener(node, "touchmove", moveListener);
      }
      if (endListener) {
        InternalEvent.addListener(node, "touchend", endListener);
      }
    }
  }
  /**
   * Removes the given listeners from mousedown, mousemove, mouseup and the
   * respective touch events if <Client.IS_TOUCH> is true.
   */
  static removeGestureListeners(node, startListener, moveListener, endListener) {
    if (startListener) {
      InternalEvent.removeListener(node, Client.IS_POINTER ? "pointerdown" : "mousedown", startListener);
    }
    if (moveListener) {
      InternalEvent.removeListener(node, Client.IS_POINTER ? "pointermove" : "mousemove", moveListener);
    }
    if (endListener) {
      InternalEvent.removeListener(node, Client.IS_POINTER ? "pointerup" : "mouseup", endListener);
    }
    if (!Client.IS_POINTER && Client.IS_TOUCH) {
      if (startListener) {
        InternalEvent.removeListener(node, "touchstart", startListener);
      }
      if (moveListener) {
        InternalEvent.removeListener(node, "touchmove", moveListener);
      }
      if (endListener) {
        InternalEvent.removeListener(node, "touchend", endListener);
      }
    }
  }
  /**
   * Redirects the mouse events from the given DOM node to the graph dispatch
   * loop using the event and given state as event arguments. State can
   * either be an instance of <CellState> or a function that returns an
   * <CellState>. The down, move, up and dblClick arguments are optional
   * functions that take the trigger event as arguments and replace the
   * default behaviour.
   */
  static redirectMouseEvents(node, graph, state = null, down = null, move = null, up = null, dblClick = null) {
    const getState = (evt) => {
      return typeof state === "function" ? state(evt) : state;
    };
    InternalEvent.addGestureListeners(node, (evt) => {
      if (down) {
        down(evt);
      } else if (!isConsumed(evt)) {
        graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, getState(evt)));
      }
    }, (evt) => {
      if (move) {
        move(evt);
      } else if (!isConsumed(evt)) {
        graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));
      }
    }, (evt) => {
      if (up) {
        up(evt);
      } else if (!isConsumed(evt)) {
        graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, getState(evt)));
      }
    });
    InternalEvent.addListener(node, "dblclick", (evt) => {
      if (dblClick) {
        dblClick(evt);
      } else if (!isConsumed(evt)) {
        const tmp = getState(evt);
        graph.dblClick(evt, tmp == null ? void 0 : tmp.cell);
      }
    });
  }
  /**
   * Removes the known listeners from the given DOM node and its descendants.
   *
   * @param element DOM node to remove the listeners from.
   */
  static release(element) {
    try {
      InternalEvent.removeAllListeners(element);
      const children = element.childNodes;
      if (children !== void 0) {
        const childCount = children.length;
        for (let i = 0; i < childCount; i += 1) {
          InternalEvent.release(children[i]);
        }
      }
    } catch (e) {
    }
  }
  /**
   * Installs the given function as a handler for mouse wheel events. The
   * function has two arguments: the mouse event and a boolean that specifies
   * if the wheel was moved up or down.
   *
   * This has been tested with IE 6 and 7, Firefox (all versions), Opera and
   * Safari. It does currently not work on Safari for Mac.
   *
   * ### Example
   *
   * @example
   * ```javascript
   * mxEvent.addMouseWheelListener(function (evt, up)
   * {
   *   GlobalConfig.logger.show();
   *   GlobalConfig.logger.debug('mouseWheel: up='+up);
   * });
   * ```
   *
   * @param funct Handler function that takes the event argument and a boolean up
   * argument for the mousewheel direction.
   * @param target Target for installing the listener in Google Chrome. See
   * https://www.chromestatus.com/features/6662647093133312.
   */
  static addMouseWheelListener(funct, target) {
    if (funct != null) {
      const wheelHandler = (evt) => {
        if (evt.ctrlKey) {
          evt.preventDefault();
        }
        if (Math.abs(evt.deltaX) > 0.5 || Math.abs(evt.deltaY) > 0.5) {
          funct(evt, evt.deltaY == 0 ? -evt.deltaX > 0 : -evt.deltaY > 0);
        }
      };
      target = target != null ? target : window;
      if (Client.IS_SF && !Client.IS_TOUCH) {
        let scale = 1;
        InternalEvent.addListener(target, "gesturestart", (evt) => {
          InternalEvent.consume(evt);
          scale = 1;
        });
        InternalEvent.addListener(target, "gesturechange", (evt) => {
          InternalEvent.consume(evt);
          if (typeof evt.scale === "number") {
            const diff = scale - evt.scale;
            if (Math.abs(diff) > 0.2) {
              funct(evt, diff < 0, true);
              scale = evt.scale;
            }
          }
        });
        InternalEvent.addListener(target, "gestureend", (evt) => {
          InternalEvent.consume(evt);
        });
      } else {
        let evtCache = [];
        let dx0 = 0;
        let dy0 = 0;
        InternalEvent.addGestureListeners(target, (evt) => {
          if (!isMouseEvent(evt) && evt.pointerId != null) {
            evtCache.push(evt);
          }
        }, (evt) => {
          if (!isMouseEvent(evt) && evtCache.length == 2) {
            for (let i = 0; i < evtCache.length; i += 1) {
              if (evt.pointerId == evtCache[i].pointerId) {
                evtCache[i] = evt;
                break;
              }
            }
            const dx = Math.abs(evtCache[0].clientX - evtCache[1].clientX);
            const dy = Math.abs(evtCache[0].clientY - evtCache[1].clientY);
            const tx = Math.abs(dx - dx0);
            const ty = Math.abs(dy - dy0);
            if (tx > InternalEvent.PINCH_THRESHOLD || ty > InternalEvent.PINCH_THRESHOLD) {
              const cx = evtCache[0].clientX + (evtCache[1].clientX - evtCache[0].clientX) / 2;
              const cy = evtCache[0].clientY + (evtCache[1].clientY - evtCache[0].clientY) / 2;
              funct(evtCache[0], tx > ty ? dx > dx0 : dy > dy0, true, cx, cy);
              dx0 = dx;
              dy0 = dy;
            }
          }
        }, (evt) => {
          evtCache = [];
          dx0 = 0;
          dy0 = 0;
        });
      }
      InternalEvent.addListener(target, "wheel", wheelHandler);
    }
  }
  /**
   * Disables the context menu for the given element.
   */
  static disableContextMenu(element) {
    InternalEvent.addListener(element, "contextmenu", (evt) => {
      if (evt.preventDefault) {
        evt.preventDefault();
      }
      return false;
    });
  }
  /**
   * Consumes the given event.
   *
   * @param evt Native event to be consumed.
   * @param {boolean} [preventDefault=true] Optional boolean to prevent the default for the event.
   * Default is true.
   * @param {boolean} [stopPropagation=true] Option boolean to stop event propagation. Default is
   * true.
   */
  static consume(evt, preventDefault = true, stopPropagation = true) {
    if (preventDefault) {
      if (evt.preventDefault) {
        if (stopPropagation) {
          evt.stopPropagation();
        }
        evt.preventDefault();
      } else if (stopPropagation) {
        evt.cancelBubble = true;
      }
    }
    evt.isConsumed = true;
    if (!evt.preventDefault) {
      evt.returnValue = false;
    }
  }
}
InternalEvent.LABEL_HANDLE = -1;
InternalEvent.ROTATION_HANDLE = -2;
InternalEvent.CUSTOM_HANDLE = -100;
InternalEvent.VIRTUAL_HANDLE = -1e5;
InternalEvent.MOUSE_DOWN = "mouseDown";
InternalEvent.MOUSE_MOVE = "mouseMove";
InternalEvent.MOUSE_UP = "mouseUp";
InternalEvent.ACTIVATE = "activate";
InternalEvent.RESIZE_START = "resizeStart";
InternalEvent.RESIZE = "resize";
InternalEvent.RESIZE_END = "resizeEnd";
InternalEvent.MOVE_START = "moveStart";
InternalEvent.MOVE = "move";
InternalEvent.MOVE_END = "moveEnd";
InternalEvent.PAN_START = "panStart";
InternalEvent.PAN = "pan";
InternalEvent.PAN_END = "panEnd";
InternalEvent.MINIMIZE = "minimize";
InternalEvent.NORMALIZE = "normalize";
InternalEvent.MAXIMIZE = "maximize";
InternalEvent.HIDE = "hide";
InternalEvent.SHOW = "show";
InternalEvent.CLOSE = "close";
InternalEvent.DESTROY = "destroy";
InternalEvent.REFRESH = "refresh";
InternalEvent.SIZE = "size";
InternalEvent.SELECT = "select";
InternalEvent.FIRED = "fired";
InternalEvent.FIRE_MOUSE_EVENT = "fireMouseEvent";
InternalEvent.GESTURE = "gesture";
InternalEvent.TAP_AND_HOLD = "tapAndHold";
InternalEvent.GET = "get";
InternalEvent.RECEIVE = "receive";
InternalEvent.CONNECT = "connect";
InternalEvent.DISCONNECT = "disconnect";
InternalEvent.SUSPEND = "suspend";
InternalEvent.RESUME = "resume";
InternalEvent.MARK = "mark";
InternalEvent.ROOT = "root";
InternalEvent.POST = "post";
InternalEvent.OPEN = "open";
InternalEvent.SAVE = "save";
InternalEvent.BEFORE_ADD_VERTEX = "beforeAddVertex";
InternalEvent.ADD_VERTEX = "addVertex";
InternalEvent.AFTER_ADD_VERTEX = "afterAddVertex";
InternalEvent.DONE = "done";
InternalEvent.EXECUTE = "execute";
InternalEvent.EXECUTED = "executed";
InternalEvent.BEGIN_UPDATE = "beginUpdate";
InternalEvent.START_EDIT = "startEdit";
InternalEvent.END_UPDATE = "endUpdate";
InternalEvent.END_EDIT = "endEdit";
InternalEvent.BEFORE_UNDO = "beforeUndo";
InternalEvent.UNDO = "undo";
InternalEvent.REDO = "redo";
InternalEvent.CHANGE = "change";
InternalEvent.NOTIFY = "notify";
InternalEvent.LAYOUT_CELLS = "layoutCells";
InternalEvent.CLICK = "click";
InternalEvent.SCALE = "scale";
InternalEvent.TRANSLATE = "translate";
InternalEvent.SCALE_AND_TRANSLATE = "scaleAndTranslate";
InternalEvent.UP = "up";
InternalEvent.DOWN = "down";
InternalEvent.ADD = "add";
InternalEvent.REMOVE = "remove";
InternalEvent.CLEAR = "clear";
InternalEvent.ADD_CELLS = "addCells";
InternalEvent.CELLS_ADDED = "cellsAdded";
InternalEvent.MOVE_CELLS = "moveCells";
InternalEvent.CELLS_MOVED = "cellsMoved";
InternalEvent.RESIZE_CELLS = "resizeCells";
InternalEvent.CELLS_RESIZED = "cellsResized";
InternalEvent.TOGGLE_CELLS = "toggleCells";
InternalEvent.CELLS_TOGGLED = "cellsToggled";
InternalEvent.ORDER_CELLS = "orderCells";
InternalEvent.CELLS_ORDERED = "cellsOrdered";
InternalEvent.REMOVE_CELLS = "removeCells";
InternalEvent.CELLS_REMOVED = "cellsRemoved";
InternalEvent.GROUP_CELLS = "groupCells";
InternalEvent.UNGROUP_CELLS = "ungroupCells";
InternalEvent.REMOVE_CELLS_FROM_PARENT = "removeCellsFromParent";
InternalEvent.FOLD_CELLS = "foldCells";
InternalEvent.CELLS_FOLDED = "cellsFolded";
InternalEvent.ALIGN_CELLS = "alignCells";
InternalEvent.LABEL_CHANGED = "labelChanged";
InternalEvent.CONNECT_CELL = "connectCell";
InternalEvent.CELL_CONNECTED = "cellConnected";
InternalEvent.SPLIT_EDGE = "splitEdge";
InternalEvent.FLIP_EDGE = "flipEdge";
InternalEvent.START_EDITING = "startEditing";
InternalEvent.EDITING_STARTED = "editingStarted";
InternalEvent.EDITING_STOPPED = "editingStopped";
InternalEvent.ADD_OVERLAY = "addOverlay";
InternalEvent.REMOVE_OVERLAY = "removeOverlay";
InternalEvent.UPDATE_CELL_SIZE = "updateCellSize";
InternalEvent.ESCAPE = "escape";
InternalEvent.DOUBLE_CLICK = "doubleClick";
InternalEvent.START = "start";
InternalEvent.RESET = "reset";
InternalEvent.PINCH_THRESHOLD = 10;
class Point {
  constructor(x = 0, y = 0) {
    this._x = 0;
    this._y = 0;
    this.x = x;
    this.y = y;
  }
  get x() {
    return this._x;
  }
  set x(x) {
    if (Number.isNaN(x))
      throw new Error("Invalid x supplied.");
    this._x = x;
  }
  get y() {
    return this._y;
  }
  set y(y) {
    if (Number.isNaN(y))
      throw new Error("Invalid y supplied.");
    this._y = y;
  }
  /**
   * Returns true if the given object equals this point.
   */
  equals(p) {
    if (!p)
      return false;
    return p.x === this.x && p.y === this.y;
  }
  /**
   * Returns a clone of this {@link Point}.
   */
  clone() {
    return new Point(this.x, this.y);
  }
}
class Rectangle extends Point {
  constructor(x = 0, y = 0, width = 0, height = 0) {
    super(x, y);
    this._width = 0;
    this._height = 0;
    this.width = width;
    this.height = height;
  }
  get width() {
    return this._width;
  }
  set width(width) {
    if (Number.isNaN(width))
      throw new Error("Invalid width supplied.");
    this._width = width;
  }
  get height() {
    return this._height;
  }
  set height(height) {
    if (Number.isNaN(height))
      throw new Error("Invalid height supplied.");
    this._height = height;
  }
  /**
   * Sets this rectangle to the specified values
   */
  setRect(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  /**
   * Returns the x-coordinate of the center point.
   */
  getCenterX() {
    return this.x + this.width / 2;
  }
  /**
   * Returns the y-coordinate of the center point.
   */
  getCenterY() {
    return this.y + this.height / 2;
  }
  /**
   * Adds the given rectangle to this rectangle.
   */
  add(rect) {
    const minX = Math.min(this.x, rect.x);
    const minY = Math.min(this.y, rect.y);
    const maxX = Math.max(this.x + this.width, rect.x + rect.width);
    const maxY = Math.max(this.y + this.height, rect.y + rect.height);
    this.x = minX;
    this.y = minY;
    this.width = maxX - minX;
    this.height = maxY - minY;
  }
  /**
   * Changes this rectangle to where it overlaps with the given rectangle.
   */
  intersect(rect) {
    const r1 = this.x + this.width;
    const r2 = rect.x + rect.width;
    const b1 = this.y + this.height;
    const b2 = rect.y + rect.height;
    this.x = Math.max(this.x, rect.x);
    this.y = Math.max(this.y, rect.y);
    this.width = Math.min(r1, r2) - this.x;
    this.height = Math.min(b1, b2) - this.y;
  }
  /**
   * Grows the rectangle by the given amount, that is, this method subtracts
   * the given amount from the x- and y-coordinates and adds twice the amount
   * to the width and height.
   */
  grow(amount) {
    this.x -= amount;
    this.y -= amount;
    this.width += 2 * amount;
    this.height += 2 * amount;
  }
  /**
   * Returns the top, left corner as a new {@link Point}.
   */
  getPoint() {
    return new Point(this.x, this.y);
  }
  /**
   * Rotates this rectangle by 90 degree around its center point.
   */
  rotate90() {
    const t = (this.width - this.height) / 2;
    this.x += t;
    this.y -= t;
    const tmp = this.width;
    this.width = this.height;
    this.height = tmp;
  }
  /**
   * Returns true if the given object equals this rectangle.
   */
  equals(rect) {
    if (!rect)
      return false;
    return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
  }
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
}
Rectangle.fromRectangle = (rect) => {
  return new Rectangle(rect.x, rect.y, rect.width, rect.height);
};
const ltrim = (str, chars = "\\s") => str != null ? str.replace(new RegExp(`^[${chars}]+`, "g"), "") : null;
const rtrim = (str, chars = "\\s") => str != null ? str.replace(new RegExp(`[${chars}]+$`, "g"), "") : null;
const trim = (str, chars) => ltrim(rtrim(str, chars), chars);
const getFunctionName = (f) => {
  let str = null;
  if (f != null) {
    if (f.name != null) {
      str = f.name;
    } else {
      str = trim(f.toString());
      if (str !== null && /^function\s/.test(str)) {
        str = ltrim(str.substring(9));
        if (str !== null) {
          const idx2 = str.indexOf("(");
          if (idx2 > 0) {
            str = str.substring(0, idx2);
          }
        }
      }
    }
  }
  return str;
};
const replaceTrailingNewlines = (str, pattern) => {
  let postfix = "";
  while (str.length > 0 && str.charAt(str.length - 1) == "\n") {
    str = str.substring(0, str.length - 1);
    postfix += pattern;
  }
  return str + postfix;
};
const removeWhitespace = (node, before) => {
  var _a, _b;
  let tmp = before ? node.previousSibling : node.nextSibling;
  while (tmp != null && tmp.nodeType === NODETYPE.TEXT) {
    const next = before ? tmp.previousSibling : tmp.nextSibling;
    const text = getTextContent(tmp);
    if (((_a = trim(text)) == null ? void 0 : _a.length) === 0) {
      (_b = tmp.parentNode) == null ? void 0 : _b.removeChild(tmp);
    }
    tmp = next;
  }
};
const htmlEntities = (s, newline = true) => {
  s = String(s || "");
  s = s.replace(/&/g, "&amp;");
  s = s.replace(/"/g, "&quot;");
  s = s.replace(/'/g, "&#39;");
  s = s.replace(/</g, "&lt;");
  s = s.replace(/>/g, "&gt;");
  if (newline) {
    s = s.replace(/\n/g, "&#xa;");
  }
  return s;
};
const toString = (obj) => {
  let output = "";
  for (const i in obj) {
    try {
      if (obj[i] == null) {
        output += `${i} = [null]
`;
      } else if (typeof obj[i] === "function") {
        output += `${i} => [Function]
`;
      } else if (typeof obj[i] === "object") {
        const ctor = getFunctionName(obj[i].constructor);
        output += `${i} => [${ctor}]
`;
      } else {
        output += `${i} = ${obj[i]}
`;
      }
    } catch (e) {
      output += `${i}=${e.message}`;
    }
  }
  return output;
};
const StringUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getFunctionName,
  htmlEntities,
  ltrim,
  removeWhitespace,
  replaceTrailingNewlines,
  rtrim,
  toString,
  trim
}, Symbol.toStringTag, { value: "Module" }));
class ObjectIdentity {
  /**
   * Returns the ID for the given object or function.
   */
  static get(obj) {
    if (obj) {
      if (obj[IDENTITY_FIELD_NAME] === null || obj[IDENTITY_FIELD_NAME] === void 0) {
        if (typeof obj === "object") {
          const ctor = getFunctionName(obj.constructor);
          obj[IDENTITY_FIELD_NAME] = `${ctor}#${ObjectIdentity.counter++}`;
        } else if (typeof obj === "function") {
          obj[IDENTITY_FIELD_NAME] = `Function#${ObjectIdentity.counter++}`;
        }
      }
      return obj[IDENTITY_FIELD_NAME];
    }
    return null;
  }
  /**
   * Deletes the ID from the given object or function.
   */
  static clear(obj) {
    delete obj[IDENTITY_FIELD_NAME];
  }
}
ObjectIdentity.FIELD_NAME = IDENTITY_FIELD_NAME;
ObjectIdentity.counter = 0;
class Dictionary {
  constructor() {
    this.map = {};
    this.clear();
  }
  /**
   * Clears the dictionary.
   */
  clear() {
    this.map = {};
  }
  /**
   * Returns the value for the given key.
   */
  get(key) {
    const id = ObjectIdentity.get(key);
    return this.map[id] ?? null;
  }
  /**
   * Stores the value under the given key and returns the previous
   * value for that key.
   */
  put(key, value) {
    const id = ObjectIdentity.get(key);
    const previous = this.map[id];
    this.map[id] = value;
    return previous ?? null;
  }
  /**
   * Removes the value for the given key and returns the value that
   * has been removed.
   */
  remove(key) {
    const id = ObjectIdentity.get(key);
    const previous = this.map[id];
    delete this.map[id];
    return previous ?? null;
  }
  /**
   * Returns all keys as an array.
   */
  getKeys() {
    const result = [];
    for (const key in this.map) {
      result.push(key);
    }
    return result;
  }
  /**
   * Returns all values as an array.
   */
  getValues() {
    const result = [];
    for (const key in this.map) {
      result.push(this.map[key]);
    }
    return result;
  }
  /**
   * Visits all entries in the dictionary using the given function with the
   * following signature: (key, value)=> where key is a string and
   * value is an object.
   *
   * @param visitor A function that takes the key and value as arguments.
   */
  visit(visitor) {
    for (const key in this.map) {
      visitor(key, this.map[key]);
    }
  }
}
const getElapseMillisecondsMessage = (baseTimestamp) => baseTimestamp ? ` (${(/* @__PURE__ */ new Date()).getTime() - baseTimestamp} ms)` : "";
class NoOpLogger {
  debug(_message) {
  }
  enter(_message) {
    return void 0;
  }
  error(_message, ..._optionalParams) {
  }
  info(_message) {
  }
  leave(_message, _baseTimestamp) {
  }
  show() {
  }
  trace(_message) {
  }
  warn(_message) {
  }
}
class ConsoleLogger {
  constructor() {
    this.debugEnabled = false;
    this.infoEnabled = false;
    this.traceEnabled = false;
  }
  /* eslint-disable no-console -- we must use "console" to direct logs to the browser console */
  enter(message) {
    if (this.traceEnabled) {
      console.trace(`Entering ${message}`);
      return (/* @__PURE__ */ new Date()).getTime();
    }
  }
  leave(message, baseTimestamp) {
    if (this.traceEnabled) {
      const dt = getElapseMillisecondsMessage(baseTimestamp);
      console.trace(`Leaving ${message}${dt}`);
    }
  }
  show() {
  }
  trace(message) {
    if (this.traceEnabled) {
      console.trace(message);
    }
  }
  debug(message) {
    if (this.debugEnabled) {
      console.debug(message);
    }
  }
  info(message) {
    if (this.infoEnabled) {
      console.info(message);
    }
  }
  warn(message) {
    console.warn(message);
  }
  error(message, ...optionalParams) {
    console.error(message, ...optionalParams);
  }
}
const shallowCopy = (source, target) => {
  for (const key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      const sourceValue = source[key];
      if (Array.isArray(sourceValue)) {
        target[key] = [...sourceValue];
      } else {
        target[key] = sourceValue;
      }
    }
  }
};
class NoOpI18n {
  isEnabled() {
    return false;
  }
  get() {
    return null;
  }
  addResource() {
  }
}
const GlobalConfig = {
  /**
   * Configure the {@link I18nProvider} to use for all translated messages.
   *
   * Available implementations provided by maxGraph are:
   * * {@link NoOpI18n} - Default implementation that does nothing.
   * * {@link TranslationsAsI18n} - Uses {@link Translations} to manage translations.
   *
   * To change the i18n provider, set this property to an instance of the desired provider:
   * ```js
   * // To use the i18n system provided by maxGraph
   * GlobalConfig.i18n = new TranslationsAsI18n();
   * ```
   *
   * @default {@link NoOpI18n}
   * @since 0.17.0
   */
  i18n: new NoOpI18n(),
  /**
   * Configure the logger to use for all log messages.
   *
   * Available implementations provided by maxGraph are:
   * * {@link ConsoleLogger} - Directs logs to the browser console.
   * * {@link NoOpLogger} - Default implementation that does nothing.
   * * {@link MaxLogAsLogger} - Directs logs to {@link MaxLog}.
   *
   * To change the logger, set this property to an instance of the desired logger:
   * ```js
   * // To direct logs to the browser console
   * GlobalConfig.logger = new ConsoleLogger();
   * // To direct logs to MaxLog
   * GlobalConfig.logger = new MaxLogAsLogger();
   * ```
   *
   * @default {@link NoOpLogger}
   */
  logger: new NoOpLogger()
};
const StyleDefaultsConfig = {
  /**
   * Defines the color to be used to draw shadows in shapes and windows.
   * @default {@link SHADOWCOLOR}
   */
  shadowColor: SHADOWCOLOR,
  /**
   * Specifies the x-offset of the shadow.
   * @default {@link SHADOW_OFFSET_X}
   */
  shadowOffsetX: SHADOW_OFFSET_X,
  /**
   * Specifies the y-offset of the shadow.
   * @default {@link SHADOW_OFFSET_Y}
   */
  shadowOffsetY: SHADOW_OFFSET_Y,
  /**
   * Defines the opacity for shadow. Possible values are between 1 (opaque) and 0 (transparent).
   * @default {@link SHADOW_OPACITY}
   */
  shadowOpacity: SHADOW_OPACITY
};
const defaultStyleDefaultsConfig = { ...StyleDefaultsConfig };
const resetStyleDefaultsConfig = () => {
  shallowCopy(defaultStyleDefaultsConfig, StyleDefaultsConfig);
};
const doEval = (expression) => {
  return eval(expression);
};
const isElement = (node) => (node == null ? void 0 : node.nodeType) === NODETYPE.ELEMENT;
const isNullish = (v) => v === null || v === void 0;
const mixInto = (dest) => (mixin) => {
  const keys = Reflect.ownKeys(mixin);
  try {
    for (const key of keys) {
      Object.defineProperty(dest.prototype, key, {
        value: mixin[key],
        writable: true
      });
    }
  } catch (e) {
    GlobalConfig.logger.error("Error while mixing", e);
  }
};
const matchBinaryMask = (value, mask) => {
  return (value & mask) === mask;
};
const toRadians = (deg) => {
  return Math.PI * deg / 180;
};
const toDegree = (rad) => {
  return rad * 180 / Math.PI;
};
const arcToCurves = (x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y) => {
  x -= x0;
  y -= y0;
  if (r1 === 0 || r2 === 0) {
    return [];
  }
  const fS = sweepFlag;
  const psai = angle;
  r1 = Math.abs(r1);
  r2 = Math.abs(r2);
  const ctx = -x / 2;
  const cty = -y / 2;
  const cpsi = Math.cos(psai * Math.PI / 180);
  const spsi = Math.sin(psai * Math.PI / 180);
  const rxd = cpsi * ctx + spsi * cty;
  const ryd = -1 * spsi * ctx + cpsi * cty;
  const rxdd = rxd * rxd;
  const rydd = ryd * ryd;
  const r1x = r1 * r1;
  const r2y = r2 * r2;
  const lamda = rxdd / r1x + rydd / r2y;
  let sds;
  if (lamda > 1) {
    r1 = Math.sqrt(lamda) * r1;
    r2 = Math.sqrt(lamda) * r2;
    sds = 0;
  } else {
    let seif = 1;
    if (largeArcFlag === fS) {
      seif = -1;
    }
    sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
  }
  const txd = sds * r1 * ryd / r2;
  const tyd = -1 * sds * r2 * rxd / r1;
  const tx = cpsi * txd - spsi * tyd + x / 2;
  const ty = spsi * txd + cpsi * tyd + y / 2;
  let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
  let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;
  rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
  let dr = rad >= 0 ? rad : 2 * Math.PI + rad;
  if (!fS && dr > 0) {
    dr -= 2 * Math.PI;
  } else if (fS && dr < 0) {
    dr += 2 * Math.PI;
  }
  const sse = dr * 2 / Math.PI;
  const seg = Math.ceil(sse < 0 ? -1 * sse : sse);
  const segr = dr / seg;
  const t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);
  const cpsir1 = cpsi * r1;
  const cpsir2 = cpsi * r2;
  const spsir1 = spsi * r1;
  const spsir2 = spsi * r2;
  let mc = Math.cos(s1);
  let ms = Math.sin(s1);
  let x2 = -t * (cpsir1 * ms + spsir2 * mc);
  let y2 = -t * (spsir1 * ms - cpsir2 * mc);
  let x3 = 0;
  let y3 = 0;
  const result = [];
  for (let n = 0; n < seg; ++n) {
    s1 += segr;
    mc = Math.cos(s1);
    ms = Math.sin(s1);
    x3 = cpsir1 * mc - spsir2 * ms + tx;
    y3 = spsir1 * mc + cpsir2 * ms + ty;
    const dx = -t * (cpsir1 * ms + spsir2 * mc);
    const dy = -t * (spsir1 * ms - cpsir2 * mc);
    const index = n * 6;
    result[index] = Number(x2 + x0);
    result[index + 1] = Number(y2 + y0);
    result[index + 2] = Number(x3 - dx + x0);
    result[index + 3] = Number(y3 - dy + y0);
    result[index + 4] = Number(x3 + x0);
    result[index + 5] = Number(y3 + y0);
    x2 = x3 + dx;
    y2 = y3 + dy;
  }
  return result;
};
const getBoundingBox = (rect, rotation, cx = null) => {
  let result = null;
  if (rect && rotation !== 0) {
    const rad = toRadians(rotation);
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    cx = cx != null ? cx : new Point(rect.x + rect.width / 2, rect.y + rect.height / 2);
    let p1 = new Point(rect.x, rect.y);
    let p2 = new Point(rect.x + rect.width, rect.y);
    let p3 = new Point(p2.x, rect.y + rect.height);
    let p4 = new Point(rect.x, p3.y);
    p1 = getRotatedPoint(p1, cos, sin, cx);
    p2 = getRotatedPoint(p2, cos, sin, cx);
    p3 = getRotatedPoint(p3, cos, sin, cx);
    p4 = getRotatedPoint(p4, cos, sin, cx);
    result = new Rectangle(p1.x, p1.y, 0, 0);
    result.add(new Rectangle(p2.x, p2.y, 0, 0));
    result.add(new Rectangle(p3.x, p3.y, 0, 0));
    result.add(new Rectangle(p4.x, p4.y, 0, 0));
  }
  return result;
};
const getRotatedPoint = (pt, cos, sin, c = new Point()) => {
  const x = pt.x - c.x;
  const y = pt.y - c.y;
  const x1 = x * cos - y * sin;
  const y1 = y * cos + x * sin;
  return new Point(x1 + c.x, y1 + c.y);
};
const getPortConstraints = (terminal, edge, source, defaultValue) => {
  const value = terminal.style.portConstraint ?? (source ? edge.style.sourcePortConstraint : edge.style.targetPortConstraint);
  if (isNullish(value)) {
    return defaultValue;
  }
  const directions = value.toString();
  let returnValue = DIRECTION_MASK.NONE;
  const constraintRotationEnabled = terminal.style.portConstraintRotation ?? false;
  const rotation = constraintRotationEnabled ? terminal.style.rotation ?? 0 : 0;
  let quad = 0;
  if (rotation > 45) {
    quad = 1;
    if (rotation >= 135) {
      quad = 2;
    }
  } else if (rotation < -45) {
    quad = 3;
    if (rotation <= -135) {
      quad = 2;
    }
  }
  if (directions.indexOf(DIRECTION.NORTH) >= 0) {
    switch (quad) {
      case 0:
        returnValue |= DIRECTION_MASK.NORTH;
        break;
      case 1:
        returnValue |= DIRECTION_MASK.EAST;
        break;
      case 2:
        returnValue |= DIRECTION_MASK.SOUTH;
        break;
      case 3:
        returnValue |= DIRECTION_MASK.WEST;
        break;
    }
  }
  if (directions.indexOf(DIRECTION.WEST) >= 0) {
    switch (quad) {
      case 0:
        returnValue |= DIRECTION_MASK.WEST;
        break;
      case 1:
        returnValue |= DIRECTION_MASK.NORTH;
        break;
      case 2:
        returnValue |= DIRECTION_MASK.EAST;
        break;
      case 3:
        returnValue |= DIRECTION_MASK.SOUTH;
        break;
    }
  }
  if (directions.indexOf(DIRECTION.SOUTH) >= 0) {
    switch (quad) {
      case 0:
        returnValue |= DIRECTION_MASK.SOUTH;
        break;
      case 1:
        returnValue |= DIRECTION_MASK.WEST;
        break;
      case 2:
        returnValue |= DIRECTION_MASK.NORTH;
        break;
      case 3:
        returnValue |= DIRECTION_MASK.EAST;
        break;
    }
  }
  if (directions.indexOf(DIRECTION.EAST) >= 0) {
    switch (quad) {
      case 0:
        returnValue |= DIRECTION_MASK.EAST;
        break;
      case 1:
        returnValue |= DIRECTION_MASK.SOUTH;
        break;
      case 2:
        returnValue |= DIRECTION_MASK.WEST;
        break;
      case 3:
        returnValue |= DIRECTION_MASK.NORTH;
        break;
    }
  }
  return returnValue;
};
const reversePortConstraints = (constraint) => {
  let result = 0;
  result = (constraint & DIRECTION_MASK.WEST) << 3;
  result |= (constraint & DIRECTION_MASK.NORTH) << 1;
  result |= (constraint & DIRECTION_MASK.SOUTH) >> 1;
  result |= (constraint & DIRECTION_MASK.EAST) >> 3;
  return result;
};
const findNearestSegment = (state, x, y) => {
  let index = -1;
  if (state.absolutePoints.length > 0) {
    let last = state.absolutePoints[0];
    let min = null;
    for (let i = 1; i < state.absolutePoints.length; i += 1) {
      const current = state.absolutePoints[i];
      if (!last || !current)
        continue;
      const dist = ptSegDistSq(last.x, last.y, current.x, current.y, x, y);
      if (min == null || dist < min) {
        min = dist;
        index = i - 1;
      }
      last = current;
    }
  }
  return index;
};
const getDirectedBounds = (rect, m, style, flipH, flipV) => {
  const d = (style == null ? void 0 : style.direction) ?? "east";
  flipH ?? (flipH = (style == null ? void 0 : style.flipH) ?? false);
  flipV ?? (flipV = (style == null ? void 0 : style.flipV) ?? false);
  m.x = Math.round(Math.max(0, Math.min(rect.width, m.x)));
  m.y = Math.round(Math.max(0, Math.min(rect.height, m.y)));
  m.width = Math.round(Math.max(0, Math.min(rect.width, m.width)));
  m.height = Math.round(Math.max(0, Math.min(rect.height, m.height)));
  if (flipV && (d === DIRECTION.SOUTH || d === DIRECTION.NORTH) || flipH && (d === DIRECTION.EAST || d === DIRECTION.WEST)) {
    const tmp = m.x;
    m.x = m.width;
    m.width = tmp;
  }
  if (flipH && (d === DIRECTION.SOUTH || d === DIRECTION.NORTH) || flipV && (d === DIRECTION.EAST || d === DIRECTION.WEST)) {
    const tmp = m.y;
    m.y = m.height;
    m.height = tmp;
  }
  const m2 = Rectangle.fromRectangle(m);
  if (d === DIRECTION.SOUTH) {
    m2.y = m.x;
    m2.x = m.height;
    m2.width = m.y;
    m2.height = m.width;
  } else if (d === DIRECTION.WEST) {
    m2.y = m.height;
    m2.x = m.width;
    m2.width = m.x;
    m2.height = m.y;
  } else if (d === DIRECTION.NORTH) {
    m2.y = m.width;
    m2.x = m.y;
    m2.width = m.height;
    m2.height = m.x;
  }
  return new Rectangle(rect.x + m2.x, rect.y + m2.y, rect.width - m2.width - m2.x, rect.height - m2.height - m2.y);
};
const getPerimeterPoint = (pts, center, point) => {
  let min = null;
  for (let i = 0; i < pts.length - 1; i += 1) {
    const pt = intersection(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, center.x, center.y, point.x, point.y);
    if (pt != null) {
      const dx = point.x - pt.x;
      const dy = point.y - pt.y;
      const ip = { p: pt, distSq: dy * dy + dx * dx };
      if (ip != null && (min == null || min.distSq > ip.distSq)) {
        min = ip;
      }
    }
  }
  return min != null ? min.p : null;
};
const rectangleIntersectsSegment = (bounds, p1, p2) => {
  const top = bounds.y;
  const left = bounds.x;
  const bottom = top + bounds.height;
  const right = left + bounds.width;
  let minX = p1.x;
  let maxX = p2.x;
  if (p1.x > p2.x) {
    minX = p2.x;
    maxX = p1.x;
  }
  if (maxX > right) {
    maxX = right;
  }
  if (minX < left) {
    minX = left;
  }
  if (minX > maxX) {
    return false;
  }
  let minY = p1.y;
  let maxY = p2.y;
  const dx = p2.x - p1.x;
  if (Math.abs(dx) > 1e-7) {
    const a = (p2.y - p1.y) / dx;
    const b = p1.y - a * p1.x;
    minY = a * minX + b;
    maxY = a * maxX + b;
  }
  if (minY > maxY) {
    const tmp = maxY;
    maxY = minY;
    minY = tmp;
  }
  if (maxY > bottom) {
    maxY = bottom;
  }
  if (minY < top) {
    minY = top;
  }
  if (minY > maxY) {
    return false;
  }
  return true;
};
const contains = (bounds, x, y) => {
  return bounds.x <= x && bounds.x + bounds.width >= x && bounds.y <= y && bounds.y + bounds.height >= y;
};
const intersects$1 = (a, b) => {
  let tw = a.width;
  let th = a.height;
  let rw = b.width;
  let rh = b.height;
  if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {
    return false;
  }
  const tx = a.x;
  const ty = a.y;
  const rx = b.x;
  const ry = b.y;
  rw += rx;
  rh += ry;
  tw += tx;
  th += ty;
  return (rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry);
};
const intersectsHotspot = (state, x, y, hotspot, min, max) => {
  hotspot = hotspot != null ? hotspot : 1;
  min = min != null ? min : 0;
  max = max != null ? max : 0;
  if (hotspot > 0) {
    let cx = state.getCenterX();
    let cy = state.getCenterY();
    let w = state.width;
    let h = state.height;
    const style = state.style;
    const start = ((style == null ? void 0 : style.startSize) ?? 0) * state.view.scale;
    if (start > 0) {
      if ((style == null ? void 0 : style.horizontal) ?? true) {
        cy = state.y + start / 2;
        h = start;
      } else {
        cx = state.x + start / 2;
        w = start;
      }
    }
    w = Math.max(min, w * hotspot);
    h = Math.max(min, h * hotspot);
    if (max > 0) {
      w = Math.min(w, max);
      h = Math.min(h, max);
    }
    const rect = new Rectangle(cx - w / 2, cy - h / 2, w, h);
    const alpha = toRadians((style == null ? void 0 : style.rotation) ?? 0);
    if (alpha != 0) {
      const cos = Math.cos(-alpha);
      const sin = Math.sin(-alpha);
      const cx2 = new Point(state.getCenterX(), state.getCenterY());
      const pt = getRotatedPoint(new Point(x, y), cos, sin, cx2);
      x = pt.x;
      y = pt.y;
    }
    return contains(rect, x, y);
  }
  return true;
};
const isNumeric = (n) => {
  return !Number.isNaN(parseFloat(n)) && isFinite(+n) && (typeof n !== "string" || n.toLowerCase().indexOf("0x") < 0);
};
const isInteger = (n) => {
  return String(parseInt(n)) === String(n);
};
const mod = (n, m) => {
  return (n % m + m) % m;
};
const intersection = (x0, y0, x1, y1, x2, y2, x3, y3) => {
  const denom = (y3 - y2) * (x1 - x0) - (x3 - x2) * (y1 - y0);
  const nume_a = (x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2);
  const nume_b = (x1 - x0) * (y0 - y2) - (y1 - y0) * (x0 - x2);
  const ua = nume_a / denom;
  const ub = nume_b / denom;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    const x = x0 + ua * (x1 - x0);
    const y = y0 + ua * (y1 - y0);
    return new Point(x, y);
  }
  return null;
};
const ptSegDistSq = (x1, y1, x2, y2, px, py) => {
  x2 -= x1;
  y2 -= y1;
  px -= x1;
  py -= y1;
  let dotprod = px * x2 + py * y2;
  let projlenSq;
  if (dotprod <= 0) {
    projlenSq = 0;
  } else {
    px = x2 - px;
    py = y2 - py;
    dotprod = px * x2 + py * y2;
    if (dotprod <= 0) {
      projlenSq = 0;
    } else {
      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
    }
  }
  let lenSq = px * px + py * py - projlenSq;
  if (lenSq < 0) {
    lenSq = 0;
  }
  return lenSq;
};
const ptLineDist = (x1, y1, x2, y2, px, py) => {
  return Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
};
const relativeCcw = (x1, y1, x2, y2, px, py) => {
  x2 -= x1;
  y2 -= y1;
  px -= x1;
  py -= y1;
  let ccw = px * y2 - py * x2;
  if (ccw == 0) {
    ccw = px * x2 + py * y2;
    if (ccw > 0) {
      px -= x2;
      py -= y2;
      ccw = px * x2 + py * y2;
      if (ccw < 0) {
        ccw = 0;
      }
    }
  }
  return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
};
const mathUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arcToCurves,
  contains,
  findNearestSegment,
  getBoundingBox,
  getDirectedBounds,
  getPerimeterPoint,
  getPortConstraints,
  getRotatedPoint,
  intersection,
  intersects: intersects$1,
  intersectsHotspot,
  isInteger,
  isNumeric,
  mod,
  ptLineDist,
  ptSegDistSq,
  rectangleIntersectsSegment,
  relativeCcw,
  reversePortConstraints,
  toDegree,
  toRadians
}, Symbol.toStringTag, { value: "Module" }));
class CellPath {
  constructor() {
    throw new Error("Static class can't be instantiated!");
  }
  /**
   * Creates the cell path for the given cell. The cell path is a
   * concatenation of the indices of all ancestors on the (finite) path to
   * the root, eg. "0.0.0.1".
   *
   * @param cell Cell whose path should be returned.
   */
  static create(cell) {
    let result = "";
    let parent = cell.getParent();
    while (parent) {
      const index = parent.getIndex(cell);
      result = index + CellPath.PATH_SEPARATOR + result;
      cell = parent;
      parent = cell.getParent();
    }
    const n = result.length;
    if (n > 1) {
      result = result.substring(0, n - 1);
    }
    return result;
  }
  /**
   * Returns the path for the parent of the cell represented by the given
   * path. Returns null if the given path has no parent.
   *
   * @param path Path whose parent path should be returned.
   */
  static getParentPath(path) {
    const index = path.lastIndexOf(CellPath.PATH_SEPARATOR);
    if (index >= 0) {
      return path.substring(0, index);
    }
    if (path.length > 0) {
      return "";
    }
    return null;
  }
  /**
   * Returns the cell for the specified cell path using the given root as the
   * root of the path.
   *
   * @param root Root cell of the path to be resolved.
   * @param path String that defines the path.
   */
  static resolve(root, path) {
    let parent = root;
    const tokens = path.split(CellPath.PATH_SEPARATOR);
    for (let i = 0; i < tokens.length; i += 1) {
      parent = parent.getChildAt(parseInt(tokens[i]));
    }
    return parent;
  }
  /**
   * Compares the given cell paths and returns -1 if p1 is smaller, 0 if
   * p1 is equal and 1 if p1 is greater than p2.
   */
  static compare(p1, p2) {
    const min = Math.min(p1.length, p2.length);
    let comp = 0;
    for (let i = 0; i < min; i += 1) {
      if (p1[i] !== p2[i]) {
        if (p1[i].length === 0 || p2[i].length === 0) {
          comp = p1[i] === p2[i] ? 0 : p1[i] > p2[i] ? 1 : -1;
        } else {
          const t1 = parseInt(p1[i]);
          const t2 = parseInt(p2[i]);
          comp = t1 === t2 ? 0 : t1 > t2 ? 1 : -1;
        }
        break;
      }
    }
    if (comp === 0) {
      const t1 = p1.length;
      const t2 = p2.length;
      if (t1 !== t2) {
        comp = t1 > t2 ? 1 : -1;
      }
    }
    return comp;
  }
}
CellPath.PATH_SEPARATOR = ".";
const removeCursors = (element) => {
  if (element.style) {
    element.style.cursor = "";
  }
  const children = element.children;
  if (children) {
    const childCount = children.length;
    for (let i = 0; i < childCount; i += 1) {
      removeCursors(children[i]);
    }
  }
};
const getCurrentStyle = (element) => {
  return !element || element.toString() === "[object ShadowRoot]" ? null : window.getComputedStyle(element, "");
};
const parseCssNumber = (value) => {
  if (value === "thin") {
    value = "2";
  } else if (value === "medium") {
    value = "4";
  } else if (value === "thick") {
    value = "6";
  }
  let n = parseFloat(value);
  if (Number.isNaN(n)) {
    n = 0;
  }
  return n;
};
const setPrefixedStyle = (style, name, value) => {
  let prefix = null;
  if (Client.IS_SF || Client.IS_GC) {
    prefix = "Webkit";
  } else if (Client.IS_MT) {
    prefix = "Moz";
  }
  style.setProperty(name, value);
  if (prefix !== null && name.length > 0) {
    name = prefix + name.substring(0, 1).toUpperCase() + name.substring(1);
    style.setProperty(name, value);
  }
};
const hasScrollbars = (node) => {
  const style = getCurrentStyle(node);
  return !!style && (style.overflow === "scroll" || style.overflow === "auto");
};
const getDocumentSize = () => {
  const b = document.body;
  const d = document.documentElement;
  try {
    return new Rectangle(0, 0, b.clientWidth ?? d.clientWidth, Math.max(b.clientHeight ?? 0, d.clientHeight));
  } catch (e) {
    return new Rectangle();
  }
};
const fit = (node) => {
  const ds = getDocumentSize();
  const left = node.offsetLeft;
  const width = node.offsetWidth;
  const offset = getDocumentScrollOrigin(node.ownerDocument);
  const sl = offset.x;
  const st = offset.y;
  const right = sl + ds.width;
  if (left + width > right) {
    node.style.left = `${Math.max(sl, right - width)}px`;
  }
  const top = node.offsetTop;
  const height = node.offsetHeight;
  const bottom = st + ds.height;
  if (top + height > bottom) {
    node.style.top = `${Math.max(st, bottom - height)}px`;
  }
};
const getOffset = (container, scrollOffset = false) => {
  let offsetLeft = 0;
  let offsetTop = 0;
  let fixed = false;
  let node = container;
  const b = document.body;
  const d = document.documentElement;
  while (node != null && node != b && node != d && !fixed) {
    const style = getCurrentStyle(node);
    if (style != null) {
      fixed = fixed || style.position == "fixed";
    }
    node = node.parentNode;
  }
  if (!scrollOffset && !fixed) {
    const offset = getDocumentScrollOrigin(container.ownerDocument);
    offsetLeft += offset.x;
    offsetTop += offset.y;
  }
  const r = container.getBoundingClientRect();
  if (r != null) {
    offsetLeft += r.left;
    offsetTop += r.top;
  }
  return new Point(offsetLeft, offsetTop);
};
const getDocumentScrollOrigin = (doc) => {
  const wnd = doc.defaultView || doc.parentWindow;
  const x = wnd != null && window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
  const y = wnd != null && window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
  return new Point(x, y);
};
const getScrollOrigin = (node = null, includeAncestors = false, includeDocument = true) => {
  const doc = node != null ? node.ownerDocument : document;
  const b = doc.body;
  const d = doc.documentElement;
  const result = new Point();
  let fixed = false;
  while (node != null && node != b && node != d) {
    if (!Number.isNaN(node.scrollLeft) && !Number.isNaN(node.scrollTop)) {
      result.x += node.scrollLeft;
      result.y += node.scrollTop;
    }
    const style = getCurrentStyle(node);
    if (style != null) {
      fixed = fixed || style.position == "fixed";
    }
    node = includeAncestors ? node.parentNode : null;
  }
  if (!fixed && includeDocument) {
    const origin = getDocumentScrollOrigin(doc);
    result.x += origin.x;
    result.y += origin.y;
  }
  return result;
};
const convertPoint = (container, x, y) => {
  const origin = getScrollOrigin(container, false);
  const offset = getOffset(container);
  offset.x -= origin.x;
  offset.y -= origin.y;
  return new Point(x - offset.x, y - offset.y);
};
const setCellStyles = (model, cells, key, value) => {
  if (cells.length > 0) {
    model.batchUpdate(() => {
      for (let i = 0; i < cells.length; i += 1) {
        const cell = cells[i];
        if (cell) {
          const style = cell.getClonedStyle();
          style[key] = value;
          model.setStyle(cell, style);
        }
      }
    });
  }
};
const setCellStyleFlags = (model, cells, key, flag, value) => {
  if (cells.length > 0) {
    model.batchUpdate(() => {
      for (let i = 0; i < cells.length; i += 1) {
        const cell = cells[i];
        if (cell) {
          const style = setStyleFlag(cell.getClonedStyle(), key, flag, value);
          model.setStyle(cell, style);
        }
      }
    });
  }
};
const setStyleFlag = (style, key, flag, value) => {
  const v = style[key];
  if (v === void 0) {
    style[key] = value === void 0 || value ? flag : 0;
  } else {
    if (value === void 0) {
      style[key] = v ^ flag;
    } else if (value) {
      style[key] = v | flag;
    } else {
      style[key] = v & ~flag;
    }
  }
  return style;
};
const setOpacity = (node, value) => {
  node.style.opacity = String(value / 100);
};
const getSizeForString = (text, fontSize = DEFAULT_FONTSIZE, fontFamily = DEFAULT_FONTFAMILY, textWidth = null, fontStyle = null) => {
  const div = document.createElement("div");
  div.style.fontFamily = fontFamily;
  div.style.fontSize = `${Math.round(fontSize)}px`;
  div.style.lineHeight = `${Math.round(fontSize * LINE_HEIGHT)}px`;
  if (fontStyle !== null) {
    matchBinaryMask(fontStyle, FONT.BOLD) && (div.style.fontWeight = "bold");
    matchBinaryMask(fontStyle, FONT.ITALIC) && (div.style.fontWeight = "italic");
    const txtDecor = [];
    matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
    matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
    txtDecor.length > 0 && (div.style.textDecoration = txtDecor.join(" "));
  }
  div.style.position = "absolute";
  div.style.visibility = "hidden";
  div.style.display = "inline-block";
  if (textWidth !== null) {
    div.style.width = `${textWidth}px`;
    div.style.whiteSpace = "normal";
  } else {
    div.style.whiteSpace = "nowrap";
  }
  div.innerHTML = text;
  document.body.appendChild(div);
  const size = new Rectangle(0, 0, div.offsetWidth, div.offsetHeight);
  document.body.removeChild(div);
  return size;
};
const sortCells = (cells, ascending = true) => {
  const lookup = new Dictionary();
  cells.sort((o1, o2) => {
    let p1 = lookup.get(o1);
    if (p1 == null) {
      p1 = CellPath.create(o1).split(CellPath.PATH_SEPARATOR);
      lookup.put(o1, p1);
    }
    let p2 = lookup.get(o2);
    if (p2 == null) {
      p2 = CellPath.create(o2).split(CellPath.PATH_SEPARATOR);
      lookup.put(o2, p2);
    }
    const comp = CellPath.compare(p1, p2);
    return comp == 0 ? 0 : comp > 0 == ascending ? 1 : -1;
  });
  return cells;
};
const getAlignmentAsPoint = (align, valign) => {
  let dx = -0.5;
  let dy = -0.5;
  if (align === ALIGN.LEFT) {
    dx = 0;
  } else if (align === ALIGN.RIGHT) {
    dx = -1;
  }
  if (valign === ALIGN.TOP) {
    dy = 0;
  } else if (valign === ALIGN.BOTTOM) {
    dy = -1;
  }
  return new Point(dx, dy);
};
const styleUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  convertPoint,
  fit,
  getAlignmentAsPoint,
  getCurrentStyle,
  getDocumentScrollOrigin,
  getDocumentSize,
  getOffset,
  getScrollOrigin,
  getSizeForString,
  hasScrollbars,
  parseCssNumber,
  removeCursors,
  setCellStyleFlags,
  setCellStyles,
  setOpacity,
  setPrefixedStyle,
  setStyleFlag,
  sortCells
}, Symbol.toStringTag, { value: "Module" }));
class UrlConverter {
  constructor() {
    this.enabled = true;
    this.baseUrl = null;
    this.baseDomain = null;
  }
  /**
   * Private helper function to update the base URL.
   */
  updateBaseUrl() {
    this.baseDomain = `${location.protocol}//${location.host}`;
    this.baseUrl = this.baseDomain + location.pathname;
    const tmp = this.baseUrl.lastIndexOf("/");
    if (tmp > 0) {
      this.baseUrl = this.baseUrl.substring(0, tmp + 1);
    }
  }
  /**
   * Returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Sets <enabled>.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * Returns <baseUrl>.
   */
  getBaseUrl() {
    return this.baseUrl;
  }
  /**
   * Sets <baseUrl>.
   */
  setBaseUrl(value) {
    this.baseUrl = value;
  }
  /**
   * Returns <baseDomain>.
   */
  getBaseDomain() {
    return this.baseDomain;
  }
  /**
   * Sets <baseDomain>.
   */
  setBaseDomain(value) {
    this.baseDomain = value;
  }
  /**
   * Returns true if the given URL is relative.
   */
  isRelativeUrl(url) {
    return url && url.substring(0, 2) !== "//" && url.substring(0, 7) !== "http://" && url.substring(0, 8) !== "https://" && url.substring(0, 10) !== "data:image" && url.substring(0, 7) !== "file://";
  }
  /**
   * Converts the given URL to an absolute URL with protol and domain.
   * Relative URLs are first converted to absolute URLs.
   */
  convert(url) {
    if (this.isEnabled() && this.isRelativeUrl(url)) {
      if (!this.getBaseUrl()) {
        this.updateBaseUrl();
      }
      if (url.charAt(0) === "/") {
        url = this.getBaseDomain() + url;
      } else {
        url = this.getBaseUrl() + url;
      }
    }
    return url;
  }
}
const clone = function _clone(obj, transients = null, shallow = false) {
  shallow = shallow != null ? shallow : false;
  let clone2 = null;
  if (obj != null && typeof obj.constructor === "function") {
    clone2 = new obj.constructor();
    for (const i in obj) {
      if (i != ObjectIdentity.FIELD_NAME && (transients == null || transients.indexOf(i) < 0)) {
        if (!shallow && typeof obj[i] === "object") {
          clone2[i] = _clone(obj[i]);
        } else {
          clone2[i] = obj[i];
        }
      }
    }
  }
  return clone2;
};
const cloneUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clone
}, Symbol.toStringTag, { value: "Module" }));
class AbstractCanvas2D {
  constructor() {
    this.state = this.createState();
    this.states = [];
    this.path = [];
    this.rotateHtml = true;
    this.lastX = 0;
    this.lastY = 0;
    this.moveOp = "M";
    this.lineOp = "L";
    this.quadOp = "Q";
    this.curveOp = "C";
    this.closeOp = "Z";
    this.pointerEvents = false;
    this.pointerEventsValue = null;
    this.addOp = (op, ...args) => {
      this.path.push(op);
      if (args.length > 1) {
        const s = this.state;
        for (let i = 1; i < args.length; i += 2) {
          this.lastX = args[i - 1];
          this.lastY = args[i];
          this.path.push(this.format((this.lastX + s.dx) * s.scale));
          this.path.push(this.format((this.lastY + s.dy) * s.scale));
        }
      }
    };
    this.converter = this.createUrlConverter();
    this.reset();
  }
  /**
   * Create a new <UrlConverter> and returns it.
   */
  createUrlConverter() {
    return new UrlConverter();
  }
  /**
   * Resets the state of this canvas.
   */
  reset() {
    this.state = this.createState();
    this.states = [];
  }
  /**
   * Creates the state of the this canvas.
   */
  createState() {
    return {
      dx: 0,
      dy: 0,
      scale: 1,
      alpha: 1,
      fillAlpha: 1,
      strokeAlpha: 1,
      fillColor: NONE,
      gradientFillAlpha: 1,
      gradientColor: NONE,
      gradientAlpha: 1,
      gradientDirection: DIRECTION.EAST,
      strokeColor: NONE,
      strokeWidth: 1,
      dashed: false,
      dashPattern: "3 3",
      fixDash: false,
      lineCap: "flat",
      lineJoin: "miter",
      miterLimit: 10,
      fontColor: "#000000",
      fontBackgroundColor: NONE,
      fontBorderColor: NONE,
      fontSize: DEFAULT_FONTSIZE,
      fontFamily: DEFAULT_FONTFAMILY,
      fontStyle: 0,
      shadow: false,
      shadowColor: StyleDefaultsConfig.shadowColor,
      shadowAlpha: StyleDefaultsConfig.shadowOpacity,
      shadowDx: StyleDefaultsConfig.shadowOffsetX,
      shadowDy: StyleDefaultsConfig.shadowOffsetY,
      rotation: 0,
      rotationCx: 0,
      rotationCy: 0
    };
  }
  /**
   * Rounds all numbers to integers.
   */
  format(value) {
    return Math.round(value);
  }
  /**
   * Rotates the given point and returns the result as an {@link Point}.
   */
  rotatePoint(x, y, theta, cx, cy) {
    const rad = theta * (Math.PI / 180);
    return getRotatedPoint(new Point(x, y), Math.cos(rad), Math.sin(rad), new Point(cx, cy));
  }
  /**
   * Saves the current state.
   */
  save() {
    this.states.push(this.state);
    this.state = clone(this.state);
  }
  /**
   * Restores the current state.
   */
  restore() {
    const state = this.states.pop();
    if (state)
      this.state = state;
  }
  /**
   * Sets the current link. Hook for subclassers.
   */
  setLink(link2) {
  }
  /**
   * Scales the current state.
   */
  scale(value) {
    this.state.scale *= value;
    if (this.state.strokeWidth !== null)
      this.state.strokeWidth *= value;
  }
  /**
   * Translates the current state.
   */
  translate(dx, dy) {
    this.state.dx += dx;
    this.state.dy += dy;
  }
  /**
   * Rotates the current state.
   */
  rotate(theta, flipH, flipV, cx, cy) {
  }
  /**
   * Sets the current alpha.
   */
  setAlpha(value) {
    this.state.alpha = value;
  }
  /**
   * Sets the current solid fill alpha.
   */
  setFillAlpha(value) {
    this.state.fillAlpha = value;
  }
  /**
   * Sets the current stroke alpha.
   */
  setStrokeAlpha(value) {
    this.state.strokeAlpha = value;
  }
  /**
   * Sets the current fill color.
   */
  setFillColor(value) {
    this.state.fillColor = value ?? NONE;
    this.state.gradientColor = NONE;
  }
  /**
   * Sets the current gradient.
   */
  setGradient(color1, color2, x, y, w, h, direction, alpha1 = 1, alpha2 = 1) {
    const s = this.state;
    s.fillColor = color1;
    s.gradientFillAlpha = alpha1;
    s.gradientColor = color2;
    s.gradientAlpha = alpha2;
    s.gradientDirection = direction;
  }
  /**
   * Sets the current stroke color.
   */
  setStrokeColor(value) {
    this.state.strokeColor = value ?? NONE;
  }
  /**
   * Sets the current stroke width.
   */
  setStrokeWidth(value) {
    this.state.strokeWidth = value;
  }
  /**
   * Enables or disables dashed lines.
   */
  setDashed(value, fixDash = false) {
    this.state.dashed = value;
    this.state.fixDash = fixDash;
  }
  /**
   * Sets the current dash pattern.
   */
  setDashPattern(value) {
    this.state.dashPattern = value;
  }
  /**
   * Sets the current line cap.
   */
  setLineCap(value) {
    this.state.lineCap = value;
  }
  /**
   * Sets the current line join.
   */
  setLineJoin(value) {
    this.state.lineJoin = value;
  }
  /**
   * Sets the current miter limit.
   */
  setMiterLimit(value) {
    this.state.miterLimit = value;
  }
  /**
   * Sets the current font color.
   */
  setFontColor(value) {
    this.state.fontColor = value ?? NONE;
  }
  /**
   * Sets the current font background color.
   */
  setFontBackgroundColor(value) {
    this.state.fontBackgroundColor = value ?? NONE;
  }
  /**
   * Sets the current font border color.
   */
  setFontBorderColor(value) {
    this.state.fontBorderColor = value ?? NONE;
  }
  /**
   * Sets the current font size.
   */
  setFontSize(value) {
    this.state.fontSize = value;
  }
  /**
   * Sets the current font family.
   */
  setFontFamily(value) {
    this.state.fontFamily = value;
  }
  /**
   * Sets the current font style.
   */
  setFontStyle(value) {
    this.state.fontStyle = value;
  }
  /**
   * Enables or disables and configures the current shadow.
   */
  setShadow(enabled) {
    this.state.shadow = enabled;
  }
  /**
   * Sets the current shadow color.
   *
   * @param value Hexadecimal representation of the color or `none`.
   */
  setShadowColor(value) {
    this.state.shadowColor = value ?? NONE;
  }
  /**
   * Sets the current shadow alpha.
   *
   * @param value Number that represents the new alpha. Possible values are between 1 (opaque) and 0 (transparent).
   */
  setShadowAlpha(value) {
    this.state.shadowAlpha = value;
  }
  /**
   * Sets the current shadow offset.
   *
   * @param dx Number that represents the horizontal offset of the shadow.
   * @param dy Number that represents the vertical offset of the shadow.
   */
  setShadowOffset(dx, dy) {
    this.state.shadowDx = dx;
    this.state.shadowDy = dy;
  }
  /**
   * Starts a new path.
   */
  begin() {
    this.lastX = 0;
    this.lastY = 0;
    this.path = [];
  }
  /**
   *  Moves the current path the given coordinates.
   */
  moveTo(x, y) {
    this.addOp(this.moveOp, x, y);
  }
  /**
   * Draws a line to the given coordinates. Uses moveTo with the op argument.
   */
  lineTo(x, y) {
    this.addOp(this.lineOp, x, y);
  }
  /**
   * Adds a quadratic curve to the current path.
   */
  quadTo(x1, y1, x2, y2) {
    this.addOp(this.quadOp, x1, y1, x2, y2);
  }
  /**
   * Adds a bezier curve to the current path.
   */
  curveTo(x1, y1, x2, y2, x3, y3) {
    this.addOp(this.curveOp, x1, y1, x2, y2, x3, y3);
  }
  /**
   * Adds the given arc to the current path. This is a synthetic operation that
   * is broken down into curves.
   * @param rx: The x distance between the current position
   *            and the center of the ellipse around which to arc
   * @param ry: The y distance between the current position
   *            and the center of the ellipse around which to arc
   * @param x: The x position of the end point of the arc
   * @param y: The y position of the end point of the arc
   */
  arcTo(rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
    const curves = arcToCurves(this.lastX, this.lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y);
    if (curves != null) {
      for (let i = 0; i < curves.length; i += 6) {
        this.curveTo(curves[i], curves[i + 1], curves[i + 2], curves[i + 3], curves[i + 4], curves[i + 5]);
      }
    }
  }
  /**
   * Closes the current path.
   */
  close(x1, y1, x2, y2, x3, y3) {
    this.addOp(this.closeOp);
  }
}
class TemporaryCellStates {
  constructor(view, scale = 1, cells, isCellVisibleFn = null, getLinkForCellState = null) {
    this.view = view;
    this.oldValidateCellState = view.validateCellState;
    this.oldBounds = view.getGraphBounds();
    this.oldStates = view.getStates();
    this.oldScale = view.getScale();
    this.oldDoRedrawShape = view.graph.cellRenderer.doRedrawShape;
    if (getLinkForCellState != null) {
      view.graph.cellRenderer.doRedrawShape = (state) => {
        const shape = state == null ? void 0 : state.shape;
        const oldPaint = shape.paint;
        shape.paint = (c) => {
          const link2 = getLinkForCellState(state);
          if (link2 != null) {
            c.setLink(link2);
          }
          oldPaint.apply(shape, [c]);
          if (link2 != null) {
            c.setLink(null);
          }
        };
        this.oldDoRedrawShape.apply(view.graph.cellRenderer, [state]);
        shape.paint = oldPaint;
      };
    }
    view.validateCellState = (cell, recurse) => {
      if (cell == null || isCellVisibleFn == null || isCellVisibleFn(cell)) {
        return this.oldValidateCellState.apply(view, [cell, recurse]);
      }
      return null;
    };
    view.setStates(new Dictionary());
    view.setScale(scale);
    view.resetValidationState();
    let bbox = null;
    for (const cell of cells) {
      const bounds = view.getBoundingBox(view.validateCellState(view.validateCell(cell)));
      if (bbox == null) {
        bbox = bounds;
      } else {
        bbox.add(bounds);
      }
    }
    view.setGraphBounds(bbox || new Rectangle());
  }
  destroy() {
    const view = this.view;
    view.setScale(this.oldScale);
    view.setStates(this.oldStates);
    view.setGraphBounds(this.oldBounds);
    view.validateCellState = this.oldValidateCellState;
    view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;
  }
}
const remove = (obj, array) => {
  let result = null;
  if (typeof array === "object") {
    let index = array.indexOf(obj);
    while (index >= 0) {
      array.splice(index, 1);
      result = obj;
      index = array.indexOf(obj);
    }
  }
  for (const key in array) {
    if (array[key] == obj) {
      delete array[key];
      result = obj;
    }
  }
  return result;
};
const equalPoints = (a, b) => {
  if (!a && b || a && !b || a && b && a.length != b.length) {
    return false;
  }
  if (a && b) {
    for (let i = 0; i < a.length; i += 1) {
      const p = a[i];
      if (!p || p && !p.equals(b[i]))
        return false;
    }
  }
  return true;
};
const equalEntries = (a, b) => {
  let count = 0;
  if (!a && b || a && !b || a && b && a.length != b.length) {
    return false;
  }
  if (a && b) {
    for (const key in b) {
      count++;
    }
    for (const key in a) {
      count--;
      if ((!Number.isNaN(a[key]) || !Number.isNaN(b[key])) && a[key] !== b[key]) {
        return false;
      }
    }
  }
  return count === 0;
};
const removeDuplicates = (arr) => {
  const dict = new Dictionary();
  const result = [];
  for (let i = 0; i < arr.length; i += 1) {
    if (!dict.get(arr[i])) {
      result.push(arr[i]);
      dict.put(arr[i], true);
    }
  }
  return result;
};
class Geometry extends Rectangle {
  constructor(x = 0, y = 0, width = 0, height = 0) {
    super(x, y, width, height);
    this.TRANSLATE_CONTROL_POINTS = true;
    this.alternateBounds = null;
    this.sourcePoint = null;
    this.targetPoint = null;
    this.points = null;
    this.offset = null;
    this.relative = false;
  }
  setRelative(isRelative) {
    this.relative = isRelative;
  }
  /**
   * Swaps the x, y, width and height with the values stored in
   * {@link alternateBounds} and puts the previous values into {@link alternateBounds} as
   * a rectangle. This operation is carried-out in-place, that is, using the
   * existing geometry instance. If this operation is called during a graph
   * model transactional change, then the geometry should be cloned before
   * calling this method and setting the geometry of the cell using
   * {@link GraphDataModel.setGeometry}.
   */
  swap() {
    if (this.alternateBounds) {
      const old = new Rectangle(this.x, this.y, this.width, this.height);
      this.x = this.alternateBounds.x;
      this.y = this.alternateBounds.y;
      this.width = this.alternateBounds.width;
      this.height = this.alternateBounds.height;
      this.alternateBounds = old;
    }
  }
  /**
   * Returns the {@link Point} representing the source or target point of this
   * edge. This is only used if the edge has no source or target vertex.
   *
   * @param {Boolean} isSource that specifies if the source or target point should be returned.
   */
  getTerminalPoint(isSource) {
    return isSource ? this.sourcePoint : this.targetPoint;
  }
  /**
   * Sets the {@link sourcePoint} or {@link targetPoint} to the given {@link Point} and
   * returns the new point.
   *
   * @param {Point} point to be used as the new source or target point.
   * @param {Boolean} isSource that specifies if the source or target point should be set.
   */
  setTerminalPoint(point, isSource) {
    if (isSource) {
      this.sourcePoint = point;
    } else {
      this.targetPoint = point;
    }
    return point;
  }
  /**
   * Rotates the geometry by the given angle around the given center. That is,
   * {@link x} and {@link y} of the geometry, the {@link sourcePoint}, {@link targetPoint} and all
   * {@link points} are translated by the given amount. {@link x} and {@link y} are only
   * translated if {@link relative} is false.
   *
   * @param {Number} angle that specifies the rotation angle in degrees.
   * @param {Point} cx   that specifies the center of the rotation.
   */
  rotate(angle, cx) {
    const rad = toRadians(angle);
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    if (!this.relative) {
      const ct = new Point(this.getCenterX(), this.getCenterY());
      const pt = getRotatedPoint(ct, cos, sin, cx);
      this.x = Math.round(pt.x - this.width / 2);
      this.y = Math.round(pt.y - this.height / 2);
    }
    if (this.sourcePoint) {
      const pt = getRotatedPoint(this.sourcePoint, cos, sin, cx);
      this.sourcePoint.x = Math.round(pt.x);
      this.sourcePoint.y = Math.round(pt.y);
    }
    if (this.targetPoint) {
      const pt = getRotatedPoint(this.targetPoint, cos, sin, cx);
      this.targetPoint.x = Math.round(pt.x);
      this.targetPoint.y = Math.round(pt.y);
    }
    if (this.points) {
      for (let i = 0; i < this.points.length; i += 1) {
        if (this.points[i]) {
          const pt = getRotatedPoint(this.points[i], cos, sin, cx);
          this.points[i].x = Math.round(pt.x);
          this.points[i].y = Math.round(pt.y);
        }
      }
    }
  }
  /**
   * Translates the geometry by the specified amount. That is, {@link x} and {@link y} of the
   * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are translated
   * by the given amount. {@link x} and {@link y} are only translated if {@link relative} is false.
   * If {@link TRANSLATE_CONTROL_POINTS} is false, then {@link points} are not modified by
   * this function.
   *
   * @param {Number} dx that specifies the x-coordinate of the translation.
   * @param {Number} dy that specifies the y-coordinate of the translation.
   */
  translate(dx, dy) {
    if (!this.relative) {
      this.x += dx;
      this.y += dy;
    }
    if (this.sourcePoint) {
      this.sourcePoint.x = this.sourcePoint.x + dx;
      this.sourcePoint.y = this.sourcePoint.y + dy;
    }
    if (this.targetPoint) {
      this.targetPoint.x = this.targetPoint.x + dx;
      this.targetPoint.y = this.targetPoint.y + dy;
    }
    if (this.TRANSLATE_CONTROL_POINTS && this.points) {
      for (let i = 0; i < this.points.length; i += 1) {
        if (this.points[i]) {
          this.points[i].x = this.points[i].x + dx;
          this.points[i].y = this.points[i].y + dy;
        }
      }
    }
  }
  /**
   * Scales the geometry by the given amount. That is, {@link x} and {@link y} of the
   * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are scaled
   * by the given amount. {@link x}, {@link y}, {@link width} and {@link height} are only scaled if
   * {@link relative} is false. If {@link fixedAspect} is true, then the smaller value
   * is used to scale the width and the height.
   *
   * @param {Number} sx that specifies the horizontal scale factor.
   * @param {Number} sy that specifies the vertical scale factor.
   * @param {Optional} fixedAspect boolean to keep the aspect ratio fixed.
   */
  scale(sx, sy, fixedAspect) {
    if (this.sourcePoint) {
      this.sourcePoint.x = this.sourcePoint.x * sx;
      this.sourcePoint.y = this.sourcePoint.y * sy;
    }
    if (this.targetPoint) {
      this.targetPoint.x = this.targetPoint.x * sx;
      this.targetPoint.y = this.targetPoint.y * sy;
    }
    if (this.points) {
      for (let i = 0; i < this.points.length; i += 1) {
        if (this.points[i]) {
          this.points[i].x = this.points[i].x * sx;
          this.points[i].y = this.points[i].y * sy;
        }
      }
    }
    if (!this.relative) {
      this.x *= sx;
      this.y *= sy;
      if (fixedAspect) {
        sy = sx = Math.min(sx, sy);
      }
      this.width *= sx;
      this.height *= sy;
    }
  }
  /**
   * Returns true if the given object equals this geometry.
   */
  equals(geom) {
    var _a, _b, _c, _d;
    if (!geom)
      return false;
    return super.equals(geom) && this.relative === geom.relative && (this.sourcePoint === null && geom.sourcePoint === null || !!((_a = this.sourcePoint) == null ? void 0 : _a.equals(geom.sourcePoint))) && (this.targetPoint === null && geom.targetPoint === null || !!((_b = this.targetPoint) == null ? void 0 : _b.equals(geom.targetPoint))) && equalPoints(this.points, geom.points) && (this.alternateBounds === null && geom.alternateBounds === null || !!((_c = this.alternateBounds) == null ? void 0 : _c.equals(geom.alternateBounds))) && (this.offset === null && geom.offset === null || !!((_d = this.offset) == null ? void 0 : _d.equals(geom.offset)));
  }
  clone() {
    return clone(this);
  }
}
class MaxXmlRequest {
  constructor(url, params = null, method = "POST", async = true, username = null, password = null) {
    this.binary = false;
    this.withCredentials = false;
    this.request = null;
    this.decodeSimulateValues = false;
    this.url = url;
    this.params = params;
    this.method = method || "POST";
    this.async = async;
    this.username = username;
    this.password = password;
  }
  /**
   * Returns {@link binary}.
   */
  isBinary() {
    return this.binary;
  }
  /**
   * Sets {@link binary}.
   *
   * @param value
   */
  setBinary(value) {
    this.binary = value;
  }
  /**
   * Returns the response as a string.
   */
  getText() {
    return this.request.responseText;
  }
  /**
   * Returns true if the response is ready.
   */
  isReady() {
    return this.request.readyState === 4;
  }
  /**
   * Returns the document element of the response XML document.
   */
  getDocumentElement() {
    const doc = this.getXml();
    if (doc != null) {
      return doc.documentElement;
    }
    return null;
  }
  /**
   * Returns the response as an XML document. Use {@link getDocumentElement} to get
   * the document element of the XML document.
   */
  getXml() {
    let xml = this.request.responseXML;
    if (xml == null || xml.documentElement == null) {
      xml = new DOMParser().parseFromString(this.request.responseText, "text/xml");
    }
    return xml;
  }
  /**
   * Returns the status as a number, e.g. 404 for "Not found" or 200 for "OK".
   * Note: The NS_ERROR_NOT_AVAILABLE for invalid responses cannot be caught.
   */
  getStatus() {
    var _a;
    return (_a = this.request) == null ? void 0 : _a.status;
  }
  /**
   * Creates and returns the inner {@link request} object.
   */
  create() {
    const req = new XMLHttpRequest();
    if (this.isBinary() && req.overrideMimeType) {
      req.overrideMimeType("text/plain; charset=x-user-defined");
    }
    return req;
  }
  /**
   * Send the {@link request} to the target URL using the specified functions to process the response asynchronously.
   *
   * Note: Due to technical limitations, `onerror` is currently ignored.
   *
   * @param onload Function to be invoked if a successful response was received.
   * @param onerror Function to be called on any error. Unused in this implementation, intended for overridden function.
   * @param timeout Optional timeout in ms before calling ontimeout.
   * @param ontimeout Optional function to execute on timeout.
   */
  send(onload = null, onerror = null, timeout = null, ontimeout = null) {
    this.request = this.create();
    if (this.request != null) {
      if (onload != null) {
        this.request.onreadystatechange = () => {
          if (this.isReady()) {
            onload(this);
            this.request.onreadystatechange = null;
          }
        };
      }
      this.request.open(this.method, this.url, this.async, this.username, this.password);
      this.setRequestHeaders(this.request, this.params);
      if (window.XMLHttpRequest && this.withCredentials) {
        this.request.withCredentials = "true";
      }
      if (window.XMLHttpRequest && timeout != null && ontimeout != null) {
        this.request.timeout = timeout;
        this.request.ontimeout = ontimeout;
      }
      this.request.send(this.params);
    }
  }
  /**
   * Sets the headers for the given request and parameters. This sets the
   * content-type to application/x-www-form-urlencoded if any params exist.
   *
   * @example
   * ```JavaScript
   * request.setRequestHeaders = function(request, params)
   * {
   *   if (params != null)
   *   {
   *     request.setRequestHeader('Content-Type',
   *             'multipart/form-data');
   *     request.setRequestHeader('Content-Length',
   *             params.length);
   *   }
   * };
   * ```
   *
   * Use the code above before calling {@link send} if you require a
   * multipart/form-data request.
   *
   * @param request
   * @param params
   */
  setRequestHeaders(request, params) {
    if (params != null) {
      request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    }
  }
  /**
   * Creates and posts a request to the given target URL using a dynamically
   * created form inside the given document.
   *
   * @param doc Document that contains the form element.
   * @param target Target to send the form result to.
   */
  simulate(doc, target = null) {
    doc = doc || document;
    let old = null;
    if (doc === document) {
      old = window.onbeforeunload;
      window.onbeforeunload = null;
    }
    const form = doc.createElement("form");
    form.setAttribute("method", this.method);
    form.setAttribute("action", this.url);
    if (target != null) {
      form.setAttribute("target", target);
    }
    form.style.display = "none";
    form.style.visibility = "hidden";
    const params = this.params;
    const pars = params.indexOf("&") > 0 ? params.split("&") : params.split(" ");
    for (let i = 0; i < pars.length; i += 1) {
      const pos = pars[i].indexOf("=");
      if (pos > 0) {
        const name = pars[i].substring(0, pos);
        let value = pars[i].substring(pos + 1);
        if (this.decodeSimulateValues) {
          value = decodeURIComponent(value);
        }
        const textarea = doc.createElement("textarea");
        textarea.setAttribute("wrap", "off");
        textarea.setAttribute("name", name);
        write(textarea, value);
        form.appendChild(textarea);
      }
    }
    doc.body.appendChild(form);
    form.submit();
    if (form.parentNode != null) {
      form.parentNode.removeChild(form);
    }
    if (old != null) {
      window.onbeforeunload = old;
    }
  }
}
const load = (url) => {
  const req = new MaxXmlRequest(url, null, "GET", false);
  req.send();
  return req;
};
const get = (url, onload = null, onerror = null, binary = false, timeout = null, ontimeout = null, headers = null) => {
  const req = new MaxXmlRequest(url, null, "GET");
  const { setRequestHeaders } = req;
  if (headers) {
    req.setRequestHeaders = (request, params) => {
      setRequestHeaders.apply(void 0, [request, params]);
      for (const key in headers) {
        request.setRequestHeader(key, headers[key]);
      }
    };
  }
  if (binary != null) {
    req.setBinary(binary);
  }
  req.send(onload, onerror, timeout, ontimeout);
  return req;
};
const getAll = (urls, onload, onerror) => {
  let remain = urls.length;
  const result = [];
  let errors = 0;
  const err = () => {
    if (errors == 0 && onerror != null) {
      onerror();
    }
    errors++;
  };
  for (let i = 0; i < urls.length; i += 1) {
    ((url, index) => {
      get(url, (req) => {
        const status = req.getStatus();
        if (status < 200 || status > 299) {
          err();
        } else {
          result[index] = req;
          remain--;
          if (remain == 0) {
            onload(result);
          }
        }
      }, err);
    })(urls[i], i);
  }
  if (remain == 0) {
    onload(result);
  }
};
const post = (url, params = null, onload, onerror = null) => {
  return new MaxXmlRequest(url, params).send(onload, onerror);
};
const submit = (url, params, doc, target) => {
  return new MaxXmlRequest(url, params).simulate(doc, target);
};
const requestUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get,
  getAll,
  load,
  post,
  submit
}, Symbol.toStringTag, { value: "Module" }));
class ObjectCodec {
  constructor(template, exclude = [], idrefs = [], mapping = {}) {
    this.template = template;
    this.exclude = exclude;
    this.idrefs = idrefs;
    this.mapping = mapping;
    this.reverse = {};
    for (const i in this.mapping) {
      this.reverse[this.mapping[i]] = i;
    }
  }
  /**
   * Returns the name used for the node names and lookup of the codec when
   * classes are encoded and nodes are decoded. For classes to work with
   * this the codec registry automatically adds an alias for the classname
   * if that is different from what this returns.
   *
   * The default implementation returns the classname of the template class if no name is set.
   */
  getName() {
    return this.name ?? this.template.constructor.name;
  }
  setName(name) {
    this.name = name;
  }
  /**
   * Returns a new instance of the template for this codec.
   */
  cloneTemplate() {
    return new this.template.constructor();
  }
  /**
   * Returns the field name for the given attribute name.
   * Looks up the value in the {@link reverse} mapping or returns
   * the input if there is no reverse mapping for the
   * given name.
   */
  getFieldName(attributename) {
    if (attributename != null) {
      const mapped = this.reverse[attributename];
      if (mapped != null) {
        attributename = mapped;
      }
    }
    return attributename;
  }
  /**
   * Returns the attribute name for the given field name.
   * Looks up the value in the {@link mapping} or returns
   * the input if there is no mapping for the
   * given name.
   */
  getAttributeName(fieldname) {
    if (fieldname != null) {
      const mapped = this.mapping[fieldname];
      if (mapped != null) {
        fieldname = mapped;
      }
    }
    return fieldname;
  }
  /**
   * Returns true if the given attribute is to be ignored by the codec. This
   * implementation returns true if the given field name is in {@link exclude} or
   * if the field name equals {@link ObjectIdentity.FIELD_NAME}.
   *
   * @param obj Object instance that contains the field.
   * @param attr Fieldname of the field.
   * @param value Value of the field.
   * @param write Boolean indicating if the field is being encoded or decoded.
   * Write is true if the field is being encoded, else it is being decoded.
   */
  isExcluded(obj, attr, value, write2) {
    return attr == ObjectIdentity.FIELD_NAME || this.exclude.indexOf(attr) >= 0;
  }
  /**
   * Returns true if the given field name is to be treated
   * as a textual reference (ID). This implementation returns
   * true if the given field name is in {@link idrefs}.
   *
   * @param obj Object instance that contains the field.
   * @param attr Field name of the field.
   * @param value Value of the field.
   * @param write Boolean indicating if the field is being encoded or decoded.
   * Write is true if the field is being encoded, else it is being decoded.
   */
  isReference(obj, attr, value, write2) {
    return this.idrefs.indexOf(attr) >= 0;
  }
  /**
   * Encodes the specified object and returns a node
   * representing then given object. Calls {@link beforeEncode}
   * after creating the node and {@link afterEncode} with the
   * resulting node after processing.
   *
   * Enc is a reference to the calling encoder. It is used
   * to encode complex objects and create references.
   *
   * This implementation encodes all variables of an
   * object according to the following rules:
   *
   * - If the variable name is in {@link exclude} then it is ignored.
   * - If the variable name is in {@link idrefs} then {@link Codec.getId}
   * is used to replace the object with its ID.
   * - The variable name is mapped using {@link mapping}.
   * - If obj is an array and the variable name is numeric
   * (ie. an index) then it is not encoded.
   * - If the value is an object, then the codec is used to
   * create a child node with the variable name encoded into
   * the "as" attribute.
   * - Else, if {@link encodeDefaults} is true or the value differs
   * from the template value, then ...
   * - ... if obj is not an array, then the value is mapped to
   * an attribute.
   * - ... else if obj is an array, the value is mapped to an
   * add child with a value attribute or a text child node,
   * if the value is a function.
   *
   * If no ID exists for a variable in {@link idrefs} or if an object
   * cannot be encoded, a warning is issued using {@link GlobalConfig.logger}.
   *
   * Returns the resulting XML node that represents the given
   * object.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object to be encoded.
   */
  encode(enc, obj) {
    const node = enc.document.createElement(this.getName());
    obj = this.beforeEncode(enc, obj, node);
    this.encodeObject(enc, obj, node);
    return this.afterEncode(enc, obj, node);
  }
  /**
   * Encodes the value of each member in then given obj into the given node using
   * {@link encodeValue}.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object to be encoded.
   * @param node XML node that contains the encoded object.
   */
  encodeObject(enc, obj, node) {
    enc.setAttribute(node, "id", enc.getId(obj));
    for (const i in obj) {
      let name = i;
      const value = obj[name];
      if (value != null && !this.isExcluded(obj, name, value, true)) {
        if (isInteger(name)) {
          name = null;
        }
        this.encodeValue(enc, obj, name, value, node);
      }
    }
  }
  /**
   * Converts the given value according to the mappings
   * and id-refs in this codec and uses {@link writeAttribute}
   * to write the attribute into the given node.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object whose property is going to be encoded.
   * @param name XML node that contains the encoded object.
   * @param value Value of the property to be encoded.
   * @param node XML node that contains the encoded object.
   */
  encodeValue(enc, obj, name, value, node) {
    if (value != null) {
      if (name != null && this.isReference(obj, name, value, true)) {
        const tmp = enc.getId(value);
        if (tmp == null) {
          GlobalConfig.logger.warn(`ObjectCodec.encode: No ID for ${this.getName()}.${name}=${value}`);
          return;
        }
        value = tmp;
      }
      if (name == null || enc.encodeDefaults || this.template[name] != value) {
        name = this.getAttributeName(name);
        this.writeAttribute(enc, obj, name, value, node);
      }
    }
  }
  /**
   * Writes the given value into node using {@link writePrimitiveAttribute}
   * or {@link writeComplexAttribute} depending on the type of the value.
   */
  writeAttribute(enc, obj, name, value, node) {
    if (typeof value !== "object") {
      this.writePrimitiveAttribute(enc, obj, name, value, node);
    } else {
      this.writeComplexAttribute(enc, obj, name, value, node);
    }
  }
  /**
   * Writes the given value as an attribute of the given node.
   */
  writePrimitiveAttribute(enc, obj, name, value, node) {
    value = this.convertAttributeToXml(enc, obj, name, value, node);
    if (name == null) {
      const child = enc.document.createElement("add");
      if (typeof value === "function") {
        child.appendChild(enc.document.createTextNode(value));
      } else {
        enc.setAttribute(child, "value", value);
      }
      node.appendChild(child);
    } else if (typeof value !== "function") {
      enc.setAttribute(node, name, value);
    }
  }
  /**
   * Writes the given value as a child node of the given node.
   */
  writeComplexAttribute(enc, obj, name, value, node) {
    const child = enc.encode(value);
    if (child != null) {
      if (name != null) {
        child.setAttribute("as", name);
      }
      node.appendChild(child);
    } else {
      GlobalConfig.logger.warn(`ObjectCodec.encode: No node for ${this.getName()}.${name}: ${value}`);
    }
  }
  /**
   * Converts true to "1" and false to "0" is {@link isBooleanAttribute} returns true.
   * All other values are not converted.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Objec to convert the attribute for.
   * @param name Name of the attribute to be converted.
   * @param value Value to be converted.
   */
  convertAttributeToXml(enc, obj, name, value, node) {
    if (this.isBooleanAttribute(enc, obj, name, value)) {
      value = value == true ? "1" : "0";
    }
    return value;
  }
  /**
   * Returns true if the given object attribute is a boolean value.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object to convert the attribute for.
   * @param name Name of the attribute to be converted.
   * @param value Value of the attribute to be converted.
   */
  isBooleanAttribute(enc, obj, name, value) {
    return typeof value.length === "undefined" && (value == true || value == false);
  }
  /**
   * Converts booleans and numeric values to the respective types. Values are
   * numeric if {@link isNumericAttribute} returns true.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param attr XML attribute to be converted.
   * @param obj Objec to convert the attribute for.
   */
  convertAttributeFromXml(dec, attr, obj) {
    let { value } = attr;
    if (this.isNumericAttribute(dec, attr, obj)) {
      value = parseFloat(value);
      if (Number.isNaN(value) || !Number.isFinite(value)) {
        value = 0;
      }
    }
    return value;
  }
  /**
   * Returns true if the given XML attribute is or should be a numeric value.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param attr XML attribute to be converted.
   * @param obj Object to convert the attribute for.
   */
  isNumericAttribute(dec, attr, obj) {
    return obj.constructor === Geometry && (attr.name === "x" || attr.name === "y" || attr.name === "width" || attr.name === "height") || obj.constructor === Point && (attr.name === "x" || attr.name === "y") || isNumeric(attr.value);
  }
  /**
   * Hook for subclassers to pre-process the object before
   * encoding. This returns the input object. The return
   * value of this function is used in {@link encode} to perform
   * the default encoding into the given node.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object to be encoded.
   * @param node XML node to encode the object into.
   */
  beforeEncode(enc, obj, node) {
    return obj;
  }
  /**
   * Hook for subclassers to post-process the node
   * for the given object after encoding and return the
   * post-processed node. This implementation returns
   * the input node. The return value of this method
   * is returned to the encoder from {@link encode}.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object to be encoded.
   * @param node XML node that represents the default encoding.
   */
  afterEncode(enc, obj, node) {
    return node;
  }
  /**
   * Parses the given node into the object or returns a new object
   * representing the given node.
   *
   * Dec is a reference to the calling decoder. It is used to decode
   * complex objects and resolve references.
   *
   * If a node has an id attribute then the object cache is checked for the
   * object. If the object is not yet in the cache then it is constructed
   * using the constructor of {@link template} and cached in {@link Codec.objects}.
   *
   * This implementation decodes all attributes and childs of a node
   * according to the following rules:
   *
   * - If the variable name is in {@link exclude} or if the attribute name is "id"
   * or "as" then it is ignored.
   * - If the variable name is in {@link idrefs} then {@link Codec.getObject} is used
   * to replace the reference with an object.
   * - The variable name is mapped using a reverse {@link mapping}.
   * - If the value has a child node, then the codec is used to create a
   * child object with the variable name taken from the "as" attribute.
   * - If the object is an array and the variable name is empty then the
   * value or child object is appended to the array.
   * - If an add child has no value or the object is not an array then
   * the child text content is evaluated using {@link eval}.
   *
   * For add nodes where the object is not an array and the variable name
   * is defined, the default mechanism is used, allowing to override/add
   * methods as follows:
   *
   * ```javascript
   * <Object>
   *   <add as="hello"><![CDATA[
   *     function(arg1) {
   *       mxUtils.alert('Hello '+arg1);
   *     }
   *   ]]></add>
   * </Object>
   * ```
   *
   * If no object exists for an ID in {@link idrefs} a warning is issued
   * using {@link GlobalConfig.logger}.
   *
   * Returns the resulting object that represents the given XML node
   * or the object given to the method as the into parameter.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param node XML node to be decoded.
   * @param into Optional object to encode the node into.
   */
  decode(dec, node, into) {
    const id = node.getAttribute("id");
    let obj = dec.objects[id];
    if (obj == null) {
      obj = into || this.cloneTemplate();
      if (id != null) {
        dec.putObject(id, obj);
      }
    }
    const _node = this.beforeDecode(dec, node, obj);
    this.decodeNode(dec, _node, obj);
    return this.afterDecode(dec, _node, obj);
  }
  /**
   * Calls {@link decodeAttributes} and {@link decodeChildren} for the given node.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param node XML node to be decoded.
   * @param obj Objec to encode the node into.
   */
  decodeNode(dec, node, obj) {
    if (node != null) {
      this.decodeAttributes(dec, node, obj);
      this.decodeChildren(dec, node, obj);
    }
  }
  /**
   * Decodes all attributes of the given node using {@link decodeAttribute}.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param node XML node to be decoded.
   * @param obj Object to encode the node into.
   */
  decodeAttributes(dec, node, obj) {
    const attrs = node.attributes;
    if (attrs != null) {
      for (let i = 0; i < attrs.length; i += 1) {
        this.decodeAttribute(dec, attrs[i], obj);
      }
    }
  }
  /**
   * Returns true if the given attribute should be ignored. This implementation
   * returns true if the attribute name is "as" or "id".
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param attr XML attribute to be decoded.
   * @param obj Objec to encode the attribute into.
   */
  isIgnoredAttribute(dec, attr, obj) {
    return attr.nodeName === "as" || attr.nodeName === "id";
  }
  /**
   * Reads the given attribute into the specified object.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param attr XML attribute to be decoded.
   * @param obj Objec to encode the attribute into.
   */
  decodeAttribute(dec, attr, obj) {
    if (!this.isIgnoredAttribute(dec, attr, obj)) {
      const name = attr.nodeName;
      let value = this.convertAttributeFromXml(dec, attr, obj);
      const fieldname = this.getFieldName(name);
      if (this.isReference(obj, fieldname, value, false)) {
        const tmp = dec.getObject(value);
        if (tmp == null) {
          GlobalConfig.logger.warn(`ObjectCodec.decode: No object for ${this.getName()}.${name}=${value}`);
          return;
        }
        value = tmp;
      }
      if (!this.isExcluded(obj, name, value, false)) {
        obj[name] = value;
      }
    }
  }
  /**
   * Decodes all children of the given node using {@link decodeChild}.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param node XML node to be decoded.
   * @param obj Objec to encode the node into.
   */
  decodeChildren(dec, node, obj) {
    let child = node.firstChild;
    while (child) {
      const tmp = child.nextSibling;
      if (isElement(child) && !this.processInclude(dec, child, obj)) {
        this.decodeChild(dec, child, obj);
      }
      child = tmp;
    }
  }
  /**
   * Reads the specified child into the given object.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param child XML child element to be decoded.
   * @param obj Objec to encode the node into.
   */
  decodeChild(dec, child, obj) {
    const fieldname = this.getFieldName(child.getAttribute("as"));
    if (fieldname == null || !this.isExcluded(obj, fieldname, child, false)) {
      const template = this.getFieldTemplate(obj, fieldname, child);
      let value = null;
      if (child.nodeName === "add") {
        value = child.getAttribute("value");
        if (value == null && ObjectCodec.allowEval) {
          value = doEval(getTextContent(child));
        }
      } else {
        value = dec.decode(child, template);
      }
      try {
        this.addObjectValue(obj, fieldname, value, template);
      } catch (e) {
        throw new Error(`${e.message} for ${child.nodeName}`);
      }
    }
  }
  /**
   * Returns the template instance for the given field. This returns the
   * value of the field, null if the value is an array or an empty collection
   * if the value is a collection. The value is then used to populate the
   * field for a new instance. For strongly typed languages it may be
   * required to override this to return the correct collection instance
   * based on the encoded child.
   */
  getFieldTemplate(obj, fieldname, child) {
    let template = obj[fieldname];
    if (template instanceof Array && template.length > 0) {
      template = null;
    }
    return template;
  }
  /**
   * Sets the decoded child node as a value of the given object. If the
   * object is a map, then the value is added with the given field name as a
   * key. If the field name is not empty, then setFieldValue is called or
   * else, if the object is a collection, the value is added to the
   * collection. For strongly typed languages it may be required to
   * override this with the correct code to add an entry to an object.
   */
  addObjectValue(obj, fieldname, value, template) {
    if (value != null && value !== template) {
      if (fieldname != null && fieldname.length > 0) {
        obj[fieldname] = value;
      } else {
        obj.push(value);
      }
    }
  }
  /**
   * Returns true if the given node is an include directive and
   * executes the include by decoding the XML document. Returns
   * false if the given node is not an include directive.
   *
   * @param dec {@link Codec} that controls the encoding/decoding process.
   * @param node XML node to be checked.
   * @param into Optional object to pass-thru to the codec.
   */
  processInclude(dec, node, into) {
    if (node.nodeName === "include") {
      const name = node.getAttribute("name");
      if (name != null) {
        try {
          const xml = load(name).getDocumentElement();
          if (xml != null) {
            dec.decode(xml, into);
          }
        } catch (e) {
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Hook for subclassers to pre-process the node for
   * the specified object and return the node to be
   * used for further processing by {@link decode}.
   * The object is created based on the template in the
   * calling method and is never null. This implementation
   * returns the input node. The return value of this
   * function is used in {@link decode} to perform
   * the default decoding into the given object.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param node XML node to be decoded.
   * @param obj Object to encode the node into.
   */
  beforeDecode(dec, node, obj) {
    return node;
  }
  /**
   * Hook for subclassers to post-process the object after
   * decoding. This implementation returns the given object
   * without any changes. The return value of this method
   * is returned to the decoder from {@link decode}.
   *
   * @param dec {@link Codec} that controls the encoding process.
   * @param node XML node to be decoded.
   * @param obj Object that represents the default decoding.
   */
  afterDecode(dec, node, obj) {
    return obj;
  }
}
ObjectCodec.allowEval = false;
class CodecRegistry {
  /**
   * Registers a new codec and associates the name of the codec via {@link ObjectCodec.getName} with the codec object.
   *
   * @param codec ObjectCodec to be registered.
   * @param registerAlias if `true`, register an alias if the codec name doesn't match the name of the constructor of {@link ObjectCodec.template}.
   */
  static register(codec, registerAlias = true) {
    if (codec != null) {
      const name = codec.getName();
      CodecRegistry.codecs[name] = codec;
      const classname = codec.template.constructor.name;
      if (registerAlias && classname !== name) {
        CodecRegistry.addAlias(classname, name);
      }
    }
    return codec;
  }
  /**
   * Adds an alias for mapping a classname to a codec name.
   */
  static addAlias(classname, codecname) {
    CodecRegistry.aliases[classname] = codecname;
  }
  /**
   * Returns a codec that handles objects that are constructed using the given constructor or a codec registered under the provided name.
   *
   * When passing a name, the method first check if an alias exists for the name, and if so, it uses it to retrieve the codec.
   *
   * If there is no registered Codec, the method tries to register a new Codec using the provided constructor.
   *
   * @param constructorOrName JavaScript constructor function of the Codec or Codec name.
   */
  static getCodec(constructorOrName) {
    if (constructorOrName == null) {
      return null;
    }
    let codec = null;
    let name = typeof constructorOrName === "string" ? constructorOrName : constructorOrName.name;
    const tmp = CodecRegistry.aliases[name];
    if (tmp != null) {
      name = tmp;
    }
    codec = CodecRegistry.codecs[name] ?? null;
    if (codec == null) {
      try {
        codec = new ObjectCodec(new constructorOrName());
        CodecRegistry.register(codec);
      } catch (e) {
      }
    }
    return codec;
  }
  /**
   * First try to get the codec by the name it is registered with. If it doesn't exist, use the alias eventually declared
   * to get the codec.
   * @param name the name of the codec that is willing to be retrieved.
   */
  static getCodecByName(name) {
    let codec = CodecRegistry.codecs[name];
    if (!codec) {
      const alias = CodecRegistry.aliases[name];
      if (alias) {
        codec = CodecRegistry.codecs[alias];
      }
    }
    return codec ?? null;
  }
}
CodecRegistry.codecs = {};
CodecRegistry.aliases = {};
class Cell {
  constructor(value = null, geometry = null, style = {}) {
    this.invalidating = false;
    this.onInit = null;
    this.overlays = [];
    this.id = null;
    this.value = null;
    this.geometry = null;
    this.style = {};
    this.vertex = false;
    this.edge = false;
    this.connectable = true;
    this.visible = true;
    this.collapsed = false;
    this.parent = null;
    this.source = null;
    this.target = null;
    this.children = [];
    this.edges = [];
    this.mxTransient = [
      "id",
      "value",
      "parent",
      "source",
      "target",
      "children",
      "edges"
    ];
    this.value = value;
    this.setGeometry(geometry);
    this.setStyle(style);
    if (this.onInit) {
      this.onInit();
    }
  }
  // TODO: Document me!!!
  getChildren() {
    return this.children || [];
  }
  /**
   * Returns the Id of the cell as a string.
   */
  getId() {
    return this.id;
  }
  /**
   * Sets the Id of the cell to the given string.
   */
  setId(id) {
    this.id = id;
  }
  /**
   * Returns the user object of the cell. The user
   * object is stored in <value>.
   */
  getValue() {
    return this.value;
  }
  /**
   * Sets the user object of the cell. The user object
   * is stored in <value>.
   */
  setValue(value) {
    this.value = value;
  }
  /**
   * Changes the user object after an in-place edit
   * and returns the previous value. This implementation
   * replaces the user object with the given value and
   * returns the old user object.
   */
  valueChanged(newValue) {
    const previous = this.getValue();
    this.setValue(newValue);
    return previous;
  }
  /**
   * Returns the {@link Geometry} that describes the <geometry>.
   */
  getGeometry() {
    return this.geometry;
  }
  /**
   * Sets the {@link Geometry} to be used as the <geometry>.
   */
  setGeometry(geometry) {
    this.geometry = geometry;
  }
  /**
   * Returns a string that describes the {@link style}.
   *
   * **IMPORTANT**: if you want to get the style object to later update it and propagate changes to the view, use {@link getClonedStyle} instead.
   */
  getStyle() {
    return this.style;
  }
  /**
   * Use this method to get the style object to later update it and propagate changes to the view.
   *
   * See {@link GraphDataModel.setStyle} for more details.
   */
  getClonedStyle() {
    return clone(this.getStyle());
  }
  /**
   * Sets the string to be used as the {@link style}.
   */
  setStyle(style) {
    this.style = style;
  }
  /**
   * Returns true if the cell is a vertex.
   */
  isVertex() {
    return this.vertex;
  }
  /**
   * Specifies if the cell is a vertex. This should only be assigned at
   * construction of the cell and not be changed during its lifecycle.
   *
   * @param vertex Boolean that specifies if the cell is a vertex.
   */
  setVertex(vertex) {
    this.vertex = vertex;
  }
  /**
   * Returns true if the cell is an edge.
   */
  isEdge() {
    return this.edge;
  }
  /**
   * Specifies if the cell is an edge. This should only be assigned at
   * construction of the cell and not be changed during its lifecycle.
   *
   * @param edge Boolean that specifies if the cell is an edge.
   */
  setEdge(edge) {
    this.edge = edge;
  }
  /**
   * Returns true if the cell is connectable.
   */
  isConnectable() {
    return this.connectable;
  }
  /**
   * Sets the connectable state.
   *
   * @param connectable Boolean that specifies the new connectable state.
   */
  setConnectable(connectable) {
    this.connectable = connectable;
  }
  /**
   * Returns true if the cell is visibile.
   */
  isVisible() {
    return this.visible;
  }
  /**
   * Specifies if the cell is visible.
   *
   * @param visible Boolean that specifies the new visible state.
   */
  setVisible(visible) {
    this.visible = visible;
  }
  /**
   * Returns true if the cell is collapsed.
   */
  isCollapsed() {
    return this.collapsed;
  }
  /**
   * Sets the collapsed state.
   *
   * @param collapsed Boolean that specifies the new collapsed state.
   */
  setCollapsed(collapsed) {
    this.collapsed = collapsed;
  }
  /**
   * Returns the cell's parent.
   */
  getParent() {
    return this.parent;
  }
  /**
   * Sets the parent cell.
   *
   * @param parent<Cell> that represents the new parent.
   */
  setParent(parent) {
    this.parent = parent;
  }
  /**
   * Returns the source or target terminal.
   *
   * @param source Boolean that specifies if the source terminal should be
   * returned.
   */
  getTerminal(source = false) {
    return source ? this.source : this.target;
  }
  /**
   * Sets the source or target terminal and returns the new terminal.
   *
   * @param terminal  Cell that represents the new source or target terminal.
   * @param isSource  boolean that specifies if the source or target terminal should be set.
   */
  setTerminal(terminal, isSource) {
    if (isSource) {
      this.source = terminal;
    } else {
      this.target = terminal;
    }
    return terminal;
  }
  /**
   * Returns the number of child cells.
   */
  getChildCount() {
    return this.children.length;
  }
  /**
   * Returns the index of the specified child in the child array.
   *
   * @param child Child whose index should be returned.
   */
  getIndex(child) {
    if (child === null)
      return -1;
    return this.children.indexOf(child);
  }
  /**
   * Returns the child at the specified index.
   *
   * @param indexInteger that specifies the child to be returned.
   */
  getChildAt(index) {
    return this.children[index];
  }
  /**
   * Inserts the specified child into the child array at the specified index
   * and updates the parent reference of the child. If not childIndex is
   * specified then the child is appended to the child array. Returns the
   * inserted child.
   *
   * @param child<Cell> to be inserted or appended to the child array.
   * @param indexOptional integer that specifies the index at which the child
   * should be inserted into the child array.
   */
  insert(child, index) {
    if (index === void 0) {
      index = this.getChildCount();
      if (child.getParent() === this) {
        index--;
      }
    }
    child.removeFromParent();
    child.setParent(this);
    this.children.splice(index, 0, child);
    return child;
  }
  /**
   * Removes the child at the specified index from the child array and
   * returns the child that was removed. Will remove the parent reference of
   * the child.
   *
   * @param indexInteger that specifies the index of the child to be
   * removed.
   */
  remove(index) {
    let child = null;
    if (index >= 0) {
      child = this.getChildAt(index);
      if (child) {
        this.children.splice(index, 1);
        child.setParent(null);
      }
    }
    return child;
  }
  /**
   * Removes the cell from its parent.
   */
  removeFromParent() {
    if (this.parent) {
      const index = this.parent.getIndex(this);
      this.parent.remove(index);
    }
  }
  /**
   * Returns the number of edges in the edge array.
   */
  getEdgeCount() {
    return this.edges.length;
  }
  /**
   * Returns the index of the specified edge in <edges>.
   *
   * @param edge<Cell> whose index in <edges> should be returned.
   */
  getEdgeIndex(edge) {
    return this.edges.indexOf(edge);
  }
  /**
   * Returns the edge at the specified index in <edges>.
   *
   * @param indexInteger that specifies the index of the edge to be returned.
   */
  getEdgeAt(index) {
    return this.edges[index];
  }
  /**
   * Inserts the specified edge into the edge array and returns the edge.
   * Will update the respective terminal reference of the edge.
   *
   * @param edge              <Cell> to be inserted into the edge array.
   * @param isOutgoing Boolean that specifies if the edge is outgoing.
   */
  insertEdge(edge, isOutgoing = false) {
    edge.removeFromTerminal(isOutgoing);
    edge.setTerminal(this, isOutgoing);
    if (this.edges.length === 0 || edge.getTerminal(!isOutgoing) !== this || this.edges.indexOf(edge) < 0) {
      this.edges.push(edge);
    }
    return edge;
  }
  /**
   * Removes the specified edge from the edge array and returns the edge.
   * Will remove the respective terminal reference from the edge.
   *
   * @param edge<Cell> to be removed from the edge array.
   * @param isOutgoing Boolean that specifies if the edge is outgoing.
   */
  removeEdge(edge, isOutgoing = false) {
    if (edge != null) {
      if (edge.getTerminal(!isOutgoing) !== this && this.edges != null) {
        const index = this.getEdgeIndex(edge);
        if (index >= 0) {
          this.edges.splice(index, 1);
        }
      }
      edge.setTerminal(null, isOutgoing);
    }
    return edge;
  }
  /**
   * Removes the edge from its source or target terminal.
   *
   * @param isSource Boolean that specifies if the edge should be removed from its source or target terminal.
   */
  removeFromTerminal(isSource) {
    const terminal = this.getTerminal(isSource);
    if (terminal) {
      terminal.removeEdge(this, isSource);
    }
  }
  /**
   * Returns true if the user object is an XML node that contains the given attribute.
   *
   * @param name Name nameName of the attribute.
   */
  hasAttribute(name) {
    var _a;
    const userObject = this.getValue();
    return isElement(userObject) && userObject.hasAttribute ? userObject.hasAttribute(name) : !isNullish((_a = userObject.getAttribute) == null ? void 0 : _a.call(userObject, name));
  }
  /**
   * Returns the specified attribute from the user object if it is an XML node.
   *
   * @param name Name of the attribute whose value should be returned.
   * @param defaultValue Optional default value to use if the attribute has no
   * value.
   */
  getAttribute(name, defaultValue) {
    var _a;
    const userObject = this.getValue();
    const val = isElement(userObject) ? (_a = userObject.getAttribute) == null ? void 0 : _a.call(userObject, name) : null;
    return val ?? defaultValue;
  }
  /**
   * Sets the specified attribute on the user object if it is an XML node.
   *
   * @param name Name of the attribute whose value should be set.
   * @param value New value of the attribute.
   */
  setAttribute(name, value) {
    var _a;
    const userObject = this.getValue();
    if (isElement(userObject)) {
      (_a = userObject.setAttribute) == null ? void 0 : _a.call(userObject, name, value);
    }
  }
  /**
   * Returns a clone of the cell.
   *
   * Uses {@link cloneValue} to clone the user object.
   *
   * All fields in {@link mxTransient} are ignored during the cloning.
   */
  clone() {
    const c = clone(this, this.mxTransient);
    c.setValue(this.cloneValue());
    return c;
  }
  /**
   * Returns a clone of the cell's user object.
   */
  cloneValue() {
    let value = this.getValue();
    if (!isNullish(value)) {
      if (typeof value.clone === "function") {
        value = value.clone();
      } else if (!isNullish(value.nodeType) && value.cloneNode) {
        value = value.cloneNode(true);
      }
    }
    return value;
  }
  /**
   * Returns the nearest common ancestor for the specified cells to `this`.
   *
   * @param {Cell} cell2  that specifies the second cell in the tree.
   */
  getNearestCommonAncestor(cell2) {
    let path = CellPath.create(cell2);
    if (path.length > 0) {
      let cell = this;
      let current = CellPath.create(cell);
      if (path.length < current.length) {
        cell = cell2;
        const tmp = current;
        current = path;
        path = tmp;
      }
      while (cell && current) {
        const parent = cell.getParent();
        if (path.indexOf(current + CellPath.PATH_SEPARATOR) === 0 && parent) {
          return cell;
        }
        current = CellPath.getParentPath(current);
        cell = parent;
      }
    }
    return null;
  }
  /**
   * Returns true if the given parent is an ancestor of the given child. Note
   * returns true if child == parent.
   *
   * @param {Cell} child  that specifies the child.
   */
  isAncestor(child) {
    while (child && child !== this) {
      child = child.getParent();
    }
    return child === this;
  }
  /**
   * Returns the child vertices of the given parent.
   */
  getChildVertices() {
    return this.getChildCells(true, false);
  }
  /**
   * Returns the child edges of the given parent.
   */
  getChildEdges() {
    return this.getChildCells(false, true);
  }
  /**
   * Returns the children of the given cell that are vertices and/or edges
   * depending on the arguments.
   *
   * @param vertices  Boolean indicating if child vertices should be returned.
   * Default is false.
   * @param edges  Boolean indicating if child edges should be returned.
   * Default is false.
   */
  getChildCells(vertices = false, edges = false) {
    const childCount = this.getChildCount();
    const result = [];
    for (let i = 0; i < childCount; i += 1) {
      const child = this.getChildAt(i);
      if (!edges && !vertices || edges && child.isEdge() || vertices && child.isVertex()) {
        result.push(child);
      }
    }
    return result;
  }
  /**
   * Returns the number of incoming or outgoing edges, ignoring the given
   * edge.
   *
   * @param outgoing  Boolean that specifies if the number of outgoing or
   * incoming edges should be returned.
   * @param {Cell} ignoredEdge  that represents an edge to be ignored.
   */
  getDirectedEdgeCount(outgoing, ignoredEdge = null) {
    let count = 0;
    const edgeCount = this.getEdgeCount();
    for (let i = 0; i < edgeCount; i += 1) {
      const edge = this.getEdgeAt(i);
      if (edge !== ignoredEdge && edge && edge.getTerminal(outgoing) === this) {
        count += 1;
      }
    }
    return count;
  }
  /**
   * Returns all edges of the given cell without loops.
   */
  getConnections() {
    return this.getEdges(true, true, false);
  }
  /**
   * Returns the incoming edges of the given cell without loops.
   */
  getIncomingEdges() {
    return this.getEdges(true, false, false);
  }
  /**
   * Returns the outgoing edges of the given cell without loops.
   */
  getOutgoingEdges() {
    return this.getEdges(false, true, false);
  }
  /**
   * Returns all distinct edges connected to this cell as a new array of
   * {@link Cell}. If at least one of incoming or outgoing is true, then loops
   * are ignored, otherwise if both are false, then all edges connected to
   * the given cell are returned including loops.
   *
   * @param incoming  Optional boolean that specifies if incoming edges should be
   * returned. Default is true.
   * @param outgoing  Optional boolean that specifies if outgoing edges should be
   * returned. Default is true.
   * @param includeLoops  Optional boolean that specifies if loops should be returned.
   * Default is true.
   */
  getEdges(incoming = true, outgoing = true, includeLoops = true) {
    const edgeCount = this.getEdgeCount();
    const result = [];
    for (let i = 0; i < edgeCount; i += 1) {
      const edge = this.getEdgeAt(i);
      const source = edge.getTerminal(true);
      const target = edge.getTerminal(false);
      if (includeLoops && source === target || source !== target && (incoming && target === this || outgoing && source === this)) {
        result.push(edge);
      }
    }
    return result;
  }
  /**
   * Returns the absolute, accumulated origin for the children inside the
   * given parent as an {@link Point}.
   */
  getOrigin() {
    let result = new Point();
    const parent = this.getParent();
    if (parent) {
      result = parent.getOrigin();
      if (!this.isEdge()) {
        const geo = this.getGeometry();
        if (geo) {
          result.x += geo.x;
          result.y += geo.y;
        }
      }
    }
    return result;
  }
  /**
   * Returns all descendants of the given cell and the cell itself in an array.
   */
  getDescendants() {
    return this.filterDescendants(null);
  }
  /**
   * Visits all cells recursively and applies the specified filter function
   * to each cell. If the function returns true then the cell is added
   * to the resulting array. The parent and result paramters are optional.
   * If parent is not specified then the recursion starts at {@link root}.
   *
   * Example:
   * The following example extracts all vertices from a given model:
   * ```javascript
   * var filter(cell)
   * {
   * 	return model.isVertex(cell);
   * }
   * var vertices = model.filterDescendants(filter);
   * ```
   *
   * @param filter  JavaScript function that takes an {@link Cell} as an argument
   * and returns a boolean.
   */
  filterDescendants(filter) {
    let result = [];
    if (filter === null || filter(this)) {
      result.push(this);
    }
    const childCount = this.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      const child = this.getChildAt(i);
      result = result.concat(child.filterDescendants(filter));
    }
    return result;
  }
  /**
   * Returns the root of the model or the topmost parent of the given cell.
   */
  getRoot() {
    let cell = this;
    let root = cell;
    while (cell) {
      root = cell;
      cell = cell.getParent();
    }
    return root;
  }
}
const createXmlDocument$1 = () => {
  return document.implementation.createDocument("", "", null);
};
class Codec {
  constructor(document2 = createXmlDocument$1()) {
    this.elements = null;
    this.encodeDefaults = false;
    this.document = document2;
    this.objects = {};
  }
  /**
   * Associates the given object with the given ID and returns the given object.
   *
   * @param id ID for the object to be associated with.
   * @param obj Object to be associated with the ID.
   */
  putObject(id, obj) {
    this.objects[id] = obj;
    return obj;
  }
  /**
   * Returns the decoded object for the element with the specified ID in
   * {@link document}. If the object is not known then {@link lookup} is used to find an
   * object. If no object is found, then the element with the respective ID
   * from the document is parsed using {@link decode}.
   */
  getObject(id) {
    let obj = null;
    if (id != null) {
      obj = this.objects[id];
      if (obj == null) {
        obj = this.lookup(id);
        if (obj == null) {
          const node = this.getElementById(id);
          if (node != null) {
            obj = this.decode(node);
          }
        }
      }
    }
    return obj;
  }
  /**
   * Hook for subclassers to implement a custom lookup mechanism for cell IDs.
   * This implementation always returns null.
   *
   * Example:
   *
   * ```javascript
   * const codec = new Codec();
   * codec.lookup(id)
   * {
   *   return model.getCell(id);
   * };
   * ```
   *
   * @param id ID of the object to be returned.
   */
  lookup(id) {
    return null;
  }
  /**
   * Returns the element with the given ID from {@link document}.
   *
   * @param id String that contains the ID.
   */
  getElementById(id) {
    this.updateElements();
    return this.elements[id];
  }
  updateElements() {
    if (this.elements == null) {
      this.elements = {};
      if (this.document.documentElement != null) {
        this.addElement(this.document.documentElement);
      }
    }
  }
  /**
   * Adds the given element to {@link elements} if it has an ID.
   */
  addElement(node) {
    if (isElement(node)) {
      const id = node.getAttribute("id");
      if (id != null) {
        if (this.elements[id] == null) {
          this.elements[id] = node;
        } else if (this.elements[id] !== node) {
          throw new Error(`${id}: Duplicate ID`);
        }
      }
    }
    let nodeChild = node.firstChild;
    while (nodeChild != null) {
      this.addElement(nodeChild);
      nodeChild = nodeChild.nextSibling;
    }
  }
  /**
   * Returns the ID of the specified object. This implementation
   * calls {@link reference} first and if that returns null handles
   * the object as an {@link Cell} by returning their IDs using
   * {@link Cell.getId}. If no ID exists for the given cell, then
   * an on-the-fly ID is generated using {@link CellPath.create}.
   *
   * @param obj Object to return the ID for.
   */
  getId(obj) {
    let id = null;
    if (obj != null) {
      id = this.reference(obj);
      if (id == null && obj instanceof Cell) {
        id = obj.getId();
        if (id == null) {
          id = CellPath.create(obj);
          if (id.length === 0) {
            id = "root";
          }
        }
      }
    }
    return id;
  }
  /**
   * Hook for subclassers to implement a custom method
   * for retrieving IDs from objects. This implementation
   * always returns null.
   *
   * Example:
   *
   * ```javascript
   * const codec = new Codec();
   * codec.reference(obj)
   * {
   *   return obj.getCustomId();
   * };
   * ```
   *
   * @param obj Object whose ID should be returned.
   */
  reference(obj) {
    return null;
  }
  /**
   * Encodes the specified object and returns the resulting XML node.
   *
   * @param obj Object to be encoded.
   */
  encode(obj) {
    let node = null;
    if (obj != null && obj.constructor != null) {
      const enc = CodecRegistry.getCodec(obj.constructor);
      if (enc != null) {
        node = enc.encode(this, obj);
      } else if (isNode(obj)) {
        node = importNode(this.document, obj, true);
      } else {
        GlobalConfig.logger.warn(`Codec.encode: No codec for ${getFunctionName(obj.constructor)}`);
      }
    }
    return node;
  }
  /**
   * Decodes the given XML node. The optional "into"
   * argument specifies an existing object to be
   * used. If no object is given, then a new instance
   * is created using the constructor from the codec.
   *
   * The function returns the passed in object or
   * the new instance if no object was given.
   *
   * @param node XML node to be decoded.
   * @param into Optional object to be decoded into.
   */
  decode(node, into) {
    this.updateElements();
    let obj = null;
    if (isElement(node)) {
      const dec = CodecRegistry.getCodecByName(node.nodeName);
      if (dec != null) {
        obj = dec.decode(this, node, into);
      } else {
        obj = node.cloneNode(true);
        obj.removeAttribute("as");
      }
    }
    return obj;
  }
  /**
   * Encoding of cell hierarchies is built-into the core, but
   * is a higher-level function that needs to be explicitely
   * used by the respective object encoders (eg. {@link ModelCodec},
   * {@link ChildChangeCodec} and {@link RootChangeCodec}). This
   * implementation writes the given cell and its children as a
   * (flat) sequence into the given node. The children are not
   * encoded if the optional includeChildren is false. The
   * function is in charge of adding the result into the
   * given node and has no return value.
   *
   * @param cell {@link mxCell} to be encoded.
   * @param node Parent XML node to add the encoded cell into.
   * @param includeChildren Optional boolean indicating if the
   * function should include all descendents. Default is true.
   */
  encodeCell(cell, node, includeChildren) {
    const appendMe = this.encode(cell);
    if (appendMe) {
      node.appendChild(appendMe);
    }
    if (includeChildren == null || includeChildren) {
      const childCount = cell.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        this.encodeCell(cell.getChildAt(i), node);
      }
    }
  }
  /**
   * Returns true if the given codec is a cell codec. This uses
   * {@link CellCodec.isCellCodec} to check if the codec is of the
   * given type.
   */
  isCellCodec(codec) {
    if (codec != null && "isCellCodec" in codec) {
      return codec.isCellCodec();
    }
    return false;
  }
  /**
   * Decodes cells that have been encoded using inversion, ie.
   * where the user object is the enclosing node in the XML,
   * and restores the group and graph structure in the cells.
   * Returns a new {@link Cell} instance that represents the
   * given node.
   *
   * @param node XML node that contains the cell data.
   * @param restoreStructures Optional boolean indicating whether
   * the graph structure should be restored by calling insert
   * and insertEdge on the parent and terminals, respectively.
   * Default is `true`.
   */
  decodeCell(node, restoreStructures = true) {
    if (!isElement(node)) {
      return null;
    }
    let decoder = CodecRegistry.getCodec(node.nodeName);
    if (!this.isCellCodec(decoder)) {
      let child = node.firstChild;
      while (child != null && !this.isCellCodec(decoder)) {
        decoder = CodecRegistry.getCodec(child.nodeName);
        child = child.nextSibling;
      }
    }
    if (!this.isCellCodec(decoder)) {
      decoder = CodecRegistry.getCodec(Cell);
    }
    const cell = decoder == null ? void 0 : decoder.decode(this, node);
    if (restoreStructures) {
      this.insertIntoGraph(cell);
    }
    return cell;
  }
  /**
   * Inserts the given cell into its parent and terminal cells.
   */
  insertIntoGraph(cell) {
    const { parent } = cell;
    const source = cell.getTerminal(true);
    const target = cell.getTerminal(false);
    cell.setTerminal(null, false);
    cell.setTerminal(null, true);
    cell.parent = null;
    if (parent != null) {
      if (parent === cell) {
        throw new Error(`${parent.id}: Self Reference`);
      } else {
        parent.insert(cell);
      }
    }
    if (source != null) {
      source.insertEdge(cell, true);
    }
    if (target != null) {
      target.insertEdge(cell, false);
    }
  }
  /**
   * Sets the attribute on the specified node to value. This is a
   * helper method that makes sure the attribute and value arguments
   * are not null.
   *
   * @param node XML node to set the attribute for.
   * @param attribute The name of the attribute to be set.
   * @param value New value of the attribute.
   */
  setAttribute(node, attribute, value) {
    if (attribute != null && value != null) {
      node.setAttribute(attribute, value);
    }
  }
}
const createXmlDocument = () => {
  return document.implementation.createDocument("", "", null);
};
const parseXml = (xmlString) => {
  return new DOMParser().parseFromString(xmlString, "text/xml");
};
const getViewXml = (graph, scale = 1, cells = null, x0 = 0, y0 = 0) => {
  if (cells == null) {
    const model = graph.getDataModel();
    cells = [model.getRoot()];
  }
  const view = graph.getView();
  let result = null;
  const eventsEnabled = view.isEventsEnabled();
  view.setEventsEnabled(false);
  const { drawPane } = view;
  const { overlayPane } = view;
  if (graph.dialect === DIALECT.SVG) {
    view.drawPane = document.createElementNS(NS_SVG, "g");
    view.canvas.appendChild(view.drawPane);
    view.overlayPane = document.createElementNS(NS_SVG, "g");
    view.canvas.appendChild(view.overlayPane);
  } else {
    view.drawPane = view.drawPane.cloneNode(false);
    view.canvas.appendChild(view.drawPane);
    view.overlayPane = view.overlayPane.cloneNode(false);
    view.canvas.appendChild(view.overlayPane);
  }
  const translate2 = view.getTranslate();
  view.translate = new Point(x0, y0);
  const temp = new TemporaryCellStates(graph.getView(), scale, cells);
  try {
    const enc = new Codec();
    result = enc.encode(graph.getView());
  } finally {
    temp.destroy();
    view.translate = translate2;
    view.canvas.removeChild(view.drawPane);
    view.canvas.removeChild(view.overlayPane);
    view.drawPane = drawPane;
    view.overlayPane = overlayPane;
    view.setEventsEnabled(eventsEnabled);
  }
  return result;
};
const getXml = (node, linefeed = "&#xa;") => {
  const xmlSerializer = new XMLSerializer();
  let xml = xmlSerializer.serializeToString(node);
  xml = xml.replace(/\n/g, linefeed);
  return xml;
};
const getPrettyXml = (node, tab = "  ", indent = "", newline = "\n", ns = null) => {
  const result = [];
  if (node != null) {
    if (node.namespaceURI != null && node.namespaceURI !== ns) {
      ns = node.namespaceURI;
      if (node.getAttribute("xmlns") == null) {
        node.setAttribute("xmlns", node.namespaceURI);
      }
    }
    if (node.nodeType === NODETYPE.DOCUMENT) {
      result.push(getPrettyXml(node.documentElement, tab, indent, newline, ns));
    } else if (node.nodeType === NODETYPE.DOCUMENT_FRAGMENT) {
      let tmp = node.firstChild;
      if (tmp != null) {
        while (tmp != null) {
          result.push(getPrettyXml(tmp, tab, indent, newline, ns));
          tmp = tmp.nextSibling;
        }
      }
    } else if (node.nodeType === NODETYPE.COMMENT) {
      const value = getTextContent(node);
      if (value.length > 0) {
        result.push(`${indent}<!--${value}-->${newline}`);
      }
    } else if (node.nodeType === NODETYPE.TEXT) {
      const value = trim(getTextContent(node));
      if (value && value.length > 0) {
        result.push(indent + htmlEntities(value, false) + newline);
      }
    } else if (node.nodeType === NODETYPE.CDATA) {
      const value = getTextContent(node);
      if (value.length > 0) {
        result.push(`${indent}<![CDATA[${value}]]${newline}`);
      }
    } else {
      result.push(`${indent}<${node.nodeName}`);
      const attrs = node.attributes;
      if (attrs != null) {
        for (let i = 0; i < attrs.length; i += 1) {
          const val = htmlEntities(attrs[i].value);
          result.push(` ${attrs[i].nodeName}="${val}"`);
        }
      }
      let tmp = node.firstChild;
      if (tmp != null) {
        result.push(`>${newline}`);
        while (tmp != null) {
          result.push(getPrettyXml(tmp, tab, indent + tab, newline, ns));
          tmp = tmp.nextSibling;
        }
        result.push(`${indent}</${node.nodeName}>${newline}`);
      } else {
        result.push(` />${newline}`);
      }
    }
  }
  return result.join("");
};
const findNode = (node, attr, value) => {
  if (isElement(node)) {
    const tmp = node.getAttribute(attr);
    if (tmp && tmp === value) {
      return node;
    }
  }
  node = node.firstChild;
  while (node) {
    const result = findNode(node, attr, value);
    if (result) {
      return result;
    }
    node = node.nextSibling;
  }
  return null;
};
const xmlUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createXmlDocument,
  findNode,
  getPrettyXml,
  getViewXml,
  getXml,
  parseXml
}, Symbol.toStringTag, { value: "Module" }));
const useAbsoluteIds = typeof DOMParser === "function" && !Client.IS_CHROMEAPP && !Client.IS_EDGE && document.getElementsByTagName("base").length > 0;
class SvgCanvas2D extends AbstractCanvas2D {
  constructor(root, styleEnabled) {
    super();
    this.defs = null;
    this.styleEnabled = true;
    this.node = null;
    this.matchHtmlAlignment = true;
    this.textEnabled = true;
    this.foEnabled = true;
    this.foAltText = "[Object]";
    this.foOffset = 0;
    this.textOffset = 0;
    this.imageOffset = 0;
    this.strokeTolerance = 0;
    this.minStrokeWidth = 1;
    this.refCount = 0;
    this.lineHeightCorrection = 1;
    this.pointerEventsValue = "all";
    this.fontMetricsPadding = 10;
    this.cacheOffsetSize = true;
    this.originalRoot = null;
    this.root = root;
    this.gradients = {};
    this.defs = null;
    this.styleEnabled = styleEnabled != null ? styleEnabled : false;
    let svg = null;
    if (root.ownerDocument !== document) {
      let node = root;
      while (node && node.nodeName !== "svg") {
        node = node.parentElement;
      }
      svg = node;
    }
    if (svg) {
      const tmp = svg.getElementsByTagName("defs");
      if (tmp.length > 0) {
        this.defs = svg.getElementsByTagName("defs")[0];
      }
      if (!this.defs) {
        this.defs = this.createElement("defs");
        if (svg.firstChild != null) {
          svg.insertBefore(this.defs, svg.firstChild);
        } else {
          svg.appendChild(this.defs);
        }
      }
      if (this.styleEnabled) {
        this.defs.appendChild(this.createStyle());
      }
    }
  }
  /**
   * Rounds all numbers to 2 decimal points.
   */
  format(value) {
    return parseFloat(value.toFixed(2));
  }
  /**
   * Returns the URL of the page without the hash part. This needs to use href to
   * include any search part with no params (ie question mark alone). This is a
   * workaround for the fact that window.location.search is empty if there is
   * no search string behind the question mark.
   */
  getBaseUrl() {
    let { href } = window.location;
    const hash = href.lastIndexOf("#");
    if (hash > 0) {
      href = href.substring(0, hash);
    }
    return href;
  }
  /**
   * Returns any offsets for rendering pixels.
   */
  reset() {
    super.reset();
    this.gradients = {};
  }
  end() {
    return;
  }
  /**
   * Creates the optional style section.
   */
  createStyle() {
    const style = this.createElement("style");
    style.setAttribute("type", "text/css");
    write(style, `svg{font-family:${DEFAULT_FONTFAMILY};font-size:${DEFAULT_FONTSIZE};fill:none;stroke-miterlimit:10}`);
    return style;
  }
  /**
   * Private helper function to create SVG elements
   */
  createElement(tagName, namespace) {
    var _a;
    return (_a = this.root) == null ? void 0 : _a.ownerDocument.createElementNS(namespace || NS_SVG, tagName);
  }
  /**
   * Returns the alternate text string for the given foreignObject.
   */
  getAlternateText(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation) {
    return !isNullish(str) ? this.foAltText : null;
  }
  /**
   * Returns the alternate content for the given foreignObject.
   */
  createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation) {
    const text = this.getAlternateText(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);
    const s = this.state;
    if (!isNullish(text) && s.fontSize > 0) {
      const dy = valign === ALIGN.TOP ? 1 : valign === ALIGN.BOTTOM ? 0 : 0.3;
      const anchor = align === ALIGN.RIGHT ? "end" : align === ALIGN.LEFT ? "start" : "middle";
      const alt = this.createElement("text");
      alt.setAttribute("x", String(Math.round(x + s.dx)));
      alt.setAttribute("y", String(Math.round(y + s.dy + dy * s.fontSize)));
      alt.setAttribute("fill", s.fontColor || "black");
      alt.setAttribute("font-family", s.fontFamily);
      alt.setAttribute("font-size", `${Math.round(s.fontSize)}px`);
      anchor !== "start" && alt.setAttribute("text-anchor", anchor);
      const fontStyle = s.fontStyle;
      matchBinaryMask(fontStyle, FONT.BOLD) && alt.setAttribute("font-weight", "bold");
      matchBinaryMask(fontStyle, FONT.ITALIC) && alt.setAttribute("font-style", "italic");
      const txtDecor = [];
      matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
      matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
      txtDecor.length > 0 && alt.setAttribute("text-decoration", txtDecor.join(" "));
      write(alt, text);
      return alt;
    }
    return null;
  }
  /**
   * Private helper function to create SVG elements
   */
  createGradientId(start, end, alpha1, alpha2, direction) {
    if (start.charAt(0) === "#") {
      start = start.substring(1);
    }
    if (end.charAt(0) === "#") {
      end = end.substring(1);
    }
    start = `${start.toLowerCase()}-${alpha1}`;
    end = `${end.toLowerCase()}-${alpha2}`;
    let dir = null;
    if (direction == null || direction === DIRECTION.SOUTH) {
      dir = "s";
    } else if (direction === DIRECTION.EAST) {
      dir = "e";
    } else {
      const tmp = start;
      start = end;
      end = tmp;
      if (direction === DIRECTION.NORTH) {
        dir = "s";
      } else if (direction === DIRECTION.WEST) {
        dir = "e";
      }
    }
    return `mx-gradient-${start}-${end}-${dir}`;
  }
  /**
   * Private helper function to create SVG elements
   */
  getSvgGradient(start, end, alpha1, alpha2, direction) {
    const id = this.createGradientId(start, end, alpha1, alpha2, direction);
    let gradient = this.gradients[id];
    if (!gradient) {
      const svg = this.root.ownerSVGElement;
      let counter = 0;
      let tmpId = `${id}-${counter}`;
      if (svg) {
        gradient = svg.ownerDocument.getElementById(tmpId);
        while (gradient && gradient.ownerSVGElement !== svg) {
          tmpId = `${id}-${counter++}`;
          gradient = svg.ownerDocument.getElementById(tmpId);
        }
      } else {
        tmpId = `id${++this.refCount}`;
      }
      if (!gradient) {
        gradient = this.createSvgGradient(start, end, alpha1, alpha2, direction);
        gradient.setAttribute("id", tmpId);
        if (this.defs) {
          this.defs.appendChild(gradient);
        } else if (svg) {
          svg.appendChild(gradient);
        }
      }
      this.gradients[id] = gradient;
    }
    return gradient.getAttribute("id");
  }
  /**
   * Creates the given SVG gradient.
   */
  createSvgGradient(start, end, alpha1, alpha2, direction) {
    const gradient = this.createElement("linearGradient");
    gradient.setAttribute("x1", "0%");
    gradient.setAttribute("y1", "0%");
    gradient.setAttribute("x2", "0%");
    gradient.setAttribute("y2", "0%");
    if (direction == null || direction === DIRECTION.SOUTH) {
      gradient.setAttribute("y2", "100%");
    } else if (direction === DIRECTION.EAST) {
      gradient.setAttribute("x2", "100%");
    } else if (direction === DIRECTION.NORTH) {
      gradient.setAttribute("y1", "100%");
    } else if (direction === DIRECTION.WEST) {
      gradient.setAttribute("x1", "100%");
    }
    let op = alpha1 < 1 ? `;stop-opacity:${alpha1}` : "";
    let stop = this.createElement("stop");
    stop.setAttribute("offset", "0%");
    stop.setAttribute("style", `stop-color:${start}${op}`);
    gradient.appendChild(stop);
    op = alpha2 < 1 ? `;stop-opacity:${alpha2}` : "";
    stop = this.createElement("stop");
    stop.setAttribute("offset", "100%");
    stop.setAttribute("style", `stop-color:${end}${op}`);
    gradient.appendChild(stop);
    return gradient;
  }
  /**
   * Private helper function to create SVG elements
   */
  addNode(filled, stroked) {
    const { node } = this;
    const s = this.state;
    if (node) {
      if (node.nodeName === "path") {
        if (this.path && this.path.length > 0) {
          node.setAttribute("d", this.path.join(" "));
        } else {
          return;
        }
      }
      if (filled && s.fillColor !== NONE) {
        this.updateFill();
      } else if (!this.styleEnabled) {
        if (node.nodeName === "ellipse" && Client.IS_FF) {
          node.setAttribute("fill", "transparent");
        } else {
          node.setAttribute("fill", NONE);
        }
        filled = false;
      }
      if (stroked && s.strokeColor !== NONE) {
        this.updateStroke();
      } else if (!this.styleEnabled) {
        node.setAttribute("stroke", NONE);
      }
      if (s.transform && s.transform.length > 0) {
        node.setAttribute("transform", s.transform);
      }
      if (s.shadow) {
        this.root.appendChild(this.createShadow(node));
      }
      if (this.strokeTolerance > 0 && !filled) {
        this.root.appendChild(this.createTolerance(node));
      }
      if (this.pointerEvents) {
        node.setAttribute("pointer-events", this.pointerEventsValue);
      } else if (!this.pointerEvents && !this.originalRoot) {
        node.setAttribute("pointer-events", NONE);
      }
      if (node.nodeName !== "rect" && node.nodeName !== "path" && node.nodeName !== "ellipse" || node.getAttribute("fill") !== NONE && node.getAttribute("fill") !== "transparent" || node.getAttribute("stroke") !== NONE || node.getAttribute("pointer-events") !== NONE) {
        this.root.appendChild(node);
      }
      this.node = null;
    }
  }
  /**
   * Transfers the stroke attributes from <state> to <node>.
   */
  updateFill() {
    var _a;
    const s = this.state;
    if (s.alpha < 1 || s.fillAlpha < 1) {
      this.node.setAttribute("fill-opacity", String(s.alpha * s.fillAlpha));
    }
    if (s.fillColor !== NONE) {
      if (s.gradientColor !== NONE) {
        const id = this.getSvgGradient(s.fillColor, s.gradientColor, s.gradientFillAlpha, s.gradientAlpha, s.gradientDirection);
        if (((_a = this.root) == null ? void 0 : _a.ownerDocument) === document && useAbsoluteIds) {
          const base = this.getBaseUrl().replace(/([()])/g, "\\$1");
          this.node.setAttribute("fill", `url(${base}#${id})`);
        } else {
          this.node.setAttribute("fill", `url(#${id})`);
        }
      } else {
        this.node.setAttribute("fill", s.fillColor.toLowerCase());
      }
    }
  }
  /**
   * Returns the current stroke width (>= 1), ie. max(1, this.format(this.state.strokeWidth * this.state.scale)).
   */
  getCurrentStrokeWidth() {
    return Math.max(this.minStrokeWidth, Math.max(0.01, this.format(this.state.strokeWidth * this.state.scale)));
  }
  /**
   * Transfers the stroke attributes from {@link mxAbstractCanvas2D.state} to {@link node}.
   */
  updateStroke() {
    const s = this.state;
    if (s.strokeColor && s.strokeColor !== NONE) {
      this.node.setAttribute("stroke", s.strokeColor.toLowerCase());
    }
    if (s.alpha < 1 || s.strokeAlpha < 1) {
      this.node.setAttribute("stroke-opacity", String(s.alpha * s.strokeAlpha));
    }
    const sw = this.getCurrentStrokeWidth();
    if (sw !== 1) {
      this.node.setAttribute("stroke-width", String(sw));
    }
    if (this.node.nodeName === "path") {
      this.updateStrokeAttributes();
    }
    if (s.dashed) {
      this.node.setAttribute("stroke-dasharray", this.createDashPattern((s.fixDash ? 1 : s.strokeWidth) * s.scale));
    }
  }
  /**
   * Transfers the stroke attributes from {@link mxAbstractCanvas2D.state} to {@link node}.
   */
  updateStrokeAttributes() {
    const s = this.state;
    if (s.lineJoin && s.lineJoin !== "miter") {
      this.node.setAttribute("stroke-linejoin", s.lineJoin);
    }
    if (s.lineCap) {
      let value = s.lineCap;
      if (value === "flat") {
        value = "butt";
      }
      if (value !== "butt") {
        this.node.setAttribute("stroke-linecap", value);
      }
    }
    if (s.miterLimit != null && (!this.styleEnabled || s.miterLimit !== 10)) {
      this.node.setAttribute("stroke-miterlimit", String(s.miterLimit));
    }
  }
  /**
   * Creates the SVG dash pattern for the given state.
   */
  createDashPattern(scale) {
    const pat = [];
    if (typeof this.state.dashPattern === "string") {
      const dash = this.state.dashPattern.split(" ");
      if (dash.length > 0) {
        for (let i = 0; i < dash.length; i += 1) {
          pat[i] = Number(dash[i]) * scale;
        }
      }
    }
    return pat.join(" ");
  }
  /**
   * Creates a hit detection tolerance shape for the given node.
   */
  createTolerance(node) {
    const tol = node.cloneNode(true);
    const sw = parseFloat(tol.getAttribute("stroke-width") || "1") + this.strokeTolerance;
    tol.setAttribute("pointer-events", "stroke");
    tol.setAttribute("visibility", "hidden");
    tol.removeAttribute("stroke-dasharray");
    tol.setAttribute("stroke-width", String(sw));
    tol.setAttribute("fill", "none");
    tol.setAttribute("stroke", "white");
    return tol;
  }
  /**
   * Creates a shadow for the given node.
   */
  createShadow(node) {
    const shadow = node.cloneNode(true);
    const s = this.state;
    if (shadow.getAttribute("fill") !== "none" && (!Client.IS_FF || shadow.getAttribute("fill") !== "transparent")) {
      shadow.setAttribute("fill", s.shadowColor);
    }
    if (shadow.getAttribute("stroke") !== "none" && s.shadowColor && s.shadowColor !== NONE) {
      shadow.setAttribute("stroke", s.shadowColor);
    }
    shadow.setAttribute("transform", `translate(${this.format(s.shadowDx * s.scale)},${this.format(s.shadowDy * s.scale)})${s.transform || ""}`);
    shadow.setAttribute("opacity", String(s.shadowAlpha));
    return shadow;
  }
  /**
   * Experimental implementation for hyperlinks.
   */
  setLink(link2) {
    if (!link2) {
      this.root = this.originalRoot;
    } else {
      this.originalRoot = this.root;
      const node = this.createElement("a");
      if (node.setAttributeNS == null || this.root.ownerDocument !== document) {
        node.setAttribute("xlink:href", link2);
      } else {
        node.setAttributeNS(NS_XLINK, "xlink:href", link2);
      }
      this.root.appendChild(node);
      this.root = node;
    }
  }
  /**
   * Sets the rotation of the canvas. Note that rotation cannot be concatenated.
   */
  rotate(theta, flipH, flipV, cx, cy) {
    if (theta !== 0 || flipH || flipV) {
      const s = this.state;
      cx += s.dx;
      cy += s.dy;
      cx *= s.scale;
      cy *= s.scale;
      s.transform = s.transform || "";
      if (flipH && flipV) {
        theta += 180;
      } else if (flipH !== flipV) {
        const tx = flipH ? cx : 0;
        const sx = flipH ? -1 : 1;
        const ty = flipV ? cy : 0;
        const sy = flipV ? -1 : 1;
        s.transform += `translate(${this.format(tx)},${this.format(ty)})scale(${this.format(sx)},${this.format(sy)})translate(${this.format(-tx)},${this.format(-ty)})`;
      }
      if (flipH ? !flipV : flipV) {
        theta *= -1;
      }
      if (theta !== 0) {
        s.transform += `rotate(${this.format(theta)},${this.format(cx)},${this.format(cy)})`;
      }
      s.rotation += theta;
      s.rotationCx = cx;
      s.rotationCy = cy;
    }
  }
  /**
   * Extends superclass to create path.
   */
  begin() {
    super.begin();
    this.node = this.createElement("path");
  }
  /**
   * Private helper function to create SVG elements
   */
  rect(x, y, w, h) {
    const s = this.state;
    const n = this.createElement("rect");
    n.setAttribute("x", String(this.format((x + s.dx) * s.scale)));
    n.setAttribute("y", String(this.format((y + s.dy) * s.scale)));
    n.setAttribute("width", String(this.format(w * s.scale)));
    n.setAttribute("height", String(this.format(h * s.scale)));
    this.node = n;
  }
  /**
   * Private helper function to create SVG elements
   */
  roundrect(x, y, w, h, dx, dy) {
    this.rect(x, y, w, h);
    if (dx > 0) {
      this.node.setAttribute("rx", String(this.format(dx * this.state.scale)));
    }
    if (dy > 0) {
      this.node.setAttribute("ry", String(this.format(dy * this.state.scale)));
    }
  }
  /**
   * Private helper function to create SVG elements
   */
  ellipse(x, y, w, h) {
    const s = this.state;
    const n = this.createElement("ellipse");
    n.setAttribute("cx", String(this.format((x + w / 2 + s.dx) * s.scale)));
    n.setAttribute("cy", String(this.format((y + h / 2 + s.dy) * s.scale)));
    n.setAttribute("rx", String(w / 2 * s.scale));
    n.setAttribute("ry", String(h / 2 * s.scale));
    this.node = n;
  }
  /**
   * Private helper function to create SVG elements
   */
  image(x, y, w, h, src, aspect = true, flipH = false, flipV = false) {
    src = this.converter.convert(src);
    const s = this.state;
    x += s.dx;
    y += s.dy;
    const node = this.createElement("image");
    node.setAttribute("x", String(this.format(x * s.scale) + this.imageOffset));
    node.setAttribute("y", String(this.format(y * s.scale) + this.imageOffset));
    node.setAttribute("width", String(this.format(w * s.scale)));
    node.setAttribute("height", String(this.format(h * s.scale)));
    if (!node.setAttributeNS) {
      node.setAttribute("xlink:href", src);
    } else {
      node.setAttributeNS(NS_XLINK, "xlink:href", src);
    }
    if (!aspect) {
      node.setAttribute("preserveAspectRatio", "none");
    }
    if (s.alpha < 1 || s.fillAlpha < 1) {
      node.setAttribute("opacity", String(s.alpha * s.fillAlpha));
    }
    let tr = this.state.transform || "";
    if (flipH || flipV) {
      let sx = 1;
      let sy = 1;
      let dx = 0;
      let dy = 0;
      if (flipH) {
        sx = -1;
        dx = -w - 2 * x;
      }
      if (flipV) {
        sy = -1;
        dy = -h - 2 * y;
      }
      tr += `scale(${sx},${sy})translate(${dx * s.scale},${dy * s.scale})`;
    }
    if (tr.length > 0) {
      node.setAttribute("transform", tr);
    }
    if (!this.pointerEvents) {
      node.setAttribute("pointer-events", "none");
    }
    this.root.appendChild(node);
  }
  /**
   * Converts the given HTML string to XHTML.
   */
  convertHtml(val) {
    const doc = new DOMParser().parseFromString(val, "text/html");
    if (doc != null) {
      val = new XMLSerializer().serializeToString(doc.body);
      if (val.substring(0, 5) === "<body") {
        val = val.substring(val.indexOf(">", 5) + 1);
      }
      if (val.substring(val.length - 7, val.length) === "</body>") {
        val = val.substring(0, val.length - 7);
      }
    }
    return val;
  }
  /**
   * Private helper function to create SVG elements
   * Note: signature changed in mxgraph 4.1.0
   */
  createDiv(str) {
    let val = str;
    if (!isNode(val)) {
      val = `<div><div>${this.convertHtml(val)}</div></div>`;
    }
    if (document.createElementNS) {
      const div = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
      if (isNode(val)) {
        const n = val;
        const div2 = document.createElement("div");
        const div3 = div2.cloneNode(false);
        if (this.root.ownerDocument !== document) {
          div2.appendChild(n.cloneNode(true));
        } else {
          div2.appendChild(n);
        }
        div3.appendChild(div2);
        div.appendChild(div3);
      } else {
        div.innerHTML = val;
      }
      return div;
    }
    if (isNode(val)) {
      val = `<div><div>${getXml(val)}</div></div>`;
    }
    val = `<div xmlns="http://www.w3.org/1999/xhtml">${val}</div>`;
    return new DOMParser().parseFromString(val, "text/xml").documentElement;
  }
  /**
   * Updates existing DOM nodes for text rendering. LATER: Merge common parts with text function below.
   */
  updateText(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node) {
    if (node && node.firstChild && node.firstChild.firstChild) {
      this.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node.firstChild);
    }
  }
  /**
   * Creates a foreignObject for the given string and adds it to the given root.
   */
  addForeignObject(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, root) {
    var _a;
    const group = this.createElement("g");
    const fo = this.createElement("foreignObject");
    fo.setAttribute("style", "overflow: visible; text-align: left;");
    fo.setAttribute("pointer-events", "none");
    fo.appendChild(div);
    group.appendChild(fo);
    this.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, group);
    if (((_a = this.root) == null ? void 0 : _a.ownerDocument) !== document) {
      const alt = this.createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);
      if (alt != null) {
        fo.setAttribute("requiredFeatures", "http://www.w3.org/TR/SVG11/feature#Extensibility");
        const sw = this.createElement("switch");
        sw.appendChild(fo);
        sw.appendChild(alt);
        group.appendChild(sw);
      }
    }
    root.appendChild(group);
  }
  /**
   * Updates existing DOM nodes for text rendering.
   */
  updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, g) {
    const s = this.state.scale;
    SvgCanvas2D.createCss(w + 2, h, align, valign, wrap, overflow, clip, this.state.fontBackgroundColor != null ? this.state.fontBackgroundColor : null, this.state.fontBorderColor != null ? this.state.fontBorderColor : null, `display: flex; align-items: unsafe ${valign === ALIGN.TOP ? "flex-start" : valign === ALIGN.BOTTOM ? "flex-end" : "center"}; justify-content: unsafe ${align === ALIGN.LEFT ? "flex-start" : align === ALIGN.RIGHT ? "flex-end" : "center"}; `, this.getTextCss(), s, (dx, dy, flex, item, block) => {
      x += this.state.dx;
      y += this.state.dy;
      const fo = g.firstChild;
      const div = fo.firstChild;
      const box = div.firstChild;
      const text = box.firstChild;
      const r = (this.rotateHtml ? this.state.rotation : 0) + (rotation != null ? rotation : 0);
      let t = (this.foOffset !== 0 ? `translate(${this.foOffset} ${this.foOffset})` : "") + (s !== 1 ? `scale(${s})` : "");
      text.setAttribute("style", block);
      box.setAttribute("style", item);
      fo.setAttribute("width", `${Math.ceil(1 / Math.min(1, s) * 100)}%`);
      fo.setAttribute("height", `${Math.ceil(1 / Math.min(1, s) * 100)}%`);
      const yp = Math.round(y + dy);
      if (yp < 0) {
        fo.setAttribute("y", String(yp));
      } else {
        fo.removeAttribute("y");
        flex += `padding-top: ${yp}px; `;
      }
      div.setAttribute("style", `${flex}margin-left: ${Math.round(x + dx)}px;`);
      t += r !== 0 ? `rotate(${r} ${x} ${y})` : "";
      if (t !== "") {
        g.setAttribute("transform", t);
      } else {
        g.removeAttribute("transform");
      }
      if (this.state.alpha !== 1) {
        g.setAttribute("opacity", String(this.state.alpha));
      } else {
        g.removeAttribute("opacity");
      }
    });
  }
  /**
   * Private helper function to create SVG elements
   */
  getTextCss() {
    const s = this.state;
    const lh = LINE_HEIGHT * this.lineHeightCorrection;
    let css = `display: inline-block; font-size: ${s.fontSize}px; font-family: ${s.fontFamily}; color: ${s.fontColor}; line-height: ${lh}; pointer-events: ${this.pointerEvents ? this.pointerEventsValue : "none"}; `;
    const fontStyle = s.fontStyle;
    matchBinaryMask(fontStyle, FONT.BOLD) && (css += "font-weight: bold; ");
    matchBinaryMask(fontStyle, FONT.ITALIC) && (css += "font-style: italic; ");
    const txtDecor = [];
    matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
    matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
    txtDecor.length > 0 && (css += `text-decoration: ${txtDecor.join(" ")}; `);
    return css;
  }
  /**
   * Paints the given text. Possible values for format are empty string for plain
   * text and html for HTML markup. Note that HTML markup is only supported if
   * foreignObject is supported and <foEnabled> is true. (This means IE9 and later
   * does currently not support HTML text as part of shapes.)
   */
  text(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation = 0, dir) {
    if (this.textEnabled && str != null) {
      rotation = rotation != null ? rotation : 0;
      if (this.foEnabled && format === "html") {
        const div = this.createDiv(str);
        if (div != null) {
          if (dir != null) {
            div.setAttribute("dir", dir);
          }
          this.addForeignObject(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, this.root);
        }
      } else {
        this.plainText(x + this.state.dx, y + this.state.dy, w, h, str, align, valign, wrap, overflow, clip, rotation, dir);
      }
    }
  }
  /**
   * Creates a clip for the given coordinates.
   */
  createClip(x, y, w, h) {
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);
    const id = `mx-clip-${x}-${y}-${w}-${h}`;
    let counter = 0;
    let tmp = `${id}-${counter}`;
    while (document.getElementById(tmp) != null) {
      tmp = `${id}-${++counter}`;
    }
    const clip = this.createElement("clipPath");
    clip.setAttribute("id", tmp);
    const rect = this.createElement("rect");
    rect.setAttribute("x", String(x));
    rect.setAttribute("y", String(y));
    rect.setAttribute("width", String(w));
    rect.setAttribute("height", String(h));
    clip.appendChild(rect);
    return clip;
  }
  /**
   * Paints the given text. Possible values for format are empty string for
   * plain text and html for HTML markup.
   */
  plainText(x, y, w, h, str, align, valign, wrap, overflow, clip, rotation = 0, dir) {
    const s = this.state;
    const size = s.fontSize;
    const node = this.createElement("g");
    let tr = s.transform || "";
    this.updateFont(node);
    if (!this.pointerEvents && this.originalRoot == null) {
      node.setAttribute("pointer-events", "none");
    }
    if (rotation !== 0) {
      tr += `rotate(${rotation},${this.format(x * s.scale)},${this.format(y * s.scale)})`;
    }
    if (dir != null) {
      node.setAttribute("direction", dir);
    }
    if (clip && w > 0 && h > 0) {
      let cx = x;
      let cy2 = y;
      if (align === ALIGN.CENTER) {
        cx -= w / 2;
      } else if (align === ALIGN.RIGHT) {
        cx -= w;
      }
      if (overflow !== "fill") {
        if (valign === ALIGN.MIDDLE) {
          cy2 -= h / 2;
        } else if (valign === ALIGN.BOTTOM) {
          cy2 -= h;
        }
      }
      const c = this.createClip(cx * s.scale - 2, cy2 * s.scale - 2, w * s.scale + 4, h * s.scale + 4);
      if (this.defs != null) {
        this.defs.appendChild(c);
      } else {
        this.root.appendChild(c);
      }
      if (!Client.IS_CHROMEAPP && !Client.IS_EDGE && this.root.ownerDocument === document) {
        const base = this.getBaseUrl().replace(/([()])/g, "\\$1");
        node.setAttribute("clip-path", `url(${base}#${c.getAttribute("id")})`);
      } else {
        node.setAttribute("clip-path", `url(#${c.getAttribute("id")})`);
      }
    }
    const anchor = align === ALIGN.RIGHT ? "end" : align === ALIGN.CENTER ? "middle" : "start";
    if (anchor !== "start") {
      node.setAttribute("text-anchor", anchor);
    }
    if (!this.styleEnabled || size !== DEFAULT_FONTSIZE) {
      node.setAttribute("font-size", `${size * s.scale}px`);
    }
    if (tr.length > 0) {
      node.setAttribute("transform", tr);
    }
    if (s.alpha < 1) {
      node.setAttribute("opacity", String(s.alpha));
    }
    const lines = str.split("\n");
    const lh = Math.round(size * LINE_HEIGHT);
    const textHeight = size + (lines.length - 1) * lh;
    let cy = y + size - 1;
    if (valign === ALIGN.MIDDLE) {
      if (overflow === "fill") {
        cy -= h / 2;
      } else {
        const dy = (this.matchHtmlAlignment && clip && h > 0 ? Math.min(textHeight, h) : textHeight) / 2;
        cy -= dy;
      }
    } else if (valign === ALIGN.BOTTOM) {
      if (overflow === "fill") {
        cy -= h;
      } else {
        const dy = this.matchHtmlAlignment && clip && h > 0 ? Math.min(textHeight, h) : textHeight;
        cy -= dy + 1;
      }
    }
    for (let i = 0; i < lines.length; i += 1) {
      const line = trim(lines[i]);
      if (line) {
        const text = this.createElement("text");
        text.setAttribute("x", String(this.format(x * s.scale) + this.textOffset));
        text.setAttribute("y", String(this.format(cy * s.scale) + this.textOffset));
        write(text, line);
        node.appendChild(text);
      }
      cy += lh;
    }
    this.root.appendChild(node);
    this.addTextBackground(node, str, x, y, w, overflow === "fill" ? h : textHeight, align, valign, overflow);
  }
  /**
   * Updates the text properties for the given node. (NOTE: For this to work in
   * IE, the given node must be a text or tspan element.)
   */
  updateFont(node) {
    const s = this.state;
    if (s.fontColor && s.fontColor !== NONE) {
      node.setAttribute("fill", s.fontColor);
    }
    if (!this.styleEnabled || s.fontFamily !== DEFAULT_FONTFAMILY) {
      node.setAttribute("font-family", s.fontFamily);
    }
    const fontStyle = s.fontStyle;
    matchBinaryMask(fontStyle, FONT.BOLD) && node.setAttribute("font-weight", "bold");
    matchBinaryMask(fontStyle, FONT.ITALIC) && node.setAttribute("font-style", "italic");
    const txtDecor = [];
    matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
    matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
    txtDecor.length > 0 && node.setAttribute("text-decoration", txtDecor.join(" "));
  }
  /**
   * Background color and border
   */
  addTextBackground(node, str, x, y, w, h, align, valign, overflow) {
    var _a;
    const s = this.state;
    if (s.fontBackgroundColor != null || s.fontBorderColor != null) {
      let bbox = null;
      if (overflow === "fill" || overflow === "width") {
        if (align === ALIGN.CENTER) {
          x -= w / 2;
        } else if (align === ALIGN.RIGHT) {
          x -= w;
        }
        if (valign === ALIGN.MIDDLE) {
          y -= h / 2;
        } else if (valign === ALIGN.BOTTOM) {
          y -= h;
        }
        bbox = new Rectangle((x + 1) * s.scale, y * s.scale, (w - 2) * s.scale, (h + 2) * s.scale);
      } else if (node.getBBox != null && this.root.ownerDocument === document) {
        try {
          bbox = node.getBBox();
          bbox = new Rectangle(bbox.x, bbox.y + 1, bbox.width, bbox.height + 0);
        } catch (e) {
        }
      }
      if (bbox == null || bbox.width === 0 || bbox.height === 0) {
        const div = document.createElement("div");
        div.style.lineHeight = String(LINE_HEIGHT);
        div.style.fontSize = `${s.fontSize}px`;
        div.style.fontFamily = s.fontFamily;
        div.style.whiteSpace = "nowrap";
        div.style.position = "absolute";
        div.style.visibility = "hidden";
        div.style.display = "inline-block";
        matchBinaryMask(s.fontStyle, FONT.BOLD) && (div.style.fontWeight = "bold");
        matchBinaryMask(s.fontStyle, FONT.ITALIC) && (div.style.fontStyle = "italic");
        str = htmlEntities(str, false);
        div.innerHTML = str.replace(/\n/g, "<br/>");
        document.body.appendChild(div);
        const w2 = div.offsetWidth;
        const h2 = div.offsetHeight;
        document.body.removeChild(div);
        if (align === ALIGN.CENTER) {
          x -= w2 / 2;
        } else if (align === ALIGN.RIGHT) {
          x -= w2;
        }
        if (valign === ALIGN.MIDDLE) {
          y -= h2 / 2;
        } else if (valign === ALIGN.BOTTOM) {
          y -= h2;
        }
        bbox = new Rectangle((x + 1) * s.scale, (y + 2) * s.scale, w2 * s.scale, (h2 + 1) * s.scale);
      }
      if (bbox != null) {
        const n = this.createElement("rect");
        n.setAttribute("fill", s.fontBackgroundColor || "none");
        n.setAttribute("stroke", s.fontBorderColor || "none");
        n.setAttribute("x", String(Math.floor(bbox.x - 1)));
        n.setAttribute("y", String(Math.floor(bbox.y - 1)));
        n.setAttribute("width", String(Math.ceil(bbox.width + 2)));
        n.setAttribute("height", String(Math.ceil(bbox.height)));
        const sw = s.fontBorderColor ? Math.max(1, this.format(s.scale)) : 0;
        n.setAttribute("stroke-width", String(sw));
        if (((_a = this.root) == null ? void 0 : _a.ownerDocument) === document && mod(sw, 2) === 1) {
          n.setAttribute("transform", "translate(0.5, 0.5)");
        }
        node.insertBefore(n, node.firstChild);
      }
    }
  }
  /**
   * Paints the outline of the current path.
   */
  stroke() {
    this.addNode(false, true);
  }
  /**
   * Fills the current path.
   */
  fill() {
    this.addNode(true, false);
  }
  /**
   * Fills and paints the outline of the current path.
   */
  fillAndStroke() {
    this.addNode(true, true);
  }
}
SvgCanvas2D.createCss = (w, h, align, valign, wrap, overflow, clip, bg, border, flex, block, scale, callback) => {
  let item = `box-sizing: border-box; font-size: 0; text-align: ${align === ALIGN.LEFT ? "left" : align === ALIGN.RIGHT ? "right" : "center"}; `;
  const pt = getAlignmentAsPoint(align, valign);
  let ofl = "overflow: hidden; ";
  let fw = "width: 1px; ";
  let fh = "height: 1px; ";
  let dx = pt.x * w;
  let dy = pt.y * h;
  if (clip) {
    fw = `width: ${Math.round(w)}px; `;
    item += `max-height: ${Math.round(h)}px; `;
    dy = 0;
  } else if (overflow === "fill") {
    fw = `width: ${Math.round(w)}px; `;
    fh = `height: ${Math.round(h)}px; `;
    block += "width: 100%; height: 100%; ";
    item += fw + fh;
  } else if (overflow === "width") {
    fw = `width: ${Math.round(w)}px; `;
    block += "width: 100%; ";
    item += fw;
    dy = 0;
    if (h > 0) {
      item += `max-height: ${Math.round(h)}px; `;
    }
  } else {
    ofl = "";
    dy = 0;
  }
  let bgc = "";
  if (bg) {
    bgc += `background-color: ${bg}; `;
  }
  if (border) {
    bgc += `border: 1px solid ${border}; `;
  }
  if (ofl == "" || clip) {
    block += bgc;
  } else {
    item += bgc;
  }
  if (wrap && w > 0) {
    block += `white-space: normal; word-wrap: ${WORD_WRAP}; `;
    fw = `width: ${Math.round(w)}px; `;
    if (ofl !== "" && overflow !== "fill") {
      dy = 0;
    }
  } else {
    block += "white-space: nowrap; ";
    if (ofl === "") {
      dx = 0;
    }
  }
  callback(dx, dy, flex + fw + fh, item + ofl, block, ofl);
};
class Shape {
  constructor(stencil = null) {
    this.preserveImageAspect = false;
    this.overlay = null;
    this.indicator = null;
    this.indicatorShape = null;
    this.opacity = 100;
    this.isDashed = false;
    this.fill = NONE;
    this.gradient = NONE;
    this.gradientDirection = DIRECTION.EAST;
    this.fillOpacity = 100;
    this.strokeOpacity = 100;
    this.stroke = NONE;
    this.strokeWidth = 1;
    this.spacing = 0;
    this.startSize = 1;
    this.endSize = 1;
    this.startArrow = NONE;
    this.endArrow = NONE;
    this.direction = DIRECTION.EAST;
    this.flipH = false;
    this.flipV = false;
    this.isShadow = false;
    this.isRounded = false;
    this.rotation = 0;
    this.cursor = "";
    this.verticalTextRotation = 0;
    this.oldGradients = {};
    this.glass = false;
    this.dialect = null;
    this.scale = 1;
    this.antiAlias = true;
    this.minSvgStrokeWidth = 1;
    this.bounds = null;
    this.points = [];
    this.state = null;
    this.style = null;
    this.boundingBox = null;
    this.stencil = null;
    this.svgStrokeTolerance = 8;
    this.pointerEvents = true;
    this.originalPointerEvents = null;
    this.svgPointerEvents = "all";
    this.shapePointerEvents = false;
    this.stencilPointerEvents = false;
    this.outline = false;
    this.visible = true;
    this.useSvgBoundingBox = true;
    this.image = null;
    this.imageSrc = null;
    this.indicatorColor = NONE;
    this.indicatorStrokeColor = NONE;
    this.indicatorGradientColor = NONE;
    this.indicatorDirection = DIRECTION.EAST;
    this.indicatorImageSrc = null;
    if (stencil) {
      this.stencil = stencil;
    }
    this.node = this.create();
  }
  /**
   * Initializes the shape by creaing the DOM node using <create>
   * and adding it into the given container.
   *
   * @param container DOM node that will contain the shape.
   */
  init(container) {
    if (!this.node.parentNode) {
      container.appendChild(this.node);
    }
  }
  /**
   * Sets the styles to their default values.
   */
  initStyles() {
    this.strokeWidth = 1;
    this.rotation = 0;
    this.opacity = 100;
    this.fillOpacity = 100;
    this.strokeOpacity = 100;
    this.flipH = false;
    this.flipV = false;
  }
  /**
   * Returns true if HTML is allowed for this shape. This implementation always
   * returns false.
   */
  isHtmlAllowed() {
    return false;
  }
  /**
   * Returns 0, or 0.5 if <strokewidth> % 2 == 1.
   */
  getSvgScreenOffset() {
    const sw = this.stencil && this.stencil.strokeWidthValue !== "inherit" ? Number(this.stencil.strokeWidthValue) : this.strokeWidth ?? 0;
    return mod(Math.max(1, Math.round(sw * this.scale)), 2) === 1 ? 0.5 : 0;
  }
  /**
   * Creates and returns the DOM node for the shape.
   * This implementation assumes that `maxGraph` produces SVG elements.
   */
  create() {
    return document.createElementNS(NS_SVG, "g");
  }
  redraw() {
    this.updateBoundsFromPoints();
    if (this.visible && this.checkBounds()) {
      this.node.style.visibility = "visible";
      this.clear();
      this.redrawShape();
      this.updateBoundingBox();
    } else {
      this.node.style.visibility = "hidden";
      this.boundingBox = null;
    }
  }
  /**
   * Removes all child nodes and resets all CSS.
   */
  clear() {
    while (this.node.lastChild) {
      this.node.removeChild(this.node.lastChild);
    }
  }
  /**
   * Updates the bounds based on the points.
   */
  updateBoundsFromPoints() {
    const pts = this.points;
    if (pts.length > 0 && pts[0]) {
      this.bounds = new Rectangle(Math.round(pts[0].x), Math.round(pts[0].y), 1, 1);
      for (const pt of pts) {
        if (pt) {
          this.bounds.add(new Rectangle(Math.round(pt.x), Math.round(pt.y), 1, 1));
        }
      }
    }
  }
  /**
   * Returns the {@link Rectangle} for the label bounds of this shape, based on the
   * given scaled and translated bounds of the shape. This method should not
   * change the rectangle in-place. This implementation returns the given rect.
   */
  getLabelBounds(rect) {
    var _a, _b, _c;
    const d = ((_a = this.style) == null ? void 0 : _a.direction) ?? DIRECTION.EAST;
    let bounds = rect.clone();
    if (d !== DIRECTION.SOUTH && d !== DIRECTION.NORTH && this.state && this.state.text && this.state.text.isPaintBoundsInverted()) {
      bounds = bounds.clone();
      [bounds.width, bounds.height] = [bounds.height, bounds.width];
    }
    let labelMargins = this.getLabelMargins(bounds);
    if (labelMargins) {
      labelMargins = labelMargins.clone();
      let flipH = ((_b = this.style) == null ? void 0 : _b.flipH) ?? false;
      let flipV = ((_c = this.style) == null ? void 0 : _c.flipV) ?? false;
      if (this.state && this.state.text && this.state.text.isPaintBoundsInverted()) {
        const tmp = labelMargins.x;
        labelMargins.x = labelMargins.height;
        labelMargins.height = labelMargins.width;
        labelMargins.width = labelMargins.y;
        labelMargins.y = tmp;
        [flipH, flipV] = [flipV, flipH];
      }
      return getDirectedBounds(rect, labelMargins, this.style, flipH, flipV);
    }
    return rect;
  }
  /**
   * Returns the scaled top, left, bottom and right margin to be used for
   * computing the label bounds as an {@link Rectangle}, where the bottom and right
   * margin are defined in the width and height of the rectangle, respectively.
   */
  getLabelMargins(rect) {
    return null;
  }
  /**
   * Returns true if the bounds are not null and all of its variables are numeric.
   */
  checkBounds() {
    return !Number.isNaN(this.scale) && Number.isFinite(this.scale) && this.scale > 0 && this.bounds && !Number.isNaN(this.bounds.x) && !Number.isNaN(this.bounds.y) && !Number.isNaN(this.bounds.width) && !Number.isNaN(this.bounds.height) && this.bounds.width > 0 && this.bounds.height > 0;
  }
  /**
   * Updates the SVG or VML shape.
   */
  redrawShape() {
    const canvas = this.createCanvas();
    if (canvas) {
      canvas.pointerEvents = this.pointerEvents;
      this.beforePaint(canvas);
      this.paint(canvas);
      this.afterPaint(canvas);
      if (this.node !== canvas.root && canvas.root) {
        this.node.insertAdjacentHTML("beforeend", canvas.root.outerHTML);
      }
      this.destroyCanvas(canvas);
    }
  }
  /**
   * Creates a new canvas for drawing this shape. May return null.
   */
  createCanvas() {
    const canvas = this.createSvgCanvas();
    if (canvas && this.outline) {
      canvas.setStrokeWidth(this.strokeWidth);
      canvas.setStrokeColor(this.stroke);
      if (this.isDashed) {
        canvas.setDashed(this.isDashed);
      }
      canvas.setStrokeWidth = () => {
        return;
      };
      canvas.setStrokeColor = () => {
        return;
      };
      canvas.setFillColor = () => {
        return;
      };
      canvas.setGradient = () => {
        return;
      };
      canvas.setDashed = () => {
        return;
      };
      canvas.text = () => {
        return;
      };
    }
    return canvas;
  }
  /**
   * Creates and returns an {@link SvgCanvas2D} for rendering this shape.
   */
  createSvgCanvas() {
    if (!this.node)
      return null;
    const canvas = new SvgCanvas2D(this.node, false);
    canvas.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;
    canvas.pointerEventsValue = this.svgPointerEvents;
    const off = this.getSvgScreenOffset();
    if (off !== 0) {
      this.node.setAttribute("transform", `translate(${off},${off})`);
    } else {
      this.node.removeAttribute("transform");
    }
    canvas.minStrokeWidth = this.minSvgStrokeWidth;
    if (!this.antiAlias) {
      canvas.format = (value) => {
        return Math.round(value);
      };
    }
    return canvas;
  }
  /**
   * Destroys the given canvas which was used for drawing. This implementation
   * increments the reference counts on all shared gradients used in the canvas.
   */
  destroyCanvas(canvas) {
    if (canvas instanceof SvgCanvas2D) {
      for (const key in canvas.gradients) {
        const gradient = canvas.gradients[key];
        if (gradient) {
          gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;
        }
      }
      this.releaseSvgGradients(this.oldGradients);
      this.oldGradients = canvas.gradients;
    }
  }
  /**
   * Invoked before paint is called.
   */
  beforePaint(c) {
    return;
  }
  /**
   * Invokes after paint was called.
   */
  afterPaint(c) {
    return;
  }
  /**
   * Generic rendering code.
   */
  paint(c) {
    let strokeDrawn = false;
    if (c && this.outline) {
      const { stroke } = c;
      c.stroke = (...args) => {
        strokeDrawn = true;
        stroke.apply(c, args);
      };
      const { fillAndStroke } = c;
      c.fillAndStroke = (...args) => {
        strokeDrawn = true;
        fillAndStroke.apply(c, args);
      };
    }
    const s = this.scale;
    const bounds = this.bounds;
    if (bounds) {
      let x = bounds.x / s;
      let y = bounds.y / s;
      let w = bounds.width / s;
      let h = bounds.height / s;
      if (this.isPaintBoundsInverted()) {
        const t = (w - h) / 2;
        x += t;
        y -= t;
        const tmp = w;
        w = h;
        h = tmp;
      }
      this.updateTransform(c, x, y, w, h);
      this.configureCanvas(c, x, y, w, h);
      let bg = null;
      if (!this.stencil && this.points.length === 0 && this.shapePointerEvents || this.stencil && this.stencilPointerEvents) {
        const bb = this.createBoundingBox();
        if (bb && this.node) {
          bg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);
          this.node.appendChild(bg);
        }
      }
      if (this.stencil) {
        this.stencil.drawShape(c, this, x, y, w, h);
      } else {
        c.setStrokeWidth(this.strokeWidth);
        if (this.points.length > 0) {
          const pts = [];
          for (let i = 0; i < this.points.length; i += 1) {
            const p = this.points[i];
            if (p) {
              pts.push(new Point(p.x / s, p.y / s));
            }
          }
          this.paintEdgeShape(c, pts);
        } else {
          this.paintVertexShape(c, x, y, w, h);
        }
      }
      if (bg && c.state && !isNullish(c.state.transform)) {
        bg.setAttribute("transform", c.state.transform);
      }
      if (c && this.outline && !strokeDrawn) {
        c.rect(x, y, w, h);
        c.stroke();
      }
    }
  }
  /**
   * Sets the state of the canvas for drawing the shape.
   */
  configureCanvas(c, x, y, w, h) {
    var _a;
    let dash = null;
    if (this.style && this.style.dashPattern != null) {
      dash = this.style.dashPattern;
    }
    c.setAlpha(this.opacity / 100);
    c.setFillAlpha(this.fillOpacity / 100);
    c.setStrokeAlpha(this.strokeOpacity / 100);
    if (this.isShadow) {
      c.setShadow(this.isShadow);
    }
    if (this.isDashed) {
      c.setDashed(this.isDashed, ((_a = this.style) == null ? void 0 : _a.fixDash) ?? false);
    }
    if (dash) {
      c.setDashPattern(dash);
    }
    if (this.fill !== NONE && this.gradient !== NONE) {
      const b = this.getGradientBounds(c, x, y, w, h);
      c.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);
    } else {
      c.setFillColor(this.fill);
    }
    c.setStrokeColor(this.stroke);
  }
  /**
   * Returns the bounding box for the gradient box for this shape.
   */
  getGradientBounds(c, x, y, w, h) {
    return new Rectangle(x, y, w, h);
  }
  /**
   * Sets the scale and rotation on the given canvas.
   */
  updateTransform(c, x, y, w, h) {
    c.scale(this.scale);
    c.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w / 2, y + h / 2);
  }
  /**
   * Paints the vertex shape.
   */
  paintVertexShape(c, x, y, w, h) {
    this.paintBackground(c, x, y, w, h);
    if (!this.outline || !this.style || !(this.style.backgroundOutline ?? false)) {
      c.setShadow(false);
      this.paintForeground(c, x, y, w, h);
    }
  }
  /**
   * Hook for subclassers. This implementation is empty.
   */
  paintBackground(c, x, y, w, h) {
    return;
  }
  /**
   * Hook for subclassers. This implementation is empty.
   */
  paintForeground(c, x, y, w, h) {
    return;
  }
  /**
   * Hook for subclassers. This implementation is empty.
   */
  paintEdgeShape(c, pts) {
    return;
  }
  /**
   * Returns the arc size for the given dimension.
   */
  getArcSize(w, h) {
    var _a, _b, _c;
    let r = 0;
    if (((_a = this.style) == null ? void 0 : _a.absoluteArcSize) ?? false) {
      r = Math.min(w / 2, Math.min(h / 2, (((_b = this.style) == null ? void 0 : _b.arcSize) ?? LINE_ARCSIZE) / 2));
    } else {
      const f = (((_c = this.style) == null ? void 0 : _c.arcSize) ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;
      r = Math.min(w * f, h * f);
    }
    return r;
  }
  /**
   * Paints the glass gradient effect.
   */
  paintGlassEffect(c, x, y, w, h, arc) {
    const sw = Math.ceil((this.strokeWidth ?? 0) / 2);
    const size = 0.4;
    c.setGradient("#ffffff", "#ffffff", x, y, w, h * 0.6, "south", 0.9, 0.1);
    c.begin();
    arc += 2 * sw;
    if (this.isRounded) {
      c.moveTo(x - sw + arc, y - sw);
      c.quadTo(x - sw, y - sw, x - sw, y - sw + arc);
      c.lineTo(x - sw, y + h * size);
      c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);
      c.lineTo(x + w + sw, y - sw + arc);
      c.quadTo(x + w + sw, y - sw, x + w + sw - arc, y - sw);
    } else {
      c.moveTo(x - sw, y - sw);
      c.lineTo(x - sw, y + h * size);
      c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);
      c.lineTo(x + w + sw, y - sw);
    }
    c.close();
    c.fill();
  }
  /**
   * Paints the given points with rounded corners.
   */
  addPoints(c, pts, rounded = false, arcSize, close = false, exclude = [], initialMove = true) {
    if (pts.length > 0) {
      const pe = pts[pts.length - 1];
      if (close && rounded) {
        pts = pts.slice();
        const p0 = pts[0];
        const wp = new Point(pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);
        pts.splice(0, 0, wp);
      }
      let pt = pts[0];
      let i = 1;
      if (initialMove) {
        c.moveTo(pt.x, pt.y);
      } else {
        c.lineTo(pt.x, pt.y);
      }
      while (i < (close ? pts.length : pts.length - 1)) {
        let tmp = pts[mod(i, pts.length)];
        let dx = pt.x - tmp.x;
        let dy = pt.y - tmp.y;
        if (rounded && (dx !== 0 || dy !== 0) && exclude.indexOf(i - 1) < 0) {
          let dist = Math.sqrt(dx * dx + dy * dy);
          const nx1 = dx * Math.min(arcSize, dist / 2) / dist;
          const ny1 = dy * Math.min(arcSize, dist / 2) / dist;
          const x1 = tmp.x + nx1;
          const y1 = tmp.y + ny1;
          c.lineTo(x1, y1);
          let next = pts[mod(i + 1, pts.length)];
          while (i < pts.length - 2 && Math.round(next.x - tmp.x) === 0 && Math.round(next.y - tmp.y) === 0) {
            next = pts[mod(i + 2, pts.length)];
            i++;
          }
          dx = next.x - tmp.x;
          dy = next.y - tmp.y;
          dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
          const nx2 = dx * Math.min(arcSize, dist / 2) / dist;
          const ny2 = dy * Math.min(arcSize, dist / 2) / dist;
          const x2 = tmp.x + nx2;
          const y2 = tmp.y + ny2;
          c.quadTo(tmp.x, tmp.y, x2, y2);
          tmp = new Point(x2, y2);
        } else {
          c.lineTo(tmp.x, tmp.y);
        }
        pt = tmp;
        i += 1;
      }
      if (close) {
        c.close();
      } else {
        c.lineTo(pe.x, pe.y);
      }
    }
  }
  /**
   * Resets all styles.
   */
  resetStyles() {
    this.initStyles();
    this.spacing = 0;
    this.fill = NONE;
    this.gradient = NONE;
    this.gradientDirection = DIRECTION.EAST;
    this.stroke = NONE;
    this.startSize = 1;
    this.endSize = 1;
    this.startArrow = NONE;
    this.endArrow = NONE;
    this.direction = DIRECTION.EAST;
    this.isShadow = false;
    this.isDashed = false;
    this.isRounded = false;
    this.glass = false;
  }
  /**
   * Applies the style of the given <CellState> to the shape. This
   * implementation assigns the following styles to local fields:
   *
   * - <'fillColor'> => fill
   * - <'gradientColor'> => gradient
   * - <'gradientDirection'> => gradientDirection
   * - <'opacity'> => opacity
   * - {@link Constants#STYLE_FILL_OPACITY} => fillOpacity
   * - {@link Constants#STYLE_STROKE_OPACITY} => strokeOpacity
   * - <'strokeColor'> => stroke
   * - <'strokeWidth'> => strokewidth
   * - <'shadow'> => isShadow
   * - <'dashed'> => isDashed
   * - <'spacing'> => spacing
   * - <'startSize'> => startSize
   * - <'endSize'> => endSize
   * - <'rounded'> => isRounded
   * - <'startArrow'> => startArrow
   * - <'endArrow'> => endArrow
   * - <'rotation'> => rotation
   * - <'direction'> => direction
   * - <'glass'> => glass
   *
   * This keeps a reference to the <style>. If you need to keep a reference to
   * the cell, you can override this method and store a local reference to
   * state.cell or the <CellState> itself. If <outline> should be true, make
   * sure to set it before calling this method.
   *
   * @param state <CellState> of the corresponding cell.
   */
  apply(state) {
    this.state = state;
    this.style = state.style;
    if (this.style) {
      this.fill = this.style.fillColor ?? this.fill;
      this.gradient = this.style.gradientColor ?? this.gradient;
      this.gradientDirection = this.style.gradientDirection ?? this.gradientDirection;
      this.opacity = this.style.opacity ?? this.opacity;
      this.fillOpacity = this.style.fillOpacity ?? this.fillOpacity;
      this.strokeOpacity = this.style.strokeOpacity ?? this.strokeOpacity;
      this.stroke = this.style.strokeColor ?? this.stroke;
      this.strokeWidth = this.style.strokeWidth ?? this.strokeWidth;
      this.spacing = this.style.spacing ?? this.spacing;
      this.startSize = this.style.startSize ?? this.startSize;
      this.endSize = this.style.endSize ?? this.endSize;
      this.startArrow = this.style.startArrow ?? this.startArrow;
      this.endArrow = this.style.endArrow ?? this.endArrow;
      this.rotation = this.style.rotation ?? this.rotation;
      this.direction = this.style.direction ?? this.direction;
      this.flipH = !!this.style.flipH;
      this.flipV = !!this.style.flipV;
      if (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH) {
        const tmp = this.flipH;
        this.flipH = this.flipV;
        this.flipV = tmp;
      }
      this.isShadow = this.style.shadow ?? this.isShadow;
      this.isDashed = this.style.dashed ?? this.isDashed;
      this.isRounded = this.style.rounded ?? this.isRounded;
      this.glass = this.style.glass ?? this.glass;
    }
  }
  /**
   * Sets the cursor on the given shape.
   *
   * @param cursor The cursor to be used.
   */
  setCursor(cursor) {
    this.cursor = cursor;
    this.node.style.cursor = cursor;
  }
  /**
   * Returns the current cursor.
   */
  getCursor() {
    return this.cursor;
  }
  /**
   * Hook for subclassers.
   */
  isRoundable(c, x, y, w, h) {
    return false;
  }
  /**
   * Updates the <boundingBox> for this shape using <createBoundingBox> and
   * <augmentBoundingBox> and stores the result in <boundingBox>.
   */
  updateBoundingBox() {
    if (this.useSvgBoundingBox && this.node.ownerSVGElement) {
      try {
        const b = this.node.getBBox();
        if (b.width > 0 && b.height > 0) {
          this.boundingBox = new Rectangle(b.x, b.y, b.width, b.height);
          this.boundingBox.grow((this.strokeWidth ?? 0) * this.scale / 2);
          return;
        }
      } catch (e) {
      }
    }
    if (this.bounds) {
      let bbox = this.createBoundingBox();
      if (bbox) {
        this.augmentBoundingBox(bbox);
        const rot = this.getShapeRotation();
        if (rot !== 0) {
          bbox = getBoundingBox(bbox, rot);
        }
      }
      this.boundingBox = bbox;
    }
  }
  /**
   * Returns a new rectangle that represents the bounding box of the bare shape
   * with no shadows or strokewidths.
   */
  createBoundingBox() {
    if (!this.bounds)
      return null;
    const bb = this.bounds.clone();
    if (this.stencil && (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH) || this.isPaintBoundsInverted()) {
      bb.rotate90();
    }
    return bb;
  }
  /**
   * Augments the bounding box with the strokewidth and shadow offsets.
   */
  augmentBoundingBox(bbox) {
    if (this.isShadow) {
      bbox.width += Math.ceil(StyleDefaultsConfig.shadowOffsetX * this.scale);
      bbox.height += Math.ceil(StyleDefaultsConfig.shadowOffsetX * this.scale);
    }
    bbox.grow((this.strokeWidth ?? 0) * this.scale / 2);
  }
  /**
   * Returns true if the bounds should be inverted.
   */
  isPaintBoundsInverted() {
    return !this.stencil && (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH);
  }
  /**
   * Returns the rotation from the style.
   */
  getRotation() {
    return this.rotation ?? 0;
  }
  /**
   * Returns the rotation for the text label.
   */
  getTextRotation() {
    var _a;
    let rot = this.getRotation();
    if (!(((_a = this.style) == null ? void 0 : _a.horizontal) ?? true)) {
      rot += this.verticalTextRotation || -90;
    }
    return rot;
  }
  /**
   * Returns the actual rotation of the shape.
   */
  getShapeRotation() {
    let rot = this.getRotation();
    if (this.direction === DIRECTION.NORTH) {
      rot += 270;
    } else if (this.direction === DIRECTION.WEST) {
      rot += 180;
    } else if (this.direction === DIRECTION.SOUTH) {
      rot += 90;
    }
    return rot;
  }
  /**
   * Adds a transparent rectangle that catches all events.
   */
  createTransparentSvgRectangle(x, y, w, h) {
    const rect = document.createElementNS(NS_SVG, "rect");
    rect.setAttribute("x", String(x));
    rect.setAttribute("y", String(y));
    rect.setAttribute("width", String(w));
    rect.setAttribute("height", String(h));
    rect.setAttribute("fill", NONE);
    rect.setAttribute("stroke", NONE);
    rect.setAttribute("pointer-events", "all");
    return rect;
  }
  redrawHtmlShape() {
    return;
  }
  /**
   * Sets a transparent background CSS style to catch all events.
   *
   * Paints the line shape.
   */
  setTransparentBackgroundImage(node) {
    node.style.backgroundImage = `url('${Client.imageBasePath}/transparent.gif')`;
  }
  /**
   * Paints the line shape.
   */
  releaseSvgGradients(grads) {
    for (const key in grads) {
      const gradient = grads[key];
      if (gradient) {
        gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;
        if (gradient.mxRefCount === 0 && gradient.parentNode) {
          gradient.parentNode.removeChild(gradient);
        }
      }
    }
  }
  /**
   * Destroys the shape by removing it from the DOM and releasing the DOM
   * node associated with the shape using {@link Event#release}.
   */
  destroy() {
    InternalEvent.release(this.node);
    if (this.node.parentNode) {
      this.node.parentNode.removeChild(this.node);
    }
    this.node.innerHTML = "";
    this.releaseSvgGradients(this.oldGradients);
    this.oldGradients = {};
  }
}
class RectangleShape extends Shape {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Returns true for non-rounded, non-rotated shapes with no glass gradient.
   */
  isHtmlAllowed() {
    let events = true;
    if (this.style && this.style.pointerEvents != null) {
      events = this.style.pointerEvents;
    }
    return !this.isRounded && !this.glass && this.rotation === 0 && (events || this.fill !== NONE);
  }
  /**
   * Generic background painting implementation.
   */
  paintBackground(c, x, y, w, h) {
    var _a, _b, _c;
    let events = true;
    if (this.style && this.style.pointerEvents != null) {
      events = this.style.pointerEvents;
    }
    if (events || this.fill !== NONE || this.stroke !== NONE) {
      if (!events && this.fill === NONE) {
        c.pointerEvents = false;
      }
      if (this.isRounded) {
        let r = 0;
        if (((_a = this.style) == null ? void 0 : _a.absoluteArcSize) ?? false) {
          r = Math.min(w / 2, Math.min(h / 2, (((_b = this.style) == null ? void 0 : _b.arcSize) ?? LINE_ARCSIZE) / 2));
        } else {
          const f = (((_c = this.style) == null ? void 0 : _c.arcSize) ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;
          r = Math.min(w * f, h * f);
        }
        c.roundrect(x, y, w, h, r, r);
      } else {
        c.rect(x, y, w, h);
      }
      c.fillAndStroke();
    }
  }
  /**
   * Adds roundable support.
   */
  isRoundable(c, x, y, w, h) {
    return true;
  }
  /**
   * Generic background painting implementation.
   */
  paintForeground(c, x, y, w, h) {
    if (this.glass && !this.outline && this.fill !== NONE) {
      this.paintGlassEffect(c, x, y, w, h, this.getArcSize(w + this.strokeWidth, h + this.strokeWidth));
    }
  }
}
class CellState extends Rectangle {
  /**
   * Constructs a new object that represents the current state of the given Cell in the specified view.
   *
   * @param view {@link GraphView} that contains the state.
   * @param cell {@link Cell} that this state represents.
   * @param style the style of the Cell.
   */
  constructor(view = null, cell = null, style = null) {
    super();
    this.node = null;
    this.cellBounds = null;
    this.paintBounds = null;
    this.boundingBox = null;
    this.control = null;
    this.overlays = new Dictionary();
    this.invalidStyle = false;
    this.invalid = true;
    this.absolutePoints = [];
    this.visibleSourceState = null;
    this.visibleTargetState = null;
    this.terminalDistance = 0;
    this.length = 0;
    this.segments = [];
    this.shape = null;
    this.text = null;
    this.unscaledWidth = 0;
    this.unscaledHeight = 0;
    this.parentHighlight = null;
    this.point = null;
    if (view) {
      this.view = view;
    }
    if (cell) {
      this.cell = cell;
    }
    this.style = style ?? {};
    this.origin = new Point();
    this.absoluteOffset = new Point();
  }
  /**
   * Returns the {@link Rectangle} that should be used as the perimeter of the cell.
   *
   * @param border Optional border to be added around the perimeter bounds.
   * @param bounds Optional {@link Rectangle} to be used as the initial bounds.
   */
  getPerimeterBounds(border = 0, bounds = new Rectangle(this.x, this.y, this.width, this.height)) {
    var _a, _b;
    if (((_b = (_a = this.shape) == null ? void 0 : _a.stencil) == null ? void 0 : _b.aspect) === "fixed") {
      const aspect = this.shape.stencil.computeAspect(this.shape, bounds.x, bounds.y, bounds.width, bounds.height);
      bounds.x = aspect.x;
      bounds.y = aspect.y;
      bounds.width = this.shape.stencil.w0 * aspect.width;
      bounds.height = this.shape.stencil.h0 * aspect.height;
    }
    if (border !== 0) {
      bounds.grow(border);
    }
    return bounds;
  }
  /**
   * Sets the first or last point in <absolutePoints> depending on isSource.
   *
   * @param point {@link Point} that represents the terminal point.
   * @param isSource Boolean that specifies if the first or last point should be assigned.
   */
  setAbsoluteTerminalPoint(point, isSource = false) {
    if (isSource) {
      if (this.absolutePoints.length === 0) {
        this.absolutePoints.push(point);
      } else {
        this.absolutePoints[0] = point;
      }
    } else if (this.absolutePoints.length === 0) {
      this.absolutePoints.push(null);
      this.absolutePoints.push(point);
    } else if (this.absolutePoints.length === 1) {
      this.absolutePoints.push(point);
    } else {
      this.absolutePoints[this.absolutePoints.length - 1] = point;
    }
  }
  /**
   * Sets the given cursor on the shape and text shape.
   */
  setCursor(cursor) {
    if (this.shape) {
      this.shape.setCursor(cursor);
    }
    if (this.text) {
      this.text.setCursor(cursor);
    }
  }
  /**
   * Returns the visible source or target terminal cell.
   *
   * @param source Boolean that specifies if the source or target cell should be returned.
   */
  getVisibleTerminal(source = false) {
    var _a;
    return ((_a = this.getVisibleTerminalState(source)) == null ? void 0 : _a.cell) ?? null;
  }
  /**
   * Returns the visible source or target terminal state.
   *
   * @param source Boolean that specifies if the source or target state should be returned.
   */
  getVisibleTerminalState(source = false) {
    return source ? this.visibleSourceState : this.visibleTargetState;
  }
  /**
   * Sets the visible source or target terminal state.
   *
   * @param terminalState {@link CellState} that represents the terminal.
   * @param source Boolean that specifies if the source or target state should be set.
   */
  setVisibleTerminalState(terminalState, source = false) {
    if (source) {
      this.visibleSourceState = terminalState;
    } else {
      this.visibleTargetState = terminalState;
    }
  }
  /**
   * Returns the unscaled, untranslated bounds.
   */
  getCellBounds() {
    return this.cellBounds;
  }
  /**
   * Returns the unscaled, untranslated paint bounds.
   *
   * This is the same as {@link getCellBounds} but with a 90-degrees rotation if the  {@link Shape.isPaintBoundsInverted} returns `true`.
   */
  getPaintBounds() {
    return this.paintBounds;
  }
  /**
   * Updates the {@link cellBounds} and {@link paintBounds}.
   */
  updateCachedBounds() {
    const view = this.view;
    const tr = view.translate;
    const s = view.scale;
    this.cellBounds = new Rectangle(this.x / s - tr.x, this.y / s - tr.y, this.width / s, this.height / s);
    this.paintBounds = Rectangle.fromRectangle(this.cellBounds);
    if (this.shape && this.shape.isPaintBoundsInverted()) {
      this.paintBounds.rotate90();
    }
  }
  /**
   * Copies all fields from the given state to this state.
   */
  setState(state) {
    this.view = state.view;
    this.cell = state.cell;
    this.style = state.style;
    this.absolutePoints = state.absolutePoints;
    this.origin = state.origin;
    this.absoluteOffset = state.absoluteOffset;
    this.boundingBox = state.boundingBox;
    this.terminalDistance = state.terminalDistance;
    this.segments = state.segments;
    this.length = state.length;
    this.x = state.x;
    this.y = state.y;
    this.width = state.width;
    this.height = state.height;
    this.unscaledWidth = state.unscaledWidth;
    this.unscaledHeight = state.unscaledHeight;
  }
  /**
   * Returns a clone of this {@link Point}.
   */
  clone() {
    const clone2 = new CellState(this.view, this.cell, this.style);
    for (let i = 0; i < this.absolutePoints.length; i += 1) {
      const p = this.absolutePoints[i];
      clone2.absolutePoints[i] = p ? p.clone() : null;
    }
    if (this.origin) {
      clone2.origin = this.origin.clone();
    }
    if (this.absoluteOffset) {
      clone2.absoluteOffset = this.absoluteOffset.clone();
    }
    if (this.boundingBox) {
      clone2.boundingBox = this.boundingBox.clone();
    }
    clone2.terminalDistance = this.terminalDistance;
    clone2.segments = this.segments;
    clone2.length = this.length;
    clone2.x = this.x;
    clone2.y = this.y;
    clone2.width = this.width;
    clone2.height = this.height;
    clone2.unscaledWidth = this.unscaledWidth;
    clone2.unscaledHeight = this.unscaledHeight;
    return clone2;
  }
  /**
   * Destroys the state and all associated resources.
   */
  destroy() {
    this.view.graph.cellRenderer.destroy(this);
  }
  /**
   * Returns `true` if the given cell state is a loop.
   *
   * @param state {@link CellState} that represents a potential loop.
   */
  isLoop(state) {
    const src = this.getVisibleTerminalState(true);
    return src && src === this.getVisibleTerminalState(false);
  }
  /*****************************************************************************
   * Group: Graph appearance
   *****************************************************************************/
  /**
   * Returns the vertical alignment for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.verticalAlign}
   * property of {@link style}.
   */
  getVerticalAlign() {
    return this.style.verticalAlign ?? ALIGN.MIDDLE;
  }
  /**
   * Returns `true` if the given state has no stroke, no fill color and no image.
   */
  isTransparentState() {
    return (this.style.strokeColor ?? NONE) === NONE && (this.style.fillColor ?? NONE) === NONE && !this.getImageSrc();
  }
  /**
   * Returns the image URL for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.image} property
   * of {@link style}.
   */
  getImageSrc() {
    return this.style.image || null;
  }
  /**
   * Returns the indicator color for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.indicatorColor}
   * property of {@link style}.
   */
  getIndicatorColor() {
    return this.style.indicatorColor || null;
  }
  /**
   * Returns the indicator gradient color for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.gradientColor}
   * property of {@link style}.
   */
  getIndicatorGradientColor() {
    return this.style.gradientColor || null;
  }
  /**
   * Returns the indicator shape for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.indicatorShape}
   * property of {@link style}.
   */
  getIndicatorShape() {
    return this.style.indicatorShape || null;
  }
  /**
   * Returns the indicator image for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.indicatorImage}
   * property of {@link style}.
   */
  getIndicatorImageSrc() {
    return this.style.indicatorImage || null;
  }
}
class UndoableEdit {
  constructor(source, significant = true) {
    this.changes = [];
    this.significant = true;
    this.undone = false;
    this.redone = false;
    this.source = source;
    this.changes = [];
    this.significant = significant;
  }
  /**
   * Returns true if the this edit contains no changes.
   */
  isEmpty() {
    return this.changes.length === 0;
  }
  /**
   * Returns <significant>.
   */
  isSignificant() {
    return this.significant;
  }
  /**
   * Adds the specified change to this edit. The change is an object that is
   * expected to either have an undo and redo, or an execute function.
   */
  add(change) {
    this.changes.push(change);
  }
  /**
   * Hook to notify any listeners of the changes after an <undo> or <redo>
   * has been carried out. This implementation is empty.
   */
  notify() {
    return;
  }
  /**
   * Hook to free resources after the edit has been removed from the command
   * history. This implementation is empty.
   */
  die() {
    return;
  }
  /**
   * Undoes all changes in this edit.
   */
  undo() {
    if (!this.undone) {
      this.source.fireEvent(new EventObject(InternalEvent.START_EDIT));
      const count = this.changes.length;
      for (let i = count - 1; i >= 0; i--) {
        const change = this.changes[i];
        if (change.execute) {
          change.execute();
        } else if (change.undo) {
          change.undo();
        }
        this.source.fireEvent(new EventObject(InternalEvent.EXECUTED, { change }));
      }
      this.undone = true;
      this.redone = false;
      this.source.fireEvent(new EventObject(InternalEvent.END_EDIT));
    }
    this.notify();
  }
  /**
   * Redoes all changes in this edit.
   */
  redo() {
    if (!this.redone) {
      this.source.fireEvent(new EventObject(InternalEvent.START_EDIT));
      const count = this.changes.length;
      for (let i = 0; i < count; i += 1) {
        const change = this.changes[i];
        if (change.execute != null) {
          change.execute();
        } else if (change.redo != null) {
          change.redo();
        }
        this.source.fireEvent(new EventObject(InternalEvent.EXECUTED, { change }));
      }
      this.undone = false;
      this.redone = true;
      this.source.fireEvent(new EventObject(InternalEvent.END_EDIT));
    }
    this.notify();
  }
}
class ImageShape extends RectangleShape {
  constructor(bounds, imageSrc, fill = "#FFFFFF", stroke = "#000000", strokeWidth = 1) {
    super(bounds, fill, stroke, strokeWidth);
    this.imageSrc = imageSrc;
    this.shadow = false;
    this.preserveImageAspect = true;
  }
  /**
   * Disables offset in IE9 for crisper image output.
   */
  getSvgScreenOffset() {
    return 0;
  }
  /**
   * Overrides to replace the fill and stroke colors with the respective values from {@link imageBackground} and {@link imageBorder}.
   *
   * Applies the style of the given {@link CellState} to the shape. This implementation assigns the following styles to local fields:
   *
   * - {@link imageBackground} => fill
   * - {@link imageBorder} => stroke
   *
   * @param {CellState} state   {@link CellState} of the corresponding cell.
   */
  apply(state) {
    super.apply(state);
    this.fill = NONE;
    this.stroke = NONE;
    this.gradient = NONE;
    if (this.style && this.style.imageAspect != null) {
      this.preserveImageAspect = this.style.imageAspect;
    }
  }
  /**
   * Returns true if HTML is allowed for this shape. This implementation always
   * returns false.
   */
  isHtmlAllowed() {
    return !this.preserveImageAspect;
  }
  /**
   * Disables inherited roundable support.
   */
  isRoundable(c, x, y, w, h) {
    return false;
  }
  /**
   * Generic background painting implementation.
   */
  paintVertexShape(c, x, y, w, h) {
    var _a, _b;
    if (this.imageSrc) {
      const fill = ((_a = this.style) == null ? void 0 : _a.imageBackground) ?? NONE;
      const stroke = ((_b = this.style) == null ? void 0 : _b.imageBorder) ?? NONE;
      if (fill !== NONE) {
        c.setFillColor(fill);
        c.setStrokeColor(stroke);
        c.rect(x, y, w, h);
        c.fillAndStroke();
      }
      c.image(x, y, w, h, this.imageSrc, this.preserveImageAspect, false, false);
      if (stroke !== NONE) {
        c.setShadow(false);
        c.setStrokeColor(stroke);
        c.rect(x, y, w, h);
        c.stroke();
      }
    } else {
      this.paintBackground(c, x, y, w, h);
    }
  }
}
class CurrentRootChange {
  constructor(view, root) {
    this.view = view;
    this.root = root;
    this.previous = root;
    this.isUp = root === null;
    if (!this.isUp) {
      let tmp = this.view.currentRoot;
      while (tmp) {
        if (tmp === root) {
          this.isUp = true;
          break;
        }
        tmp = tmp.getParent();
      }
    }
  }
  /**
   * Changes the current root of the view.
   */
  execute() {
    const tmp = this.view.currentRoot;
    this.view.currentRoot = this.previous;
    this.previous = tmp;
    const translate2 = this.view.graph.getTranslateForRoot(this.view.currentRoot);
    if (translate2) {
      this.view.translate = new Point(-translate2.x, -translate2.y);
    }
    if (this.isUp) {
      this.view.clear(this.view.currentRoot, true, true);
      this.view.validate(null);
    } else {
      this.view.refresh();
    }
    const name = this.isUp ? InternalEvent.UP : InternalEvent.DOWN;
    this.view.fireEvent(new EventObject(name, { root: this.view.currentRoot, previous: this.previous }));
    this.isUp = !this.isUp;
  }
}
class StyleRegistry {
  /**
   * Puts the given object into the registry under the given name.
   */
  static putValue(name, obj) {
    StyleRegistry.values[name] = obj;
  }
  /**
   * Returns the value associated with the given name.
   */
  static getValue(name) {
    return StyleRegistry.values[name];
  }
  /**
   * Returns the name for the given value.
   */
  static getName(value) {
    for (const key in StyleRegistry.values) {
      if (StyleRegistry.values[key] === value) {
        return key;
      }
    }
    return null;
  }
}
StyleRegistry.values = {};
function isI18nEnabled() {
  return GlobalConfig.i18n.isEnabled();
}
function translate(key, params, defaultValue) {
  return GlobalConfig.i18n.get(key, params, defaultValue);
}
class GraphView extends EventSource {
  constructor(graph) {
    super();
    this.backgroundImage = null;
    this.backgroundPageShape = null;
    this.EMPTY_POINT = new Point();
    this.doneResource = isI18nEnabled() ? "done" : "";
    this.updatingDocumentResource = isI18nEnabled() ? "updatingDocument" : "";
    this.allowEval = false;
    this.captureDocumentGesture = true;
    this.rendering = true;
    this.currentRoot = null;
    this.graphBounds = new Rectangle();
    this.scale = 1;
    this.translate = new Point();
    this.states = new Dictionary();
    this.updateStyle = false;
    this.lastNode = null;
    this.lastHtmlNode = null;
    this.lastForegroundNode = null;
    this.lastForegroundHtmlNode = null;
    this.endHandler = null;
    this.moveHandler = null;
    this.graph = graph;
  }
  /**
   * Returns {@link graphBounds}.
   */
  getGraphBounds() {
    return this.graphBounds;
  }
  /**
   * Sets {@link graphBounds}.
   */
  setGraphBounds(value) {
    this.graphBounds = value;
  }
  /**
   * Returns the {@link scale}.
   */
  getScale() {
    return this.scale;
  }
  /**
   * Sets the scale and fires a {@link scale} event before calling {@link revalidate} followed
   * by {@link Graph.sizeDidChange}.
   *
   * @param value Decimal value that specifies the new scale (1 is 100%).
   */
  setScale(value) {
    const previousScale = this.scale;
    if (previousScale !== value) {
      this.scale = value;
      if (this.isEventsEnabled()) {
        this.viewStateChanged();
      }
    }
    this.fireEvent(new EventObject(InternalEvent.SCALE, { scale: value, previousScale }));
  }
  /**
   * Returns the {@link translate}.
   */
  getTranslate() {
    return this.translate;
  }
  isRendering() {
    return this.rendering;
  }
  setRendering(value) {
    this.rendering = value;
  }
  /**
   * Sets the translation and fires a {@link translate} event before calling
   * {@link revalidate} followed by {@link Graph.sizeDidChange}. The translation is the
   * negative of the origin.
   *
   * @param dx X-coordinate of the translation.
   * @param dy Y-coordinate of the translation.
   */
  setTranslate(dx, dy) {
    const previousTranslate = new Point(this.translate.x, this.translate.y);
    if (this.translate.x !== dx || this.translate.y !== dy) {
      this.translate.x = dx;
      this.translate.y = dy;
      if (this.isEventsEnabled()) {
        this.viewStateChanged();
      }
    }
    this.fireEvent(new EventObject(InternalEvent.TRANSLATE, {
      translate: this.translate,
      previousTranslate
    }));
  }
  /**
   * Returns {@link allowEval}.
   */
  isAllowEval() {
    return this.allowEval;
  }
  /**
   * Sets {@link allowEval}.
   */
  setAllowEval(value) {
    this.allowEval = value;
  }
  /**
   * Returns {@link states}.
   */
  getStates() {
    return this.states;
  }
  /**
   * Sets {@link states}.
   */
  setStates(value) {
    this.states = value;
  }
  /**
   * Returns the DOM node that contains the background-, draw- and
   * overlay- and decoratorpanes.
   */
  getCanvas() {
    return this.canvas;
  }
  /**
   * Returns the DOM node that represents the background layer.
   */
  getBackgroundPane() {
    return this.backgroundPane;
  }
  /**
   * Returns the DOM node that represents the main drawing layer.
   */
  getDrawPane() {
    return this.drawPane;
  }
  /**
   * Returns the DOM node that represents the layer above the drawing layer.
   */
  getOverlayPane() {
    return this.overlayPane;
  }
  /**
   * Returns the DOM node that represents the topmost drawing layer.
   */
  getDecoratorPane() {
    return this.decoratorPane;
  }
  /**
   * Returns the union of all {@link mxCellStates} for the given array of {@link Cell}.
   *
   * @param cells Array of {@link Cell} whose bounds should be returned.
   */
  getBounds(cells) {
    let result = null;
    if (cells.length > 0) {
      for (let i = 0; i < cells.length; i += 1) {
        if (cells[i].isVertex() || cells[i].isEdge()) {
          const state = this.getState(cells[i]);
          if (state) {
            if (!result) {
              result = Rectangle.fromRectangle(state);
            } else {
              result.add(state);
            }
          }
        }
      }
    }
    return result;
  }
  /**
   * Sets and returns the current root and fires an {@link undo} event before
   * calling {@link graph.sizeDidChange}.
   *
   * @param root {@link mxCell} that specifies the root of the displayed cell hierarchy.
   */
  setCurrentRoot(root) {
    if (this.currentRoot !== root) {
      const change = new CurrentRootChange(this, root);
      change.execute();
      const edit = new UndoableEdit(this, true);
      edit.add(change);
      this.fireEvent(new EventObject(InternalEvent.UNDO, { edit }));
      this.graph.sizeDidChange();
      this.currentRoot = root;
    }
    return root;
  }
  /**
   * Sets the scale and translation and fires a {@link scale} and {@link translate} event
   * before calling {@link revalidate} followed by {@link graph.sizeDidChange}.
   *
   * @param scale Decimal value that specifies the new scale (1 is 100%).
   * @param dx X-coordinate of the translation.
   * @param dy Y-coordinate of the translation.
   */
  scaleAndTranslate(scale, dx, dy) {
    const previousScale = this.scale;
    const previousTranslate = new Point(this.translate.x, this.translate.y);
    if (this.scale !== scale || this.translate.x !== dx || this.translate.y !== dy) {
      this.scale = scale;
      this.translate.x = dx;
      this.translate.y = dy;
      if (this.isEventsEnabled()) {
        this.viewStateChanged();
      }
    }
    this.fireEvent(new EventObject(InternalEvent.SCALE_AND_TRANSLATE, {
      scale,
      previousScale,
      translate: this.translate,
      previousTranslate
    }));
  }
  /**
   * Invoked after {@link scale} and/or {@link translate} has changed.
   */
  viewStateChanged() {
    this.revalidate();
    this.graph.sizeDidChange();
  }
  /**
   * Clears the view if {@link currentRoot} is not null and revalidates.
   */
  refresh() {
    if (this.currentRoot) {
      this.clear();
    }
    this.revalidate();
  }
  /**
   * Revalidates the complete view with all cell states.
   */
  revalidate() {
    this.invalidate();
    this.validate();
  }
  /**
   * Removes the state of the given cell and all descendants if the given
   * cell is not the current root.
   *
   * @param cell Optional {@link Cell} for which the state should be removed. Default
   * is the root of the model.
   * @param force Boolean indicating if the current root should be ignored for
   * recursion.
   */
  clear(cell, force = false, recurse = true) {
    if (!cell) {
      cell = this.graph.getDataModel().getRoot();
    }
    if (cell) {
      this.removeState(cell);
      if (recurse && (force || cell !== this.currentRoot)) {
        const childCount = cell.getChildCount();
        for (let i = 0; i < childCount; i += 1) {
          this.clear(cell.getChildAt(i), force);
        }
      } else {
        this.invalidate(cell);
      }
    }
  }
  /**
   * Invalidates the state of the given cell, all its descendants and
   * connected edges.
   *
   * @param cell Optional {@link Cell} to be invalidated. Default is the root of the
   * model.
   */
  invalidate(cell = null, recurse = true, includeEdges = true) {
    const model = this.graph.getDataModel();
    cell = cell ?? model.getRoot();
    if (cell) {
      const state = this.getState(cell);
      if (state) {
        state.invalid = true;
      }
      if (!cell.invalidating) {
        cell.invalidating = true;
        if (recurse) {
          const childCount = cell.getChildCount();
          for (let i = 0; i < childCount; i += 1) {
            const child = cell.getChildAt(i);
            this.invalidate(child, recurse, includeEdges);
          }
        }
        if (includeEdges) {
          const edgeCount = cell.getEdgeCount();
          for (let i = 0; i < edgeCount; i += 1) {
            this.invalidate(cell.getEdgeAt(i), recurse, includeEdges);
          }
        }
        cell.invalidating = false;
      }
    }
  }
  /**
   * Calls {@link validateCell} and {@link validateCellState} and updates the {@link graphBounds}
   * using {@link getBoundingBox}. Finally the background is validated using
   * {@link validateBackground}.
   *
   * @param cell Optional {@link Cell} to be used as the root of the validation.
   * Default is {@link currentRoot} or the root of the model.
   */
  validate(cell = null) {
    const t0 = GlobalConfig.logger.enter("GraphView.validate");
    this.resetValidationState();
    const c = cell || (this.currentRoot ?? this.graph.getDataModel().getRoot());
    if (c) {
      const graphBounds = this.getBoundingBox(this.validateCellState(c ? this.validateCell(c) : null));
      this.setGraphBounds(graphBounds ?? this.getEmptyBounds());
      this.validateBackground();
      this.resetValidationState();
    }
    GlobalConfig.logger.leave("GraphView.validate", t0);
  }
  /**
   * Returns the bounds for an empty graph. This returns a rectangle at
   * {@link translate} with the size of 0 x 0.
   */
  getEmptyBounds() {
    return new Rectangle(this.translate.x * this.scale, this.translate.y * this.scale);
  }
  /**
   * Returns the bounding box of the shape and the label for the given
   * {@link CellState} and its children if recurse is true.
   *
   * @param state {@link CellState} whose bounding box should be returned.
   * @param recurse Optional boolean indicating if the children should be included.
   * Default is true.
   */
  getBoundingBox(state = null, recurse = true) {
    let bbox = null;
    if (state) {
      if (state.shape && state.shape.boundingBox) {
        bbox = state.shape.boundingBox.clone();
      }
      if (state.text && state.text.boundingBox) {
        if (bbox) {
          bbox.add(state.text.boundingBox);
        } else {
          bbox = state.text.boundingBox.clone();
        }
      }
      if (recurse) {
        const childCount = state.cell.getChildCount();
        for (let i = 0; i < childCount; i += 1) {
          const bounds = this.getBoundingBox(this.getState(state.cell.getChildAt(i)));
          if (bounds) {
            if (!bbox) {
              bbox = bounds;
            } else {
              bbox.add(bounds);
            }
          }
        }
      }
    }
    return bbox;
  }
  /**
   * Creates and returns the shape used as the background page.
   *
   * @param bounds {@link mxRectangle} that represents the bounds of the shape.
   */
  createBackgroundPageShape(bounds) {
    return new RectangleShape(bounds, "white", "black");
  }
  /**
   * Calls {@link validateBackgroundImage} and {@link validateBackgroundPage}.
   */
  validateBackground() {
    this.validateBackgroundImage();
    this.validateBackgroundPage();
  }
  /**
   * Validates the background image.
   */
  validateBackgroundImage() {
    const bg = this.graph.getBackgroundImage();
    if (bg) {
      if (!this.backgroundImage || this.backgroundImage.imageSrc !== bg.src) {
        if (this.backgroundImage) {
          this.backgroundImage.destroy();
        }
        const bounds = new Rectangle(0, 0, 1, 1);
        this.backgroundImage = new ImageShape(bounds, bg.src);
        this.backgroundImage.dialect = this.graph.dialect;
        this.backgroundImage.init(this.backgroundPane);
        this.backgroundImage.redraw();
      }
      this.redrawBackgroundImage(this.backgroundImage, bg);
    } else if (this.backgroundImage) {
      this.backgroundImage.destroy();
      this.backgroundImage = null;
    }
  }
  /**
   * Validates the background page.
   */
  validateBackgroundPage() {
    const graph = this.graph;
    if (graph.pageVisible) {
      const bounds = this.getBackgroundPageBounds();
      if (this.backgroundPageShape == null) {
        this.backgroundPageShape = this.createBackgroundPageShape(bounds);
        this.backgroundPageShape.scale = this.scale;
        this.backgroundPageShape.isShadow = true;
        this.backgroundPageShape.dialect = this.graph.dialect;
        this.backgroundPageShape.init(this.backgroundPane);
        this.backgroundPageShape.redraw();
        if (this.backgroundPageShape.node) {
          if (graph.isNativeDblClickEnabled()) {
            InternalEvent.addListener(this.backgroundPageShape.node, "dblclick", (evt) => {
              graph.dblClick(evt);
            });
          }
          InternalEvent.addGestureListeners(this.backgroundPageShape.node, (evt) => {
            graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));
          }, (evt) => {
            const tooltipHandler = graph.getPlugin("TooltipHandler");
            if (tooltipHandler && tooltipHandler.isHideOnHover()) {
              tooltipHandler.hide();
            }
            if (graph.isMouseDown && !isConsumed(evt)) {
              graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt));
            }
          }, (evt) => {
            graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));
          });
        }
      } else {
        this.backgroundPageShape.scale = this.scale;
        this.backgroundPageShape.bounds = bounds;
        this.backgroundPageShape.redraw();
      }
    } else if (this.backgroundPageShape) {
      this.backgroundPageShape.destroy();
      this.backgroundPageShape = null;
    }
  }
  /**
   * Returns the bounds for the background page.
   */
  getBackgroundPageBounds() {
    const fmt = this.graph.pageFormat;
    const ps = this.scale * this.graph.pageScale;
    return new Rectangle(this.scale * this.translate.x, this.scale * this.translate.y, fmt.width * ps, fmt.height * ps);
  }
  /**
   * Updates the bounds and redraws the background image.
   *
   * Example:
   *
   * If the background image should not be scaled, this can be replaced with
   * the following.
   *
   * @example
   * ```javascript
   * redrawBackground(backgroundImage, bg)
   * {
   *   backgroundImage.bounds.x = this.translate.x;
   *   backgroundImage.bounds.y = this.translate.y;
   *   backgroundImage.bounds.width = bg.width;
   *   backgroundImage.bounds.height = bg.height;
   *
   *   backgroundImage.redraw();
   * };
   * ```
   *
   * @param backgroundImage {@link mxImageShape} that represents the background image.
   * @param bg {@link mxImage} that specifies the image and its dimensions.
   */
  redrawBackgroundImage(backgroundImage, bg) {
    backgroundImage.scale = this.scale;
    if (backgroundImage.bounds) {
      const bounds = backgroundImage.bounds;
      bounds.x = this.scale * this.translate.x;
      bounds.y = this.scale * this.translate.y;
      bounds.width = this.scale * bg.width;
      bounds.height = this.scale * bg.height;
    }
    backgroundImage.redraw();
  }
  /**
   * Recursively creates the cell state for the given cell if visible is true and
   * the given cell is visible. If the cell is not visible but the state exists
   * then it is removed using {@link removeState}.
   *
   * @param cell {@link mxCell} whose {@link CellState} should be created.
   * @param visible Optional boolean indicating if the cell should be visible. Default
   * is true.
   */
  validateCell(cell, visible = true) {
    visible = visible && cell.isVisible();
    const state = this.getState(cell, visible);
    if (state && !visible) {
      this.removeState(cell);
    } else {
      const childCount = cell.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        this.validateCell(cell.getChildAt(i), visible && (!cell.isCollapsed() || cell === this.currentRoot));
      }
    }
    return cell;
  }
  /**
   * Validates and repaints the {@link CellState} for the given {@link Cell}.
   *
   * @param cell {@link mxCell} whose {@link CellState} should be validated.
   * @param recurse Optional boolean indicating if the children of the cell should be
   * validated. Default is true.
   */
  validateCellState(cell, recurse = true) {
    let state = null;
    if (cell) {
      state = this.getState(cell);
      if (state) {
        if (state.invalid) {
          state.invalid = false;
          if (!state.style || state.invalidStyle) {
            state.style = this.graph.getCellStyle(state.cell);
            state.invalidStyle = false;
          }
          if (cell !== this.currentRoot) {
            this.validateCellState(cell.getParent(), false);
          }
          state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, true), false), true);
          state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, false), false), false);
          this.updateCellState(state);
          if (cell !== this.currentRoot && !state.invalid) {
            this.graph.cellRenderer.redraw(state, false, this.isRendering());
            state.updateCachedBounds();
          }
        }
        if (recurse && !state.invalid) {
          if (state.shape) {
            this.stateValidated(state);
          }
          const childCount = cell.getChildCount();
          for (let i = 0; i < childCount; i += 1) {
            this.validateCellState(cell.getChildAt(i));
          }
        }
      }
    }
    return state;
  }
  /**
   * Updates the given {@link CellState}.
   *
   * @param state {@link CellState} to be updated.
   */
  updateCellState(state) {
    const absoluteOffset = state.absoluteOffset;
    const origin = state.origin;
    absoluteOffset.x = 0;
    absoluteOffset.y = 0;
    origin.x = 0;
    origin.y = 0;
    state.length = 0;
    if (state.cell !== this.currentRoot) {
      const parent = state.cell.getParent();
      const pState = parent ? this.getState(parent) : null;
      if (pState && pState.cell !== this.currentRoot) {
        origin.x += pState.origin.x;
        origin.y += pState.origin.y;
      }
      let offset = this.graph.getChildOffsetForCell(state.cell);
      if (offset) {
        origin.x += offset.x;
        origin.y += offset.y;
      }
      const geo = state.cell.getGeometry();
      if (geo) {
        if (!state.cell.isEdge()) {
          offset = geo.offset ? geo.offset : this.EMPTY_POINT;
          if (geo.relative && pState) {
            if (pState.cell.isEdge()) {
              const point = this.getPoint(pState, geo);
              if (point) {
                origin.x += point.x / this.scale - pState.origin.x - this.translate.x;
                origin.y += point.y / this.scale - pState.origin.y - this.translate.y;
              }
            } else {
              origin.x += geo.x * pState.unscaledWidth + offset.x;
              origin.y += geo.y * pState.unscaledHeight + offset.y;
            }
          } else {
            absoluteOffset.x = this.scale * offset.x;
            absoluteOffset.y = this.scale * offset.y;
            origin.x += geo.x;
            origin.y += geo.y;
          }
        }
        state.x = this.scale * (this.translate.x + origin.x);
        state.y = this.scale * (this.translate.y + origin.y);
        state.width = this.scale * geo.width;
        state.unscaledWidth = geo.width;
        state.height = this.scale * geo.height;
        state.unscaledHeight = geo.height;
        if (state.cell.isVertex()) {
          this.updateVertexState(state, geo);
        }
        if (state.cell.isEdge()) {
          this.updateEdgeState(state, geo);
        }
      }
    }
    state.updateCachedBounds();
  }
  /**
   * Validates the given cell state.
   */
  updateVertexState(state, geo) {
    const parent = state.cell.getParent();
    const pState = parent ? this.getState(parent) : null;
    if (geo.relative && pState && !pState.cell.isEdge()) {
      const alpha = toRadians(pState.style.rotation ?? 0);
      if (alpha !== 0) {
        const cos = Math.cos(alpha);
        const sin = Math.sin(alpha);
        const ct = new Point(state.getCenterX(), state.getCenterY());
        const cx = new Point(pState.getCenterX(), pState.getCenterY());
        const pt = getRotatedPoint(ct, cos, sin, cx);
        state.x = pt.x - state.width / 2;
        state.y = pt.y - state.height / 2;
      }
    }
    this.updateVertexLabelOffset(state);
  }
  /**
   * Validates the given cell state.
   */
  updateEdgeState(state, geo) {
    const source = state.getVisibleTerminalState(true);
    const target = state.getVisibleTerminalState(false);
    if (state.cell.getTerminal(true) && !source || !source && !geo.getTerminalPoint(true) || state.cell.getTerminal(false) && !target || !target && !geo.getTerminalPoint(false)) {
      this.clear(state.cell, true);
    } else {
      this.updateFixedTerminalPoints(state, source, target);
      this.updatePoints(state, geo.points, source, target);
      this.updateFloatingTerminalPoints(state, source, target);
      const pts = state.absolutePoints;
      if (state.cell !== this.currentRoot && (pts == null || pts.length < 2 || pts[0] == null || pts[pts.length - 1] == null)) {
        this.clear(state.cell, true);
      } else {
        this.updateEdgeBounds(state);
        this.updateEdgeLabelOffset(state);
      }
    }
  }
  /**
   * Updates the absoluteOffset of the given vertex cell state. This takes
   * into account the label position styles.
   *
   * @param state {@link CellState} whose absolute offset should be updated.
   */
  updateVertexLabelOffset(state) {
    const h = state.style.labelPosition ?? ALIGN.CENTER;
    if (h === ALIGN.LEFT) {
      let lw = state.style.labelWidth ?? null;
      if (lw != null) {
        lw *= this.scale;
      } else {
        lw = state.width;
      }
      state.absoluteOffset.x -= lw;
    } else if (h === ALIGN.RIGHT) {
      state.absoluteOffset.x += state.width;
    } else if (h === ALIGN.CENTER) {
      const lw = state.style.labelWidth ?? null;
      if (lw != null) {
        const align = state.style.align ?? ALIGN.CENTER;
        let dx = 0;
        if (align === ALIGN.CENTER) {
          dx = 0.5;
        } else if (align === ALIGN.RIGHT) {
          dx = 1;
        }
        if (dx !== 0) {
          state.absoluteOffset.x -= (lw * this.scale - state.width) * dx;
        }
      }
    }
    const v = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;
    if (v === ALIGN.TOP) {
      state.absoluteOffset.y -= state.height;
    } else if (v === ALIGN.BOTTOM) {
      state.absoluteOffset.y += state.height;
    }
  }
  /**
   * Resets the current validation state.
   */
  resetValidationState() {
    this.lastNode = null;
    this.lastHtmlNode = null;
    this.lastForegroundNode = null;
    this.lastForegroundHtmlNode = null;
  }
  /**
   * Invoked when a state has been processed in {@link validatePoints}. This is used
   * to update the order of the DOM nodes of the shape.
   *
   * @param state {@link CellState} that represents the cell state.
   */
  stateValidated(state) {
    const graph = this.graph;
    const fg = state.cell.isEdge() && graph.keepEdgesInForeground || state.cell.isVertex() && graph.keepEdgesInBackground;
    const htmlNode = fg ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode;
    const node = fg ? this.lastForegroundNode || this.lastNode : this.lastNode;
    const result = graph.cellRenderer.insertStateAfter(state, node, htmlNode);
    if (fg) {
      this.lastForegroundHtmlNode = result[1];
      this.lastForegroundNode = result[0];
    } else {
      this.lastHtmlNode = result[1];
      this.lastNode = result[0];
    }
  }
  /**
   * Sets the initial absolute terminal points in the given state before the edge
   * style is computed.
   *
   * @param edge {@link CellState} whose initial terminal points should be updated.
   * @param source {@link CellState} which represents the source terminal.
   * @param target {@link CellState} which represents the target terminal.
   */
  updateFixedTerminalPoints(edge, source, target) {
    this.updateFixedTerminalPoint(edge, source, true, this.graph.getConnectionConstraint(edge, source, true));
    this.updateFixedTerminalPoint(edge, target, false, this.graph.getConnectionConstraint(edge, target, false));
  }
  /**
   * Sets the fixed source or target terminal point on the given edge.
   *
   * @param edge <CellState> whose terminal point should be updated.
   * @param terminal <CellState> which represents the actual terminal.
   * @param source Boolean that specifies if the terminal is the source.
   * @param constraint {@link ConnectionConstraint} that specifies the connection.
   */
  updateFixedTerminalPoint(edge, terminal, source, constraint) {
    edge.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge, terminal, source, constraint), source);
  }
  /**
   * Returns the fixed source or target terminal point for the given edge.
   *
   * @param edge <CellState> whose terminal point should be returned.
   * @param terminal <CellState> which represents the actual terminal.
   * @param source Boolean that specifies if the terminal is the source.
   * @param constraint {@link ConnectionConstraint} that specifies the connection.
   */
  getFixedTerminalPoint(edge, terminal, source, constraint) {
    let pt = null;
    if (constraint && terminal) {
      pt = this.graph.getConnectionPoint(terminal, constraint, false);
    }
    if (!pt && !terminal) {
      const s = this.scale;
      const tr = this.translate;
      const orig = edge.origin;
      const geo = edge.cell.getGeometry();
      pt = geo.getTerminalPoint(source);
      if (pt) {
        pt = new Point(s * (tr.x + pt.x + orig.x), s * (tr.y + pt.y + orig.y));
      }
    }
    return pt;
  }
  /**
   * Updates the bounds of the given cell state to reflect the bounds of the stencil
   * if it has a fixed aspect and returns the previous bounds as an {@link Rectangle} if
   * the bounds have been modified or null otherwise.
   *
   * @param edge {@link CellState} whose bounds should be updated.
   */
  updateBoundsFromStencil(state) {
    let previous = null;
    if (state && state.shape && state.shape.stencil && state.shape.stencil.aspect === "fixed") {
      previous = Rectangle.fromRectangle(state);
      const asp = state.shape.stencil.computeAspect(
        null,
        // this argument is not used
        state.x,
        state.y,
        state.width,
        state.height
      );
      state.setRect(asp.x, asp.y, state.shape.stencil.w0 * asp.width, state.shape.stencil.h0 * asp.height);
    }
    return previous;
  }
  /**
   * Updates the absolute points in the given state using the specified array
   * of {@link Point} as the relative points.
   *
   * @param edge {@link CellState} whose absolute points should be updated.
   * @param points Array of {@link Point} that constitute the relative points.
   * @param source {@link CellState} that represents the source terminal.
   * @param target {@link CellState} that represents the target terminal.
   */
  updatePoints(edge, points, source, target) {
    const pts = [];
    pts.push(edge.absolutePoints[0]);
    const edgeStyle = this.getEdgeStyle(edge, points, source, target);
    if (edgeStyle && source) {
      const src = this.getTerminalPort(edge, source, true);
      const trg = target ? this.getTerminalPort(edge, target, false) : null;
      const srcBounds = this.updateBoundsFromStencil(src);
      const trgBounds = this.updateBoundsFromStencil(trg);
      edgeStyle(edge, src, trg, points, pts);
      if (src && srcBounds) {
        src.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);
      }
      if (trg && trgBounds) {
        trg.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);
      }
    } else if (points) {
      for (let i = 0; i < points.length; i += 1) {
        if (points[i]) {
          const pt = clone(points[i]);
          pts.push(this.transformControlPoint(edge, pt));
        }
      }
    }
    const tmp = edge.absolutePoints;
    pts.push(tmp[tmp.length - 1]);
    edge.absolutePoints = pts;
  }
  /**
   * Transforms the given control point to an absolute point.
   */
  transformControlPoint(state, pt, ignoreScale = false) {
    if (state && pt) {
      const orig = state.origin;
      const scale = ignoreScale ? 1 : this.scale;
      return new Point(scale * (pt.x + this.translate.x + orig.x), scale * (pt.y + this.translate.y + orig.y));
    }
    return null;
  }
  /**
   * Returns `true` if the given edge should be routed with {@link graph.defaultLoopStyle}
   * or the {@link CellStateStyle.orthogonalLoop} defined for the given edge.
   * This implementation returns `true` if the given edge is a loop and does not
   */
  isLoopStyleEnabled(edge, points = [], source = null, target = null) {
    const sc = this.graph.getConnectionConstraint(edge, source, true);
    const tc = this.graph.getConnectionConstraint(edge, target, false);
    if ((points == null || points.length < 2) && !((edge.style.orthogonalLoop ?? false) || (sc == null || sc.point == null) && (tc == null || tc.point == null))) {
      return source != null && source === target;
    }
    return false;
  }
  /**
   * Returns the edge style function to be used to render the given edge state.
   */
  getEdgeStyle(edge, points = [], source = null, target = null) {
    let edgeStyle = this.isLoopStyleEnabled(edge, points, source, target) ? edge.style.loopStyle ?? this.graph.defaultLoopStyle : !(edge.style.noEdgeStyle ?? false) ? edge.style.edgeStyle : null;
    if (typeof edgeStyle === "string") {
      let tmp = StyleRegistry.getValue(edgeStyle);
      if (!tmp && this.isAllowEval()) {
        tmp = doEval(edgeStyle);
      }
      edgeStyle = tmp;
    }
    if (typeof edgeStyle === "function") {
      return edgeStyle;
    }
    return null;
  }
  /**
   * Updates the terminal points in the given state after the edge style was
   * computed for the edge.
   *
   * @param state {@link CellState} whose terminal points should be updated.
   * @param source {@link CellState} that represents the source terminal.
   * @param target {@link CellState} that represents the target terminal.
   */
  updateFloatingTerminalPoints(state, source, target) {
    const pts = state.absolutePoints;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    if (!pe && target) {
      this.updateFloatingTerminalPoint(state, target, source, false);
    }
    if (!p0 && source) {
      this.updateFloatingTerminalPoint(state, source, target, true);
    }
  }
  /**
   * Updates the absolute terminal point in the given state for the given
   * start and end state, where start is the source if source is true.
   *
   * @param edge {@link CellState} whose terminal point should be updated.
   * @param start {@link CellState} for the terminal on "this" side of the edge.
   * @param end {@link CellState} for the terminal on the other side of the edge.
   * @param source Boolean indicating if start is the source terminal state.
   */
  updateFloatingTerminalPoint(edge, start, end, source) {
    edge.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source);
  }
  /**
   * Returns the floating terminal point for the given edge, start and end
   * state, where start is the source if source is true.
   *
   * @param edge {@link CellState} whose terminal point should be returned.
   * @param start {@link CellState} for the terminal on "this" side of the edge.
   * @param end {@link CellState} for the terminal on the other side of the edge.
   * @param source Boolean indicating if start is the source terminal state.
   */
  getFloatingTerminalPoint(edge, start, end, source) {
    start = this.getTerminalPort(edge, start, source);
    let next = this.getNextPoint(edge, end, source);
    const orth = this.graph.isOrthogonal(edge);
    const alpha = toRadians(start.style.rotation ?? 0);
    const center = new Point(start.getCenterX(), start.getCenterY());
    if (alpha !== 0) {
      const cos = Math.cos(-alpha);
      const sin = Math.sin(-alpha);
      next = getRotatedPoint(next, cos, sin, center);
    }
    let border = edge.style.perimeterSpacing ?? 0;
    border += edge.style[source ? "sourcePerimeterSpacing" : "targetPerimeterSpacing"] ?? 0;
    let pt = this.getPerimeterPoint(start, next, alpha === 0 && orth, border);
    if (pt && alpha !== 0) {
      const cos = Math.cos(alpha);
      const sin = Math.sin(alpha);
      pt = getRotatedPoint(pt, cos, sin, center);
    }
    return pt;
  }
  /**
   * Returns an {@link CellState} that represents the source or target terminal or
   * port for the given edge.
   *
   * @param state {@link CellState} that represents the state of the edge.
   * @param terminal {@link CellState} that represents the terminal.
   * @param source Boolean indicating if the given terminal is the source terminal.
   */
  getTerminalPort(state, terminal, source = false) {
    const key = source ? "sourcePort" : "targetPort";
    const id = state.style[key];
    if (id) {
      const cell = this.graph.getDataModel().getCell(id);
      if (cell) {
        const tmp = this.getState(cell, false);
        if (tmp) {
          terminal = tmp;
        }
      }
    }
    return terminal;
  }
  /**
   * Returns an {@link Point} that defines the location of the intersection point between
   * the perimeter and the line between the center of the shape and the given point.
   *
   * @param terminal {@link CellState} for the source or target terminal.
   * @param next {@link Point} that lies outside the given terminal.
   * @param orthogonal Boolean that specifies if the orthogonal projection onto
   * the perimeter should be returned. If this is false then the intersection
   * of the perimeter and the line between the next and the center point is
   * returned.
   * @param border Optional border between the perimeter and the shape.
   */
  getPerimeterPoint(terminal, next, orthogonal, border = 0) {
    let point = null;
    if (terminal != null) {
      const perimeter = this.getPerimeterFunction(terminal);
      if (perimeter != null && next != null) {
        const bounds = this.getPerimeterBounds(terminal, border);
        if (bounds.width > 0 || bounds.height > 0) {
          point = new Point(next.x, next.y);
          let flipH = false;
          let flipV = false;
          if (terminal.cell.isVertex()) {
            flipH = !!terminal.style.flipH;
            flipV = !!terminal.style.flipV;
            if (flipH) {
              point.x = 2 * bounds.getCenterX() - point.x;
            }
            if (flipV) {
              point.y = 2 * bounds.getCenterY() - point.y;
            }
          }
          point = perimeter(bounds, terminal, point, orthogonal);
          if (point != null) {
            if (flipH) {
              point.x = 2 * bounds.getCenterX() - point.x;
            }
            if (flipV) {
              point.y = 2 * bounds.getCenterY() - point.y;
            }
          }
        }
      }
      if (point == null) {
        point = this.getPoint(terminal);
      }
    }
    return point;
  }
  /**
   * Returns the x-coordinate of the center point for automatic routing.
   */
  getRoutingCenterX(state) {
    const f = state.style ? state.style.routingCenterX ?? 0 : 0;
    return state.getCenterX() + f * state.width;
  }
  /**
   * Returns the y-coordinate of the center point for automatic routing.
   */
  getRoutingCenterY(state) {
    const f = state.style ? state.style.routingCenterY ?? 0 : 0;
    return state.getCenterY() + f * state.height;
  }
  /**
   * Returns the perimeter bounds for the given terminal, edge pair as an
   * {@link Rectangle}.
   *
   * If you have a model where each terminal has a relative child that should
   * act as the graphical endpoint for a connection from/to the terminal, then
   * this method can be replaced as follows:
   *
   * @example
   * ```javascript
   * var oldGetPerimeterBounds = getPerimeterBounds;
   * getPerimeterBounds(terminal, edge, isSource)
   * {
   *   var model = this.graph.getDataModel();
   *   var childCount = model.getChildCount(terminal.cell);
   *
   *   if (childCount > 0)
   *   {
   *     var child = model.getChildAt(terminal.cell, 0);
   *     var geo = model.getGeometry(child);
   *
   *     if (geo != null &&
   *         geo.relative)
   *     {
   *       var state = this.getState(child);
   *
   *       if (state != null)
   *       {
   *         terminal = state;
   *       }
   *     }
   *   }
   *
   *   return oldGetPerimeterBounds.apply(this, arguments);
   * };
   * ```
   *
   * @param terminal CellState that represents the terminal.
   * @param border Number that adds a border between the shape and the perimeter.
   */
  getPerimeterBounds(terminal, border = 0) {
    border += terminal.style.perimeterSpacing ?? 0;
    return terminal.getPerimeterBounds(border * this.scale);
  }
  /**
   * Returns the perimeter function for the given state.
   */
  getPerimeterFunction(state) {
    let perimeter = state.style.perimeter;
    if (typeof perimeter === "string") {
      let tmp = StyleRegistry.getValue(perimeter);
      if (tmp == null && this.isAllowEval()) {
        tmp = doEval(perimeter);
      }
      perimeter = tmp;
    }
    if (typeof perimeter === "function") {
      return perimeter;
    }
    return null;
  }
  /**
   * Returns the nearest point in the list of absolute points or the center
   * of the opposite terminal.
   *
   * @param edge {@link CellState} that represents the edge.
   * @param opposite {@link CellState} that represents the opposite terminal.
   * @param source Boolean indicating if the next point for the source or target
   * should be returned.
   */
  getNextPoint(edge, opposite, source = false) {
    const pts = edge.absolutePoints;
    let point = null;
    if (pts.length >= 2) {
      const count = pts.length;
      point = pts[source ? Math.min(1, count - 1) : Math.max(0, count - 2)];
    }
    if (!point && opposite) {
      point = new Point(opposite.getCenterX(), opposite.getCenterY());
    }
    return point;
  }
  /**
   * Returns the nearest ancestor terminal that is visible. The edge appears
   * to be connected to this terminal on the display. The result of this method
   * is cached in {@link CellState.getVisibleTerminalState}.
   *
   * @param edge {@link mxCell} whose visible terminal should be returned.
   * @param source Boolean that specifies if the source or target terminal
   * should be returned.
   */
  getVisibleTerminal(edge, source) {
    const model = this.graph.getDataModel();
    let result = edge.getTerminal(source);
    let best = result;
    while (result && result !== this.currentRoot) {
      if (best && !best.isVisible() || result.isCollapsed()) {
        best = result;
      }
      result = result.getParent();
    }
    if (best && (!model.contains(best) || best.getParent() === model.getRoot() || best === this.currentRoot)) {
      best = null;
    }
    return best;
  }
  /**
   * Updates the given state using the bounding box of t
   * he absolute points.
   * Also updates {@link CellState.terminalDistance}, {@link CellState.length} and
   * {@link CellState.segments}.
   *
   * @param state {@link CellState} whose bounds should be updated.
   */
  updateEdgeBounds(state) {
    const points = state.absolutePoints;
    const p0 = points[0];
    const pe = points[points.length - 1];
    if (p0 && pe && (p0.x !== pe.x || p0.y !== pe.y)) {
      const dx = pe.x - p0.x;
      const dy = pe.y - p0.y;
      state.terminalDistance = Math.sqrt(dx * dx + dy * dy);
    } else {
      state.terminalDistance = 0;
    }
    let length = 0;
    const segments = [];
    let pt = p0;
    if (pt) {
      let minX = pt.x;
      let minY = pt.y;
      let maxX = minX;
      let maxY = minY;
      for (let i = 1; i < points.length; i += 1) {
        const tmp = points[i];
        if (tmp) {
          const dx = pt.x - tmp.x;
          const dy = pt.y - tmp.y;
          const segment = Math.sqrt(dx * dx + dy * dy);
          segments.push(segment);
          length += segment;
          pt = tmp;
          minX = Math.min(pt.x, minX);
          minY = Math.min(pt.y, minY);
          maxX = Math.max(pt.x, maxX);
          maxY = Math.max(pt.y, maxY);
        }
      }
      state.length = length;
      state.segments = segments;
      const markerSize = 1;
      state.x = minX;
      state.y = minY;
      state.width = Math.max(markerSize, maxX - minX);
      state.height = Math.max(markerSize, maxY - minY);
    }
  }
  /**
   * Returns the absolute point on the edge for the given relative
   * {@link Geometry} as an {@link Point}. The edge is represented by the given
   * {@link CellState}.
   *
   * @param state {@link CellState} that represents the state of the parent edge.
   * @param geometry {@link mxGeometry} that represents the relative location.
   */
  getPoint(state, geometry = null) {
    let x = state.getCenterX();
    let y = state.getCenterY();
    if (state.segments != null && (geometry == null || geometry.relative)) {
      const gx = geometry != null ? geometry.x / 2 : 0;
      const pointCount = state.absolutePoints.length;
      const dist = Math.round((gx + 0.5) * state.length);
      let segment = state.segments[0];
      let length = 0;
      let index = 1;
      while (dist >= Math.round(length + segment) && index < pointCount - 1) {
        length += segment;
        segment = state.segments[index++];
      }
      const factor = segment === 0 ? 0 : (dist - length) / segment;
      const p0 = state.absolutePoints[index - 1];
      const pe = state.absolutePoints[index];
      if (p0 != null && pe != null) {
        let gy = 0;
        let offsetX = 0;
        let offsetY = 0;
        if (geometry != null) {
          gy = geometry.y;
          const { offset } = geometry;
          if (offset != null) {
            offsetX = offset.x;
            offsetY = offset.y;
          }
        }
        const dx = pe.x - p0.x;
        const dy = pe.y - p0.y;
        const nx = segment === 0 ? 0 : dy / segment;
        const ny = segment === 0 ? 0 : dx / segment;
        x = p0.x + dx * factor + (nx * gy + offsetX) * this.scale;
        y = p0.y + dy * factor - (ny * gy - offsetY) * this.scale;
      }
    } else if (geometry != null) {
      const { offset } = geometry;
      if (offset != null) {
        x += offset.x;
        y += offset.y;
      }
    }
    return new Point(x, y);
  }
  /**
   * Gets the relative point that describes the given, absolute label
   * position for the given edge state.
   *
   * @param state {@link CellState} that represents the state of the parent edge.
   * @param x Specifies the x-coordinate of the absolute label location.
   * @param y Specifies the y-coordinate of the absolute label location.
   */
  getRelativePoint(edgeState, x, y) {
    const geometry = edgeState.cell.getGeometry();
    if (geometry) {
      const absolutePoints = edgeState.absolutePoints;
      const pointCount = absolutePoints.length;
      if (geometry.relative && pointCount > 1) {
        const totalLength = edgeState.length;
        const { segments } = edgeState;
        let p0 = absolutePoints[0];
        let pe = absolutePoints[1];
        let minDist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);
        let length = 0;
        let index = 0;
        let tmp = 0;
        for (let i = 2; i < pointCount; i += 1) {
          p0 = pe;
          pe = absolutePoints[i];
          const dist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);
          tmp += segments[i - 2];
          if (dist <= minDist) {
            minDist = dist;
            index = i - 1;
            length = tmp;
          }
        }
        const seg = segments[index];
        p0 = absolutePoints[index];
        pe = absolutePoints[index + 1];
        const x2 = p0.x;
        const y2 = p0.y;
        const x1 = pe.x;
        const y1 = pe.y;
        let px = x;
        let py = y;
        const xSegment = x2 - x1;
        const ySegment = y2 - y1;
        px -= x1;
        py -= y1;
        let projlenSq = 0;
        px = xSegment - px;
        py = ySegment - py;
        const dotprod = px * xSegment + py * ySegment;
        if (dotprod <= 0) {
          projlenSq = 0;
        } else {
          projlenSq = dotprod * dotprod / (xSegment * xSegment + ySegment * ySegment);
        }
        let projlen = Math.sqrt(projlenSq);
        if (projlen > seg) {
          projlen = seg;
        }
        let yDistance = Math.sqrt(ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y));
        const direction = relativeCcw(p0.x, p0.y, pe.x, pe.y, x, y);
        if (direction === -1) {
          yDistance = -yDistance;
        }
        return new Point((totalLength / 2 - length - projlen) / totalLength * -2, yDistance / this.scale);
      }
    }
    return new Point();
  }
  /**
   * Updates {@link CellState.absoluteOffset} for the given state. The absolute
   * offset is normally used for the position of the edge label. Is is
   * calculated from the geometry as an absolute offset from the center
   * between the two endpoints if the geometry is absolute, or as the
   * relative distance between the center along the line and the absolute
   * orthogonal distance if the geometry is relative.
   *
   * @param state {@link CellState} whose absolute offset should be updated.
   */
  updateEdgeLabelOffset(state) {
    const points = state.absolutePoints;
    const absoluteOffset = state.absoluteOffset;
    absoluteOffset.x = state.getCenterX();
    absoluteOffset.y = state.getCenterY();
    if (points.length > 0 && state.segments) {
      const geometry = state.cell.getGeometry();
      if (geometry) {
        if (geometry.relative) {
          const offset = this.getPoint(state, geometry);
          state.absoluteOffset = offset;
        } else {
          const p0 = points[0];
          const pe = points[points.length - 1];
          if (p0 && pe) {
            const dx = pe.x - p0.x;
            const dy = pe.y - p0.y;
            let x0 = 0;
            let y0 = 0;
            const off = geometry.offset;
            if (off) {
              x0 = off.x;
              y0 = off.y;
            }
            const x = p0.x + dx / 2 + x0 * this.scale;
            const y = p0.y + dy / 2 + y0 * this.scale;
            absoluteOffset.x = x;
            absoluteOffset.y = y;
          }
        }
      }
    }
  }
  /**
   * Returns the {@link CellState} for the given cell. If create is true, then
   * the state is created if it does not yet exist.
   *
   * @param cell {@link mxCell} for which the {@link CellState} should be returned.
   * @param create Optional boolean indicating if a new state should be created
   * if it does not yet exist. Default is false.
   */
  getState(cell, create = false) {
    let state = this.states.get(cell);
    if (create && (!state || this.updateStyle) && cell.isVisible()) {
      if (!state) {
        state = this.createState(cell);
        this.states.put(cell, state);
      } else {
        state.style = this.graph.getCellStyle(cell);
      }
    }
    return state;
  }
  /**
   * Returns the {@link mxCellStates} for the given array of {@link Cell}. The array
   * contains all states that are not null, that is, the returned array may
   * have less elements than the given array. If no argument is given, then
   * this returns {@link states}.
   */
  getCellStates(cells = null) {
    if (!cells) {
      return this.states.getValues();
    }
    const result = [];
    for (const cell of cells) {
      const state = this.getState(cell);
      if (state) {
        result.push(state);
      }
    }
    return result;
  }
  /**
   * Removes and returns the {@link CellState} for the given cell.
   *
   * @param cell {@link mxCell} for which the {@link CellState} should be removed.
   */
  removeState(cell) {
    const state = this.states.remove(cell);
    if (state) {
      this.graph.cellRenderer.destroy(state);
      state.invalid = true;
      state.destroy();
    }
    return state;
  }
  /**
   * Creates and returns an {@link CellState} for the given cell and initializes
   * it using {@link cellRenderer.initialize}.
   *
   * @param cell {@link mxCell} for which a new {@link CellState} should be created.
   */
  createState(cell) {
    return new CellState(this, cell, this.graph.getCellStyle(cell));
  }
  /**
   * Returns true if the event origin is one of the drawing panes or
   * containers of the view.
   */
  isContainerEvent(evt) {
    const source = getSource(evt);
    return source && (source === this.graph.container || // @ts-ignore parentNode may exist
    source.parentNode === this.backgroundPane || // @ts-ignore parentNode may exist
    source.parentNode && source.parentNode.parentNode === this.backgroundPane || source === this.canvas.parentNode || source === this.canvas || source === this.backgroundPane || source === this.drawPane || source === this.overlayPane || source === this.decoratorPane);
  }
  isScrollEvent(evt) {
    const graph = this.graph;
    const offset = getOffset(graph.container);
    const eventClientPosition = evt instanceof MouseEvent ? [evt.clientX, evt.clientY] : [evt.touches[0].clientX, evt.touches[0].clientY];
    const pt = new Point(eventClientPosition[0] - offset.x, eventClientPosition[1] - offset.y);
    const container = graph.container;
    const outWidth = container.offsetWidth;
    const inWidth = container.clientWidth;
    if (outWidth > inWidth && pt.x > inWidth + 2 && pt.x <= outWidth) {
      return true;
    }
    const outHeight = container.offsetHeight;
    const inHeight = container.clientHeight;
    return outHeight > inHeight && pt.y > inHeight + 2 && pt.y <= outHeight;
  }
  /**
   * Initializes the graph event dispatch loop for the specified container
   * and invokes {@link create} to create the required DOM nodes for the display.
   */
  init() {
    this.installListeners();
    this.createSvg();
  }
  /**
   * Installs the required listeners in the container.
   */
  installListeners() {
    const graph = this.graph;
    const { container } = graph;
    if (Client.IS_TOUCH) {
      InternalEvent.addListener(container, "gesturestart", (evt) => {
        graph.fireGestureEvent(evt);
        InternalEvent.consume(evt);
      });
      InternalEvent.addListener(container, "gesturechange", (evt) => {
        graph.fireGestureEvent(evt);
        InternalEvent.consume(evt);
      });
      InternalEvent.addListener(container, "gestureend", (evt) => {
        graph.fireGestureEvent(evt);
        InternalEvent.consume(evt);
      });
    }
    let pointerId = null;
    InternalEvent.addGestureListeners(container, (evt) => {
      if (this.isContainerEvent(evt) && (!Client.IS_GC && !Client.IS_SF || !this.isScrollEvent(evt))) {
        graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));
        pointerId = evt.pointerId;
      }
    }, (evt) => {
      if (this.isContainerEvent(evt) && // @ts-ignore
      (pointerId === null || evt.pointerId === pointerId)) {
        graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt));
      }
    }, (evt) => {
      if (this.isContainerEvent(evt)) {
        graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));
      }
      pointerId = null;
    });
    InternalEvent.addListener(container, "dblclick", (evt) => {
      if (this.isContainerEvent(evt)) {
        graph.dblClick(evt);
      }
    });
    const getState = (evt) => {
      let state = null;
      if (Client.IS_TOUCH) {
        const x = getClientX(evt);
        const y = getClientY(evt);
        const pt = convertPoint(container, x, y);
        const cell = graph.getCellAt(pt.x, pt.y);
        if (cell)
          state = graph.view.getState(cell);
      }
      return state;
    };
    graph.addMouseListener({
      mouseDown: (sender, me) => {
        const popupMenuHandler = graph.getPlugin("PopupMenuHandler");
        popupMenuHandler == null ? void 0 : popupMenuHandler.hideMenu();
      },
      mouseMove: () => {
        return;
      },
      mouseUp: () => {
        return;
      }
    });
    this.moveHandler = (evt) => {
      const tooltipHandler = graph.getPlugin("TooltipHandler");
      if (tooltipHandler && tooltipHandler.isHideOnHover()) {
        tooltipHandler.hide();
      }
      if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display !== "none" && graph.container.style.visibility !== "hidden" && !isConsumed(evt)) {
        graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));
      }
    };
    this.endHandler = (evt) => {
      if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display !== "none" && graph.container.style.visibility !== "hidden") {
        graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));
      }
    };
    InternalEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);
  }
  /**
   * Creates and returns the DOM nodes for the SVG display.
   */
  createSvg() {
    const { container } = this.graph;
    const canvas = this.canvas = document.createElementNS(NS_SVG, "g");
    this.backgroundPane = document.createElementNS(NS_SVG, "g");
    canvas.appendChild(this.backgroundPane);
    this.drawPane = document.createElementNS(NS_SVG, "g");
    canvas.appendChild(this.drawPane);
    this.overlayPane = document.createElementNS(NS_SVG, "g");
    canvas.appendChild(this.overlayPane);
    this.decoratorPane = document.createElementNS(NS_SVG, "g");
    canvas.appendChild(this.decoratorPane);
    const root = document.createElementNS(NS_SVG, "svg");
    root.style.left = "0px";
    root.style.top = "0px";
    root.style.width = "100%";
    root.style.height = "100%";
    root.style.display = "block";
    root.appendChild(this.canvas);
    if (container != null) {
      container.appendChild(root);
      this.updateContainerStyle(container);
    }
  }
  /**
   * Function: createHtml
   *
   * Creates the DOM nodes for the HTML display.
   */
  createHtml() {
    const container = this.graph.container;
    if (container != null) {
      this.canvas = this.createHtmlPane("100%", "100%");
      this.canvas.style.overflow = "hidden";
      this.backgroundPane = this.createHtmlPane("1px", "1px");
      this.drawPane = this.createHtmlPane("1px", "1px");
      this.overlayPane = this.createHtmlPane("1px", "1px");
      this.decoratorPane = this.createHtmlPane("1px", "1px");
      this.canvas.appendChild(this.backgroundPane);
      this.canvas.appendChild(this.drawPane);
      this.canvas.appendChild(this.overlayPane);
      this.canvas.appendChild(this.decoratorPane);
      container.appendChild(this.canvas);
      this.updateContainerStyle(container);
    }
  }
  /**
   * Function: updateHtmlCanvasSize
   *
   * Updates the size of the HTML canvas.
   */
  updateHtmlCanvasSize(width, height) {
    if (this.graph.container != null) {
      const ow = this.graph.container.offsetWidth;
      const oh = this.graph.container.offsetHeight;
      if (ow < width) {
        this.canvas.style.width = width + "px";
      } else {
        this.canvas.style.width = "100%";
      }
      if (oh < height) {
        this.canvas.style.height = height + "px";
      } else {
        this.canvas.style.height = "100%";
      }
    }
  }
  /**
   * Function: createHtmlPane
   *
   * Creates and returns a drawing pane in HTML (DIV).
   */
  createHtmlPane(width, height) {
    const pane = document.createElement("DIV");
    if (width != null && height != null) {
      pane.style.position = "absolute";
      pane.style.left = "0px";
      pane.style.top = "0px";
      pane.style.width = width;
      pane.style.height = height;
    } else {
      pane.style.position = "relative";
    }
    return pane;
  }
  /**
   * Updates the style of the container after installing the SVG DOM elements.
   */
  updateContainerStyle(container) {
    const style = getCurrentStyle(container);
    if (style != null && style.position == "static") {
      container.style.position = "relative";
    }
    if (Client.IS_POINTER) {
      container.style.touchAction = "none";
    }
  }
  /**
   * Destroys the view and all its resources.
   */
  destroy() {
    let root = null;
    if (this.canvas && this.canvas instanceof SVGElement) {
      root = this.canvas.ownerSVGElement;
    }
    if (!root) {
      root = this.canvas;
    }
    if (root && root.parentNode) {
      this.clear(this.currentRoot, true);
      InternalEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler);
      InternalEvent.release(this.graph.container);
      root.parentNode.removeChild(root);
      this.moveHandler = null;
      this.endHandler = null;
      this.canvas = null;
      this.backgroundPane = null;
      this.drawPane = null;
      this.overlayPane = null;
      this.decoratorPane = null;
    }
  }
}
class PolylineShape extends Shape {
  /**
   * Constructs a new polyline shape.
   *
   * @param points Array of <{@link Point} that define the points. This is stored in {@link Shape.points}.
   * @param stroke String that defines the stroke color. Default is 'black'. This is stored in {@link Shape.stroke}.
   * @param strokeWidth Optional integer that defines the stroke width. Default is 1. This is stored in {@link Shape.strokeWidth}.
   */
  constructor(points, stroke, strokeWidth = 1) {
    super();
    this.points = points;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Returns 0.
   */
  getRotation() {
    return 0;
  }
  /**
   * Returns 0.
   */
  getShapeRotation() {
    return 0;
  }
  /**
   * Returns false.
   */
  isPaintBoundsInverted() {
    return false;
  }
  /**
   * Paints the line shape.
   */
  paintEdgeShape(c, pts) {
    var _a;
    const prev = c.pointerEventsValue;
    c.pointerEventsValue = "stroke";
    if (!((_a = this.style) == null ? void 0 : _a.curved)) {
      this.paintLine(c, pts, this.isRounded);
    } else {
      this.paintCurvedLine(c, pts);
    }
    c.pointerEventsValue = prev;
  }
  /**
   * Paints the line shape.
   */
  paintLine(c, pts, rounded) {
    var _a;
    const arcSize = ((_a = this.style) == null ? void 0 : _a.arcSize) ?? LINE_ARCSIZE;
    c.begin();
    this.addPoints(c, pts, rounded, arcSize, false);
    c.stroke();
  }
  /**
   * Paints the line shape.
   */
  paintCurvedLine(c, pts) {
    c.begin();
    const pt = pts[0];
    const n = pts.length;
    c.moveTo(pt.x, pt.y);
    for (let i = 1; i < n - 2; i += 1) {
      const p02 = pts[i];
      const p12 = pts[i + 1];
      const ix = (p02.x + p12.x) / 2;
      const iy = (p02.y + p12.y) / 2;
      c.quadTo(p02.x, p02.y, ix, iy);
    }
    const p0 = pts[n - 2];
    const p1 = pts[n - 1];
    c.quadTo(p0.x, p0.y, p1.x, p1.y);
    c.stroke();
  }
}
class MarkerShape {
  /**
   * Adds a factory method that updates a given endpoint and returns a
   * function to paint the marker onto the given canvas.
   */
  static addMarker(type, funct) {
    MarkerShape.markers[type] = funct;
  }
  /**
   * Returns a function to paint the given marker.
   */
  static createMarker(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    const markerFunction = MarkerShape.markers[type];
    return markerFunction ? markerFunction(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) : null;
  }
}
MarkerShape.markers = {};
function createArrow(widthFactor) {
  return (canvas, _shape, type, pe, unitX, unitY, size, _source, sw, filled) => {
    const endOffsetX = unitX * sw * 1.118;
    const endOffsetY = unitY * sw * 1.118;
    unitX *= size + sw;
    unitY *= size + sw;
    const pt = pe.clone();
    pt.x -= endOffsetX;
    pt.y -= endOffsetY;
    const f = type !== ARROW.CLASSIC && type !== ARROW.CLASSIC_THIN ? 1 : 3 / 4;
    pe.x += -unitX * f - endOffsetX;
    pe.y += -unitY * f - endOffsetY;
    return () => {
      canvas.begin();
      canvas.moveTo(pt.x, pt.y);
      canvas.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);
      if (type === ARROW.CLASSIC || type === ARROW.CLASSIC_THIN) {
        canvas.lineTo(pt.x - unitX * 3 / 4, pt.y - unitY * 3 / 4);
      }
      canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
      canvas.close();
      if (filled) {
        canvas.fillAndStroke();
      } else {
        canvas.stroke();
      }
    };
  };
}
function createOpenArrow(widthFactor) {
  return (canvas, _shape, _type, pe, unitX, unitY, size, _source, sw, _filled) => {
    const endOffsetX = unitX * sw * 1.118;
    const endOffsetY = unitY * sw * 1.118;
    unitX *= size + sw;
    unitY *= size + sw;
    const pt = pe.clone();
    pt.x -= endOffsetX;
    pt.y -= endOffsetY;
    pe.x += -endOffsetX * 2;
    pe.y += -endOffsetY * 2;
    return () => {
      canvas.begin();
      canvas.moveTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);
      canvas.lineTo(pt.x, pt.y);
      canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
      canvas.stroke();
    };
  };
}
const oval = (canvas, _shape, _type, pe, unitX, unitY, size, _source, _sw, filled) => {
  const a = size / 2;
  const pt = pe.clone();
  pe.x -= unitX * a;
  pe.y -= unitY * a;
  return () => {
    canvas.ellipse(pt.x - a, pt.y - a, size, size);
    if (filled) {
      canvas.fillAndStroke();
    } else {
      canvas.stroke();
    }
  };
};
function diamond(canvas, _shape, type, pe, unitX, unitY, size, _source, sw, filled) {
  const swFactor = type === ARROW.DIAMOND ? 0.7071 : 0.9862;
  const endOffsetX = unitX * sw * swFactor;
  const endOffsetY = unitY * sw * swFactor;
  unitX *= size + sw;
  unitY *= size + sw;
  const pt = pe.clone();
  pt.x -= endOffsetX;
  pt.y -= endOffsetY;
  pe.x += -unitX - endOffsetX;
  pe.y += -unitY - endOffsetY;
  const tk = type === ARROW.DIAMOND ? 2 : 3.4;
  return () => {
    canvas.begin();
    canvas.moveTo(pt.x, pt.y);
    canvas.lineTo(pt.x - unitX / 2 - unitY / tk, pt.y + unitX / tk - unitY / 2);
    canvas.lineTo(pt.x - unitX, pt.y - unitY);
    canvas.lineTo(pt.x - unitX / 2 + unitY / tk, pt.y - unitY / 2 - unitX / tk);
    canvas.close();
    if (filled) {
      canvas.fillAndStroke();
    } else {
      canvas.stroke();
    }
  };
}
let isDefaultMarkersRegistered = false;
const registerDefaultEdgeMarkers = () => {
  if (!isDefaultMarkersRegistered) {
    MarkerShape.addMarker("classic", createArrow(2));
    MarkerShape.addMarker("classicThin", createArrow(3));
    MarkerShape.addMarker("block", createArrow(2));
    MarkerShape.addMarker("blockThin", createArrow(3));
    MarkerShape.addMarker("open", createOpenArrow(2));
    MarkerShape.addMarker("openThin", createOpenArrow(3));
    MarkerShape.addMarker("oval", oval);
    MarkerShape.addMarker("diamond", diamond);
    MarkerShape.addMarker("diamondThin", diamond);
    isDefaultMarkersRegistered = true;
  }
};
class ConnectorShape extends PolylineShape {
  constructor(points, stroke, strokewidth) {
    super(points, stroke, strokewidth);
  }
  /**
   * Updates the {@link boundingBox} for this shape using {@link createBoundingBox}
   * and {@link augmentBoundingBox} and stores the result in {@link boundingBox}.
   */
  updateBoundingBox() {
    var _a;
    this.useSvgBoundingBox = ((_a = this.style) == null ? void 0 : _a.curved) ?? false;
    super.updateBoundingBox();
  }
  /**
   * Paints the line shape.
   */
  paintEdgeShape(c, pts) {
    var _a, _b, _c, _d;
    const sourceMarker = this.createMarker(c, pts, true);
    const targetMarker = this.createMarker(c, pts, false);
    super.paintEdgeShape(c, pts);
    c.setShadow(false);
    c.setDashed(false);
    if (sourceMarker) {
      const strokeColor = ((_a = this.style) == null ? void 0 : _a.startStrokeColor) ?? this.stroke;
      c.setStrokeColor(strokeColor);
      c.setFillColor(((_b = this.style) == null ? void 0 : _b.startFillColor) ?? strokeColor);
      sourceMarker();
    }
    if (targetMarker) {
      const strokeColor = ((_c = this.style) == null ? void 0 : _c.endStrokeColor) ?? this.stroke;
      c.setStrokeColor(strokeColor);
      c.setFillColor(((_d = this.style) == null ? void 0 : _d.endFillColor) ?? strokeColor);
      targetMarker();
    }
  }
  /**
   * Prepares the marker by adding offsets in pts and returning a function to paint the marker.
   */
  createMarker(c, pts, source) {
    if (!this.style)
      return null;
    let result = null;
    const n = pts.length;
    const type = (source ? this.style.startArrow : this.style.endArrow) || NONE;
    let p0 = source ? pts[1] : pts[n - 2];
    const pe = source ? pts[0] : pts[n - 1];
    if (type !== NONE && p0 !== null && pe !== null) {
      let count = 1;
      while (count < n - 1 && Math.round(p0.x - pe.x) === 0 && Math.round(p0.y - pe.y) === 0) {
        p0 = source ? pts[1 + count] : pts[n - 2 - count];
        count++;
      }
      const dx = pe.x - p0.x;
      const dy = pe.y - p0.y;
      const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
      const unitX = dx / dist;
      const unitY = dy / dist;
      const size = (source ? this.style.startSize : this.style.endSize) ?? DEFAULT_MARKERSIZE;
      const filled = (source ? this.style.startFill : this.style.endFill) ?? true;
      result = MarkerShape.createMarker(c, this, type, pe, unitX, unitY, size, source, this.strokeWidth, filled);
    }
    return result;
  }
  /**
   * Augments the bounding box with the strokewidth and shadow offsets.
   */
  augmentBoundingBox(bbox) {
    super.augmentBoundingBox(bbox);
    if (!this.style)
      return;
    let size = 0;
    if (this.style.startArrow !== NONE) {
      size = (this.style.startSize ?? DEFAULT_MARKERSIZE) + 1;
    }
    if (this.style.endArrow !== NONE) {
      size = Math.max(size, this.style.endSize ?? DEFAULT_MARKERSIZE) + 1;
    }
    bbox.grow(size * this.scale);
  }
}
class TextShape extends Shape {
  constructor(value, bounds, align = ALIGN.CENTER, valign = ALIGN.MIDDLE, color = "black", family = DEFAULT_FONTFAMILY, size = DEFAULT_FONTSIZE, fontStyle = DEFAULT_FONTSTYLE, spacing = 2, spacingTop = 0, spacingRight = 0, spacingBottom = 0, spacingLeft = 0, horizontal = true, background = NONE, border = NONE, wrap = false, clipped = false, overflow = "visible", labelPadding = 0, textDirection = DEFAULT_TEXT_DIRECTION) {
    super();
    this.margin = null;
    this.unrotatedBoundingBox = null;
    this.flipH = false;
    this.flipV = false;
    this.baseSpacingTop = 0;
    this.baseSpacingBottom = 0;
    this.baseSpacingLeft = 0;
    this.baseSpacingRight = 0;
    this.replaceLinefeeds = true;
    this.verticalTextRotation = -90;
    this.ignoreClippedStringSize = true;
    this.ignoreStringSize = false;
    this.lastValue = null;
    this.cacheEnabled = true;
    this.value = value;
    this.bounds = bounds;
    this.color = color ?? "black";
    this.align = align ?? ALIGN.CENTER;
    this.valign = valign ?? ALIGN.MIDDLE;
    this.family = family ?? DEFAULT_FONTFAMILY;
    this.size = size ?? DEFAULT_FONTSIZE;
    this.fontStyle = fontStyle ?? DEFAULT_FONTSTYLE;
    this.spacing = spacing ?? 2;
    this.spacingTop = this.spacing + (spacingTop ?? 0);
    this.spacingRight = this.spacing + (spacingRight ?? 0);
    this.spacingBottom = this.spacing + (spacingBottom ?? 0);
    this.spacingLeft = this.spacing + (spacingLeft ?? 0);
    this.horizontal = horizontal ?? true;
    this.background = background;
    this.border = border;
    this.wrap = wrap ?? false;
    this.clipped = clipped ?? false;
    this.overflow = overflow ?? "visible";
    this.labelPadding = labelPadding ?? 0;
    this.textDirection = textDirection;
    this.rotation = 0;
    this.updateMargin();
  }
  /**
   * Disables offset in IE9 for crisper image output.
   */
  getSvgScreenOffset() {
    return 0;
  }
  /**
   * Returns true if the bounds are not null and all of its variables are numeric.
   */
  checkBounds() {
    return !isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 && this.bounds && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height);
  }
  /**
   * Generic rendering code.
   */
  paint(c, update = false) {
    const s = this.scale;
    const x = this.bounds.x / s;
    const y = this.bounds.y / s;
    const w = this.bounds.width / s;
    const h = this.bounds.height / s;
    this.updateTransform(c, x, y, w, h);
    this.configureCanvas(c, x, y, w, h);
    if (update) {
      c.updateText(x, y, w, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);
    } else {
      const realHtml = isNode(this.value) || this.dialect === DIALECT.STRICTHTML;
      const fmt = realHtml ? "html" : "";
      let val = this.value;
      if (!realHtml && fmt === "html") {
        val = htmlEntities(val, false);
      }
      if (fmt === "html" && !isNode(this.value)) {
        val = replaceTrailingNewlines(val, "<div><br></div>");
      }
      val = !isNode(this.value) && this.replaceLinefeeds && fmt === "html" ? val.replace(/\n/g, "<br/>") : val;
      let dir = this.textDirection;
      if (dir === TEXT_DIRECTION.AUTO && !realHtml) {
        dir = this.getAutoDirection();
      }
      if (dir !== TEXT_DIRECTION.LTR && dir !== TEXT_DIRECTION.RTL) {
        dir = TEXT_DIRECTION.DEFAULT;
      }
      c.text(x, y, w, h, val, this.align, this.valign, this.wrap, fmt, this.overflow, this.clipped, this.getTextRotation(), dir);
    }
  }
  /**
   * Renders the text using the given DOM nodes.
   */
  redraw() {
    if (this.visible && this.checkBounds() && this.cacheEnabled && this.lastValue === this.value && (isNode(this.value) || this.dialect === DIALECT.STRICTHTML)) {
      if (this.node.nodeName === "DIV") {
        this.redrawHtmlShape();
        this.updateBoundingBox();
      } else {
        const canvas = this.createCanvas();
        if (canvas) {
          canvas.pointerEvents = this.pointerEvents;
          this.paint(canvas, true);
          this.destroyCanvas(canvas);
          this.updateBoundingBox();
        }
      }
    } else {
      super.redraw();
      if (isNode(this.value) || this.dialect === DIALECT.STRICTHTML) {
        this.lastValue = this.value;
      } else {
        this.lastValue = null;
      }
    }
  }
  /**
   * Resets all styles.
   */
  resetStyles() {
    super.resetStyles();
    this.color = "black";
    this.align = ALIGN.CENTER;
    this.valign = ALIGN.MIDDLE;
    this.family = DEFAULT_FONTFAMILY;
    this.size = DEFAULT_FONTSIZE;
    this.fontStyle = DEFAULT_FONTSTYLE;
    this.spacing = 2;
    this.spacingTop = 2;
    this.spacingRight = 2;
    this.spacingBottom = 2;
    this.spacingLeft = 2;
    this.horizontal = true;
    this.background = NONE;
    this.border = NONE;
    this.textDirection = DEFAULT_TEXT_DIRECTION;
    this.margin = null;
  }
  /**
   * Extends mxShape to update the text styles.
   *
   * @param state <CellState> of the corresponding cell.
   */
  apply(state) {
    const old = this.spacing;
    super.apply(state);
    if (this.style) {
      this.fontStyle = this.style.fontStyle ?? this.fontStyle;
      this.family = this.style.fontFamily ?? this.family;
      this.size = this.style.fontSize ?? this.size;
      this.color = this.style.fontColor ?? this.color;
      this.align = this.style.align ?? this.align;
      this.valign = this.style.verticalAlign ?? this.valign;
      this.spacing = this.style.spacing ?? this.spacing;
      this.spacingTop = (this.style.spacingTop ?? this.spacingTop - old) + this.spacing;
      this.spacingRight = (this.style.spacingRight ?? this.spacingRight - old) + this.spacing;
      this.spacingBottom = (this.style.spacingBottom ?? this.spacingBottom - old) + this.spacing;
      this.spacingLeft = (this.style.spacingLeft ?? this.spacingLeft - old) + this.spacing;
      this.horizontal = this.style.horizontal ?? this.horizontal;
      this.background = this.style.labelBackgroundColor ?? this.background;
      this.border = this.style.labelBorderColor ?? this.border;
      this.textDirection = this.style.textDirection ?? DEFAULT_TEXT_DIRECTION;
      this.opacity = this.style.textOpacity ?? 100;
      this.updateMargin();
    }
    this.flipV = false;
    this.flipH = false;
  }
  /**
   * Used to determine the automatic text direction. Returns
   * {@link Constants#TEXT_DIRECTION_LTR} or {@link Constants#TEXT_DIRECTION_RTL}
   * depending on the contents of <value>. This is not invoked for HTML, wrapped
   * content or if <value> is a DOM node.
   */
  getAutoDirection() {
    const tmp = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(String(this.value));
    return tmp && tmp.length > 0 && tmp[0] > "z" ? TEXT_DIRECTION.RTL : TEXT_DIRECTION.LTR;
  }
  /**
   * Returns the node that contains the rendered input.
   */
  getContentNode() {
    let result = this.node;
    if (result) {
      if (!result.ownerSVGElement) {
        result = this.node.firstChild.firstChild;
      } else {
        result = result.firstChild.firstChild.firstChild.firstChild.firstChild;
      }
    }
    return result;
  }
  /**
   * Updates the <boundingBox> for this shape using the given node and position.
   */
  updateBoundingBox() {
    var _a, _b, _c;
    let { node } = this;
    this.boundingBox = this.bounds.clone();
    const rot = this.getTextRotation();
    const h = ((_a = this.style) == null ? void 0 : _a.labelPosition) ?? ALIGN.CENTER;
    const v = ((_b = this.style) == null ? void 0 : _b.verticalLabelPosition) ?? ALIGN.MIDDLE;
    if (!this.ignoreStringSize && node && this.overflow !== "fill" && (!this.clipped || !this.ignoreClippedStringSize || h !== ALIGN.CENTER || v !== ALIGN.MIDDLE)) {
      let ow = null;
      let oh = null;
      if (node.firstChild && node.firstChild.firstChild && node.firstChild.firstChild.nodeName === "foreignObject") {
        node = node.firstChild.firstChild.firstChild.firstChild;
        oh = node.offsetHeight * this.scale;
        if (this.overflow === "width") {
          ow = this.boundingBox.width;
        } else {
          ow = node.offsetWidth * this.scale;
        }
      } else {
        try {
          const b = node.getBBox();
          if (typeof this.value === "string" && ((_c = trim(this.value)) == null ? void 0 : _c.length) === 0) {
            this.boundingBox = null;
          } else if (b.width === 0 && b.height === 0) {
            this.boundingBox = null;
          } else {
            this.boundingBox = new Rectangle(b.x, b.y, b.width, b.height);
          }
          return;
        } catch (e) {
        }
      }
      if (ow && oh) {
        this.boundingBox = new Rectangle(this.bounds.x, this.bounds.y, ow, oh);
      }
    }
    if (this.boundingBox) {
      const margin = this.margin;
      if (rot !== 0) {
        const bbox = getBoundingBox(new Rectangle(margin.x * this.boundingBox.width, margin.y * this.boundingBox.height, this.boundingBox.width, this.boundingBox.height), rot, new Point(0, 0));
        this.unrotatedBoundingBox = Rectangle.fromRectangle(this.boundingBox);
        this.unrotatedBoundingBox.x += margin.x * this.unrotatedBoundingBox.width;
        this.unrotatedBoundingBox.y += margin.y * this.unrotatedBoundingBox.height;
        this.boundingBox.x += bbox.x;
        this.boundingBox.y += bbox.y;
        this.boundingBox.width = bbox.width;
        this.boundingBox.height = bbox.height;
      } else {
        this.boundingBox.x += margin.x * this.boundingBox.width;
        this.boundingBox.y += margin.y * this.boundingBox.height;
        this.unrotatedBoundingBox = null;
      }
    }
  }
  /**
   * Returns 0 to avoid using rotation in the canvas via updateTransform.
   */
  getShapeRotation() {
    return 0;
  }
  /**
   * Returns the rotation for the text label of the corresponding shape.
   */
  getTextRotation() {
    return this.state && this.state.shape ? this.state.shape.getTextRotation() : 0;
  }
  /**
   * Inverts the bounds if {@link Shape#isBoundsInverted} returns true or if the
   * horizontal style is false.
   */
  isPaintBoundsInverted() {
    return !this.horizontal && !!this.state && this.state.cell.isVertex();
  }
  /**
   * Sets the state of the canvas for drawing the shape.
   */
  configureCanvas(c, x, y, w, h) {
    super.configureCanvas(c, x, y, w, h);
    c.setFontColor(this.color);
    c.setFontBackgroundColor(this.background);
    c.setFontBorderColor(this.border);
    c.setFontFamily(this.family);
    c.setFontSize(this.size);
    c.setFontStyle(this.fontStyle);
  }
  /**
   * Private helper function to create SVG elements
   */
  getHtmlValue() {
    let val = this.value;
    if (this.dialect !== DIALECT.STRICTHTML) {
      val = htmlEntities(val, false);
    }
    val = replaceTrailingNewlines(val, "<div><br></div>");
    val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
    return val;
  }
  /**
   * Private helper function to create SVG elements
   */
  getTextCss() {
    const lh = LINE_HEIGHT;
    let css = `display: inline-block; font-size: ${this.size}px; font-family: ${this.family}; color: ${this.color}; line-height: ${lh}; pointer-events: ${this.pointerEvents ? "all" : "none"}; `;
    matchBinaryMask(this.fontStyle, FONT.BOLD) && (css += "font-weight: bold; ");
    matchBinaryMask(this.fontStyle, FONT.ITALIC) && (css += "font-style: italic; ");
    const txtDecor = [];
    matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
    matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
    txtDecor.length > 0 && (css += `text-decoration: ${txtDecor.join(" ")}; `);
    return css;
  }
  /**
   * Updates the HTML node(s) to reflect the latest bounds and scale.
   */
  redrawHtmlShape() {
    const w = Math.max(0, Math.round(this.bounds.width / this.scale));
    const h = Math.max(0, Math.round(this.bounds.height / this.scale));
    const flex = `position: absolute; left: ${Math.round(this.bounds.x)}px; top: ${Math.round(this.bounds.y)}px; pointer-events: none; `;
    const block = this.getTextCss();
    const margin = this.margin;
    const node = this.node;
    SvgCanvas2D.createCss(w + 2, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.background !== NONE ? htmlEntities(this.background, true) : null, this.border !== NONE ? htmlEntities(this.border, true) : null, flex, block, this.scale, (dx, dy, flex2, item, block2, ofl) => {
      const r = this.getTextRotation();
      let tr = (this.scale !== 1 ? `scale(${this.scale}) ` : "") + (r !== 0 ? `rotate(${r}deg) ` : "") + (margin.x !== 0 || margin.y !== 0 ? `translate(${margin.x * 100}%,${margin.y * 100}%)` : "");
      if (tr !== "") {
        tr = `transform-origin: 0 0; transform: ${tr}; `;
      }
      if (ofl === "") {
        flex2 += item;
        item = `display:inline-block; min-width: 100%; ${tr}`;
      } else {
        item += tr;
        if (Client.IS_SF) {
          item += "-webkit-clip-path: content-box;";
        }
      }
      if (this.opacity < 100) {
        block2 += `opacity: ${this.opacity / 100}; `;
      }
      node.setAttribute("style", flex2);
      const html = isNode(this.value) ? (
        // @ts-ignore
        this.value.outerHTML
      ) : this.getHtmlValue();
      if (!node.firstChild) {
        node.innerHTML = `<div><div>${html}</div></div>`;
      }
      node.firstChild.firstChild.setAttribute("style", block2);
      node.firstChild.setAttribute("style", item);
    });
  }
  /**
   * Sets the inner HTML of the given element to the <value>.
   */
  updateInnerHtml(elt) {
    if (isNode(this.value)) {
      elt.innerHTML = this.value.outerHTML;
    } else {
      let val = this.value;
      if (this.dialect !== DIALECT.STRICTHTML) {
        val = htmlEntities(val, false);
      }
      val = replaceTrailingNewlines(val, "<div>&nbsp;</div>");
      val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
      val = `<div style="display:inline-block;_display:inline;">${val}</div>`;
      elt.innerHTML = val;
    }
  }
  /**
   * Updates the HTML node(s) to reflect the latest bounds and scale.
   */
  updateValue() {
    const node = this.node;
    if (isNode(this.value)) {
      node.innerHTML = "";
      node.appendChild(this.value);
    } else {
      let val = this.value;
      if (this.dialect !== DIALECT.STRICTHTML) {
        val = htmlEntities(val, false);
      }
      val = replaceTrailingNewlines(val, "<div><br></div>");
      val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
      const bg = this.background !== NONE ? this.background : null;
      const bd = this.border !== NONE ? this.border : null;
      if (this.overflow === "fill" || this.overflow === "width") {
        if (bg) {
          node.style.backgroundColor = bg;
        }
        if (bd) {
          node.style.border = `1px solid ${bd}`;
        }
      } else {
        let css = "";
        if (bg) {
          css += `background-color:${htmlEntities(bg, true)};`;
        }
        if (bd) {
          css += `border:1px solid ${htmlEntities(bd, true)};`;
        }
        const lh = LINE_HEIGHT;
        val = `<div style="zoom:1;${css}display:inline-block;_display:inline;text-decoration:inherit;padding-bottom:1px;padding-right:1px;line-height:${lh}">${val}</div>`;
      }
      node.innerHTML = val;
      const divs = node.getElementsByTagName("div");
      if (divs.length > 0) {
        let dir = this.textDirection;
        if (dir === TEXT_DIRECTION.AUTO && this.dialect !== DIALECT.STRICTHTML) {
          dir = this.getAutoDirection();
        }
        if (dir === TEXT_DIRECTION.LTR || dir === TEXT_DIRECTION.RTL) {
          divs[divs.length - 1].setAttribute("dir", dir);
        } else {
          divs[divs.length - 1].removeAttribute("dir");
        }
      }
    }
  }
  /**
   * Updates the HTML node(s) to reflect the latest bounds and scale.
   */
  updateFont(node) {
    const { style } = node;
    style.lineHeight = LINE_HEIGHT;
    style.fontSize = `${this.size}px`;
    style.fontFamily = this.family;
    style.verticalAlign = "top";
    style.color = this.color;
    matchBinaryMask(this.fontStyle, FONT.BOLD) ? style.fontWeight = "bold" : style.fontWeight = "";
    matchBinaryMask(this.fontStyle, FONT.ITALIC) ? style.fontStyle = "italic" : style.fontStyle = "";
    const txtDecor = [];
    matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
    matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
    txtDecor.length > 0 && (style.textDecoration = txtDecor.join(" "));
    if (this.align === ALIGN.CENTER) {
      style.textAlign = "center";
    } else if (this.align === ALIGN.RIGHT) {
      style.textAlign = "right";
    } else {
      style.textAlign = "left";
    }
  }
  /**
   * Updates the HTML node(s) to reflect the latest bounds and scale.
   */
  updateSize(node, enableWrap = false) {
    const w = Math.max(0, Math.round(this.bounds.width / this.scale));
    const h = Math.max(0, Math.round(this.bounds.height / this.scale));
    const { style } = node;
    if (this.clipped) {
      style.overflow = "hidden";
      style.maxHeight = `${h}px`;
      style.maxWidth = `${w}px`;
    } else if (this.overflow === "fill") {
      style.width = `${w + 1}px`;
      style.height = `${h + 1}px`;
      style.overflow = "hidden";
    } else if (this.overflow === "width") {
      style.width = `${w + 1}px`;
      style.maxHeight = `${h + 1}px`;
      style.overflow = "hidden";
    }
    if (this.wrap && w > 0) {
      style.wordWrap = WORD_WRAP;
      style.whiteSpace = "normal";
      style.width = `${w}px`;
      if (enableWrap && this.overflow !== "fill" && this.overflow !== "width") {
        let sizeDiv = node;
        if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName === "DIV") {
          sizeDiv = sizeDiv.firstChild;
          if (node.style.wordWrap === "break-word") {
            sizeDiv.style.width = "100%";
          }
        }
        let tmp = sizeDiv.offsetWidth;
        if (tmp === 0) {
          const prev = node.parentNode;
          node.style.visibility = "hidden";
          document.body.appendChild(node);
          tmp = sizeDiv.offsetWidth;
          node.style.visibility = "";
          prev.appendChild(node);
        }
        tmp += 3;
        if (this.clipped) {
          tmp = Math.min(tmp, w);
        }
        style.width = `${tmp}px`;
      }
    } else {
      style.whiteSpace = "nowrap";
    }
  }
  /**
   * Returns the spacing as an {@link Point}.
   */
  updateMargin() {
    this.margin = getAlignmentAsPoint(this.align, this.valign);
  }
  /**
   * Returns the spacing as an {@link Point}.
   */
  getSpacing() {
    let dx = 0;
    let dy = 0;
    if (this.align === ALIGN.CENTER) {
      dx = (this.spacingLeft - this.spacingRight) / 2;
    } else if (this.align === ALIGN.RIGHT) {
      dx = -this.spacingRight - this.baseSpacingRight;
    } else {
      dx = this.spacingLeft + this.baseSpacingLeft;
    }
    if (this.valign === ALIGN.MIDDLE) {
      dy = (this.spacingTop - this.spacingBottom) / 2;
    } else if (this.valign === ALIGN.BOTTOM) {
      dy = -this.spacingBottom - this.baseSpacingBottom;
    } else {
      dy = this.spacingTop + this.baseSpacingTop;
    }
    return new Point(dx, dy);
  }
}
class StencilShapeRegistry {
  /**
   * Adds the given {@link StencilShape}.
   */
  static addStencil(name, stencil) {
    StencilShapeRegistry.stencils[name] = stencil;
  }
  /**
   * Returns the {@link StencilShape} for the given name.
   */
  static getStencil(name) {
    return StencilShapeRegistry.stencils[name];
  }
}
StencilShapeRegistry.stencils = {};
const placeholderStyleValues = ["inherit", "swimlane", "indicated"];
const placeholderStyleProperties = [
  "fillColor",
  "strokeColor",
  "gradientColor",
  "fontColor"
];
class CellRenderer {
  constructor() {
    this.defaultEdgeShape = ConnectorShape;
    this.defaultVertexShape = RectangleShape;
    this.defaultTextShape = TextShape;
    this.legacyControlPosition = true;
    this.legacySpacing = true;
    this.antiAlias = true;
    this.minSvgStrokeWidth = 1;
    this.forceControlClickHandler = false;
  }
  /**
   * Registers the given constructor under the specified key in this instance of the renderer.
   * @example
   * ```
   * CellRenderer.registerShape(Constants.SHAPE_RECTANGLE, RectangleShape);
   * ```
   *
   * @param key the shape name.
   * @param shape constructor of the {@link Shape} subclass.
   */
  static registerShape(key, shape) {
    CellRenderer.defaultShapes[key] = shape;
  }
  /**
   * Initializes the shape in the given state by calling its init method with
   * the correct container after configuring it using {@link configureShape}.
   *
   * @param state {@link CellState} for which the shape should be initialized.
   */
  initializeShape(state) {
    if (state.shape) {
      state.shape.dialect = state.view.graph.dialect;
      this.configureShape(state);
      state.shape.init(state.view.getDrawPane());
    }
  }
  /**
   * Creates and returns the shape for the given cell state.
   *
   * @param state {@link CellState} for which the shape should be created.
   */
  createShape(state) {
    const stencil = StencilShapeRegistry.getStencil(state.style.shape);
    if (stencil) {
      return new Shape(stencil);
    }
    const shapeConstructor = this.getShapeConstructor(state);
    return new shapeConstructor();
  }
  /**
   * Creates the indicator shape for the given cell state.
   *
   * @param state {@link CellState} for which the indicator shape should be created.
   */
  createIndicatorShape(state) {
    if (state.shape) {
      state.shape.indicatorShape = this.getShape(state.getIndicatorShape());
    }
  }
  /**
   * Returns the shape for the given name from {@link defaultShapes}.
   */
  getShape(name) {
    return name ? CellRenderer.defaultShapes[name] : null;
  }
  /**
   * Returns the constructor to be used for creating the shape.
   */
  getShapeConstructor(state) {
    let ctor = this.getShape(state.style.shape || null);
    if (!ctor) {
      ctor = state.cell.isEdge() ? this.defaultEdgeShape : this.defaultVertexShape;
    }
    return ctor;
  }
  /**
   * Configures the shape for the given cell state.
   *
   * @param state {@link CellState} for which the shape should be configured.
   */
  configureShape(state) {
    const shape = state.shape;
    if (shape) {
      shape.apply(state);
      shape.imageSrc = state.getImageSrc() || null;
      shape.indicatorColor = state.getIndicatorColor() || NONE;
      shape.indicatorStrokeColor = state.style.indicatorStrokeColor || NONE;
      shape.indicatorGradientColor = state.getIndicatorGradientColor() || NONE;
      if (state.style.indicatorDirection) {
        shape.indicatorDirection = state.style.indicatorDirection;
      }
      shape.indicatorImageSrc = state.getIndicatorImageSrc() || null;
      this.postConfigureShape(state);
    }
  }
  /**
   * Replaces any reserved words used for attributes, eg. inherit,
   * indicated or swimlane for colors in the shape for the given state.
   * This implementation resolves these keywords on the fill, stroke
   * and gradient color keys.
   */
  postConfigureShape(state) {
    if (state.shape) {
      this.resolveColor(state, "indicatorGradientColor", "gradientColor");
      this.resolveColor(state, "indicatorColor", "fillColor");
      this.resolveColor(state, "gradient", "gradientColor");
      this.resolveColor(state, "stroke", "strokeColor");
      this.resolveColor(state, "fill", "fillColor");
    }
  }
  /**
   * Check if style properties supporting placeholders requires resolution.
   */
  checkPlaceholderStyles(state) {
    for (const property of placeholderStyleProperties) {
      if (placeholderStyleValues.includes(state.style[property])) {
        return true;
      }
    }
    return false;
  }
  /**
   * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets
   * the respective color on the shape.
   */
  resolveColor(state, field, key) {
    const shape = key === "fontColor" ? state.text : state.shape;
    if (shape) {
      const graph = state.view.graph;
      const value = shape[field];
      let referenced = null;
      if (value === "inherit") {
        referenced = state.cell.getParent();
      } else if (value === "swimlane") {
        shape[field] = key === "strokeColor" || key === "fontColor" ? "#000000" : "#ffffff";
        if (state.cell.getTerminal(false)) {
          referenced = state.cell.getTerminal(false);
        } else {
          referenced = state.cell;
        }
        referenced = graph.getSwimlane(referenced);
        key = graph.swimlaneIndicatorColorAttribute;
      } else if (value === "indicated" && state.shape) {
        shape[field] = state.shape.indicatorColor;
      } else if (key !== "fillColor" && value === "fillColor" && state.shape) {
        shape[field] = state.style.fillColor;
      } else if (key !== "strokeColor" && value === "strokeColor" && state.shape) {
        shape[field] = state.style.strokeColor;
      }
      if (referenced) {
        const rstate = graph.getView().getState(referenced);
        shape[field] = null;
        if (rstate) {
          const rshape = key === "fontColor" ? rstate.text : rstate.shape;
          if (rshape && field !== "indicatorColor") {
            shape[field] = rshape[field];
          } else {
            shape[field] = rstate.style[key];
          }
        }
      }
    }
  }
  /**
   * Returns the value to be used for the label.
   *
   * @param state {@link CellState} for which the label should be created.
   */
  getLabelValue(state) {
    const graph = state.view.graph;
    return graph.getLabel(state.cell);
  }
  /**
   * Creates the label for the given cell state.
   *
   * @param state {@link CellState} for which the label should be created.
   * @param value the label value.
   */
  createLabel(state, value) {
    const graph = state.view.graph;
    if ((state.style.fontSize || 0) > 0 || state.style.fontSize == null) {
      const isForceHtml = graph.isHtmlLabel(state.cell) || isNode(value);
      state.text = new this.defaultTextShape(value, new Rectangle(), state.style.align ?? ALIGN.CENTER, state.getVerticalAlign(), state.style.fontColor, state.style.fontFamily, state.style.fontSize, state.style.fontStyle, state.style.spacing, state.style.spacingTop, state.style.spacingRight, state.style.spacingBottom, state.style.spacingLeft, state.style.horizontal, state.style.labelBackgroundColor, state.style.labelBorderColor, graph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell), graph.isLabelClipped(state.cell), state.style.overflow, state.style.labelPadding, state.style.textDirection ?? DEFAULT_TEXT_DIRECTION);
      state.text.opacity = state.style.textOpacity ?? 100;
      state.text.dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;
      state.text.style = state.style;
      state.text.state = state;
      this.initializeLabel(state, state.text);
      let forceGetCell = false;
      const getState = (evt) => {
        let result = state;
        if (Client.IS_TOUCH || forceGetCell) {
          const x = getClientX(evt);
          const y = getClientY(evt);
          const pt = convertPoint(graph.container, x, y);
          result = graph.view.getState(graph.getCellAt(pt.x, pt.y));
        }
        return result;
      };
      InternalEvent.addGestureListeners(state.text.node, (evt) => {
        if (this.isLabelEvent(state, evt)) {
          graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));
          const source = getSource(evt);
          forceGetCell = // @ts-ignore nodeName should exist.
          graph.dialect !== DIALECT.SVG && source.nodeName === "IMG";
        }
      }, (evt) => {
        if (this.isLabelEvent(state, evt)) {
          graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));
        }
      }, (evt) => {
        if (this.isLabelEvent(state, evt)) {
          graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, getState(evt)));
          forceGetCell = false;
        }
      });
      if (graph.isNativeDblClickEnabled()) {
        InternalEvent.addListener(state.text.node, "dblclick", (evt) => {
          if (this.isLabelEvent(state, evt)) {
            graph.dblClick(evt, state.cell);
            InternalEvent.consume(evt);
          }
        });
      }
    }
  }
  /**
   * Initializes the label with a suitable container.
   *
   * @param state {@link CellState} whose label should be initialized.
   * @param shape {@link Shape} that represents the label.
   */
  initializeLabel(state, shape) {
    if (Client.IS_SVG && Client.NO_FO && shape.dialect !== DIALECT.SVG) {
      const graph = state.view.graph;
      shape.init(graph.container);
    } else {
      shape.init(state.view.getDrawPane());
    }
  }
  /**
   * Creates the actual shape for showing the overlay for the given cell state.
   *
   * @param state {@link CellState} for which the overlay should be created.
   */
  createCellOverlays(state) {
    const graph = state.view.graph;
    const cellOverlays = graph.getCellOverlays(state.cell);
    const createdOverlays = new Dictionary();
    for (const cellOverlay of cellOverlays) {
      const shape = state.overlays.remove(cellOverlay);
      if (shape) {
        createdOverlays.put(cellOverlay, shape);
        continue;
      }
      const overlayShape = this.createOverlayShape(state, cellOverlay);
      overlayShape.dialect = graph.dialect;
      overlayShape.overlay = cellOverlay;
      this.initializeOverlay(state, overlayShape);
      this.installCellOverlayListeners(state, cellOverlay, overlayShape);
      this.configureOverlayShape(state, cellOverlay, overlayShape);
      createdOverlays.put(cellOverlay, overlayShape);
    }
    state.overlays.visit((id, shape) => {
      shape.destroy();
    });
    state.overlays = createdOverlays;
  }
  /**
   * Create the Shape of the overlay.
   *
   * @param _state {@link CellState} for which the overlay shape should be created.
   * @param cellOverlay {@link CellOverlay} used to create the Shape of the overlay.
   * @since 0.16.0
   */
  createOverlayShape(_state, cellOverlay) {
    const overlayShape = new ImageShape(new Rectangle(), cellOverlay.image.src);
    overlayShape.preserveImageAspect = false;
    return overlayShape;
  }
  /**
   * Initializes the given overlay.
   *
   * @param state {@link CellState}  for which the overlay should be created.
   * @param overlay {@link Shape} that represents the overlay.
   */
  initializeOverlay(state, overlay) {
    overlay.init(state.view.getOverlayPane());
  }
  /**
   * Installs the listeners for the given {@link CellState} , {@link CellOverlay} and {@link Shape} that represents the overlay.
   */
  installCellOverlayListeners(state, overlay, shape) {
    const graph = state.view.graph;
    InternalEvent.addListener(shape.node, "click", (evt) => {
      if (graph.isEditing()) {
        graph.stopEditing(!graph.isInvokesStopCellEditing());
      }
      overlay.fireEvent(new EventObject(InternalEvent.CLICK, { event: evt, cell: state.cell }));
    });
    InternalEvent.addGestureListeners(shape.node, (evt) => {
      InternalEvent.consume(evt);
    }, (evt) => {
      graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, state));
    });
    if (Client.IS_TOUCH) {
      InternalEvent.addListener(shape.node, "touchend", (evt) => {
        overlay.fireEvent(new EventObject(InternalEvent.CLICK, { event: evt, cell: state.cell }));
      });
    }
  }
  /**
   * Configure the Shape of the overlay. Generally, it is used to configure the DOM node of the Shape
   *
   * The default implementation set the cursor in the DOM node of the Shape based on the {@link CellOverlay.cursor}.
   *
   * @param _state {@link CellState} for which the overlay shape should be created.
   * @param cellOverlay {@link CellOverlay} used to create the Shape of the overlay.
   * @param overlayShape the {@link Shape} of the overlay.
   * @since 0.16.0
   */
  configureOverlayShape(_state, cellOverlay, overlayShape) {
    if (cellOverlay.cursor) {
      overlayShape.node.style.cursor = cellOverlay.cursor;
    }
  }
  /**
   * Creates the control for the given cell state.
   *
   * @param state {@link CellState}  for which the control should be created.
   */
  createControl(state) {
    const graph = state.view.graph;
    const image = graph.getFoldingImage(state);
    if (graph.isFoldingEnabled() && image) {
      if (!state.control) {
        const b = new Rectangle(0, 0, image.width, image.height);
        state.control = new ImageShape(b, image.src);
        state.control.preserveImageAspect = false;
        state.control.dialect = graph.dialect;
        this.initControl(state, state.control, true, this.createControlClickHandler(state));
      }
    } else if (state.control) {
      state.control.destroy();
      state.control = null;
    }
  }
  /**
   * Hook for creating the click handler for the folding icon.
   *
   * @param state {@link CellState}  whose control click handler should be returned.
   */
  createControlClickHandler(state) {
    const graph = state.view.graph;
    return (evt) => {
      if (this.forceControlClickHandler || graph.isEnabled()) {
        const collapse = !state.cell.isCollapsed();
        graph.foldCells(collapse, false, [state.cell], false, evt);
        InternalEvent.consume(evt);
      }
    };
  }
  /**
   * Initializes the given control and returns the corresponding DOM node.
   *
   * @param state {@link CellState} for which the control should be initialized.
   * @param control {@link Shape} to be initialized.
   * @param handleEvents Boolean indicating if mousedown and mousemove should fire events via the graph.
   * @param clickHandler Optional function to implement clicks on the control.
   */
  initControl(state, control, handleEvents, clickHandler) {
    const graph = state.view.graph;
    const isForceHtml = graph.isHtmlLabel(state.cell) && Client.NO_FO && graph.dialect === DIALECT.SVG;
    if (isForceHtml) {
      control.dialect = DIALECT.PREFERHTML;
      control.init(graph.container);
      control.node.style.zIndex = String(1);
    } else {
      control.init(state.view.getOverlayPane());
    }
    const node = control.node;
    if (clickHandler && !Client.IS_IOS) {
      if (graph.isEnabled()) {
        node.style.cursor = "pointer";
      }
      InternalEvent.addListener(node, "click", clickHandler);
    }
    if (handleEvents) {
      let first = null;
      InternalEvent.addGestureListeners(node, (evt) => {
        first = new Point(getClientX(evt), getClientY(evt));
        graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));
        InternalEvent.consume(evt);
      }, (evt) => {
        graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, state));
      }, (evt) => {
        graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, state));
        InternalEvent.consume(evt);
      });
      if (clickHandler && Client.IS_IOS) {
        node.addEventListener("touchend", (evt) => {
          if (first) {
            const tol = graph.getEventTolerance();
            if (Math.abs(first.x - getClientX(evt)) < tol && Math.abs(first.y - getClientY(evt)) < tol) {
              clickHandler.call(clickHandler, evt);
              InternalEvent.consume(evt);
            }
          }
        }, true);
      }
    }
    return node;
  }
  /**
   * Returns `true` if the event is for the shape of the given state.
   *
   * This implementation always returns `true`.
   *
   * @param state {@link CellState}  whose shape fired the event.
   * @param evt Mouse event which was fired.
   */
  isShapeEvent(state, evt) {
    return true;
  }
  /**
   * Returns `true` if the event is for the label of the given state.
   *
   * This implementation always returns `true`.
   *
   * @param state {@link CellState}  whose label fired the event.
   * @param evt Mouse event which was fired.
   */
  isLabelEvent(state, evt) {
    return true;
  }
  /**
   * Installs the event listeners for the given cell state.
   *
   * @param state {@link CellState}  for which the event listeners should be isntalled.
   */
  installListeners(state) {
    const graph = state.view.graph;
    const getState = (evt) => {
      let result = state;
      const source = getSource(evt);
      if (source && graph.dialect !== DIALECT.SVG && // @ts-ignore nodeName should exist
      source.nodeName === "IMG" || Client.IS_TOUCH) {
        const x = getClientX(evt);
        const y = getClientY(evt);
        const pt = convertPoint(graph.container, x, y);
        const cell = graph.getCellAt(pt.x, pt.y);
        result = cell ? graph.view.getState(cell) : null;
      }
      return result;
    };
    if (state.shape) {
      InternalEvent.addGestureListeners(state.shape.node, (evt) => {
        if (this.isShapeEvent(state, evt)) {
          graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));
        }
      }, (evt) => {
        if (this.isShapeEvent(state, evt)) {
          graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));
        }
      }, (evt) => {
        if (this.isShapeEvent(state, evt)) {
          graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, getState(evt)));
        }
      });
      if (graph.isNativeDblClickEnabled()) {
        InternalEvent.addListener(state.shape.node, "dblclick", (evt) => {
          if (this.isShapeEvent(state, evt)) {
            graph.dblClick(evt, state.cell);
            InternalEvent.consume(evt);
          }
        });
      }
    }
  }
  /**
   * Redraws the label for the given cell state.
   *
   * @param state {@link CellState}  whose label should be redrawn.
   */
  redrawLabel(state, forced) {
    const graph = state.view.graph;
    const value = this.getLabelValue(state);
    const wrapping = graph.isWrapping(state.cell);
    const clipping = graph.isLabelClipped(state.cell);
    const isForceHtml = graph.isHtmlLabel(state.cell) || value && isNode(value);
    const dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;
    const overflow = state.style.overflow ?? "visible";
    if (state.text && (state.text.wrap !== wrapping || state.text.clipped !== clipping || state.text.overflow !== overflow || state.text.dialect !== dialect)) {
      state.text.destroy();
      state.text = null;
    }
    if (state.text == null && value != null && (isNode(value) || value.length > 0)) {
      this.createLabel(state, value);
    } else if (state.text != null && (value == null || value.length == 0)) {
      state.text.destroy();
      state.text = null;
    }
    if (state.text != null) {
      if (forced) {
        if (state.text.lastValue != null && this.isTextShapeInvalid(state, state.text)) {
          state.text.lastValue = null;
        }
        state.text.resetStyles();
        state.text.apply(state);
        state.text.valign = state.getVerticalAlign();
      }
      const bounds = this.getLabelBounds(state);
      const nextScale = this.getTextScale(state);
      this.resolveColor(state, "color", "fontColor");
      if (forced || state.text.value !== value || state.text.wrap !== wrapping || state.text.overflow !== overflow || state.text.clipped !== clipping || state.text.scale !== nextScale || state.text.dialect !== dialect || state.text.bounds == null || !state.text.bounds.equals(bounds)) {
        state.text.dialect = dialect;
        state.text.value = value;
        state.text.bounds = bounds;
        state.text.scale = nextScale;
        state.text.wrap = wrapping;
        state.text.clipped = clipping;
        state.text.overflow = overflow;
        const vis = state.text.node.style.visibility;
        this.redrawLabelShape(state.text);
        state.text.node.style.visibility = vis;
      }
    }
  }
  /**
   * Returns true if the style for the text shape has changed.
   *
   * @param state {@link CellState}  whose label should be checked.
   * @param shape {@link Text} shape to be checked.
   */
  isTextShapeInvalid(state, shape) {
    function check(property, styleName, defaultValue) {
      let result = false;
      if (styleName === "spacingTop" || styleName === "spacingRight" || styleName === "spacingBottom" || styleName === "spacingLeft") {
        result = // @ts-ignore
        parseFloat(String(shape[property])) - parseFloat(String(shape.spacing)) !== (state.style[styleName] || defaultValue);
      } else {
        result = shape[property] !== (state.style[styleName] || defaultValue);
      }
      return result;
    }
    return check("fontStyle", "fontStyle", DEFAULT_FONTSTYLE) || check("family", "fontFamily", DEFAULT_FONTFAMILY) || check("size", "fontSize", DEFAULT_FONTSIZE) || check("color", "fontColor", "black") || check("align", "align", "") || check("valign", "verticalAlign", "") || check("spacing", "spacing", 2) || check("spacingTop", "spacingTop", 0) || check("spacingRight", "spacingRight", 0) || check("spacingBottom", "spacingBottom", 0) || check("spacingLeft", "spacingLeft", 0) || check("horizontal", "horizontal", true) || check("background", "labelBackgroundColor", null) || check("border", "labelBorderColor", null) || check("opacity", "textOpacity", 100) || check("textDirection", "textDirection", DEFAULT_TEXT_DIRECTION);
  }
  /**
   * Called to invoked redraw on the given text shape.
   *
   * @param shape {@link Text} shape to be redrawn.
   */
  redrawLabelShape(shape) {
    shape.redraw();
  }
  /**
   * Returns the scaling used for the label of the given state
   *
   * @param state {@link CellState}  whose label scale should be returned.
   */
  getTextScale(state) {
    return state.view.scale;
  }
  /**
   * Returns the bounds to be used to draw the label of the given state.
   *
   * @param state {@link CellState}  whose label bounds should be returned.
   */
  getLabelBounds(state) {
    const { scale } = state.view;
    const isEdge = state.cell.isEdge();
    let bounds = new Rectangle(state.absoluteOffset.x, state.absoluteOffset.y);
    if (isEdge) {
      const spacing = state.text.getSpacing();
      bounds.x += spacing.x * scale;
      bounds.y += spacing.y * scale;
      const geo = state.cell.getGeometry();
      if (geo != null) {
        bounds.width = Math.max(0, geo.width * scale);
        bounds.height = Math.max(0, geo.height * scale);
      }
    } else {
      if (state.text.isPaintBoundsInverted()) {
        const tmp = bounds.x;
        bounds.x = bounds.y;
        bounds.y = tmp;
      }
      bounds.x += state.x;
      bounds.y += state.y;
      bounds.width = Math.max(1, state.width);
      bounds.height = Math.max(1, state.height);
    }
    if (state.text.isPaintBoundsInverted()) {
      const t = (state.width - state.height) / 2;
      bounds.x += t;
      bounds.y -= t;
      const tmp = bounds.width;
      bounds.width = bounds.height;
      bounds.height = tmp;
    }
    if (state.shape != null) {
      const hpos = state.style.labelPosition ?? ALIGN.CENTER;
      const vpos = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;
      if (hpos === ALIGN.CENTER && vpos === ALIGN.MIDDLE) {
        bounds = state.shape.getLabelBounds(bounds);
      }
    }
    const lw = state.style.labelWidth ?? null;
    if (lw != null) {
      bounds.width = lw * scale;
    }
    if (!isEdge) {
      this.rotateLabelBounds(state, bounds);
    }
    return bounds;
  }
  /**
   * Adds the shape rotation to the given label bounds and
   * applies the alignment and offsets.
   *
   * @param state {@link CellState}  whose label bounds should be rotated.
   * @param bounds {@link Rectangle} the rectangle to be rotated.
   */
  rotateLabelBounds(state, bounds) {
    bounds.y -= state.text.margin.y * bounds.height;
    bounds.x -= state.text.margin.x * bounds.width;
    if (!this.legacySpacing || state.style.overflow !== "fill" && state.style.overflow !== "width") {
      const s = state.view.scale;
      const spacing = state.text.getSpacing();
      bounds.x += spacing.x * s;
      bounds.y += spacing.y * s;
      const hpos = state.style.labelPosition ?? ALIGN.CENTER;
      const vpos = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;
      const lw = state.style.labelWidth ?? null;
      bounds.width = Math.max(0, bounds.width - (hpos === ALIGN.CENTER && lw == null ? (
        // @ts-ignore
        state.text.spacingLeft * s + state.text.spacingRight * s
      ) : 0));
      bounds.height = Math.max(0, bounds.height - (vpos === ALIGN.MIDDLE ? (
        // @ts-ignore
        state.text.spacingTop * s + state.text.spacingBottom * s
      ) : 0));
    }
    const theta = state.text.getTextRotation();
    if (theta !== 0 && state != null && // @ts-ignore
    state.cell.isVertex()) {
      const cx = state.getCenterX();
      const cy = state.getCenterY();
      if (bounds.x !== cx || bounds.y !== cy) {
        const rad = theta * (Math.PI / 180);
        const pt = getRotatedPoint(new Point(bounds.x, bounds.y), Math.cos(rad), Math.sin(rad), new Point(cx, cy));
        bounds.x = pt.x;
        bounds.y = pt.y;
      }
    }
  }
  /**
   * Redraws the overlays for the given cell state.
   *
   * @param state {@link CellState}  whose overlays should be redrawn.
   */
  redrawCellOverlays(state, forced = false) {
    this.createCellOverlays(state);
    if (state.overlays != null) {
      const rot = mod(state.style.rotation ?? 0, 90);
      const rad = toRadians(rot);
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      state.overlays.visit((id, shape) => {
        const bounds = shape.overlay.getBounds(state);
        if (!state.cell.isEdge()) {
          if (state.shape != null && rot !== 0) {
            let cx = bounds.getCenterX();
            let cy = bounds.getCenterY();
            const point = getRotatedPoint(new Point(cx, cy), cos, sin, new Point(state.getCenterX(), state.getCenterY()));
            cx = point.x;
            cy = point.y;
            bounds.x = Math.round(cx - bounds.width / 2);
            bounds.y = Math.round(cy - bounds.height / 2);
          }
        }
        if (forced || shape.bounds == null || shape.scale !== state.view.scale || !shape.bounds.equals(bounds)) {
          shape.bounds = bounds;
          shape.scale = state.view.scale;
          shape.redraw();
        }
      });
    }
  }
  /**
   * Redraws the control for the given cell state.
   *
   * @param state {@link CellState}  whose control should be redrawn.
   */
  redrawControl(state, forced = false) {
    const image = state.view.graph.getFoldingImage(state);
    if (state.control != null && image != null) {
      const bounds = this.getControlBounds(state, image.width, image.height);
      const r = this.legacyControlPosition ? state.style.rotation ?? 0 : state.shape.getTextRotation();
      const s = state.view.scale;
      if (forced || state.control.scale !== s || !state.control.bounds.equals(bounds) || state.control.rotation !== r) {
        state.control.rotation = r;
        state.control.bounds = bounds;
        state.control.scale = s;
        state.control.redraw();
      }
    }
  }
  /**
   * Returns the bounds to be used to draw the control (folding icon) of the given state.
   */
  getControlBounds(state, w, h) {
    if (state.control != null) {
      const s = state.view.scale;
      let cx = state.getCenterX();
      let cy = state.getCenterY();
      if (!state.cell.isEdge()) {
        cx = state.x + w * s;
        cy = state.y + h * s;
        if (state.shape != null) {
          let rot = state.shape.getShapeRotation();
          if (this.legacyControlPosition) {
            rot = state.style.rotation ?? 0;
          } else if (state.shape.isPaintBoundsInverted()) {
            const t = (state.width - state.height) / 2;
            cx += t;
            cy -= t;
          }
          if (rot !== 0) {
            const rad = toRadians(rot);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            const point = getRotatedPoint(new Point(cx, cy), cos, sin, new Point(state.getCenterX(), state.getCenterY()));
            cx = point.x;
            cy = point.y;
          }
        }
      }
      return state.cell.isEdge() ? new Rectangle(Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s)) : new Rectangle(Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s));
    }
    return null;
  }
  /**
   * Inserts the given {@link CellState} after the given nodes in the DOM.
   *
   * @param state {@link CellState} to be inserted.
   * @param node Node in {@link GraphView.drawPane} after which the shapes should be inserted.
   * @param htmlNode Node in the graph container after which the shapes should be inserted that
   * will not go into the {@link GraphView.drawPane} (e.g. HTML labels without foreignObjects).
   */
  insertStateAfter(state, node, htmlNode) {
    const graph = state.view.graph;
    const shapes = this.getShapesForState(state);
    for (let i = 0; i < shapes.length; i += 1) {
      if (shapes[i] != null && shapes[i].node != null) {
        const html = (
          // @ts-ignore
          shapes[i].node.parentNode !== state.view.getDrawPane() && // @ts-ignore
          shapes[i].node.parentNode !== state.view.getOverlayPane()
        );
        const temp = html ? htmlNode : node;
        if (temp != null && temp.nextSibling !== shapes[i].node) {
          if (temp.nextSibling == null) {
            temp.parentNode.appendChild(shapes[i].node);
          } else {
            temp.parentNode.insertBefore(shapes[i].node, temp.nextSibling);
          }
        } else if (temp == null) {
          const shapeNode = shapes[i].node;
          if (shapeNode.parentNode === graph.container) {
            let { canvas } = state.view;
            while (canvas != null && canvas.parentNode !== graph.container) {
              canvas = canvas.parentNode;
            }
            if (canvas != null && canvas.nextSibling != null) {
              if (canvas.nextSibling !== shapeNode) {
                shapeNode.parentNode.insertBefore(shapeNode, canvas.nextSibling);
              }
            } else {
              shapeNode.parentNode.appendChild(shapeNode);
            }
          } else if (shapeNode.parentNode != null && shapeNode.parentNode.firstChild != null && shapeNode.parentNode.firstChild != shapeNode) {
            shapeNode.parentNode.insertBefore(shapeNode, shapeNode.parentNode.firstChild);
          }
        }
        if (html) {
          htmlNode = shapes[i].node;
        } else {
          node = shapes[i].node;
        }
      }
    }
    return [node, htmlNode];
  }
  /**
   * Returns the {@link Shape}s for the given cell state in the order in which they should appear in the DOM.
   *
   * @param state {@link CellState}  whose shapes should be returned.
   */
  getShapesForState(state) {
    return [state.shape, state.text, state.control];
  }
  /**
   * Updates the bounds or points and scale of the shapes for the given cell
   * state. This is called in mxGraphView.validatePoints as the last step of
   * updating all cells.
   *
   * @param state {@link CellState}  for which the shapes should be updated.
   * @param force Optional boolean that specifies if the cell should be reconfiured
   * and redrawn without any additional checks.
   * @param rendering Optional boolean that specifies if the cell should actually
   * be drawn into the DOM. If this is false then redraw and/or reconfigure
   * will not be called on the shape.
   */
  redraw(state, force = false, rendering = true) {
    const shapeChanged = this.redrawShape(state, force, rendering);
    if (state.shape != null && rendering) {
      this.redrawLabel(state, shapeChanged);
      this.redrawCellOverlays(state, shapeChanged);
      this.redrawControl(state, shapeChanged);
    }
  }
  /**
   * Redraws the shape for the given cell state.
   *
   * @param state {@link CellState}  whose label should be redrawn.
   */
  redrawShape(state, force = false, rendering = true) {
    let shapeChanged = false;
    const graph = state.view.graph;
    if (state.shape != null && state.shape.style != null && state.style != null && state.shape.style.shape !== state.style.shape) {
      state.shape.destroy();
      state.shape = null;
    }
    const selectionCellsHandler = graph.getPlugin("SelectionCellsHandler");
    if (state.shape == null && graph.container != null && state.cell !== state.view.currentRoot && (state.cell.isVertex() || state.cell.isEdge())) {
      state.shape = this.createShape(state);
      if (state.shape != null) {
        state.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;
        state.shape.antiAlias = this.antiAlias;
        this.createIndicatorShape(state);
        this.initializeShape(state);
        this.createCellOverlays(state);
        this.installListeners(state);
        selectionCellsHandler == null ? void 0 : selectionCellsHandler.updateHandler(state);
      }
    } else if (!force && state.shape != null && (!equalEntries(state.shape.style, state.style) || this.checkPlaceholderStyles(state))) {
      state.shape.resetStyles();
      this.configureShape(state);
      selectionCellsHandler == null ? void 0 : selectionCellsHandler.updateHandler(state);
      force = true;
    }
    if (state.shape != null && state.shape.indicatorShape != this.getShape(state.getIndicatorShape())) {
      if (state.shape.indicator != null) {
        state.shape.indicator.destroy();
        state.shape.indicator = null;
      }
      this.createIndicatorShape(state);
      if (state.shape.indicatorShape != null) {
        state.shape.indicator = new state.shape.indicatorShape();
        state.shape.indicator.dialect = state.shape.dialect;
        state.shape.indicator.init(state.node);
        force = true;
      }
    }
    if (state.shape) {
      this.createControl(state);
      if (force || this.isShapeInvalid(state, state.shape)) {
        if (state.absolutePoints.length > 0) {
          state.shape.points = state.absolutePoints.slice();
          state.shape.bounds = null;
        } else {
          state.shape.points = [];
          state.shape.bounds = new Rectangle(state.x, state.y, state.width, state.height);
        }
        state.shape.scale = state.view.scale;
        if (rendering == null || rendering) {
          this.doRedrawShape(state);
        } else {
          state.shape.updateBoundingBox();
        }
        shapeChanged = true;
      }
    }
    return shapeChanged;
  }
  /**
   * Invokes redraw on the shape of the given state.
   */
  doRedrawShape(state) {
    var _a;
    (_a = state.shape) == null ? void 0 : _a.redraw();
  }
  /**
   * Returns true if the given shape must be repainted.
   */
  isShapeInvalid(state, shape) {
    return shape.bounds == null || shape.scale !== state.view.scale || state.absolutePoints.length === 0 && !shape.bounds.equals(state) || state.absolutePoints.length > 0 && !equalPoints(shape.points, state.absolutePoints);
  }
  /**
   * Destroys the shapes associated with the given cell state.
   *
   * @param state {@link CellState}  for which the shapes should be destroyed.
   */
  destroy(state) {
    if (state.shape) {
      if (state.text) {
        state.text.destroy();
        state.text = null;
      }
      state.overlays.visit((id, shape) => {
        shape.destroy();
      });
      state.overlays = new Dictionary();
      if (state.control) {
        state.control.destroy();
        state.control = null;
      }
      state.shape.destroy();
      state.shape = null;
    }
  }
}
CellRenderer.defaultShapes = {};
class ChildChange {
  constructor(model, parent, child, index = 0) {
    this.model = model;
    this.parent = parent;
    this.previous = parent;
    this.child = child;
    this.index = index;
    this.previousIndex = index;
  }
  /**
   * Changes the parent of {@link child} using {@link GraphDataModel.parentForCellChanged} and removes or restores the cell's connections.
   */
  execute() {
    let tmp = this.child.getParent();
    const tmp2 = tmp ? tmp.getIndex(this.child) : 0;
    if (!this.previous) {
      this.connect(this.child, false);
    }
    tmp = this.model.parentForCellChanged(this.child, this.previous, this.previousIndex);
    if (this.previous) {
      this.connect(this.child, true);
    }
    this.parent = this.previous;
    this.previous = tmp;
    this.index = this.previousIndex;
    this.previousIndex = tmp2;
  }
  /**
   * Disconnects the given cell recursively from its
   * terminals and stores the previous terminal in the
   * cell's terminals.
   *
   * @warning doc from mxGraph source code is incorrect
   */
  connect(cell, isConnect = true) {
    const source = cell.getTerminal(true);
    const target = cell.getTerminal(false);
    if (source) {
      if (isConnect) {
        this.model.terminalForCellChanged(cell, source, true);
      } else {
        this.model.terminalForCellChanged(cell, null, true);
      }
    }
    if (target) {
      if (isConnect) {
        this.model.terminalForCellChanged(cell, target, false);
      } else {
        this.model.terminalForCellChanged(cell, null, false);
      }
    }
    cell.setTerminal(source, true);
    cell.setTerminal(target, false);
    const childCount = cell.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      this.connect(cell.getChildAt(i), isConnect);
    }
  }
}
class CollapseChange {
  constructor(model, cell, collapsed) {
    this.model = model;
    this.cell = cell;
    this.collapsed = collapsed;
    this.previous = collapsed;
  }
  /**
   * Changes the collapsed state of {@link cell} to {@link previous} using {@link GraphDataModel.collapsedStateForCellChanged}.
   */
  execute() {
    this.collapsed = this.previous;
    this.previous = this.model.collapsedStateForCellChanged(this.cell, this.previous);
  }
}
class GeometryChange {
  constructor(model, cell, geometry) {
    this.model = model;
    this.cell = cell;
    this.geometry = geometry;
    this.previous = geometry;
  }
  /**
   * Changes the geometry of {@link cell} to {@link previous} using{@link GraphDataModel.geometryForCellChanged}.
   */
  execute() {
    this.geometry = this.previous;
    this.previous = this.model.geometryForCellChanged(this.cell, this.previous);
  }
}
class RootChange {
  constructor(model, root) {
    this.model = model;
    this.root = root;
    this.previous = root;
  }
  /**
   * Carries out a change of the root using {@link GraphDataModel.rootChanged}.
   */
  execute() {
    this.root = this.previous;
    this.previous = this.model.rootChanged(this.previous);
  }
}
class StyleChange {
  constructor(model, cell, style) {
    this.model = model;
    this.cell = cell;
    this.style = style;
    this.previous = style;
  }
  /**
   * Changes the style of {@link cell} to {@link previous} using {@link GraphDataModel.styleForCellChanged}.
   */
  execute() {
    this.style = this.previous;
    this.previous = this.model.styleForCellChanged(this.cell, this.previous);
  }
}
class TerminalChange {
  constructor(model, cell, terminal, source) {
    this.model = model;
    this.cell = cell;
    this.terminal = terminal;
    this.previous = terminal;
    this.source = source;
  }
  /**
   * Changes the terminal of {@link cell} to {@link previous} using {@link GraphDataModel.terminalForCellChanged}.
   */
  execute() {
    this.terminal = this.previous;
    this.previous = this.model.terminalForCellChanged(this.cell, this.previous, this.source);
  }
}
class ValueChange {
  constructor(model, cell, value) {
    this.model = model;
    this.cell = cell;
    this.value = value;
    this.previous = value;
  }
  /**
   * Changes the value of {@link cell} to {@link previous} using {@link GraphDataModel.valueForCellChanged}.
   */
  execute() {
    this.value = this.previous;
    this.previous = this.model.valueForCellChanged(this.cell, this.previous);
  }
}
class VisibleChange {
  constructor(model, cell, visible) {
    this.model = model;
    this.cell = cell;
    this.visible = visible;
    this.previous = visible;
  }
  /**
   * Changes the visible state of {@link cell} to {@link previous} using {@link GraphDataModel.visibleStateForCellChanged}.
   */
  execute() {
    this.visible = this.previous;
    this.previous = this.model.visibleStateForCellChanged(this.cell, this.previous);
  }
}
class GraphDataModel extends EventSource {
  constructor(root = null) {
    super();
    this.root = null;
    this.cells = {};
    this.maintainEdgeParent = true;
    this.ignoreRelativeEdgeParent = true;
    this.createIds = true;
    this.prefix = "";
    this.postfix = "";
    this.nextId = 0;
    this.currentEdit = null;
    this.updateLevel = 0;
    this.endingUpdate = false;
    this.currentEdit = this.createUndoableEdit();
    if (root != null) {
      this.setRoot(root);
    } else {
      this.clear();
    }
  }
  /**
   * Sets a new root using {@link createRoot}.
   */
  clear() {
    this.setRoot(this.createRoot());
  }
  /**
   * Returns {@link createIds}.
   */
  isCreateIds() {
    return this.createIds;
  }
  /**
   * Sets {@link createIds}.
   */
  setCreateIds(value) {
    this.createIds = value;
  }
  /**
   * Creates a new root cell with a default layer (child 0).
   */
  createRoot() {
    const cell = new Cell();
    cell.insert(new Cell());
    return cell;
  }
  /**
   * Returns the {@link Cell} for the specified Id or null if no cell can be
   * found for the given Id.
   *
   * @param {string} id  A string representing the Id of the cell.
   */
  getCell(id) {
    return this.cells ? this.cells[id] : null;
  }
  filterCells(cells, filter) {
    return cells.filter(filter);
  }
  getRoot(cell = null) {
    return cell ? cell.getRoot() : this.root;
  }
  /**
   * Sets the {@link root} of the model using {@link RootChange} and adds the change to
   * the current transaction. This resets all datastructures in the model and
   * is the preferred way of clearing an existing model. Returns the new
   * root.
   *
   * Example:
   *
   * ```javascript
   * var root = new mxCell();
   * root.insert(new mxCell());
   * model.setRoot(root);
   * ```
   *
   * @param {Cell} root  that specifies the new root.
   */
  setRoot(root) {
    this.execute(new RootChange(this, root));
    return root;
  }
  /**
   * Inner callback to change the root of the model and update the internal
   * datastructures, such as {@link cells} and {@link nextId}. Returns the previous root.
   *
   * @param {Cell} root  that specifies the new root.
   */
  rootChanged(root) {
    const oldRoot = this.root;
    this.root = root;
    this.nextId = 0;
    this.cells = null;
    this.cellAdded(root);
    return oldRoot;
  }
  /**
   * Returns true if the given cell is the root of the model and a non-null
   * value.
   *
   * @param {Cell} cell  that represents the possible root.
   */
  isRoot(cell = null) {
    return cell != null && this.root === cell;
  }
  /**
   * Returns true if {@link isRoot} returns true for the parent of the given cell.
   *
   * @param cell  that represents the possible layer.
   */
  isLayer(cell) {
    return cell ? this.isRoot(cell.getParent()) : false;
  }
  /**
   * Returns true if the model contains the given {@link Cell}.
   *
   * @param {Cell} cell  that specifies the cell.
   */
  contains(cell) {
    return this.root.isAncestor(cell);
  }
  /**
   * Adds the specified child to the parent at the given index using
   * {@link ChildChange} and adds the change to the current transaction. If no
   * index is specified then the child is appended to the parent's array of
   * children. Returns the inserted child.
   *
   * @param {Cell} parent  that specifies the parent to contain the child.
   * @param {Cell} child  that specifies the child to be inserted.
   * @param index  Optional integer that specifies the index of the child.
   */
  add(parent, child, index = null) {
    if (child !== parent && parent != null && child != null) {
      if (index == null) {
        index = parent.getChildCount();
      }
      const parentChanged = parent !== child.getParent();
      this.execute(new ChildChange(this, parent, child, index));
      if (this.maintainEdgeParent && parentChanged) {
        this.updateEdgeParents(child);
      }
    }
    return child;
  }
  /**
   * Inner callback to update {@link cells} when a cell has been added. This
   * implementation resolves collisions by creating new Ids. To change the
   * ID of a cell after it was inserted into the model, use the following
   * code:
   *
   * (code
   * delete model.cells[cell.getId()];
   * cell.setId(newId);
   * model.cells[cell.getId()] = cell;
   * ```
   *
   * If the change of the ID should be part of the command history, then the
   * cell should be removed from the model and a clone with the new ID should
   * be reinserted into the model instead.
   *
   * @param {Cell} cell  that specifies the cell that has been added.
   */
  cellAdded(cell) {
    if (cell != null) {
      if (cell.getId() == null && this.createIds) {
        cell.setId(this.createId(cell));
      }
      if (cell.getId() != null) {
        let collision = this.getCell(cell.getId());
        if (collision !== cell) {
          while (collision != null) {
            cell.setId(this.createId(cell));
            collision = this.getCell(cell.getId());
          }
          if (this.cells == null) {
            this.cells = {};
          }
          this.cells[cell.getId()] = cell;
        }
      }
      if (isNumeric(String(cell.getId()))) {
        this.nextId = Math.max(this.nextId, parseInt(cell.getId()));
      }
      for (const child of cell.getChildren()) {
        this.cellAdded(child);
      }
    }
  }
  /**
   * Hook method to create an Id for the specified cell. This implementation
   * concatenates {@link prefix}, id and {@link postfix} to create the Id and increments
   * {@link nextId}. The cell is ignored by this implementation, but can be used in
   * overridden methods to prefix the Ids with eg. the cell type.
   *
   * @param {Cell} cell  to create the Id for.
   */
  createId(cell) {
    const id = this.nextId;
    this.nextId++;
    return this.prefix + id + this.postfix;
  }
  /**
   * Updates the parent for all edges that are connected to cell or one of
   * its descendants using {@link updateEdgeParent}.
   */
  updateEdgeParents(cell, root = this.getRoot(cell)) {
    const childCount = cell.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      const child = cell.getChildAt(i);
      this.updateEdgeParents(child, root);
    }
    const edgeCount = cell.getEdgeCount();
    const edges = [];
    for (let i = 0; i < edgeCount; i += 1) {
      edges.push(cell.getEdgeAt(i));
    }
    for (let i = 0; i < edges.length; i += 1) {
      const edge = edges[i];
      if (root.isAncestor(edge)) {
        this.updateEdgeParent(edge, root);
      }
    }
  }
  /**
   * Inner callback to update the parent of the specified {@link Cell} to the
   * nearest-common-ancestor of its two terminals.
   *
   * @param {Cell} edge  that specifies the edge.
   * @param {Cell} root  that represents the current root of the model.
   */
  updateEdgeParent(edge, root) {
    let source = edge.getTerminal(true);
    let target = edge.getTerminal(false);
    let cell = null;
    while (source != null && !source.isEdge() && source.geometry != null && source.geometry.relative) {
      source = source.getParent();
    }
    while (target != null && this.ignoreRelativeEdgeParent && !target.isEdge() && target.geometry != null && target.geometry.relative) {
      target = target.getParent();
    }
    if (root.isAncestor(source) && root.isAncestor(target)) {
      if (source === target) {
        cell = source ? source.getParent() : null;
      } else if (source) {
        cell = source.getNearestCommonAncestor(target);
      }
      if (cell != null && (cell.getParent() !== this.root || cell.isAncestor(edge)) && edge && edge.getParent() !== cell) {
        let geo = edge.getGeometry();
        if (geo != null) {
          const origin1 = edge.getParent().getOrigin();
          const origin2 = cell.getOrigin();
          const dx = origin2.x - origin1.x;
          const dy = origin2.y - origin1.y;
          geo = geo.clone();
          geo.translate(-dx, -dy);
          this.setGeometry(edge, geo);
        }
        this.add(cell, edge, cell.getChildCount());
      }
    }
  }
  /**
   * Removes the specified cell from the model using {@link ChildChange} and adds
   * the change to the current transaction. This operation will remove the
   * cell and all of its children from the model. Returns the removed cell.
   *
   * @param {Cell} cell  that should be removed.
   */
  remove(cell) {
    if (cell === this.root) {
      this.setRoot(null);
    } else if (cell.getParent() != null) {
      this.execute(new ChildChange(this, null, cell));
    }
    return cell;
  }
  /**
   * Inner callback to update {@link cells} when a cell has been removed.
   *
   * @param {Cell} cell  that specifies the cell that has been removed.
   */
  cellRemoved(cell) {
    if (cell != null && this.cells != null) {
      const childCount = cell.getChildCount();
      for (let i = childCount - 1; i >= 0; i--) {
        this.cellRemoved(cell.getChildAt(i));
      }
      if (this.cells != null && cell.getId() != null) {
        delete this.cells[cell.getId()];
      }
    }
  }
  /**
   * Inner callback to update the parent of a cell using {@link Cell#insert}
   * on the parent and return the previous parent.
   *
   * @param {Cell} cell  to update the parent for.
   * @param {Cell} parent  that specifies the new parent of the cell.
   * @param index  Optional integer that defines the index of the child
   * in the parent's child array.
   */
  parentForCellChanged(cell, parent, index) {
    const previous = cell.getParent();
    if (parent != null) {
      if (parent !== previous || previous.getIndex(cell) !== index) {
        parent.insert(cell, index);
      }
    } else if (previous != null) {
      const oldIndex = previous.getIndex(cell);
      previous.remove(oldIndex);
    }
    const par = parent ? this.contains(parent) : null;
    const pre = this.contains(previous);
    if (par && !pre) {
      this.cellAdded(cell);
    } else if (pre && !par) {
      this.cellRemoved(cell);
    }
    return previous;
  }
  /**
   * Sets the source or target terminal of the given {@link Cell} using
   * {@link TerminalChange} and adds the change to the current transaction.
   * This implementation updates the parent of the edge using {@link updateEdgeParent}
   * if required.
   *
   * @param {Cell} edge  that specifies the edge.
   * @param {Cell} terminal  that specifies the new terminal.
   * @param isSource  Boolean indicating if the terminal is the new source or
   * target terminal of the edge.
   */
  // setTerminal(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;
  setTerminal(edge, terminal, isSource) {
    const terminalChanged = terminal !== edge.getTerminal(isSource);
    this.execute(new TerminalChange(this, edge, terminal, isSource));
    if (this.maintainEdgeParent && terminalChanged) {
      this.updateEdgeParent(edge, this.getRoot());
    }
    return terminal;
  }
  /**
   * Sets the source and target {@link Cell} of the given {@link Cell} in a single
   * transaction using {@link setTerminal} for each end of the edge.
   *
   * @param {Cell} edge  that specifies the edge.
   * @param {Cell} source  that specifies the new source terminal.
   * @param {Cell} target  that specifies the new target terminal.
   */
  // setTerminals(edge: mxCell, source: mxCell, target: mxCell): void;
  setTerminals(edge, source, target) {
    this.beginUpdate();
    try {
      this.setTerminal(edge, source, true);
      this.setTerminal(edge, target, false);
    } finally {
      this.endUpdate();
    }
  }
  /**
   * Inner helper function to update the terminal of the edge using
   * {@link Cell#insertEdge} and return the previous terminal.
   *
   * @param {Cell} edge  that specifies the edge to be updated.
   * @param {Cell} terminal  that specifies the new terminal.
   * @param isSource  Boolean indicating if the terminal is the new source or
   * target terminal of the edge.
   */
  // terminalForCellChanged(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;
  terminalForCellChanged(edge, terminal, isSource = false) {
    const previous = edge.getTerminal(isSource);
    if (terminal != null) {
      terminal.insertEdge(edge, isSource);
    } else if (previous != null) {
      previous.removeEdge(edge, isSource);
    }
    return previous;
  }
  /**
   * Returns all edges between the given source and target pair. If directed
   * is true, then only edges from the source to the target are returned,
   * otherwise, all edges between the two cells are returned.
   *
   * @param {Cell} source  that defines the source terminal of the edge to be
   * returned.
   * @param {Cell} target  that defines the target terminal of the edge to be
   * returned.
   * @param directed  Optional boolean that specifies if the direction of the
   * edge should be taken into account. Default is false.
   */
  getEdgesBetween(source, target, directed = false) {
    const tmp1 = source.getEdgeCount();
    const tmp2 = target.getEdgeCount();
    let terminal = source;
    let edgeCount = tmp1;
    if (tmp2 < tmp1) {
      edgeCount = tmp2;
      terminal = target;
    }
    const result = [];
    for (let i = 0; i < edgeCount; i += 1) {
      const edge = terminal.getEdgeAt(i);
      const src = edge.getTerminal(true);
      const trg = edge.getTerminal(false);
      const directedMatch = src === source && trg === target;
      const oppositeMatch = trg === source && src === target;
      if (directedMatch || !directed && oppositeMatch) {
        result.push(edge);
      }
    }
    return result;
  }
  /**
   * Sets the user object of then given {@link Cell} using {@link ValueChange}
   * and adds the change to the current transaction.
   *
   * @param {Cell} cell  whose user object should be changed.
   * @param value  Object that defines the new user object.
   */
  setValue(cell, value) {
    this.execute(new ValueChange(this, cell, value));
    return value;
  }
  /**
   * Inner callback to update the user object of the given {@link Cell}
   * using {@link Cell#valueChanged} and return the previous value,
   * that is, the return value of {@link Cell#valueChanged}.
   *
   * To change a specific attribute in an XML node, the following code can be
   * used.
   *
   * ```javascript
   * graph.getDataModel().valueForCellChanged(cell, value)
   * {
   *   var previous = cell.value.getAttribute('label');
   *   cell.value.setAttribute('label', value);
   *
   *   return previous;
   * };
   * ```
   */
  valueForCellChanged(cell, value) {
    return cell.valueChanged(value);
  }
  /**
   * Sets the {@link Geometry} of the given {@link Cell}. The actual update
   * of the cell is carried out in {@link geometryForCellChanged}. The
   * {@link GeometryChange} action is used to encapsulate the change.
   *
   * @param {Cell} cell  whose geometry should be changed.
   * @param {Geometry} geometry  that defines the new geometry.
   */
  setGeometry(cell, geometry) {
    if (geometry !== cell.getGeometry()) {
      this.execute(new GeometryChange(this, cell, geometry));
    }
    return geometry;
  }
  /**
   * Inner callback to update the {@link Geometry} of the given {@link Cell} using
   * {@link Cell#setGeometry} and return the previous {@link Geometry}.
   */
  geometryForCellChanged(cell, geometry) {
    const previous = cell.getGeometry();
    cell.setGeometry(geometry);
    return previous;
  }
  /**
   * Sets the style of the given {@link Cell} using {@link StyleChange} and adds the change to the current transaction.
   *
   * **IMPORTANT**: Do not pass {@link Cell.getStyle} as value of the `style` parameter. Otherwise, no style change is performed, so the view won't be updated.
   * Always get a clone of the style of the cell with {@link Cell.getClonedStyle}, then update it and pass the updated style to this method.
   *
   * @param cell  whose style should be changed.
   * @param style the new cell style to set.
   */
  setStyle(cell, style) {
    if (style !== cell.getStyle()) {
      this.execute(new StyleChange(this, cell, style));
    }
  }
  /**
   * Inner callback to update the style of the given {@link Cell}  using {@link Cell#setStyle} and return the previous style.
   *
   * **IMPORTANT**: to fully work, this method should not receive `cell.getStyle` as value of the `style` parameter. See {@link setStyle} for more information.
   *
   * @param cell  whose style should be changed.
   * @param style the new cell style to set.
   */
  styleForCellChanged(cell, style) {
    const previous = cell.getStyle();
    cell.setStyle(style);
    return previous;
  }
  /**
   * Sets the collapsed state of the given {@link Cell} using {@link CollapseChange}
   * and adds the change to the current transaction.
   *
   * @param {Cell} cell  whose collapsed state should be changed.
   * @param collapsed  Boolean that specifies the new collpased state.
   */
  setCollapsed(cell, collapsed) {
    if (collapsed !== cell.isCollapsed()) {
      this.execute(new CollapseChange(this, cell, collapsed));
    }
    return collapsed;
  }
  /**
   * Inner callback to update the collapsed state of the
   * given {@link Cell} using {@link Cell#setCollapsed} and return
   * the previous collapsed state.
   *
   * @param {Cell} cell  that specifies the cell to be updated.
   * @param collapsed  Boolean that specifies the new collapsed state.
   */
  collapsedStateForCellChanged(cell, collapsed) {
    const previous = cell.isCollapsed();
    cell.setCollapsed(collapsed);
    return previous;
  }
  /**
   * Sets the visible state of the given {@link Cell} using {@link VisibleChange} and
   * adds the change to the current transaction.
   *
   * @param {Cell} cell  whose visible state should be changed.
   * @param visible  Boolean that specifies the new visible state.
   */
  setVisible(cell, visible) {
    if (visible !== cell.isVisible()) {
      this.execute(new VisibleChange(this, cell, visible));
    }
    return visible;
  }
  /**
   * Inner callback to update the visible state of the
   * given {@link Cell} using {@link Cell#setCollapsed} and return
   * the previous visible state.
   *
   * @param {Cell} cell  that specifies the cell to be updated.
   * @param visible  Boolean that specifies the new visible state.
   */
  visibleStateForCellChanged(cell, visible) {
    const previous = cell.isVisible();
    cell.setVisible(visible);
    return previous;
  }
  /**
   * Executes the given edit and fires events if required. The edit object
   * requires an execute function which is invoked. The edit is added to the
   * {@link currentEdit} between {@link beginUpdate} and {@link endUpdate} calls, so that
   * events will be fired if this execute is an individual transaction, that
   * is, if no previous {@link beginUpdate} calls have been made without calling
   * {@link endUpdate}. This implementation fires an {@link execute} event before
   * executing the given change.
   *
   * @param change  Object that described the change.
   */
  execute(change) {
    change.execute();
    this.beginUpdate();
    this.currentEdit.add(change);
    this.fireEvent(new EventObject(InternalEvent.EXECUTE, { change }));
    this.fireEvent(new EventObject(InternalEvent.EXECUTED, { change }));
    this.endUpdate();
  }
  /**
   * Updates the model in a transaction.
   * This is a shortcut to the usage of {@link beginUpdate} and the {@link endUpdate} methods.
   *
   * ```javascript
   * const model = graph.getDataModel();
   * const parent = graph.getDefaultParent();
   * const index = model.getChildCount(parent);
   * model.batchUpdate(() => {
   *   model.add(parent, v1, index);
   *   model.add(parent, v2, index+1);
   * });
   * ```
   *
   * @param fn the update to be performed in the transaction.
   */
  batchUpdate(fn) {
    this.beginUpdate();
    try {
      fn();
    } finally {
      this.endUpdate();
    }
  }
  /**
   * Increments the {@link updateLevel} by one. The event notification
   * is queued until {@link updateLevel} reaches 0 by use of
   * {@link endUpdate}.
   *
   * All changes on {@link GraphDataModel} are transactional,
   * that is, they are executed in a single undoable change
   * on the model (without transaction isolation).
   * Therefore, if you want to combine any
   * number of changes into a single undoable change,
   * you should group any two or more API calls that
   * modify the graph model between {@link beginUpdate}
   * and {@link endUpdate} calls as shown here:
   *
   * ```javascript
   * const model = graph.getDataModel();
   * const parent = graph.getDefaultParent();
   * const index = model.getChildCount(parent);
   * model.beginUpdate();
   * try
   * {
   *   model.add(parent, v1, index);
   *   model.add(parent, v2, index+1);
   * }
   * finally
   * {
   *   model.endUpdate();
   * }
   * ```
   *
   * Of course there is a shortcut for appending a
   * sequence of cells into the default parent:
   *
   * ```javascript
   * graph.addCells([v1, v2]).
   * ```
   */
  beginUpdate() {
    this.updateLevel += 1;
    this.fireEvent(new EventObject(InternalEvent.BEGIN_UPDATE));
    if (this.updateLevel === 1) {
      this.fireEvent(new EventObject(InternalEvent.START_EDIT));
    }
  }
  /**
   * Decrements the {@link updateLevel} by one and fires an {@link undo}
   * event if the {@link updateLevel} reaches 0. This function
   * indirectly fires a {@link change} event by invoking the notify
   * function on the {@link currentEdit} und then creates a new
   * {@link currentEdit} using {@link createUndoableEdit}.
   *
   * The {@link undo} event is fired only once per edit, whereas
   * the {@link change} event is fired whenever the notify
   * function is invoked, that is, on undo and redo of
   * the edit.
   */
  endUpdate() {
    this.updateLevel -= 1;
    if (this.updateLevel === 0) {
      this.fireEvent(new EventObject(InternalEvent.END_EDIT));
    }
    if (!this.endingUpdate) {
      this.endingUpdate = this.updateLevel === 0;
      this.fireEvent(new EventObject(InternalEvent.END_UPDATE, { edit: this.currentEdit }));
      try {
        if (this.endingUpdate && !this.currentEdit.isEmpty()) {
          this.fireEvent(new EventObject(InternalEvent.BEFORE_UNDO, { edit: this.currentEdit }));
          const tmp = this.currentEdit;
          this.currentEdit = this.createUndoableEdit();
          tmp.notify();
          this.fireEvent(new EventObject(InternalEvent.UNDO, { edit: tmp }));
        }
      } finally {
        this.endingUpdate = false;
      }
    }
  }
  /**
   * Creates a new {@link UndoableEdit} that implements the
   * notify function to fire a {@link change} and {@link notify} event
   * through the {@link UndoableEdit}'s source.
   *
   * @param significant  Optional boolean that specifies if the edit to be created is
   * significant. Default is true.
   */
  createUndoableEdit(significant = true) {
    const edit = new UndoableEdit(this, significant);
    edit.notify = () => {
      edit.source.fireEvent(new EventObject(InternalEvent.CHANGE, { edit, changes: edit.changes }));
      edit.source.fireEvent(new EventObject(InternalEvent.NOTIFY, { edit, changes: edit.changes }));
    };
    return edit;
  }
  /**
   * Merges the children of the given cell into the given target cell inside
   * this model. All cells are cloned unless there is a corresponding cell in
   * the model with the same id, in which case the source cell is ignored and
   * all edges are connected to the corresponding cell in this model. Edges
   * are considered to have no identity and are always cloned unless the
   * cloneAllEdges flag is set to false, in which case edges with the same
   * id in the target model are reconnected to reflect the terminals of the
   * source edges.
   */
  mergeChildren(from, to, cloneAllEdges = true) {
    this.beginUpdate();
    try {
      const mapping = {};
      this.mergeChildrenImpl(from, to, cloneAllEdges, mapping);
      for (const key in mapping) {
        const cell = mapping[key];
        let terminal = cell.getTerminal(true);
        if (terminal != null) {
          terminal = mapping[CellPath.create(terminal)];
          this.setTerminal(cell, terminal, true);
        }
        terminal = cell.getTerminal(false);
        if (terminal != null) {
          terminal = mapping[CellPath.create(terminal)];
          this.setTerminal(cell, terminal, false);
        }
      }
    } finally {
      this.endUpdate();
    }
  }
  /**
   * Clones the children of the source cell into the given target cell in
   * this model and adds an entry to the mapping that maps from the source
   * cell to the target cell with the same id or the clone of the source cell
   * that was inserted into this model.
   */
  mergeChildrenImpl(from, to, cloneAllEdges, mapping = {}) {
    this.beginUpdate();
    try {
      const childCount = from.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        const cell = from.getChildAt(i);
        if (typeof cell.getId === "function") {
          const id = cell.getId();
          let target = id != null && (!cell.isEdge() || !cloneAllEdges) ? this.getCell(id) : null;
          if (target == null) {
            const clone2 = cell.clone();
            clone2.setId(id);
            clone2.setTerminal(cell.getTerminal(true), true);
            clone2.setTerminal(cell.getTerminal(false), false);
            target = to.insert(clone2);
            this.cellAdded(target);
          }
          mapping[CellPath.create(cell)] = target;
          this.mergeChildrenImpl(cell, target, cloneAllEdges, mapping);
        }
      }
    } finally {
      this.endUpdate();
    }
  }
}
class Stylesheet {
  constructor() {
    this.styles = /* @__PURE__ */ new Map();
    this.putDefaultVertexStyle(this.createDefaultVertexStyle());
    this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());
  }
  /**
   * Creates and returns the default vertex style.
   */
  createDefaultVertexStyle() {
    const style = {};
    style.shape = SHAPE.RECTANGLE;
    style.perimeter = "rectanglePerimeter";
    style.verticalAlign = ALIGN.MIDDLE;
    style.align = ALIGN.CENTER;
    style.fillColor = "#C3D9FF";
    style.strokeColor = "#6482B9";
    style.fontColor = "#774400";
    return style;
  }
  /**
   * Creates and returns the default edge style.
   */
  createDefaultEdgeStyle() {
    const style = {};
    style.shape = SHAPE.CONNECTOR;
    style.endArrow = ARROW.CLASSIC;
    style.verticalAlign = ALIGN.MIDDLE;
    style.align = ALIGN.CENTER;
    style.strokeColor = "#6482B9";
    style.fontColor = "#446299";
    return style;
  }
  /**
   * Sets the default style for vertices using `defaultVertex` as the style name.
   * @param style The style to be stored.
   */
  putDefaultVertexStyle(style) {
    this.putCellStyle("defaultVertex", style);
  }
  /**
   * Sets the default style for edges using `defaultEdge` as the style name.
   * @param style The style to be stored.
   */
  putDefaultEdgeStyle(style) {
    this.putCellStyle("defaultEdge", style);
  }
  /**
   * Returns the default style for vertices.
   */
  getDefaultVertexStyle() {
    return this.styles.get("defaultVertex");
  }
  /**
   * Returns the default style for edges.
   */
  getDefaultEdgeStyle() {
    return this.styles.get("defaultEdge");
  }
  /**
   * Stores the given {@link CellStateStyle} under the given name in {@link styles}.
   *
   * ### Example
   *
   * The following example adds a new style called `rounded` into an existing stylesheet:
   *
   * ```javascript
   * const style = {} as CellStateStyle;
   * style.shape = SHAPE.RECTANGLE;
   * style.perimeter = PERIMETER.RECTANGLE;
   * style.rounded = true;
   * graph.getStylesheet().putCellStyle('rounded', style);
   * ```
   *
   * ### Description
   *
   * Note that not all properties will be interpreted by all shapes. For example, the 'line' shape ignores the fill color.
   * The final call to this method associates the style with a name in the stylesheet.
   *
   * The style is used in a cell with the following code:
   * ```javascript
   * // model is an instance of GraphDataModel
   * // style is an instance of CellStyle
   * model.setStyle(cell, { baseStyleNames: ['rounded'] });
   * ```
   *
   * @param name Name for the style to be stored.
   * @param style The instance of the style to be stored.
   */
  putCellStyle(name, style) {
    this.styles.set(name, style);
  }
  /**
   * Returns a {@link CellStateStyle} computed by merging the default style, styles referenced in the specified `baseStyleNames`
   * and the properties of the `cellStyle` parameter.
   *
   * The properties are merged by taking the properties from various styles in the following order:
   *   - default style (if {@link CellStyle.ignoreDefaultStyle} is not set to `true`, otherwise it is ignored)
   *   - registered styles referenced in `baseStyleNames`, in the order of the array
   *   - `cellStyle` parameter
   *
   * To fully unset a style property i.e. the property is not set even if a value is set in the default style or in the referenced styles,
   * set the `cellStyle` property to `none`. For example. `cellStyle.fillColor = 'none'`
   *
   * @param cellStyle An object that represents the style.
   * @param defaultStyle Default style used as reference to compute the returned style.
   */
  getCellStyle(cellStyle, defaultStyle) {
    let style = cellStyle.ignoreDefaultStyle ? {} : { ...defaultStyle };
    if (cellStyle.baseStyleNames) {
      style = cellStyle.baseStyleNames.reduce((acc, styleName) => {
        return {
          ...acc,
          ...this.styles.get(styleName)
        };
      }, style);
    }
    for (const key of Object.keys(cellStyle)) {
      if (cellStyle[key] !== void 0) {
        cellStyle[key] == NONE ? delete style[key] : style[key] = cellStyle[key];
      }
    }
    "baseStyleNames" in style && delete style.baseStyleNames;
    "ignoreDefaultStyle" in style && delete style.ignoreDefaultStyle;
    return style;
  }
}
const SideToSide = (state, source, target, points, result) => {
  const { view } = state;
  let pt = points != null && points.length > 0 ? points[0] : null;
  const pts = state.absolutePoints;
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  if (pt != null) {
    pt = view.transformControlPoint(state, pt);
  }
  if (p0 != null) {
    source = new CellState();
    source.x = p0.x;
    source.y = p0.y;
  }
  if (pe != null) {
    target = new CellState();
    target.x = pe.x;
    target.y = pe.y;
  }
  if (source != null && target != null) {
    const l = Math.max(source.x, target.x);
    const r = Math.min(source.x + source.width, target.x + target.width);
    const x = pt != null ? pt.x : Math.round(r + (l - r) / 2);
    let y1 = view.getRoutingCenterY(source);
    let y2 = view.getRoutingCenterY(target);
    if (pt != null) {
      if (pt.y >= source.y && pt.y <= source.y + source.height) {
        y1 = pt.y;
      }
      if (pt.y >= target.y && pt.y <= target.y + target.height) {
        y2 = pt.y;
      }
    }
    if (!contains(target, x, y1) && !contains(source, x, y1)) {
      result.push(new Point(x, y1));
    }
    if (!contains(target, x, y2) && !contains(source, x, y2)) {
      result.push(new Point(x, y2));
    }
    if (result.length === 1) {
      if (pt != null) {
        if (!contains(target, x, pt.y) && !contains(source, x, pt.y)) {
          result.push(new Point(x, pt.y));
        }
      } else {
        const t = Math.max(source.y, target.y);
        const b = Math.min(source.y + source.height, target.y + target.height);
        result.push(new Point(x, t + (b - t) / 2));
      }
    }
  }
};
const TopToBottom = (state, source, target, points, result) => {
  const { view } = state;
  let pt = points != null && points.length > 0 ? points[0] : null;
  const pts = state.absolutePoints;
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  if (pt != null) {
    pt = view.transformControlPoint(state, pt);
  }
  if (p0 != null) {
    source = new CellState();
    source.x = p0.x;
    source.y = p0.y;
  }
  if (pe != null) {
    target = new CellState();
    target.x = pe.x;
    target.y = pe.y;
  }
  if (source != null && target != null) {
    const t = Math.max(source.y, target.y);
    const b = Math.min(source.y + source.height, target.y + target.height);
    let x = view.getRoutingCenterX(source);
    if (pt != null && pt.x >= source.x && pt.x <= source.x + source.width) {
      x = pt.x;
    }
    const y = pt != null ? pt.y : Math.round(b + (t - b) / 2);
    if (!contains(target, x, y) && !contains(source, x, y)) {
      result.push(new Point(x, y));
    }
    if (pt != null && pt.x >= target.x && pt.x <= target.x + target.width) {
      x = pt.x;
    } else {
      x = view.getRoutingCenterX(target);
    }
    if (!contains(target, x, y) && !contains(source, x, y)) {
      result.push(new Point(x, y));
    }
    if (result.length === 1) {
      if (pt != null && result.length === 1) {
        if (!contains(target, pt.x, y) && !contains(source, pt.x, y)) {
          result.push(new Point(pt.x, y));
        }
      } else {
        const l = Math.max(source.x, target.x);
        const r = Math.min(source.x + source.width, target.x + target.width);
        result.push(new Point(l + (r - l) / 2, y));
      }
    }
  }
};
const ElbowConnector = (state, source, target, points, result) => {
  let pt = points != null && points.length > 0 ? points[0] : null;
  let vertical = false;
  let horizontal = false;
  if (source != null && target != null) {
    if (pt != null) {
      const left = Math.min(source.x, target.x);
      const right = Math.max(source.x + source.width, target.x + target.width);
      const top = Math.min(source.y, target.y);
      const bottom = Math.max(source.y + source.height, target.y + target.height);
      pt = state.view.transformControlPoint(state, pt);
      vertical = pt.y < top || pt.y > bottom;
      horizontal = pt.x < left || pt.x > right;
    } else {
      const left = Math.max(source.x, target.x);
      const right = Math.min(source.x + source.width, target.x + target.width);
      vertical = left === right;
      if (!vertical) {
        const top = Math.max(source.y, target.y);
        const bottom = Math.min(source.y + source.height, target.y + target.height);
        horizontal = top === bottom;
      }
    }
  }
  if (!horizontal && (vertical || state.style.elbow === ELBOW.VERTICAL)) {
    TopToBottom(state, source, target, points, result);
  } else {
    SideToSide(state, source, target, points, result);
  }
};
const EntityRelationConnectorConfig = {
  /**
   * Defines the length of the horizontal segment of an `Entity Relation`.
   * This can be overridden using {@link CellStateStyle.segment} style.
   * @default {@link ENTITY_SEGMENT}
   */
  segment: ENTITY_SEGMENT
};
const resetEntityRelationConnectorConfig = () => {
  EntityRelationConnectorConfig.segment = ENTITY_SEGMENT;
};
const OrthogonalConnectorConfig = {
  /**
   * If the value is not set in {@link CellStateStyle.jettySize}, defines the jetty size of the connector.
   *
   * If the computed value of the jetty size coming from {@link CellStateStyle} is 'auto', it is used in the computation of the automatic jetty size.
   * See the implementation of {@link OrthConnector} for more details.
   *
   * @default 10
   */
  buffer: 10,
  /**
   * See the implementation of {@link OrthConnector} for more details.
   * @default true
   */
  pointsFallback: true
};
const originalOrthogonalConnectorConfig = { ...OrthogonalConnectorConfig };
const resetOrthogonalConnectorConfig = () => {
  shallowCopy(originalOrthogonalConnectorConfig, OrthogonalConnectorConfig);
};
const ManhattanConnectorConfig = {
  maxAllowedDirectionChange: 90,
  maxLoops: 2e3,
  endDirections: Object.values(DIRECTION),
  startDirections: Object.values(DIRECTION),
  step: 12
};
const originalManhattanConnectorConfig = {};
shallowCopy(ManhattanConnectorConfig, originalManhattanConnectorConfig);
const resetManhattanConnectorConfig = () => {
  shallowCopy(originalManhattanConnectorConfig, ManhattanConnectorConfig);
};
const EntityRelation = (state, source, target, _points, result) => {
  var _a;
  const { view } = state;
  const segment = (((_a = state.style) == null ? void 0 : _a.segment) ?? EntityRelationConnectorConfig.segment) * view.scale;
  const pts = state.absolutePoints;
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  let isSourceLeft = false;
  if (source != null) {
    const sourceGeometry = source.cell.getGeometry();
    if (sourceGeometry.relative) {
      isSourceLeft = sourceGeometry.x <= 0.5;
    } else if (target != null) {
      isSourceLeft = (pe != null ? pe.x : target.x + target.width) < (p0 != null ? p0.x : source.x);
    }
  }
  if (p0 != null) {
    source = new CellState();
    source.x = p0.x;
    source.y = p0.y;
  } else if (source != null) {
    const constraint = getPortConstraints(source, state, true, DIRECTION_MASK.NONE);
    if (constraint !== DIRECTION_MASK.NONE && constraint !== DIRECTION_MASK.WEST + DIRECTION_MASK.EAST) {
      isSourceLeft = constraint === DIRECTION_MASK.WEST;
    }
  } else {
    return;
  }
  let isTargetLeft = true;
  if (target != null) {
    const targetGeometry = target.cell.getGeometry();
    if (targetGeometry.relative) {
      isTargetLeft = targetGeometry.x <= 0.5;
    } else if (source != null) {
      isTargetLeft = (p0 != null ? p0.x : source.x + source.width) < (pe != null ? pe.x : target.x);
    }
  }
  if (pe != null) {
    target = new CellState();
    target.x = pe.x;
    target.y = pe.y;
  } else if (target != null) {
    const constraint = getPortConstraints(target, state, false, DIRECTION_MASK.NONE);
    if (constraint !== DIRECTION_MASK.NONE && constraint != DIRECTION_MASK.WEST + DIRECTION_MASK.EAST) {
      isTargetLeft = constraint === DIRECTION_MASK.WEST;
    }
  }
  if (source != null && target != null) {
    const x0 = isSourceLeft ? source.x : source.x + source.width;
    const y0 = view.getRoutingCenterY(source);
    const xe = isTargetLeft ? target.x : target.x + target.width;
    const ye = view.getRoutingCenterY(target);
    const seg = segment;
    let dx = isSourceLeft ? -seg : seg;
    const dep = new Point(x0 + dx, y0);
    dx = isTargetLeft ? -seg : seg;
    const arr = new Point(xe + dx, ye);
    if (isSourceLeft === isTargetLeft) {
      const x = isSourceLeft ? Math.min(x0, xe) - segment : Math.max(x0, xe) + segment;
      result.push(new Point(x, y0));
      result.push(new Point(x, ye));
    } else if (dep.x < arr.x === isSourceLeft) {
      const midY = y0 + (ye - y0) / 2;
      result.push(dep);
      result.push(new Point(dep.x, midY));
      result.push(new Point(arr.x, midY));
      result.push(arr);
    } else {
      result.push(dep);
      result.push(arr);
    }
  }
};
const Loop = (state, source, _target, points, result) => {
  var _a;
  const pts = state.absolutePoints;
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  if (p0 != null && pe != null) {
    if (points != null && points.length > 0) {
      for (let i = 0; i < points.length; i += 1) {
        let pt = points[i];
        pt = state.view.transformControlPoint(state, pt);
        result.push(new Point(pt.x, pt.y));
      }
    }
    return;
  }
  if (source != null) {
    const { view } = state;
    const { graph } = view;
    let pt = points != null && points.length > 0 ? points[0] : null;
    if (pt != null) {
      pt = view.transformControlPoint(state, pt);
      if (contains(source, pt.x, pt.y)) {
        pt = null;
      }
    }
    let x = 0;
    let dx = 0;
    let y = 0;
    let dy = 0;
    const seg = (state.style.segment ?? graph.gridSize) * view.scale;
    const dir = ((_a = state.style) == null ? void 0 : _a.direction) ?? DIRECTION.WEST;
    if (dir === DIRECTION.NORTH || dir === DIRECTION.SOUTH) {
      x = view.getRoutingCenterX(source);
      dx = seg;
    } else {
      y = view.getRoutingCenterY(source);
      dy = seg;
    }
    if (pt == null || pt.x < source.x || pt.x > source.x + source.width) {
      if (pt != null) {
        x = pt.x;
        dy = Math.max(Math.abs(y - pt.y), dy);
      } else if (dir === DIRECTION.NORTH) {
        y = source.y - 2 * dx;
      } else if (dir === DIRECTION.SOUTH) {
        y = source.y + source.height + 2 * dx;
      } else if (dir === DIRECTION.EAST) {
        x = source.x - 2 * dy;
      } else {
        x = source.x + source.width + 2 * dy;
      }
    } else if (pt !== null) {
      x = view.getRoutingCenterX(source);
      dx = Math.max(Math.abs(x - pt.x), dy);
      y = pt.y;
      dy = 0;
    }
    result.push(new Point(x - dx, y - dy));
    result.push(new Point(x + dx, y + dy));
  }
};
function scalePointArray(points, scale) {
  let result = [];
  if (points != null) {
    for (let i = 0; i < points.length; i += 1) {
      if (points[i] != null) {
        result[i] = new Point(Math.round(points[i].x / scale * 10) / 10, Math.round(points[i].y / scale * 10) / 10);
      } else {
        result[i] = null;
      }
    }
  } else {
    result = null;
  }
  return result;
}
function scaleCellState(state, scale) {
  let result = null;
  if (state != null) {
    result = state.clone();
    result.setRect(Math.round(state.x / scale * 10) / 10, Math.round(state.y / scale * 10) / 10, Math.round(state.width / scale * 10) / 10, Math.round(state.height / scale * 10) / 10);
  }
  return result;
}
const SegmentConnector = (state, sourceScaled, targetScaled, controlHints, result) => {
  const pts = scalePointArray(state.absolutePoints, state.view.scale);
  const source = scaleCellState(sourceScaled, state.view.scale);
  const target = scaleCellState(targetScaled, state.view.scale);
  const tol = 1;
  let lastPushed = result.length > 0 ? result[0] : null;
  let horizontal = true;
  let hint = null;
  function pushPoint(pt2) {
    pt2.x = Math.round(pt2.x * state.view.scale * 10) / 10;
    pt2.y = Math.round(pt2.y * state.view.scale * 10) / 10;
    if (lastPushed == null || Math.abs(lastPushed.x - pt2.x) >= tol || Math.abs(lastPushed.y - pt2.y) >= Math.max(1, state.view.scale)) {
      result.push(pt2);
      lastPushed = pt2;
    }
    return lastPushed;
  }
  let pt = pts[0];
  if (pt == null && source != null) {
    pt = new Point(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));
  } else if (pt != null) {
    pt = pt.clone();
  }
  const lastInx = pts.length - 1;
  let pe = null;
  if (controlHints != null && controlHints.length > 0) {
    let hints = [];
    for (let i = 0; i < controlHints.length; i += 1) {
      const tmp = state.view.transformControlPoint(state, controlHints[i], true);
      if (tmp != null) {
        hints.push(tmp);
      }
    }
    if (hints.length === 0) {
      return;
    }
    if (pt != null && hints[0] != null) {
      if (Math.abs(hints[0].x - pt.x) < tol) {
        hints[0].x = pt.x;
      }
      if (Math.abs(hints[0].y - pt.y) < tol) {
        hints[0].y = pt.y;
      }
    }
    pe = pts[lastInx];
    if (pe != null && hints[hints.length - 1] != null) {
      if (Math.abs(hints[hints.length - 1].x - pe.x) < tol) {
        hints[hints.length - 1].x = pe.x;
      }
      if (Math.abs(hints[hints.length - 1].y - pe.y) < tol) {
        hints[hints.length - 1].y = pe.y;
      }
    }
    hint = hints[0];
    let currentTerm = source;
    let currentPt = pts[0];
    let hozChan = false;
    let vertChan = false;
    let currentHint = hint;
    if (currentPt != null) {
      currentTerm = null;
    }
    for (let i = 0; i < 2; i += 1) {
      const fixedVertAlign = currentPt != null && currentPt.x === currentHint.x;
      const fixedHozAlign = currentPt != null && currentPt.y === currentHint.y;
      const inHozChan = currentTerm != null && currentHint.y >= currentTerm.y && currentHint.y <= currentTerm.y + currentTerm.height;
      const inVertChan = currentTerm != null && currentHint.x >= currentTerm.x && currentHint.x <= currentTerm.x + currentTerm.width;
      hozChan = fixedHozAlign || currentPt == null && inHozChan;
      vertChan = fixedVertAlign || currentPt == null && inVertChan;
      if (!(i == 0 && (hozChan && vertChan || fixedVertAlign && fixedHozAlign))) {
        if (currentPt != null && !fixedHozAlign && !fixedVertAlign && (inHozChan || inVertChan)) {
          horizontal = !inHozChan;
          break;
        }
        if (vertChan || hozChan) {
          horizontal = hozChan;
          if (i === 1) {
            horizontal = hints.length % 2 === 0 ? hozChan : vertChan;
          }
          break;
        }
      }
      currentTerm = target;
      currentPt = pts[lastInx];
      if (currentPt != null) {
        currentTerm = null;
      }
      currentHint = hints[hints.length - 1];
      if (fixedVertAlign && fixedHozAlign) {
        hints = hints.slice(1);
      }
    }
    if (horizontal && (pts[0] != null && pts[0].y !== hint.y || pts[0] == null && source != null && (hint.y < source.y || hint.y > source.y + source.height))) {
      pushPoint(new Point(pt.x, hint.y));
    } else if (!horizontal && (pts[0] != null && pts[0].x !== hint.x || pts[0] == null && source != null && (hint.x < source.x || hint.x > source.x + source.width))) {
      pushPoint(new Point(hint.x, pt.y));
    }
    if (horizontal) {
      pt.y = hint.y;
    } else {
      pt.x = hint.x;
    }
    for (let i = 0; i < hints.length; i += 1) {
      horizontal = !horizontal;
      hint = hints[i];
      if (horizontal) {
        pt.y = hint.y;
      } else {
        pt.x = hint.x;
      }
      pushPoint(pt.clone());
    }
  } else {
    hint = pt;
    horizontal = true;
  }
  pt = pts[lastInx];
  if (pt == null && target != null) {
    pt = new Point(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));
  }
  if (pt != null) {
    if (hint != null) {
      if (horizontal && (pts[lastInx] != null && pts[lastInx].y !== hint.y || pts[lastInx] == null && target != null && (hint.y < target.y || hint.y > target.y + target.height))) {
        pushPoint(new Point(pt.x, hint.y));
      } else if (!horizontal && (pts[lastInx] != null && pts[lastInx].x !== hint.x || pts[lastInx] == null && target != null && (hint.x < target.x || hint.x > target.x + target.width))) {
        pushPoint(new Point(hint.x, pt.y));
      }
    }
  }
  if (pts[0] == null && source != null) {
    while (result.length > 1 && result[1] != null && contains(source, result[1].x, result[1].y)) {
      result.splice(1, 1);
    }
  }
  if (pts[lastInx] == null && target != null) {
    while (result.length > 1 && result[result.length - 1] != null && contains(target, result[result.length - 1].x, result[result.length - 1].y)) {
      result.splice(result.length - 1, 1);
    }
  }
  if (pe != null && result[result.length - 1] != null && Math.abs(pe.x - result[result.length - 1].x) <= tol && Math.abs(pe.y - result[result.length - 1].y) <= tol) {
    result.splice(result.length - 1, 1);
    if (result[result.length - 1] != null) {
      if (Math.abs(result[result.length - 1].x - pe.x) < tol) {
        result[result.length - 1].x = pe.x;
      }
      if (Math.abs(result[result.length - 1].y - pe.y) < tol) {
        result[result.length - 1].y = pe.y;
      }
    }
  }
};
const dirVectors = [
  [-1, 0],
  [0, -1],
  [1, 0],
  [0, 1],
  [-1, 0],
  [0, -1],
  [1, 0]
];
const wayPoints1 = [
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0]
];
const routePatterns = [
  [
    [513, 2308, 2081, 2562],
    [513, 1090, 514, 2184, 2114, 2561],
    [513, 1090, 514, 2564, 2184, 2562],
    [513, 2308, 2561, 1090, 514, 2568, 2308]
  ],
  [
    [514, 1057, 513, 2308, 2081, 2562],
    [514, 2184, 2114, 2561],
    [514, 2184, 2562, 1057, 513, 2564, 2184],
    [514, 1057, 513, 2568, 2308, 2561]
  ],
  [
    [1090, 514, 1057, 513, 2308, 2081, 2562],
    [2114, 2561],
    [1090, 2562, 1057, 513, 2564, 2184],
    [1090, 514, 1057, 513, 2308, 2561, 2568]
  ],
  [
    [2081, 2562],
    [1057, 513, 1090, 514, 2184, 2114, 2561],
    [1057, 513, 1090, 514, 2184, 2562, 2564],
    [1057, 2561, 1090, 514, 2568, 2308]
  ]
];
const vertexSeparations = [];
const limits = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0]
];
const SIDE_MASK = 480;
const CENTER_MASK = 512;
const SOURCE_MASK = 1024;
const TARGET_MASK = 2048;
function getJettySize(state, isSource) {
  const buffer = OrthogonalConnectorConfig.buffer;
  let value = (isSource ? state.style.sourceJettySize : state.style.targetJettySize) ?? state.style.jettySize ?? buffer;
  if (value === "auto") {
    const type = (isSource ? state.style.startArrow : state.style.endArrow) ?? NONE;
    if (type !== NONE) {
      const size = (isSource ? state.style.startSize : state.style.endSize) ?? DEFAULT_MARKERSIZE;
      value = Math.max(2, Math.ceil((size + buffer) / buffer)) * buffer;
    } else {
      value = 2 * buffer;
    }
  }
  return value;
}
const OrthogonalConnector = (state, sourceScaled, targetScaled, controlHints, result) => {
  const pts = scalePointArray(state.absolutePoints, state.view.scale);
  const source = scaleCellState(sourceScaled, state.view.scale);
  const target = scaleCellState(targetScaled, state.view.scale);
  const sourceEdge = source == null ? false : source.cell.isEdge();
  const targetEdge = target == null ? false : target.cell.isEdge();
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  let sourceX = source != null ? source.x : p0.x;
  let sourceY = source != null ? source.y : p0.y;
  let sourceWidth = source != null ? source.width : 0;
  let sourceHeight = source != null ? source.height : 0;
  let targetX = target != null ? target.x : pe.x;
  let targetY = target != null ? target.y : pe.y;
  let targetWidth = target != null ? target.width : 0;
  let targetHeight = target != null ? target.height : 0;
  let sourceBuffer = getJettySize(state, true);
  let targetBuffer = getJettySize(state, false);
  if (source != null && target === source) {
    targetBuffer = Math.max(sourceBuffer, targetBuffer);
    sourceBuffer = targetBuffer;
  }
  const totalBuffer = targetBuffer + sourceBuffer;
  let tooShort = false;
  if (p0 != null && pe != null) {
    const dx2 = pe.x - p0.x;
    const dy2 = pe.y - p0.y;
    tooShort = dx2 * dx2 + dy2 * dy2 < totalBuffer * totalBuffer;
  }
  if (tooShort || OrthogonalConnectorConfig.pointsFallback && controlHints != null && controlHints.length > 0 || sourceEdge || targetEdge) {
    SegmentConnector(state, sourceScaled, targetScaled, controlHints, result);
    return;
  }
  const portConstraint = [DIRECTION_MASK.ALL, DIRECTION_MASK.ALL];
  let rotation = 0;
  if (source != null) {
    portConstraint[0] = getPortConstraints(source, state, true, DIRECTION_MASK.ALL);
    rotation = source.style.rotation ?? 0;
    if (rotation !== 0) {
      const newRect = getBoundingBox(new Rectangle(sourceX, sourceY, sourceWidth, sourceHeight), rotation);
      sourceX = newRect.x;
      sourceY = newRect.y;
      sourceWidth = newRect.width;
      sourceHeight = newRect.height;
    }
  }
  if (target != null) {
    portConstraint[1] = getPortConstraints(target, state, false, DIRECTION_MASK.ALL);
    rotation = target.style.rotation ?? 0;
    if (rotation !== 0) {
      const newRect = getBoundingBox(new Rectangle(targetX, targetY, targetWidth, targetHeight), rotation);
      targetX = newRect.x;
      targetY = newRect.y;
      targetWidth = newRect.width;
      targetHeight = newRect.height;
    }
  }
  const dir = [0, 0];
  const geo = [
    [sourceX, sourceY, sourceWidth, sourceHeight],
    [targetX, targetY, targetWidth, targetHeight]
  ];
  const buffer = [sourceBuffer, targetBuffer];
  for (let i = 0; i < 2; i += 1) {
    limits[i][1] = geo[i][0] - buffer[i];
    limits[i][2] = geo[i][1] - buffer[i];
    limits[i][4] = geo[i][0] + geo[i][2] + buffer[i];
    limits[i][8] = geo[i][1] + geo[i][3] + buffer[i];
  }
  const sourceCenX = geo[0][0] + geo[0][2] / 2;
  const sourceCenY = geo[0][1] + geo[0][3] / 2;
  const targetCenX = geo[1][0] + geo[1][2] / 2;
  const targetCenY = geo[1][1] + geo[1][3] / 2;
  const dx = sourceCenX - targetCenX;
  const dy = sourceCenY - targetCenY;
  let quad = 0;
  if (dx < 0) {
    if (dy < 0) {
      quad = 2;
    } else {
      quad = 1;
    }
  } else if (dy <= 0) {
    quad = 3;
    if (dx === 0) {
      quad = 2;
    }
  }
  let currentTerm = null;
  if (source != null) {
    currentTerm = p0;
  }
  const constraint = [
    [0.5, 0.5],
    [0.5, 0.5]
  ];
  for (let i = 0; i < 2; i += 1) {
    if (currentTerm != null) {
      constraint[i][0] = (currentTerm.x - geo[i][0]) / geo[i][2];
      if (Math.abs(currentTerm.x - geo[i][0]) <= 1) {
        dir[i] = DIRECTION_MASK.WEST;
      } else if (Math.abs(currentTerm.x - geo[i][0] - geo[i][2]) <= 1) {
        dir[i] = DIRECTION_MASK.EAST;
      }
      constraint[i][1] = (currentTerm.y - geo[i][1]) / geo[i][3];
      if (Math.abs(currentTerm.y - geo[i][1]) <= 1) {
        dir[i] = DIRECTION_MASK.NORTH;
      } else if (Math.abs(currentTerm.y - geo[i][1] - geo[i][3]) <= 1) {
        dir[i] = DIRECTION_MASK.SOUTH;
      }
    }
    currentTerm = null;
    if (target != null) {
      currentTerm = pe;
    }
  }
  const sourceTopDist = geo[0][1] - (geo[1][1] + geo[1][3]);
  const sourceLeftDist = geo[0][0] - (geo[1][0] + geo[1][2]);
  const sourceBottomDist = geo[1][1] - (geo[0][1] + geo[0][3]);
  const sourceRightDist = geo[1][0] - (geo[0][0] + geo[0][2]);
  vertexSeparations[1] = Math.max(sourceLeftDist - totalBuffer, 0);
  vertexSeparations[2] = Math.max(sourceTopDist - totalBuffer, 0);
  vertexSeparations[4] = Math.max(sourceBottomDist - totalBuffer, 0);
  vertexSeparations[3] = Math.max(sourceRightDist - totalBuffer, 0);
  const dirPref = [];
  const horPref = [];
  const vertPref = [];
  horPref[0] = sourceLeftDist >= sourceRightDist ? DIRECTION_MASK.WEST : DIRECTION_MASK.EAST;
  vertPref[0] = sourceTopDist >= sourceBottomDist ? DIRECTION_MASK.NORTH : DIRECTION_MASK.SOUTH;
  horPref[1] = reversePortConstraints(horPref[0]);
  vertPref[1] = reversePortConstraints(vertPref[0]);
  const preferredHorizDist = sourceLeftDist >= sourceRightDist ? sourceLeftDist : sourceRightDist;
  const preferredVertDist = sourceTopDist >= sourceBottomDist ? sourceTopDist : sourceBottomDist;
  const prefOrdering = [
    [0, 0],
    [0, 0]
  ];
  let preferredOrderSet = false;
  for (let i = 0; i < 2; i += 1) {
    if (dir[i] !== 0) {
      continue;
    }
    if ((horPref[i] & portConstraint[i]) === 0) {
      horPref[i] = reversePortConstraints(horPref[i]);
    }
    if ((vertPref[i] & portConstraint[i]) === 0) {
      vertPref[i] = reversePortConstraints(vertPref[i]);
    }
    prefOrdering[i][0] = vertPref[i];
    prefOrdering[i][1] = horPref[i];
  }
  if (preferredVertDist > 0 && preferredHorizDist > 0) {
    if ((horPref[0] & portConstraint[0]) > 0 && (vertPref[1] & portConstraint[1]) > 0) {
      prefOrdering[0][0] = horPref[0];
      prefOrdering[0][1] = vertPref[0];
      prefOrdering[1][0] = vertPref[1];
      prefOrdering[1][1] = horPref[1];
      preferredOrderSet = true;
    } else if ((vertPref[0] & portConstraint[0]) > 0 && (horPref[1] & portConstraint[1]) > 0) {
      prefOrdering[0][0] = vertPref[0];
      prefOrdering[0][1] = horPref[0];
      prefOrdering[1][0] = horPref[1];
      prefOrdering[1][1] = vertPref[1];
      preferredOrderSet = true;
    }
  }
  if (preferredVertDist > 0 && !preferredOrderSet) {
    prefOrdering[0][0] = vertPref[0];
    prefOrdering[0][1] = horPref[0];
    prefOrdering[1][0] = vertPref[1];
    prefOrdering[1][1] = horPref[1];
    preferredOrderSet = true;
  }
  if (preferredHorizDist > 0 && !preferredOrderSet) {
    prefOrdering[0][0] = horPref[0];
    prefOrdering[0][1] = vertPref[0];
    prefOrdering[1][0] = horPref[1];
    prefOrdering[1][1] = vertPref[1];
    preferredOrderSet = true;
  }
  for (let i = 0; i < 2; i += 1) {
    if (dir[i] !== 0) {
      continue;
    }
    if ((prefOrdering[i][0] & portConstraint[i]) === 0) {
      prefOrdering[i][0] = prefOrdering[i][1];
    }
    dirPref[i] = prefOrdering[i][0] & portConstraint[i];
    dirPref[i] |= (prefOrdering[i][1] & portConstraint[i]) << 8;
    dirPref[i] |= (prefOrdering[1 - i][i] & portConstraint[i]) << 16;
    dirPref[i] |= (prefOrdering[1 - i][1 - i] & portConstraint[i]) << 24;
    if ((dirPref[i] & 15) === 0) {
      dirPref[i] = dirPref[i] << 8;
    }
    if ((dirPref[i] & 3840) === 0) {
      dirPref[i] = dirPref[i] & 15 | dirPref[i] >> 8;
    }
    if ((dirPref[i] & 983040) === 0) {
      dirPref[i] = dirPref[i] & 65535 | (dirPref[i] & 251658240) >> 8;
    }
    dir[i] = dirPref[i] & 15;
    if (portConstraint[i] === DIRECTION_MASK.WEST || portConstraint[i] === DIRECTION_MASK.NORTH || portConstraint[i] === DIRECTION_MASK.EAST || portConstraint[i] === DIRECTION_MASK.SOUTH) {
      dir[i] = portConstraint[i];
    }
  }
  let sourceIndex = dir[0] === DIRECTION_MASK.EAST ? 3 : dir[0];
  let targetIndex = dir[1] === DIRECTION_MASK.EAST ? 3 : dir[1];
  sourceIndex -= quad;
  targetIndex -= quad;
  if (sourceIndex < 1) {
    sourceIndex += 4;
  }
  if (targetIndex < 1) {
    targetIndex += 4;
  }
  const routePattern = routePatterns[sourceIndex - 1][targetIndex - 1];
  wayPoints1[0][0] = geo[0][0];
  wayPoints1[0][1] = geo[0][1];
  switch (dir[0]) {
    case DIRECTION_MASK.WEST:
      wayPoints1[0][0] -= sourceBuffer;
      wayPoints1[0][1] += constraint[0][1] * geo[0][3];
      break;
    case DIRECTION_MASK.SOUTH:
      wayPoints1[0][0] += constraint[0][0] * geo[0][2];
      wayPoints1[0][1] += geo[0][3] + sourceBuffer;
      break;
    case DIRECTION_MASK.EAST:
      wayPoints1[0][0] += geo[0][2] + sourceBuffer;
      wayPoints1[0][1] += constraint[0][1] * geo[0][3];
      break;
    case DIRECTION_MASK.NORTH:
      wayPoints1[0][0] += constraint[0][0] * geo[0][2];
      wayPoints1[0][1] -= sourceBuffer;
      break;
  }
  let currentIndex = 0;
  let lastOrientation = (dir[0] & (DIRECTION_MASK.EAST | DIRECTION_MASK.WEST)) > 0 ? 0 : 1;
  const initialOrientation = lastOrientation;
  let currentOrientation = 0;
  for (let i = 0; i < routePattern.length; i += 1) {
    const nextDirection = routePattern[i] & 15;
    let directionIndex = nextDirection === DIRECTION_MASK.EAST ? 3 : nextDirection;
    directionIndex += quad;
    if (directionIndex > 4) {
      directionIndex -= 4;
    }
    const direction = dirVectors[directionIndex - 1];
    currentOrientation = directionIndex % 2 > 0 ? 0 : 1;
    if (currentOrientation !== lastOrientation) {
      currentIndex++;
      wayPoints1[currentIndex][0] = wayPoints1[currentIndex - 1][0];
      wayPoints1[currentIndex][1] = wayPoints1[currentIndex - 1][1];
    }
    const tar = (routePattern[i] & TARGET_MASK) > 0;
    const sou = (routePattern[i] & SOURCE_MASK) > 0;
    let side = (routePattern[i] & SIDE_MASK) >> 5;
    side <<= quad;
    if (side > 15) {
      side >>= 4;
    }
    const center = (routePattern[i] & CENTER_MASK) > 0;
    if ((sou || tar) && side < 9) {
      let limit = 0;
      const souTar = sou ? 0 : 1;
      if (center && currentOrientation === 0) {
        limit = geo[souTar][0] + constraint[souTar][0] * geo[souTar][2];
      } else if (center) {
        limit = geo[souTar][1] + constraint[souTar][1] * geo[souTar][3];
      } else {
        limit = limits[souTar][side];
      }
      if (currentOrientation === 0) {
        const lastX = wayPoints1[currentIndex][0];
        const deltaX = (limit - lastX) * direction[0];
        if (deltaX > 0) {
          wayPoints1[currentIndex][0] += direction[0] * deltaX;
        }
      } else {
        const lastY = wayPoints1[currentIndex][1];
        const deltaY = (limit - lastY) * direction[1];
        if (deltaY > 0) {
          wayPoints1[currentIndex][1] += direction[1] * deltaY;
        }
      }
    } else if (center) {
      wayPoints1[currentIndex][0] += direction[0] * Math.abs(vertexSeparations[directionIndex] / 2);
      wayPoints1[currentIndex][1] += direction[1] * Math.abs(vertexSeparations[directionIndex] / 2);
    }
    if (currentIndex > 0 && wayPoints1[currentIndex][currentOrientation] === wayPoints1[currentIndex - 1][currentOrientation]) {
      currentIndex--;
    } else {
      lastOrientation = currentOrientation;
    }
  }
  for (let i = 0; i <= currentIndex; i += 1) {
    if (i === currentIndex) {
      const targetOrientation = (dir[1] & (DIRECTION_MASK.EAST | DIRECTION_MASK.WEST)) > 0 ? 0 : 1;
      const sameOrient = targetOrientation === initialOrientation ? 0 : 1;
      if (sameOrient !== (currentIndex + 1) % 2) {
        break;
      }
    }
    result.push(new Point(Math.round(wayPoints1[i][0] * state.view.scale * 10) / 10, Math.round(wayPoints1[i][1] * state.view.scale * 10) / 10));
  }
  let index = 1;
  while (index < result.length) {
    if (result[index - 1] == null || result[index] == null || result[index - 1].x !== result[index].x || result[index - 1].y !== result[index].y) {
      index++;
    } else {
      result.splice(index, 1);
    }
  }
};
const ManhattanConnector = (state, source, target, points, result) => {
  function moveAndExpand(target2, source2) {
    target2.x += source2.x || 0;
    target2.y += source2.y || 0;
    target2.width += source2.width || 0;
    target2.height += source2.height || 0;
    return target2;
  }
  function snapCoordinateToGrid(value, gridSize) {
    return gridSize * Math.round(value / gridSize);
  }
  function snapPointToGrid(p, gx, gy) {
    p.x = snapCoordinateToGrid(p.x, gx);
    p.y = snapCoordinateToGrid(p.y, gx);
    return p;
  }
  function isPointInRectangle(rect, p) {
    return p.x >= rect.x && p.x <= rect.x + rect.width && p.y >= rect.y && p.y <= rect.y + rect.height;
  }
  function getRectangleCenter(rect) {
    return new Point(rect.x + rect.width / 2, rect.y + rect.height / 2);
  }
  function getDifferencePoint(p1, p2) {
    return new Point(p1.x - p2.x, p1.y - p2.y);
  }
  function movePoint(p, moveX, moveY) {
    p.x += moveX || 0;
    p.y += moveY || 0;
    return p;
  }
  function getPointTheta(p1, p2) {
    const p = p2.clone();
    const y = -(p.y - p1.y);
    const x = p.x - p1.x;
    const PRECISION = 10;
    const rad = y.toFixed(PRECISION) == "0" && x.toFixed(PRECISION) == "0" ? 0 : Math.atan2(y, x);
    return 180 * rad / Math.PI;
  }
  function normalizePoint(point) {
    return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
  }
  function getManhattanDistance(p1, p2) {
    return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);
  }
  function toPointFromString(pointString) {
    const xy = pointString.split(pointString.indexOf("@") === -1 ? " " : "@");
    return new Point(parseInt(xy[0], 10), parseInt(xy[1], 10));
  }
  function pointToString(point) {
    return `${point.x}@${point.y}`;
  }
  function getCellAbsoluteBounds(cellState) {
    var _a;
    const graph = cellState.view.graph;
    const cellBounds = (_a = graph.getCellBounds(cellState.cell, false, false)) == null ? void 0 : _a.clone();
    if (!cellBounds)
      return void 0;
    const view = graph.view;
    const { scale, translate: translate2 } = view;
    const { x, y } = translate2;
    const round = (v) => Math.round(v * 10) / 10;
    const res = new Rectangle(round(cellBounds.x / scale - x), round(cellBounds.y / scale - y), round(cellBounds.width / scale), round(cellBounds.height / scale));
    return res;
  }
  const mStep = ManhattanConnectorConfig.step;
  const config = {
    // Padding applied on the element bounding boxes
    paddingBox: new Geometry(-mStep, -mStep, mStep * 2, mStep * 2),
    // An array of directions to find next points on the route
    directions: [
      {
        offsetX: mStep,
        offsetY: 0,
        cost: mStep,
        angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(mStep, 0)))
      },
      {
        offsetX: 0,
        offsetY: mStep,
        cost: mStep,
        angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(0, mStep)))
      },
      {
        offsetX: -mStep,
        offsetY: 0,
        cost: mStep,
        angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(-mStep, 0)))
      },
      {
        offsetX: 0,
        offsetY: -mStep,
        cost: mStep,
        angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(0, -mStep)))
      }
    ],
    directionMap: {
      east: { x: 1, y: 0 },
      south: { x: 0, y: 1 },
      west: { x: -1, y: 0 },
      north: { x: 0, y: -1 }
    },
    // A penalty received for direction change
    penaltiesGenerator: (angle) => {
      if (angle == 45 || angle == 90 || angle == 180)
        return mStep / 2;
      return 0;
    },
    // If a function is provided, it's used to route the link while dragging an end
    // i.e. function(from, to, opts) { return []; }
    draggingRoute: null,
    previousDirAngle: 0
  };
  class ObstacleMap {
    constructor(opt) {
      this.options = opt;
      this.mapGridSize = 100;
      this.map = /* @__PURE__ */ new Map();
    }
    // Builds a map of all elements for quicker obstacle queries
    // The svg is divided to  cells, where each of them holds an information which
    // elements belong to it. When we query whether a point is in an obstacle we don't need
    // to go through all obstacles, we check only those in a particular cell.
    build(source2, target2) {
      const graph = (source2 == null ? void 0 : source2.view.graph) || (target2 == null ? void 0 : target2.view.graph);
      if (!graph)
        return;
      return Array.from(graph.getView().getCellStates()).filter((s) => s.cell && s.cell.isVertex() && !s.cell.isEdge()).map((s) => getCellAbsoluteBounds(s)).map((bbox) => bbox ? moveAndExpand(bbox, this.options.paddingBox) : null).forEach((bbox) => {
        if (!bbox)
          return;
        const origin = snapPointToGrid(new Point(bbox.x, bbox.y), this.mapGridSize);
        const corner = snapPointToGrid(new Point(bbox.x + bbox.width, bbox.y + bbox.height), this.mapGridSize);
        for (let x = origin.x; x <= corner.x; x += this.mapGridSize) {
          for (let y = origin.y; y <= corner.y; y += this.mapGridSize) {
            const gridKey = x + "@" + y;
            const rectArr = this.map.get(gridKey) || [];
            if (!this.map.has(gridKey))
              this.map.set(gridKey, rectArr);
            rectArr.push(bbox);
          }
        }
      });
    }
    isPointAccessible(point) {
      const mapKey = pointToString(snapPointToGrid(point.clone(), this.mapGridSize));
      const obstacles = this.map.get(mapKey);
      if (obstacles) {
        return obstacles.every((obstacle) => !isPointInRectangle(obstacle, point));
      }
      return true;
    }
  }
  class SortedSet {
    constructor() {
      this.items = [];
      this.hash = /* @__PURE__ */ new Map();
    }
    add(key, value) {
      const hashItem = this.hash.get(key);
      if (hashItem) {
        hashItem.value = value;
        this.items.splice(this.items.indexOf(key), 1);
      } else {
        this.hash.set(key, {
          value,
          open: true
        });
      }
      this.items.push(key);
      this.items.sort((i1, i2) => {
        const hashItem1 = this.hash.get(i1);
        const hashItem2 = this.hash.get(i2);
        if (!hashItem1 || !hashItem2)
          return 0;
        return hashItem1.value - hashItem2.value;
      });
    }
    remove(key) {
      const hashItem = this.hash.get(key);
      if (hashItem)
        hashItem.open = false;
    }
    isOpen(key) {
      const hashItem = this.hash.get(key);
      return hashItem && hashItem.open == true;
    }
    isClose(key) {
      const hashItem = this.hash.get(key);
      return hashItem && hashItem.open == false;
    }
    isEmpty() {
      return this.items.length == 0;
    }
    pop() {
      const key = this.items.shift();
      if (key)
        this.remove(key);
      return key;
    }
  }
  function reconstructRoute(parents, endPoint, startCenter, endCenter) {
    const route = [];
    let previousDirection = normalizePoint(getDifferencePoint(endCenter, endPoint));
    let current = endPoint;
    let parent;
    while (parents[pointToString(current)]) {
      parent = parents[pointToString(current)];
      if (!parent)
        continue;
      const direction = normalizePoint(getDifferencePoint(current, parent));
      if (!direction.equals(previousDirection)) {
        route.unshift(current);
        previousDirection = direction;
      }
      current = parent;
    }
    const startDirection = normalizePoint(getDifferencePoint(current, startCenter));
    if (!startDirection.equals(previousDirection)) {
      route.unshift(current);
    }
    return route;
  }
  function getRectPoints(bbox, directions, opt) {
    const step = ManhattanConnectorConfig.step;
    const center = getRectangleCenter(bbox);
    const res = [];
    for (const direction of directions) {
      const directionPoint = opt.directionMap[direction];
      const x = directionPoint.x * bbox.width / 2;
      const y = directionPoint.y * bbox.height / 2;
      const point = movePoint(center.clone(), x, y);
      if (isPointInRectangle(bbox, point)) {
        movePoint(point, directionPoint.x * step, directionPoint.y * step);
      }
      res.push(snapPointToGrid(point, step));
    }
    return res;
  }
  function normalizeAngle(angle) {
    return angle % 360 + (angle < 0 ? 360 : 0);
  }
  function getDirectionAngle(start, end, directionLength) {
    const q = 360 / directionLength;
    return Math.floor(normalizeAngle(getPointTheta(start, end) + q / 2) / q) * q;
  }
  function getDirectionChange(angle1, angle2) {
    const dirChange = Math.abs(angle1 - angle2);
    return dirChange > 180 ? 360 - dirChange : dirChange;
  }
  function estimateCost(from, endPoints) {
    let min = Infinity;
    for (let i = 0, len = endPoints.length; i < len; i++) {
      const cost = getManhattanDistance(from, endPoints[i]);
      if (cost < min)
        min = cost;
    }
    return min;
  }
  function alignPointToCell(point, edgeState, cellState, isSourceCell) {
    const cellBounds = getCellAbsoluteBounds(cellState);
    const y = isSourceCell ? edgeState.style.exitY : edgeState.style.entryY;
    const onlyHorizontalDirections = isSourceCell ? ManhattanConnectorConfig.startDirections.every((d) => d != DIRECTION.NORTH && d != DIRECTION.SOUTH) : ManhattanConnectorConfig.endDirections.every((d) => d != DIRECTION.NORTH && d != DIRECTION.SOUTH);
    if (y != void 0 && onlyHorizontalDirections) {
      const cellHeight = (cellBounds == null ? void 0 : cellBounds.height) || 0;
      point.y = (cellBounds == null ? void 0 : cellBounds.y) != void 0 ? (cellBounds == null ? void 0 : cellBounds.y) + cellHeight * y : point.y - cellHeight / 2 + cellHeight * y;
    }
    const x = isSourceCell ? edgeState.style.exitX : edgeState.style.entryX;
    const onlyVerticalDirections = isSourceCell ? ManhattanConnectorConfig.startDirections.every((d) => d != DIRECTION.WEST && d != DIRECTION.EAST) : ManhattanConnectorConfig.endDirections.every((d) => d != DIRECTION.WEST && d != DIRECTION.EAST);
    if (x != void 0 && onlyVerticalDirections) {
      const cellWidth = (cellBounds == null ? void 0 : cellBounds.width) || 0;
      point.x = (cellBounds == null ? void 0 : cellBounds.x) != void 0 ? (cellBounds == null ? void 0 : cellBounds.x) + cellWidth * x : point.x - cellWidth / 2 + cellWidth * (x || 0);
    }
  }
  function findRoute(start, end, obstacleMap, opt) {
    const step = ManhattanConnectorConfig.step;
    const startPoints = getRectPoints(start, ManhattanConnectorConfig.startDirections, opt).filter((p) => obstacleMap.isPointAccessible(p));
    const startCenter = snapPointToGrid(getRectangleCenter(start), step);
    const endPoints = getRectPoints(end, ManhattanConnectorConfig.endDirections, opt).filter((p) => obstacleMap.isPointAccessible(p));
    const endCenter = snapPointToGrid(getRectangleCenter(end), step);
    if (startPoints.length > 0 && endPoints.length > 0) {
      const openSet = new SortedSet();
      const parents = {};
      const costs = {};
      startPoints.forEach((p) => {
        const key = pointToString(p);
        openSet.add(key, estimateCost(p, endPoints));
        costs[key] = 0;
      });
      let loopsRemain = ManhattanConnectorConfig.maxLoops;
      const endPointsKeys = endPoints.map((p) => pointToString(p));
      let currentDirectionAngle;
      let previousDirectionAngle;
      while (!openSet.isEmpty() && loopsRemain > 0) {
        const currentKey = openSet.pop();
        if (currentKey == void 0) {
          continue;
        }
        const currentPoint = toPointFromString(currentKey);
        const currentCost = costs[currentKey];
        previousDirectionAngle = currentDirectionAngle;
        currentDirectionAngle = parents[currentKey] ? getDirectionAngle(parents[currentKey], currentPoint, opt.directions.length) : opt.previousDirAngle != 0 ? opt.previousDirAngle : getDirectionAngle(startCenter, currentPoint, opt.directions.length);
        if (endPointsKeys.indexOf(currentKey) >= 0) {
          const directionChangedAngle = getDirectionChange(currentDirectionAngle, getDirectionAngle(currentPoint, endCenter, opt.directions.length));
          if (currentPoint.equals(endCenter) || directionChangedAngle < 180) {
            opt.previousDirAngle = currentDirectionAngle;
            return reconstructRoute(parents, currentPoint, startCenter, endCenter);
          }
        }
        for (let i = 0; i < opt.directions.length; i++) {
          const direction = opt.directions[i];
          const directionChangedAngle = getDirectionChange(currentDirectionAngle, direction.angle);
          if (previousDirectionAngle && directionChangedAngle > ManhattanConnectorConfig.maxAllowedDirectionChange) {
            continue;
          }
          const neighborPoint = movePoint(currentPoint.clone(), direction.offsetX, direction.offsetY);
          const neighborKey = pointToString(neighborPoint);
          if (openSet.isClose(neighborKey) || !obstacleMap.isPointAccessible(neighborPoint)) {
            continue;
          }
          const costFromStart = currentCost + direction.cost + opt.penaltiesGenerator(directionChangedAngle);
          if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {
            parents[neighborKey] = currentPoint;
            costs[neighborKey] = costFromStart;
            openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));
          }
        }
        loopsRemain--;
      }
      return null;
    }
    return null;
  }
  function router(state2, source2, target2, points2, result2, opt) {
    if (points2 != null && points2.length > 0 || source2 == null || target2 == null) {
      SegmentConnector(state2, source2, target2, points2, result2);
      return;
    }
    let sourceBBox = getCellAbsoluteBounds(source2);
    sourceBBox = sourceBBox ? moveAndExpand(sourceBBox, opt.paddingBox) : void 0;
    let targetBBox = getCellAbsoluteBounds(target2);
    targetBBox = targetBBox ? moveAndExpand(targetBBox, opt.paddingBox) : void 0;
    const obstacleMap = new ObstacleMap(opt);
    obstacleMap.build(source2, target2);
    if (!sourceBBox || !targetBBox) {
      return OrthogonalConnector(state2, source2, target2, points2, result2);
    }
    const routePoints = findRoute(sourceBBox, targetBBox, obstacleMap, opt);
    if (routePoints == null || routePoints.length == 0) {
      return OrthogonalConnector(state2, source2, target2, points2, result2);
    }
    if (state2.style) {
      if (state2.visibleSourceState && routePoints.length > 0) {
        alignPointToCell(routePoints[0], state2, state2.visibleSourceState, true);
      }
      if (state2.visibleTargetState && routePoints.length > 1) {
        alignPointToCell(routePoints[routePoints.length - 1], state2, state2.visibleTargetState, false);
      }
    }
    const scale = state2.view.scale;
    routePoints.forEach((pt) => result2.push(new Point(Math.round((pt.x + state2.view.translate.x) * scale * 10) / 10, Math.round((pt.y + state2.view.translate.y) * scale * 10) / 10)));
  }
  router(state, source, target, points, result, config);
};
class EdgeStyle {
}
EdgeStyle.EntityRelation = EntityRelation;
EdgeStyle.Loop = Loop;
EdgeStyle.ElbowConnector = ElbowConnector;
EdgeStyle.SideToSide = SideToSide;
EdgeStyle.TopToBottom = TopToBottom;
EdgeStyle.SegmentConnector = SegmentConnector;
EdgeStyle.OrthConnector = OrthogonalConnector;
EdgeStyle.ManhattanConnector = ManhattanConnector;
class CellHighlight {
  constructor(graph, highlightColor, strokeWidth, dashed) {
    this.strokeWidth = 0;
    this.dashed = false;
    this.opacity = 100;
    this.shape = null;
    this.keepOnTop = false;
    this.state = null;
    this.spacing = 2;
    this.graph = graph;
    this.highlightColor = highlightColor ?? DEFAULT_VALID_COLOR;
    this.strokeWidth = strokeWidth ?? HIGHLIGHT_STROKEWIDTH;
    this.dashed = dashed ?? false;
    this.opacity = HIGHLIGHT_OPACITY;
    this.repaintHandler = () => {
      if (this.state) {
        const tmp = this.graph.view.getState(this.state.cell);
        if (!tmp) {
          this.hide();
        } else {
          this.state = tmp;
          this.repaint();
        }
      }
    };
    this.graph.getView().addListener(InternalEvent.SCALE, this.repaintHandler);
    this.graph.getView().addListener(InternalEvent.TRANSLATE, this.repaintHandler);
    this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.repaintHandler);
    this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.repaintHandler);
    this.resetHandler = () => {
      this.hide();
    };
    this.graph.getView().addListener(InternalEvent.DOWN, this.resetHandler);
    this.graph.getView().addListener(InternalEvent.UP, this.resetHandler);
  }
  /**
   * Sets the color of the rectangle used to highlight drop targets.
   *
   * @param {string} color - String that represents the new highlight color.
   */
  setHighlightColor(color) {
    this.highlightColor = color;
    if (this.shape) {
      this.shape.stroke = color;
    }
  }
  /**
   * Creates and returns the highlight shape for the given state.
   */
  drawHighlight() {
    var _a;
    this.shape = this.createShape();
    this.repaint();
    if (this.shape) {
      const node = this.shape.node;
      if (!this.keepOnTop && ((_a = node == null ? void 0 : node.parentNode) == null ? void 0 : _a.firstChild) !== node && node.parentNode) {
        node.parentNode.insertBefore(node, node.parentNode.firstChild);
      }
    }
  }
  /**
   * Creates and returns the highlight shape for the given state.
   */
  createShape() {
    if (!this.state)
      return null;
    const shape = this.graph.cellRenderer.createShape(this.state);
    shape.svgStrokeTolerance = this.graph.getEventTolerance();
    shape.points = this.state.absolutePoints;
    shape.apply(this.state);
    shape.stroke = this.highlightColor;
    shape.opacity = this.opacity;
    shape.isDashed = this.dashed;
    shape.isShadow = false;
    shape.dialect = DIALECT.SVG;
    shape.init(this.graph.getView().getOverlayPane());
    InternalEvent.redirectMouseEvents(shape.node, this.graph, this.state);
    if (this.graph.dialect !== DIALECT.SVG) {
      shape.pointerEvents = false;
    } else {
      shape.svgPointerEvents = "stroke";
    }
    return shape;
  }
  /**
   * Updates the highlight after a change of the model or view.
   */
  getStrokeWidth(state = null) {
    return this.strokeWidth;
  }
  /**
   * Updates the highlight after a change of the model or view.
   */
  repaint() {
    if (this.state && this.shape) {
      this.shape.scale = this.state.view.scale;
      if (this.state.cell.isEdge()) {
        this.shape.strokeWidth = this.getStrokeWidth();
        this.shape.points = this.state.absolutePoints;
        this.shape.outline = false;
      } else {
        this.shape.bounds = new Rectangle(this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);
        this.shape.rotation = this.state.style.rotation ?? 0;
        this.shape.strokeWidth = this.getStrokeWidth() / this.state.view.scale;
        this.shape.outline = true;
      }
      if (this.state.shape) {
        this.shape.setCursor(this.state.shape.getCursor());
      }
      this.shape.redraw();
    }
  }
  /**
   * Resets the state of the cell marker.
   */
  hide() {
    this.highlight(null);
  }
  /**
   * Marks the {@link arkedState} and fires a {@link ark} event.
   */
  highlight(state = null) {
    if (this.state !== state) {
      if (this.shape) {
        this.shape.destroy();
        this.shape = null;
      }
      this.state = state;
      if (this.state) {
        this.drawHighlight();
      }
    }
  }
  /**
   * Returns true if this highlight is at the given position.
   */
  isHighlightAt(x, y) {
    let hit = false;
    if (this.shape && document.elementFromPoint) {
      let elt = document.elementFromPoint(x, y);
      while (elt) {
        if (elt === this.shape.node) {
          hit = true;
          break;
        }
        elt = elt.parentNode;
      }
    }
    return hit;
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  destroy() {
    const graph = this.graph;
    graph.getView().removeListener(this.resetHandler);
    graph.getView().removeListener(this.repaintHandler);
    graph.getDataModel().removeListener(this.repaintHandler);
    if (this.shape) {
      this.shape.destroy();
      this.shape = null;
    }
  }
}
class CellMarker extends EventSource {
  /**
   * Constructs a new cell marker.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   * @param validColor Optional marker color for valid states. Default is {@link DEFAULT_VALID_COLOR}.
   * @param invalidColor Optional marker color for invalid states. Default is {@link DEFAULT_INVALID_COLOR}.
   * @param hotspot Portion of the width and height where a state intersects a given coordinate pair. A value of 0 means always highlight. Default is {@link DEFAULT_HOTSPOT}.
   */
  constructor(graph, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {
    super();
    this.enabled = true;
    this.hotspot = DEFAULT_HOTSPOT;
    this.hotspotEnabled = false;
    this.currentColor = NONE;
    this.validState = null;
    this.markedState = null;
    this.graph = graph;
    this.validColor = validColor;
    this.invalidColor = invalidColor;
    this.hotspot = hotspot;
    this.highlight = new CellHighlight(graph);
  }
  /**
   * Enables or disables event handling.
   * This implementation updates {@link enabled}.
   *
   * @param enabled Boolean that specifies the new enabled state.
   */
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Returns true if events are handled.
   * This implementation returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Sets the {@link hotspot}.
   */
  setHotspot(hotspot) {
    this.hotspot = hotspot;
  }
  /**
   * Returns the {@link hotspot}.
   */
  getHotspot() {
    return this.hotspot;
  }
  /**
   * Specifies whether the hotspot should be used in <intersects>.
   */
  setHotspotEnabled(enabled) {
    this.hotspotEnabled = enabled;
  }
  /**
   * Returns true if hotspot is used in <intersects>.
   */
  isHotspotEnabled() {
    return this.hotspotEnabled;
  }
  /**
   * Returns true if {@link validState} is not `null`.
   */
  hasValidState() {
    return !!this.validState;
  }
  /**
   * Returns the {@link validState}.
   */
  getValidState() {
    return this.validState;
  }
  /**
   * Returns the {@link markedState}.
   */
  getMarkedState() {
    return this.markedState;
  }
  /**
   * Resets the state of the cell marker.
   */
  reset() {
    this.validState = null;
    if (this.markedState) {
      this.markedState = null;
      this.unmark();
    }
  }
  /**
   * Processes the given event and cell and marks the state returned by {@link getState} with the color returned by {@link getMarkerColor}.
   * If the markerColor is not `null`, then the state is stored in {@link markedState}.
   * If {@link isValidState} returns `true`, then the state is stored in {@link validState} regardless of the marker color.
   * The state is returned regardless of the marker color and valid state.
   */
  process(me) {
    let state = null;
    if (this.isEnabled()) {
      state = this.getState(me);
      this.setCurrentState(state, me);
    }
    return state;
  }
  /**
   * Sets and marks the current valid state.
   */
  setCurrentState(state, me, color) {
    const isValid = state ? this.isValidState(state) : false;
    color = color ?? this.getMarkerColor(me.getEvent(), state, isValid);
    if (isValid) {
      this.validState = state;
    } else {
      this.validState = null;
    }
    if (state !== this.markedState || color !== this.currentColor) {
      this.currentColor = color;
      if (state && this.currentColor !== NONE) {
        this.markedState = state;
        this.mark();
      } else if (this.markedState) {
        this.markedState = null;
        this.unmark();
      }
    }
  }
  /**
   * Marks the given cell using the given color, or {@link validColor} if no color is specified.
   */
  markCell(cell, color) {
    const state = this.graph.getView().getState(cell);
    if (state) {
      this.currentColor = color ?? this.validColor;
      this.markedState = state;
      this.mark();
    }
  }
  /**
   * Marks the {@link markedState} and fires a {@link InternalEvent.MARK} event.
   */
  mark() {
    this.highlight.setHighlightColor(this.currentColor);
    this.highlight.highlight(this.markedState);
    this.fireEvent(new EventObject(InternalEvent.MARK, "state", this.markedState));
  }
  /**
   * Hides the marker and fires a {@link InternalEvent.MARK} event.
   */
  unmark() {
    this.mark();
  }
  /**
   * Returns true if the given {@link CellState} is a valid state.
   * If this returns `true`, then the state is stored in {@link validState}.
   * The return value of this method is used as the argument for {@link getMarkerColor}.
   */
  isValidState(state) {
    return true;
  }
  /**
   * Returns the {@link validColor} or {@link invalidColor} depending on the value of {@link isValid}.
   * The given {@link CellState} is ignored by this implementation.
   */
  getMarkerColor(evt, state, isValid) {
    return isValid ? this.validColor : this.invalidColor;
  }
  /**
   * Uses {@link getCell}, {@link getStateToMark} and {@link intersects} to return the {@link CellState} for the given {@link MouseEvent}.
   */
  getState(me) {
    const view = this.graph.getView();
    const cell = this.getCell(me);
    if (!cell)
      return null;
    const state = this.getStateToMark(view.getState(cell));
    return state && this.intersects(state, me) ? state : null;
  }
  /**
   * Returns the {@link Cell} for the given event and cell.
   * This implementation returns the given cell.
   */
  getCell(me) {
    return me.getCell();
  }
  /**
   * Returns the {@link CellState} to be marked for the given {@link CellState} under the mouse.
   * This implementation returns the given state.
   */
  getStateToMark(state) {
    return state;
  }
  /**
   * Returns `true` if the given coordinate pair intersects the given state.
   * This returns `true` if the {@link hotspot} is `0` or the coordinates are inside the hotspot for the given cell state.
   */
  intersects(state, me) {
    const x = me.getGraphX();
    const y = me.getGraphY();
    if (this.hotspotEnabled) {
      return intersectsHotspot(state, x, y, this.hotspot, MIN_HOTSPOT_SIZE, MAX_HOTSPOT_SIZE);
    }
    return true;
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  destroy() {
    this.highlight.destroy();
  }
}
class EllipseShape extends Shape {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Paints the ellipse shape.
   */
  paintVertexShape(c, x, y, w, h) {
    c.ellipse(x, y, w, h);
    c.fillAndStroke();
  }
}
class ConnectionConstraint {
  constructor(point, perimeter = true, name = null, dx = 0, dy = 0) {
    this.perimeter = true;
    this.name = null;
    this.dx = 0;
    this.dy = 0;
    this.point = point;
    this.perimeter = perimeter;
    this.name = name;
    this.dx = dx;
    this.dy = dy;
  }
}
class ConstraintHandler {
  constructor(graph) {
    this.pointImage = new ImageBox(`${Client.imageBasePath}/point.gif`, 5, 5);
    this.currentFocus = null;
    this.currentFocusArea = null;
    this.focusIcons = [];
    this.constraints = null;
    this.currentConstraint = null;
    this.focusHighlight = null;
    this.focusPoints = [];
    this.currentPoint = null;
    this.enabled = true;
    this.highlightColor = DEFAULT_VALID_COLOR;
    this.mouseleaveHandler = null;
    this.graph = graph;
    this.resetHandler = () => {
      if (this.currentFocus && !this.graph.view.getState(this.currentFocus.cell)) {
        this.reset();
      } else {
        this.redraw();
      }
    };
    this.graph.model.addListener(InternalEvent.CHANGE, this.resetHandler);
    this.graph.view.addListener(InternalEvent.SCALE_AND_TRANSLATE, this.resetHandler);
    this.graph.view.addListener(InternalEvent.TRANSLATE, this.resetHandler);
    this.graph.view.addListener(InternalEvent.SCALE, this.resetHandler);
    this.graph.addListener(InternalEvent.ROOT, this.resetHandler);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates {@link enabled}.
   *
   * @param {boolean} enabled - Boolean that specifies the new enabled state.
   */
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Resets the state of this handler.
   */
  reset() {
    for (let i = 0; i < this.focusIcons.length; i += 1) {
      this.focusIcons[i].destroy();
    }
    this.focusIcons = [];
    if (this.focusHighlight) {
      this.focusHighlight.destroy();
      this.focusHighlight = null;
    }
    this.currentConstraint = null;
    this.currentFocusArea = null;
    this.currentPoint = null;
    this.currentFocus = null;
    this.focusPoints = [];
  }
  /**
   * Returns the tolerance to be used for intersecting connection points. This
   * implementation returns {@link mxGraph.tolerance}.
   *
   * @param me {@link mxMouseEvent} whose tolerance should be returned.
   */
  getTolerance(me) {
    return this.graph.getEventTolerance();
  }
  /**
   * Returns the tolerance to be used for intersecting connection points.
   */
  getImageForConstraint(state, constraint, point) {
    return this.pointImage;
  }
  /**
   * Returns true if the given {@link mxMouseEvent} should be ignored in {@link update}. This
   * implementation always returns false.
   */
  isEventIgnored(me, source = false) {
    return false;
  }
  /**
   * Returns true if the given state should be ignored. This always returns false.
   */
  isStateIgnored(state, source = false) {
    return false;
  }
  /**
   * Destroys the {@link focusIcons} if they exist.
   */
  destroyIcons() {
    for (let i = 0; i < this.focusIcons.length; i += 1) {
      this.focusIcons[i].destroy();
    }
    this.focusIcons = [];
    this.focusPoints = [];
  }
  /**
   * Destroys the {@link focusHighlight} if one exists.
   */
  destroyFocusHighlight() {
    if (this.focusHighlight) {
      this.focusHighlight.destroy();
      this.focusHighlight = null;
    }
  }
  /**
   * Returns true if the current focused state should not be changed for the given event.
   * This returns true if shift and alt are pressed.
   */
  isKeepFocusEvent(me) {
    return isShiftDown(me.getEvent());
  }
  /**
   * Returns the cell for the given event.
   */
  getCellForEvent(me, point) {
    let cell = me.getCell();
    if (!cell && point && (me.getGraphX() !== point.x || me.getGraphY() !== point.y)) {
      cell = this.graph.getCellAt(point.x, point.y);
    }
    if (cell && !cell.isConnectable()) {
      const parent = cell.getParent();
      if (parent && parent.isVertex() && parent.isConnectable()) {
        cell = parent;
      }
    }
    if (cell) {
      return this.graph.isCellLocked(cell) ? null : cell;
    } else {
      return null;
    }
  }
  /**
   * Updates the state of this handler based on the given {@link mxMouseEvent}.
   * Source is a boolean indicating if the cell is a source or target.
   */
  update(me, source, existingEdge, point) {
    if (this.isEnabled() && !this.isEventIgnored(me)) {
      if (!this.mouseleaveHandler && this.graph.container) {
        this.mouseleaveHandler = () => {
          this.reset();
        };
        InternalEvent.addListener(this.graph.container, "mouseleave", this.resetHandler);
      }
      const tol = this.getTolerance(me);
      const x = point ? point.x : me.getGraphX();
      const y = point ? point.y : me.getGraphY();
      const grid = new Rectangle(x - tol, y - tol, 2 * tol, 2 * tol);
      const mouse = new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);
      const state = this.graph.view.getState(this.getCellForEvent(me, point));
      if (!this.isKeepFocusEvent(me) && (!this.currentFocusArea || !this.currentFocus || state || !this.currentFocus.cell.isVertex() || !intersects$1(this.currentFocusArea, mouse)) && state !== this.currentFocus) {
        this.currentFocusArea = null;
        this.currentFocus = null;
        this.setFocus(me, state, source);
      }
      this.currentConstraint = null;
      this.currentPoint = null;
      let minDistSq = null;
      let tmp;
      if (this.focusIcons.length > 0 && this.constraints && (!state || this.currentFocus === state)) {
        const cx = mouse.getCenterX();
        const cy = mouse.getCenterY();
        for (let i = 0; i < this.focusIcons.length; i += 1) {
          const dx = cx - this.focusIcons[i].bounds.getCenterX();
          const dy = cy - this.focusIcons[i].bounds.getCenterY();
          tmp = dx * dx + dy * dy;
          if ((this.intersects(this.focusIcons[i], mouse, source, existingEdge) || point && this.intersects(this.focusIcons[i], grid, source, existingEdge)) && (minDistSq === null || tmp < minDistSq)) {
            this.currentConstraint = this.constraints[i];
            this.currentPoint = this.focusPoints[i];
            minDistSq = tmp;
            tmp = this.focusIcons[i].bounds.clone();
            tmp.grow(HIGHLIGHT_SIZE + 1);
            tmp.width -= 1;
            tmp.height -= 1;
            if (!this.focusHighlight) {
              const hl = this.createHighlightShape();
              hl.dialect = DIALECT.SVG;
              hl.pointerEvents = false;
              hl.init(this.graph.getView().getOverlayPane());
              this.focusHighlight = hl;
              const getState = () => {
                return this.currentFocus ? this.currentFocus : state;
              };
              InternalEvent.redirectMouseEvents(hl.node, this.graph, getState);
            }
            this.focusHighlight.bounds = tmp;
            this.focusHighlight.redraw();
          }
        }
      }
      if (!this.currentConstraint) {
        this.destroyFocusHighlight();
      }
    } else {
      this.currentConstraint = null;
      this.currentFocus = null;
      this.currentPoint = null;
    }
  }
  /**
   * Transfers the focus to the given state as a source or target terminal. If
   * the handler is not enabled then the outline is painted, but the constraints
   * are ignored.
   */
  redraw() {
    if (this.currentFocus && this.constraints && this.focusIcons.length > 0) {
      const state = this.graph.view.getState(this.currentFocus.cell);
      this.currentFocus = state;
      this.currentFocusArea = new Rectangle(state.x, state.y, state.width, state.height);
      for (let i = 0; i < this.constraints.length; i += 1) {
        const cp = this.graph.getConnectionPoint(state, this.constraints[i]);
        const img = this.getImageForConstraint(state, this.constraints[i], cp);
        const bounds = new Rectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);
        this.focusIcons[i].bounds = bounds;
        this.focusIcons[i].redraw();
        this.currentFocusArea.add(this.focusIcons[i].bounds);
        this.focusPoints[i] = cp;
      }
    }
  }
  /**
   * Transfers the focus to the given state as a source or target terminal. If
   * the handler is not enabled then the outline is painted, but the constraints
   * are ignored.
   */
  setFocus(me, state, source) {
    var _a;
    this.constraints = state && !this.isStateIgnored(state, source) && state.cell.isConnectable() ? this.isEnabled() ? this.graph.getAllConnectionConstraints(state, source) ?? [] : [] : null;
    if (this.constraints && state) {
      this.currentFocus = state;
      this.currentFocusArea = new Rectangle(state.x, state.y, state.width, state.height);
      for (let i = 0; i < this.focusIcons.length; i += 1) {
        this.focusIcons[i].destroy();
      }
      this.focusIcons = [];
      this.focusPoints = [];
      for (let i = 0; i < this.constraints.length; i += 1) {
        const cp = this.graph.getConnectionPoint(state, this.constraints[i]);
        const img = this.getImageForConstraint(state, this.constraints[i], cp);
        const { src } = img;
        const bounds = new Rectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);
        const icon = new ImageShape(bounds, src);
        icon.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
        icon.preserveImageAspect = false;
        icon.init(this.graph.getView().getDecoratorPane());
        if (icon.node.previousSibling) {
          (_a = icon.node.parentNode) == null ? void 0 : _a.insertBefore(icon.node, icon.node.parentNode.firstChild);
        }
        const getState = () => {
          return this.currentFocus ? this.currentFocus : state;
        };
        icon.redraw();
        InternalEvent.redirectMouseEvents(icon.node, this.graph, getState);
        this.currentFocusArea.add(icon.bounds);
        this.focusIcons.push(icon);
        this.focusPoints.push(cp);
      }
      this.currentFocusArea.grow(this.getTolerance(me));
    } else {
      this.destroyIcons();
      this.destroyFocusHighlight();
    }
  }
  /**
   * Create the shape used to paint the highlight.
   *
   * Returns true if the given icon intersects the given point.
   */
  createHighlightShape() {
    const hl = new RectangleShape(new Rectangle(), this.highlightColor, this.highlightColor, HIGHLIGHT_STROKEWIDTH);
    hl.opacity = HIGHLIGHT_OPACITY;
    return hl;
  }
  /**
   * Returns true if the given icon intersects the given rectangle.
   */
  intersects(icon, mouse, source, existingEdge) {
    return intersects$1(icon.bounds, mouse);
  }
  /**
   * Destroy this handler.
   */
  onDestroy() {
    this.reset();
    this.graph.model.removeListener(this.resetHandler);
    this.graph.view.removeListener(this.resetHandler);
    this.graph.removeListener(this.resetHandler);
    if (this.mouseleaveHandler && this.graph.container) {
      InternalEvent.removeListener(this.graph.container, "mouseleave", this.mouseleaveHandler);
      this.mouseleaveHandler = null;
    }
  }
}
const EdgeHandlerConfig = {
  addBendOnShiftClickEnabled: false,
  connectFillColor: CONNECT_HANDLE_FILLCOLOR,
  handleShape: "square",
  removeBendOnShiftClickEnabled: false,
  selectionColor: EDGE_SELECTION_COLOR,
  selectionDashed: EDGE_SELECTION_DASHED,
  selectionStrokeWidth: EDGE_SELECTION_STROKEWIDTH,
  virtualBendOpacity: 20,
  virtualBendsEnabled: false
};
const defaultEdgeHandlerConfig = { ...EdgeHandlerConfig };
const resetEdgeHandlerConfig = () => {
  shallowCopy(defaultEdgeHandlerConfig, EdgeHandlerConfig);
};
const HandleConfig = {
  /**
   * Defines the default color to be used for the handle fill color. Use `none` for no color.
   * @default {@link HANDLE_FILLCOLOR}
   */
  fillColor: HANDLE_FILLCOLOR,
  /**
   * Defines the color to be used for the label handle fill color. Use `none` for no color.
   * @default {@link LABEL_HANDLE_FILLCOLOR}
   */
  labelFillColor: LABEL_HANDLE_FILLCOLOR,
  /**
   * Defines the default size for label handles.
   * @default {@link LABEL_HANDLE_SIZE}
   */
  labelSize: LABEL_HANDLE_SIZE,
  /**
   * Defines the default size for handles.
   * @default {@link HANDLE_SIZE}
   */
  size: HANDLE_SIZE,
  /**
   * Defines the default color to be used for the handle stroke color. Use `none` for no color.
   * @default {@link HANDLE_STROKECOLOR}
   */
  strokeColor: HANDLE_STROKECOLOR
};
const defaultHandleConfig = { ...HandleConfig };
const resetHandleConfig = () => {
  shallowCopy(defaultHandleConfig, HandleConfig);
};
const VertexHandlerConfig = {
  /**
   * Enable rotation handle
   * @default false
   */
  rotationEnabled: false,
  /**
   * Defines the default color to be used for the selection border of vertices. Use `none` for no color.
   * @default {@link VERTEX_SELECTION_COLOR}
   * @since 0.14.0
   */
  selectionColor: VERTEX_SELECTION_COLOR,
  /**
   * Defines the default stroke width to be used for vertex selections.
   * @default {@link VERTEX_SELECTION_STROKEWIDTH}
   * @since 0.14.0
   */
  selectionStrokeWidth: VERTEX_SELECTION_STROKEWIDTH,
  /**
   * Defines the default dashed state to be used for the vertex selection border.
   * @default {@link VERTEX_SELECTION_DASHED}
   * @since 0.14.0
   */
  selectionDashed: VERTEX_SELECTION_DASHED
};
const defaultVertexHandlerConfig = { ...VertexHandlerConfig };
const resetVertexHandlerConfig = () => {
  shallowCopy(defaultVertexHandlerConfig, VertexHandlerConfig);
};
class EdgeHandler {
  constructor(state) {
    this.error = null;
    this.bends = [];
    this.cloneEnabled = true;
    this.dblClickRemoveEnabled = false;
    this.mergeRemoveEnabled = false;
    this.straightRemoveEnabled = false;
    this.parentHighlightEnabled = false;
    this.preferHtml = false;
    this.allowHandleBoundsCheck = true;
    this.snapToTerminals = false;
    this.handleImage = null;
    this.labelHandleImage = null;
    this.tolerance = 0;
    this.outlineConnect = false;
    this.manageLabelHandle = false;
    this.currentPoint = null;
    this.parentHighlight = null;
    this.index = null;
    this.isSource = false;
    this.isTarget = false;
    this.isLabel = false;
    this.points = [];
    this.snapPoint = null;
    this.abspoints = [];
    this.startX = 0;
    this.startY = 0;
    this.outline = true;
    this.active = true;
    this.state = state;
    this.graph = this.state.view.graph;
    this.marker = this.createMarker();
    this.constraintHandler = new ConstraintHandler(this.graph);
    this.points = [];
    this.abspoints = this.getSelectionPoints(this.state);
    this.shape = this.createSelectionShape(this.abspoints);
    this.shape.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
    this.shape.init(this.graph.getView().getOverlayPane());
    this.shape.pointerEvents = false;
    this.shape.setCursor(CURSOR.MOVABLE_EDGE);
    InternalEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);
    this.preferHtml = this.state.text != null && this.state.text.node.parentNode === this.graph.container;
    if (!this.preferHtml) {
      const sourceState = this.state.getVisibleTerminalState(true);
      if (sourceState != null) {
        this.preferHtml = sourceState.text != null && sourceState.text.node.parentNode === this.graph.container;
      }
      if (!this.preferHtml) {
        const targetState = this.state.getVisibleTerminalState(false);
        if (targetState != null) {
          this.preferHtml = targetState.text != null && targetState.text.node.parentNode === this.graph.container;
        }
      }
    }
    const selectionHandler = this.graph.getPlugin("SelectionHandler");
    if (selectionHandler && (this.graph.getSelectionCount() < selectionHandler.maxCells || selectionHandler.maxCells <= 0)) {
      this.bends = this.createBends();
      if (this.isVirtualBendsEnabled()) {
        this.virtualBends = this.createVirtualBends();
      }
    }
    this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
    this.labelShape = this.createLabelHandleShape();
    this.initBend(this.labelShape);
    this.labelShape.setCursor(CURSOR.LABEL_HANDLE);
    this.customHandles = this.createCustomHandles();
    this.updateParentHighlight();
    this.redraw();
    this.escapeHandler = (_sender, _evt) => {
      const dirty = this.index != null;
      this.reset();
      if (dirty) {
        this.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());
      }
    };
    this.state.view.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);
  }
  /**
   * Returns true if the parent highlight should be visible. This implementation
   * always returns true.
   */
  isParentHighlightVisible() {
    const parent = this.state.cell.getParent();
    return parent ? !this.graph.isCellSelected(parent) : null;
  }
  /**
   * Updates the highlight of the parent if {@link parentHighlightEnabled} is true.
   */
  updateParentHighlight() {
    if (!this.isDestroyed()) {
      const visible = this.isParentHighlightVisible();
      const parent = this.state.cell.getParent();
      const pstate = parent ? this.graph.view.getState(parent) : null;
      if (this.parentHighlight) {
        if (parent && parent.isVertex() && visible) {
          const b = this.parentHighlight.bounds;
          if (pstate && b && (b.x !== pstate.x || b.y !== pstate.y || b.width !== pstate.width || b.height !== pstate.height)) {
            this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);
            this.parentHighlight.redraw();
          }
        } else {
          if (pstate && pstate.parentHighlight === this.parentHighlight) {
            pstate.parentHighlight = null;
          }
          this.parentHighlight.destroy();
          this.parentHighlight = null;
        }
      } else if (this.parentHighlightEnabled && visible) {
        if (parent && parent.isVertex() && pstate && !pstate.parentHighlight) {
          this.parentHighlight = this.createParentHighlightShape(pstate);
          this.parentHighlight.dialect = DIALECT.SVG;
          this.parentHighlight.pointerEvents = false;
          if (pstate.style.rotation) {
            this.parentHighlight.rotation = pstate.style.rotation;
          }
          this.parentHighlight.init(this.graph.getView().getOverlayPane());
          this.parentHighlight.redraw();
          pstate.parentHighlight = this.parentHighlight;
        }
      }
    }
  }
  /**
   * Returns an array of custom handles. This implementation returns an empty array.
   */
  createCustomHandles() {
    return [];
  }
  /**
   * Returns true if virtual bends should be added. This returns true if
   * {@link virtualBendsEnabled} is true and the current style allows and
   * renders custom waypoints.
   */
  isVirtualBendsEnabled(evt) {
    return EdgeHandlerConfig.virtualBendsEnabled && (this.state.style.edgeStyle == null || this.state.style.edgeStyle === NONE || this.state.style.noEdgeStyle) && this.state.style.shape !== "arrow";
  }
  /**
   * Returns true if the given cell allows new connections to be created. This implementation
   * always returns true.
   */
  isCellEnabled(cell) {
    return true;
  }
  /**
   * Returns true if the given event is a trigger to add a new Point. This
   * implementation returns true if shift is pressed.
   */
  isAddPointEvent(evt) {
    return isShiftDown(evt);
  }
  /**
   * Returns true if the given event is a trigger to remove a point. This
   * implementation returns true if shift is pressed.
   */
  isRemovePointEvent(evt) {
    return isShiftDown(evt);
  }
  /**
   * Returns the list of points that defines the selection stroke.
   */
  getSelectionPoints(state) {
    return state.absolutePoints;
  }
  /**
   * Creates the shape used to draw the selection border.
   */
  createParentHighlightShape(bounds) {
    const shape = new RectangleShape(Rectangle.fromRectangle(bounds), NONE, this.getSelectionColor());
    shape.strokeWidth = this.getSelectionStrokeWidth();
    shape.isDashed = this.isSelectionDashed();
    return shape;
  }
  /**
   * Creates the shape used to draw the selection border.
   */
  createSelectionShape(points) {
    const c = this.state.shape.constructor;
    const shape = new c();
    shape.outline = true;
    shape.apply(this.state);
    shape.isDashed = this.isSelectionDashed();
    shape.stroke = this.getSelectionColor();
    shape.isShadow = false;
    return shape;
  }
  /**
   * Returns {@link EdgeHandlerConfig.selectionColor}.
   */
  getSelectionColor() {
    return EdgeHandlerConfig.selectionColor;
  }
  /**
   * Returns {@link EdgeHandlerConfig.selectionStrokeWidth}.
   */
  getSelectionStrokeWidth() {
    return EdgeHandlerConfig.selectionStrokeWidth;
  }
  /**
   * Returns {@link EdgeHandlerConfig.selectionDashed}.
   */
  isSelectionDashed() {
    return EdgeHandlerConfig.selectionDashed;
  }
  /**
   * Returns true if the given cell is connectable. This is a hook to
   * disable floating connections. This implementation returns true.
   */
  isConnectableCell(cell) {
    return true;
  }
  /**
   * Creates and returns the {@link CellMarker} used in {@link marker}.
   */
  getCellAt(x, y) {
    return !this.outlineConnect ? this.graph.getCellAt(x, y) : null;
  }
  /**
   * Creates and returns the {@link CellMarker} used in {@link marker}.
   */
  createMarker() {
    return new EdgeHandlerCellMarker(this.graph, this);
  }
  /**
   * Returns the error message or an empty string if the connection for the
   * given source, target pair is not valid. Otherwise, it returns null. This
   * implementation uses {@link Graph#getEdgeValidationError}.
   *
   * @param source {@link Cell} that represents the source terminal.
   * @param target {@link Cell} that represents the target terminal.
   */
  validateConnection(source, target) {
    return this.graph.getEdgeValidationError(this.state.cell, source, target);
  }
  /**
   * Creates and returns the bends used for modifying the edge. This is
   * typically an array of {@link RectangleShape}.
   */
  createBends() {
    const { cell } = this.state;
    const bends = [];
    for (let i = 0; i < this.abspoints.length; i += 1) {
      if (this.isHandleVisible(i)) {
        const source = i === 0;
        const target = i === this.abspoints.length - 1;
        const terminal = source || target;
        if (terminal || this.graph.isCellBendable(cell)) {
          ((index) => {
            const bend = this.createHandleShape(index);
            this.initBend(bend, () => {
              if (this.dblClickRemoveEnabled) {
                this.removePoint(this.state, index);
              }
            });
            if (this.isHandleEnabled(i)) {
              bend.setCursor(terminal ? CURSOR.TERMINAL_HANDLE : CURSOR.BEND_HANDLE);
            }
            bends.push(bend);
            if (!terminal) {
              this.points.push(new Point(0, 0));
              bend.node.style.visibility = "hidden";
            }
          })(i);
        }
      }
    }
    return bends;
  }
  /**
   * Creates and returns the bends used for modifying the edge. This is
   * typically an array of {@link RectangleShape}.
   */
  createVirtualBends() {
    const { cell } = this.state;
    this.abspoints[0];
    const bends = [];
    if (this.graph.isCellBendable(cell)) {
      for (let i = 1; i < this.abspoints.length; i += 1) {
        ((bend) => {
          this.initBend(bend);
          bend.setCursor(CURSOR.VIRTUAL_BEND_HANDLE);
          bends.push(bend);
        })(this.createHandleShape());
      }
    }
    return bends;
  }
  /**
   * Creates the shape used to display the given bend.
   */
  isHandleEnabled(index) {
    return true;
  }
  /**
   * Returns true if the handle at the given index is visible.
   */
  isHandleVisible(index) {
    const source = this.state.getVisibleTerminalState(true);
    const target = this.state.getVisibleTerminalState(false);
    const geo = this.state.cell.getGeometry();
    const edgeStyle = geo ? this.graph.view.getEdgeStyle(this.state, geo.points || void 0, source, target) : null;
    return edgeStyle !== EdgeStyle.EntityRelation || index === 0 || index === this.abspoints.length - 1;
  }
  /**
   * Creates the shape used to display the given bend.
   * Note that the index
   * - may be `null` for special cases, such as when called from {@link ElbowEdgeHandler.createVirtualBend}.
   * - is `null` for virtual handles.
   *
   * Only images and rectangles should be returned if support for HTML labels with not foreign objects is required.
   */
  createHandleShape(_index) {
    if (this.handleImage) {
      const shape = new ImageShape(new Rectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);
      shape.preserveImageAspect = false;
      return shape;
    }
    let s = HandleConfig.size;
    if (this.preferHtml) {
      s -= 1;
    }
    const shapeConstructor = EdgeHandlerConfig.handleShape === "circle" ? EllipseShape : RectangleShape;
    return new shapeConstructor(new Rectangle(0, 0, s, s), HandleConfig.fillColor, HandleConfig.strokeColor);
  }
  /**
   * Creates the shape used to display the label handle.
   */
  createLabelHandleShape() {
    if (this.labelHandleImage) {
      const shape = new ImageShape(new Rectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);
      shape.preserveImageAspect = false;
      return shape;
    }
    const s = HandleConfig.labelSize;
    return new RectangleShape(new Rectangle(0, 0, s, s), HandleConfig.labelFillColor, HandleConfig.strokeColor);
  }
  /**
   * Helper method to initialize the given bend.
   *
   * @param bend {@link Shape} that represents the bend to be initialized.
   * @param dblClick Optional function to be called on double click.
   */
  initBend(bend, dblClick) {
    if (this.preferHtml) {
      bend.dialect = DIALECT.STRICTHTML;
      bend.init(this.graph.container);
    } else {
      bend.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
      bend.init(this.graph.getView().getOverlayPane());
    }
    InternalEvent.redirectMouseEvents(bend.node, this.graph, this.state, null, null, null, dblClick);
    if (Client.IS_TOUCH) {
      bend.node.setAttribute("pointer-events", "none");
    }
  }
  /**
   * Returns the index of the handle for the given event.
   */
  getHandleForEvent(me) {
    let result = null;
    const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;
    const hit = this.allowHandleBoundsCheck && tol > 0 ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
    let minDistSq = Number.POSITIVE_INFINITY;
    function checkShape(shape) {
      if (shape && shape.bounds && shape.node && shape.node.style.display !== "none" && shape.node.style.visibility !== "hidden" && (me.isSource(shape) || hit && intersects$1(shape.bounds, hit))) {
        const dx = me.getGraphX() - shape.bounds.getCenterX();
        const dy = me.getGraphY() - shape.bounds.getCenterY();
        const tmp = dx * dx + dy * dy;
        if (tmp <= minDistSq) {
          minDistSq = tmp;
          return true;
        }
      }
      return false;
    }
    if (this.isCustomHandleEvent(me) && this.customHandles) {
      for (let i = this.customHandles.length - 1; i >= 0; i--) {
        if (checkShape(this.customHandles[i].shape)) {
          return InternalEvent.CUSTOM_HANDLE - i;
        }
      }
    }
    if (me.isSource(this.state.text) || checkShape(this.labelShape)) {
      result = InternalEvent.LABEL_HANDLE;
    }
    for (let i = 0; i < this.bends.length; i += 1) {
      if (checkShape(this.bends[i])) {
        result = i;
      }
    }
    if (this.virtualBends && this.isAddVirtualBendEvent(me)) {
      for (let i = 0; i < this.virtualBends.length; i += 1) {
        if (checkShape(this.virtualBends[i])) {
          result = InternalEvent.VIRTUAL_HANDLE - i;
        }
      }
    }
    return result;
  }
  /**
   * Returns true if the given event allows virtual bends to be added. This
   * implementation returns true.
   */
  isAddVirtualBendEvent(me) {
    return true;
  }
  /**
   * Returns true if the given event allows custom handles to be changed. This
   * implementation returns true.
   */
  isCustomHandleEvent(me) {
    return true;
  }
  /**
   * Handles the event by checking if a special element of the handler
   * was clicked, in which case the index parameter is non-null. The
   * indices may be one of {@link InternalEvent.LABEL_HANDLE} or the number of the respective
   * control point. The source and target points are used for reconnecting
   * the edge.
   */
  mouseDown(sender, me) {
    const handle = this.getHandleForEvent(me);
    if (handle !== null && this.bends[handle]) {
      const b = this.bends[handle].bounds;
      if (b)
        this.snapPoint = new Point(b.getCenterX(), b.getCenterY());
    }
    if (EdgeHandlerConfig.addBendOnShiftClickEnabled && handle === null && this.isAddPointEvent(me.getEvent())) {
      this.addPoint(this.state, me.getEvent());
      me.consume();
    } else if (handle !== null && !me.isConsumed() && this.graph.isEnabled()) {
      const cell = me.getCell();
      if (EdgeHandlerConfig.removeBendOnShiftClickEnabled && this.isRemovePointEvent(me.getEvent())) {
        this.removePoint(this.state, handle);
      } else if (handle !== InternalEvent.LABEL_HANDLE || cell && this.graph.isLabelMovable(cell)) {
        if (this.virtualBends && handle <= InternalEvent.VIRTUAL_HANDLE) {
          setOpacity(this.virtualBends[InternalEvent.VIRTUAL_HANDLE - handle].node, 100);
        }
        this.start(me.getX(), me.getY(), handle);
      }
      me.consume();
    }
  }
  /**
   * Starts the handling of the mouse gesture.
   */
  start(x, y, index) {
    this.startX = x;
    this.startY = y;
    this.isSource = this.bends.length === 0 ? false : index === 0;
    this.isTarget = this.bends.length === 0 ? false : index === this.bends.length - 1;
    this.isLabel = index === InternalEvent.LABEL_HANDLE;
    if (this.isSource || this.isTarget) {
      const { cell } = this.state;
      const terminal = cell.getTerminal(this.isSource);
      if (terminal == null && this.graph.isTerminalPointMovable(cell, this.isSource) || terminal != null && this.graph.isCellDisconnectable(cell, terminal, this.isSource)) {
        this.index = index;
      }
    } else {
      this.index = index;
    }
    if (this.index !== null && this.index <= InternalEvent.CUSTOM_HANDLE && this.index > InternalEvent.VIRTUAL_HANDLE) {
      if (this.customHandles != null) {
        for (let i = 0; i < this.customHandles.length; i += 1) {
          if (i !== InternalEvent.CUSTOM_HANDLE - this.index) {
            this.customHandles[i].setVisible(false);
          }
        }
      }
    }
  }
  /**
   * Returns a clone of the current preview state for the given point and terminal.
   */
  clonePreviewState(point, terminal) {
    return this.state.clone();
  }
  /**
   * Returns the tolerance for the guides. Default value is
   * gridSize * scale / 2.
   */
  getSnapToTerminalTolerance() {
    return this.graph.getGridSize() * this.graph.getView().scale / 2;
  }
  /**
   * Hook for subclassers do show details while the handler is active.
   */
  updateHint(me, point) {
    return;
  }
  /**
   * Hooks for subclassers to hide details when the handler gets inactive.
   */
  removeHint() {
    return;
  }
  /**
   * Hook for rounding the unscaled width or height. This uses Math.round.
   */
  roundLength(length) {
    return Math.round(length);
  }
  /**
   * Returns true if {@link snapToTerminals} is true and if alt is not pressed.
   */
  isSnapToTerminalsEvent(me) {
    return this.snapToTerminals && !isAltDown(me.getEvent());
  }
  /**
   * Returns the point for the given event.
   */
  getPointForEvent(me) {
    const view = this.graph.getView();
    const { scale } = view;
    const point = new Point(this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);
    const tt = this.getSnapToTerminalTolerance();
    let overrideX = false;
    let overrideY = false;
    if (tt > 0 && this.isSnapToTerminalsEvent(me)) {
      const snapToPoint = (pt) => {
        if (pt) {
          const { x } = pt;
          if (Math.abs(point.x - x) < tt) {
            point.x = x;
            overrideX = true;
          }
          const { y } = pt;
          if (Math.abs(point.y - y) < tt) {
            point.y = y;
            overrideY = true;
          }
        }
      };
      const snapToTerminal = (terminal) => {
        if (terminal) {
          snapToPoint(new Point(view.getRoutingCenterX(terminal), view.getRoutingCenterY(terminal)));
        }
      };
      snapToTerminal(this.state.getVisibleTerminalState(true));
      snapToTerminal(this.state.getVisibleTerminalState(false));
      for (let i = 0; i < this.state.absolutePoints.length; i += 1) {
        snapToPoint(this.state.absolutePoints[i]);
      }
    }
    if (this.graph.isGridEnabledEvent(me.getEvent())) {
      const tr = view.translate;
      if (!overrideX) {
        point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
      }
      if (!overrideY) {
        point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
      }
    }
    return point;
  }
  /**
   * Updates the given preview state taking into account the state of the constraint handler.
   */
  getPreviewTerminalState(me) {
    this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);
    if (this.constraintHandler.currentFocus && this.constraintHandler.currentConstraint) {
      if (this.marker.highlight && this.marker.highlight.shape && this.marker.highlight.state && this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell) {
        if (this.marker.highlight.shape.stroke !== "transparent") {
          this.marker.highlight.shape.stroke = "transparent";
          this.marker.highlight.repaint();
        }
      } else {
        this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent");
      }
      const other = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(this.state.cell.getTerminal(!this.isSource)), !this.isSource);
      const otherCell = other ? other.cell : null;
      const source = this.isSource ? this.constraintHandler.currentFocus.cell : otherCell;
      const target = this.isSource ? otherCell : this.constraintHandler.currentFocus.cell;
      this.error = this.validateConnection(source, target);
      let result = null;
      if (this.error === null) {
        result = this.constraintHandler.currentFocus;
      }
      if (this.error !== null || result && !this.isCellEnabled(result.cell)) {
        this.constraintHandler.reset();
      }
      return result;
    }
    if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {
      this.marker.process(me);
      const state = this.marker.getValidState();
      if (state && !this.isCellEnabled(state.cell)) {
        this.constraintHandler.reset();
        this.marker.reset();
      }
      return this.marker.getValidState();
    }
    this.marker.reset();
    return null;
  }
  /**
   * Updates the given preview state taking into account the state of the constraint handler.
   *
   * @param pt {@link Point} that contains the current pointer position.
   * @param me Optional {@link MouseEvent} that contains the current event.
   */
  getPreviewPoints(pt, me) {
    const geometry = this.state.cell.getGeometry();
    if (!geometry)
      return null;
    let points = (geometry.points || []).slice();
    const point = new Point(pt.x, pt.y);
    let result = null;
    if (!this.isSource && !this.isTarget && this.index !== null) {
      this.convertPoint(point, false);
      if (this.index <= InternalEvent.VIRTUAL_HANDLE) {
        points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 0, point);
      }
      if (!this.isSource && !this.isTarget) {
        for (let i = 0; i < this.bends.length; i += 1) {
          if (i !== this.index) {
            const bend = this.bends[i];
            if (bend && contains(bend.bounds, pt.x, pt.y)) {
              if (this.index <= InternalEvent.VIRTUAL_HANDLE) {
                points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 1);
              } else {
                points.splice(this.index - 1, 1);
              }
              result = points;
            }
          }
        }
        if (!result && this.straightRemoveEnabled && (!me || !isAltDown(me.getEvent()))) {
          const tol = this.graph.getEventTolerance() * this.graph.getEventTolerance();
          const abs = this.state.absolutePoints.slice();
          abs[this.index] = pt;
          const src = this.state.getVisibleTerminalState(true);
          if (src != null) {
            const c = this.graph.getConnectionConstraint(this.state, src, true);
            if (c == null || this.graph.getConnectionPoint(src, c) == null) {
              abs[0] = new Point(src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));
            }
          }
          const trg = this.state.getVisibleTerminalState(false);
          if (trg != null) {
            const c = this.graph.getConnectionConstraint(this.state, trg, false);
            if (c == null || this.graph.getConnectionPoint(trg, c) == null) {
              abs[abs.length - 1] = new Point(trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));
            }
          }
          const checkRemove = (idx, tmp) => {
            if (idx > 0 && idx < abs.length - 1 && ptSegDistSq(abs[idx - 1].x, abs[idx - 1].y, abs[idx + 1].x, abs[idx + 1].y, tmp.x, tmp.y) < tol) {
              points.splice(idx - 1, 1);
              result = points;
            }
          };
          checkRemove(this.index, pt);
        }
      }
      if (result == null && this.index > InternalEvent.VIRTUAL_HANDLE) {
        points[this.index - 1] = point;
      }
    } else if (this.graph.isResetEdgesOnConnect()) {
      points = [];
    }
    return result != null ? result : points;
  }
  /**
   * Returns true if {@link outlineConnect} is true and the source of the event is the outline shape
   * or shift is pressed.
   */
  isOutlineConnectEvent(me) {
    if (!this.currentPoint)
      return false;
    const offset = getOffset(this.graph.container);
    const evt = me.getEvent();
    const clientX = getClientX(evt);
    const clientY = getClientY(evt);
    const doc = document.documentElement;
    const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
    const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;
    return this.outlineConnect && !isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX !== clientX || gridY !== clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));
  }
  /**
   * Updates the given preview state taking into account the state of the constraint handler.
   */
  updatePreviewState(edgeState, point, terminalState, me, outline = false) {
    const sourceState = this.isSource ? terminalState : this.state.getVisibleTerminalState(true);
    const targetState = this.isTarget ? terminalState : this.state.getVisibleTerminalState(false);
    let sourceConstraint = this.graph.getConnectionConstraint(edgeState, sourceState, true);
    let targetConstraint = this.graph.getConnectionConstraint(edgeState, targetState, false);
    let constraint = this.constraintHandler.currentConstraint;
    if (constraint == null && outline) {
      if (terminalState != null) {
        if (me.isSource(this.marker.highlight.shape)) {
          point = new Point(me.getGraphX(), me.getGraphY());
        }
        constraint = this.graph.getOutlineConstraint(point, terminalState, me);
        this.constraintHandler.setFocus(me, terminalState, this.isSource);
        this.constraintHandler.currentConstraint = constraint;
        this.constraintHandler.currentPoint = point;
      } else {
        constraint = new ConnectionConstraint(null);
      }
    }
    if (this.outlineConnect && this.marker.highlight != null && this.marker.highlight.shape != null) {
      const s = this.graph.view.scale;
      if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
        this.marker.highlight.shape.stroke = outline ? OUTLINE_HIGHLIGHT_COLOR : "transparent";
        this.marker.highlight.shape.strokeWidth = OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;
        this.marker.highlight.repaint();
      } else if (this.marker.hasValidState()) {
        const cell = me.getCell();
        this.marker.highlight.shape.stroke = cell && cell.isConnectable() && this.marker.getValidState() !== me.getState() ? "transparent" : DEFAULT_VALID_COLOR;
        this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;
        this.marker.highlight.repaint();
      }
    }
    if (this.isSource) {
      sourceConstraint = constraint;
    } else if (this.isTarget) {
      targetConstraint = constraint;
    }
    if (this.isSource || this.isTarget) {
      if (constraint != null && constraint.point != null) {
        edgeState.style[this.isSource ? "exitX" : "entryX"] = constraint.point.x;
        edgeState.style[this.isSource ? "exitY" : "entryY"] = constraint.point.y;
      } else {
        delete edgeState.style[this.isSource ? "exitX" : "entryX"];
        delete edgeState.style[this.isSource ? "exitY" : "entryY"];
      }
    }
    edgeState.setVisibleTerminalState(sourceState, true);
    edgeState.setVisibleTerminalState(targetState, false);
    if (!this.isSource || sourceState != null) {
      edgeState.view.updateFixedTerminalPoint(edgeState, sourceState, true, sourceConstraint);
    }
    if (!this.isTarget || targetState != null) {
      edgeState.view.updateFixedTerminalPoint(edgeState, targetState, false, targetConstraint);
    }
    if ((this.isSource || this.isTarget) && terminalState == null) {
      edgeState.setAbsoluteTerminalPoint(point, this.isSource);
      if (this.marker.getMarkedState() == null) {
        this.error = this.graph.isAllowDanglingEdges() ? null : "";
      }
    }
    edgeState.view.updatePoints(edgeState, this.points, sourceState, targetState);
    edgeState.view.updateFloatingTerminalPoints(edgeState, sourceState, targetState);
  }
  /**
   * Handles the event by updating the preview.
   */
  mouseMove(sender, me) {
    var _a;
    if (this.index != null && this.marker != null) {
      this.currentPoint = this.getPointForEvent(me);
      this.error = null;
      if (!this.graph.isIgnoreTerminalEvent(me.getEvent()) && isShiftDown(me.getEvent()) && this.snapPoint != null) {
        if (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y)) {
          this.currentPoint.x = this.snapPoint.x;
        } else {
          this.currentPoint.y = this.snapPoint.y;
        }
      }
      if (this.index <= InternalEvent.CUSTOM_HANDLE && this.index > InternalEvent.VIRTUAL_HANDLE) {
        if (this.customHandles != null) {
          this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);
          this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].positionChanged();
          if (this.shape != null && this.shape.node != null) {
            this.shape.node.style.display = "none";
          }
        }
      } else if (this.isLabel && this.label) {
        this.label.x = this.currentPoint.x;
        this.label.y = this.currentPoint.y;
      } else {
        this.points = this.getPreviewPoints(this.currentPoint, me);
        let terminalState = this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;
        if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {
          this.currentPoint = this.constraintHandler.currentPoint.clone();
        } else if (this.outlineConnect) {
          const outline = this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;
          if (outline) {
            terminalState = this.marker.highlight.state;
          } else if (terminalState != null && terminalState !== me.getState() && ((_a = me.getCell()) == null ? void 0 : _a.isConnectable()) && this.marker.highlight.shape != null) {
            this.marker.highlight.shape.stroke = "transparent";
            this.marker.highlight.repaint();
            terminalState = null;
          }
        }
        if (terminalState != null && !this.isCellEnabled(terminalState.cell)) {
          terminalState = null;
          this.marker.reset();
        }
        if (this.currentPoint) {
          const clone2 = this.clonePreviewState(this.currentPoint, terminalState != null ? terminalState.cell : null);
          this.updatePreviewState(clone2, this.currentPoint, terminalState, me, this.outline);
          const color = this.error == null ? this.marker.validColor : this.marker.invalidColor;
          this.setPreviewColor(color);
          this.abspoints = clone2.absolutePoints;
          this.active = true;
          this.updateHint(me, this.currentPoint);
        }
      }
      this.drawPreview();
      InternalEvent.consume(me.getEvent());
      me.consume();
    }
  }
  /**
   * Handles the event to applying the previewed changes on the edge by
   * using {@link moveLabel}, {@link connect} or {@link changePoints}.
   */
  mouseUp(sender, me) {
    if (this.index != null && this.marker != null) {
      if (this.shape != null && this.shape.node != null) {
        this.shape.node.style.display = "";
      }
      let edge = this.state.cell;
      const { index } = this;
      this.index = null;
      if (me.getX() !== this.startX || me.getY() !== this.startY) {
        const clone2 = !this.graph.isIgnoreTerminalEvent(me.getEvent()) && this.graph.isCloneEvent(me.getEvent()) && this.cloneEnabled && this.graph.isCellsCloneable();
        if (this.error != null) {
          if (this.error.length > 0) {
            this.graph.validationAlert(this.error);
          }
        } else if (index <= InternalEvent.CUSTOM_HANDLE && index > InternalEvent.VIRTUAL_HANDLE) {
          if (this.customHandles != null) {
            const model = this.graph.getDataModel();
            model.beginUpdate();
            try {
              this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);
              if (this.shape != null && this.shape.node != null) {
                this.shape.apply(this.state);
                this.shape.redraw();
              }
            } finally {
              model.endUpdate();
            }
          }
        } else if (this.isLabel && this.label) {
          this.moveLabel(this.state, this.label.x, this.label.y);
        } else if (this.isSource || this.isTarget) {
          let terminal = null;
          if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
            terminal = this.constraintHandler.currentFocus.cell;
          }
          if (!terminal && this.marker.hasValidState() && this.marker.highlight != null && this.marker.highlight.shape != null && this.marker.highlight.shape.stroke !== "transparent" && this.marker.highlight.shape.stroke !== "white") {
            terminal = this.marker.validState.cell;
          }
          if (terminal) {
            const model = this.graph.getDataModel();
            const parent = edge.getParent();
            model.beginUpdate();
            try {
              if (clone2) {
                let geo = edge.getGeometry();
                const cloned = this.graph.cloneCell(edge);
                model.add(parent, cloned, parent.getChildCount());
                if (geo != null) {
                  geo = geo.clone();
                  model.setGeometry(cloned, geo);
                }
                const other = edge.getTerminal(!this.isSource);
                this.graph.connectCell(cloned, other, !this.isSource);
                edge = cloned;
              }
              edge = this.connect(edge, terminal, this.isSource, clone2, me);
            } finally {
              model.endUpdate();
            }
          } else if (this.graph.isAllowDanglingEdges()) {
            const pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];
            pt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);
            pt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);
            const parent = edge.getParent();
            const pstate = parent ? this.graph.getView().getState(parent) : null;
            if (pstate != null) {
              pt.x -= pstate.origin.x;
              pt.y -= pstate.origin.y;
            }
            pt.x -= this.graph.getPanDx() / this.graph.view.scale;
            pt.y -= this.graph.getPanDy() / this.graph.view.scale;
            edge = this.changeTerminalPoint(edge, pt, this.isSource, clone2);
          }
        } else if (this.active) {
          edge = this.changePoints(edge, this.points, clone2);
        } else {
          this.graph.getView().invalidate(this.state.cell);
          this.graph.getView().validate(this.state.cell);
        }
      } else if (this.graph.isToggleEvent(me.getEvent())) {
        this.graph.selectCellForEvent(this.state.cell, me.getEvent());
      }
      if (this.marker != null) {
        this.reset();
        if (edge !== this.state.cell) {
          this.graph.setSelectionCell(edge);
        }
      }
      me.consume();
    }
  }
  /**
   * Resets the state of this handler.
   */
  reset() {
    if (this.active) {
      this.refresh();
    }
    this.error = null;
    this.index = null;
    this.points = [];
    this.snapPoint = null;
    this.isLabel = false;
    this.isSource = false;
    this.isTarget = false;
    this.active = false;
    if (this.marker) {
      this.marker.reset();
    }
    this.constraintHandler.reset();
    if (this.customHandles) {
      for (let i = 0; i < this.customHandles.length; i += 1) {
        this.customHandles[i].reset();
      }
    }
    this.setPreviewColor(EdgeHandlerConfig.selectionColor);
    this.removeHint();
    this.redraw();
  }
  /**
   * Sets the color of the preview to the given value.
   */
  setPreviewColor(color) {
    this.shape.stroke = color;
  }
  /**
   * Converts the given point in-place from screen to unscaled, untranslated
   * graph coordinates and applies the grid. Returns the given, modified
   * point instance.
   *
   * @param point {@link Point} to be converted.
   * @param gridEnabled Boolean that specifies if the grid should be applied.
   */
  convertPoint(point, gridEnabled) {
    const scale = this.graph.getView().getScale();
    const tr = this.graph.getView().getTranslate();
    if (gridEnabled) {
      point.x = this.graph.snap(point.x);
      point.y = this.graph.snap(point.y);
    }
    point.x = Math.round(point.x / scale - tr.x);
    point.y = Math.round(point.y / scale - tr.y);
    const parent = this.state.cell.getParent();
    const pstate = parent ? this.graph.getView().getState(parent) : parent;
    if (pstate) {
      point.x -= pstate.origin.x;
      point.y -= pstate.origin.y;
    }
    return point;
  }
  /**
   * Changes the coordinates for the label of the given edge.
   *
   * @param edge {@link Cell} that represents the edge.
   * @param x Integer that specifies the x-coordinate of the new location.
   * @param y Integer that specifies the y-coordinate of the new location.
   */
  moveLabel(edgeState, x, y) {
    const model = this.graph.getDataModel();
    let geometry = edgeState.cell.getGeometry();
    if (geometry != null) {
      const { scale } = this.graph.getView();
      geometry = geometry.clone();
      if (geometry.relative) {
        let pt = this.graph.getView().getRelativePoint(edgeState, x, y);
        geometry.x = Math.round(pt.x * 1e4) / 1e4;
        geometry.y = Math.round(pt.y);
        geometry.offset = new Point(0, 0);
        pt = this.graph.view.getPoint(edgeState, geometry);
        geometry.offset = new Point(Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));
      } else {
        const points = edgeState.absolutePoints;
        const p0 = points[0];
        const pe = points[points.length - 1];
        if (p0 != null && pe != null) {
          const cx = p0.x + (pe.x - p0.x) / 2;
          const cy = p0.y + (pe.y - p0.y) / 2;
          geometry.offset = new Point(Math.round((x - cx) / scale), Math.round((y - cy) / scale));
          geometry.x = 0;
          geometry.y = 0;
        }
      }
      model.setGeometry(edgeState.cell, geometry);
    }
  }
  /**
   * Changes the terminal or terminal point of the given edge in the graph model.
   *
   * @param edge {@link Cell} that represents the edge to be reconnected.
   * @param terminal {@link Cell} that represents the new terminal.
   * @param isSource Boolean indicating if the new terminal is the source or target terminal.
   * @param _isClone Boolean indicating if the new connection should be a clone of the old edge.
   * @param _me {@link MouseEvent} that contains the mouse up event.
   */
  connect(edge, terminal, isSource, _isClone, _me) {
    edge.getParent();
    this.graph.batchUpdate(() => {
      let constraint = this.constraintHandler.currentConstraint;
      if (constraint == null) {
        constraint = new ConnectionConstraint(null);
      }
      this.graph.connectCell(edge, terminal, isSource, constraint);
    });
    return edge;
  }
  /**
   * Changes the terminal point of the given edge.
   */
  changeTerminalPoint(edge, point, isSource, clone2) {
    const model = this.graph.getDataModel();
    model.batchUpdate(() => {
      if (clone2) {
        const parent = edge.getParent();
        const terminal = edge.getTerminal(!isSource);
        edge = this.graph.cloneCell(edge);
        model.add(parent, edge, parent.getChildCount());
        model.setTerminal(edge, terminal, !isSource);
      }
      let geo = edge.getGeometry();
      if (geo != null) {
        geo = geo.clone();
        geo.setTerminalPoint(point, isSource);
        model.setGeometry(edge, geo);
        this.graph.connectCell(edge, null, isSource, new ConnectionConstraint(null));
      }
    });
    return edge;
  }
  /**
   * Changes the control points of the given edge in the graph model.
   */
  changePoints(edge, points, clone2) {
    const model = this.graph.getDataModel();
    model.batchUpdate(() => {
      if (clone2) {
        const parent = edge.getParent();
        const source = edge.getTerminal(true);
        const target = edge.getTerminal(false);
        edge = this.graph.cloneCell(edge);
        model.add(parent, edge, parent.getChildCount());
        model.setTerminal(edge, source, true);
        model.setTerminal(edge, target, false);
      }
      let geo = edge.getGeometry();
      if (geo != null) {
        geo = geo.clone();
        geo.points = points;
        model.setGeometry(edge, geo);
      }
    });
    return edge;
  }
  /**
   * Adds a control point for the given state and event.
   */
  addPoint(state, evt) {
    const pt = convertPoint(this.graph.container, getClientX(evt), getClientY(evt));
    const gridEnabled = this.graph.isGridEnabledEvent(evt);
    this.convertPoint(pt, gridEnabled);
    this.addPointAt(state, pt.x, pt.y);
    InternalEvent.consume(evt);
  }
  /**
   * Adds a control point at the given point.
   */
  addPointAt(state, x, y) {
    let geo = state.cell.getGeometry();
    const pt = new Point(x, y);
    if (geo != null) {
      geo = geo.clone();
      const t = this.graph.view.translate;
      const s = this.graph.view.scale;
      let offset = new Point(t.x * s, t.y * s);
      const parent = this.state.cell.getParent();
      if (parent && parent.isVertex()) {
        const pState = this.graph.view.getState(parent);
        if (pState)
          offset = new Point(pState.x, pState.y);
      }
      const index = findNearestSegment(state, pt.x * s + offset.x, pt.y * s + offset.y);
      if (geo.points == null) {
        geo.points = [pt];
      } else {
        geo.points.splice(index, 0, pt);
      }
      this.graph.getDataModel().setGeometry(state.cell, geo);
      this.refresh();
      this.redraw();
    }
  }
  /**
   * Removes the control point at the given index from the given state.
   */
  removePoint(state, index) {
    if (index > 0 && index < this.abspoints.length - 1) {
      let geo = this.state.cell.getGeometry();
      if (geo != null && geo.points != null) {
        geo = geo.clone();
        (geo.points || []).splice(index - 1, 1);
        this.graph.getDataModel().setGeometry(state.cell, geo);
        this.refresh();
        this.redraw();
      }
    }
  }
  /**
   * Returns the fillcolor for the handle at the given index.
   */
  getHandleFillColor(index) {
    const isSource = index === 0;
    const { cell } = this.state;
    const terminal = cell.getTerminal(isSource);
    let color = HandleConfig.fillColor;
    if (terminal != null && !this.graph.isCellDisconnectable(cell, terminal, isSource) || terminal == null && !this.graph.isTerminalPointMovable(cell, isSource)) {
      color = LOCKED_HANDLE_FILLCOLOR;
    } else if (terminal != null && this.graph.isCellDisconnectable(cell, terminal, isSource)) {
      color = EdgeHandlerConfig.connectFillColor;
    }
    return color;
  }
  /**
   * Redraws the preview, and the bends- and label control points.
   */
  redraw(ignoreHandles) {
    this.abspoints = this.state.absolutePoints.slice();
    const g = this.state.cell.getGeometry();
    if (g) {
      const pts = g.points;
      if (this.bends != null && this.bends.length > 0) {
        if (pts != null) {
          if (this.points == null) {
            this.points = [];
          }
          for (let i = 1; i < this.bends.length - 1; i += 1) {
            if (this.bends[i] != null && this.abspoints[i] != null) {
              this.points[i - 1] = pts[i - 1];
            }
          }
        }
      }
    }
    this.drawPreview();
    if (!ignoreHandles) {
      this.redrawHandles();
    }
  }
  /**
   * Redraws the handles.
   */
  redrawHandles() {
    const { cell } = this.state;
    let b = this.labelShape.bounds;
    this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
    this.labelShape.bounds = new Rectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);
    const lab = this.graph.getLabel(cell);
    this.labelShape.visible = lab != null && lab.length > 0 && this.graph.isLabelMovable(cell);
    if (this.bends != null && this.bends.length > 0) {
      const n = this.abspoints.length - 1;
      const p0 = this.abspoints[0];
      const x0 = p0.x;
      const y0 = p0.y;
      b = this.bends[0].bounds;
      this.bends[0].bounds = new Rectangle(Math.floor(x0 - b.width / 2), Math.floor(y0 - b.height / 2), b.width, b.height);
      this.bends[0].fill = this.getHandleFillColor(0);
      this.bends[0].redraw();
      if (this.manageLabelHandle) {
        this.checkLabelHandle(this.bends[0].bounds);
      }
      const pe = this.abspoints[n];
      const xn = pe.x;
      const yn = pe.y;
      const bn = this.bends.length - 1;
      b = this.bends[bn].bounds;
      this.bends[bn].bounds = new Rectangle(Math.floor(xn - b.width / 2), Math.floor(yn - b.height / 2), b.width, b.height);
      this.bends[bn].fill = this.getHandleFillColor(bn);
      this.bends[bn].redraw();
      if (this.manageLabelHandle) {
        this.checkLabelHandle(this.bends[bn].bounds);
      }
      this.redrawInnerBends(p0, pe);
    }
    if (this.virtualBends && this.virtualBends.length > 0) {
      let last = this.abspoints[0];
      for (let i = 0; i < this.virtualBends.length; i += 1) {
        if (this.virtualBends[i] != null && this.abspoints[i + 1] != null) {
          const pt = this.abspoints[i + 1];
          const b2 = this.virtualBends[i];
          const x = last.x + (pt.x - last.x) / 2;
          const y = last.y + (pt.y - last.y) / 2;
          if (b2.bounds) {
            b2.bounds = new Rectangle(Math.floor(x - b2.bounds.width / 2), Math.floor(y - b2.bounds.height / 2), b2.bounds.width, b2.bounds.height);
            b2.redraw();
          }
          setOpacity(b2.node, EdgeHandlerConfig.virtualBendOpacity);
          last = pt;
          if (this.manageLabelHandle) {
            this.checkLabelHandle(b2.bounds);
          }
        }
      }
    }
    this.labelShape.redraw();
    if (this.customHandles) {
      for (let i = 0; i < this.customHandles.length; i += 1) {
        const shape = this.customHandles[i].shape;
        if (shape) {
          const temp = shape.node.style.display;
          this.customHandles[i].redraw();
          shape.node.style.display = temp;
          shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i]) ? "" : "hidden";
        }
      }
    }
  }
  /**
   * Returns true if the given custom handle is visible.
   */
  isCustomHandleVisible(handle) {
    return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1;
  }
  /**
   * Shortcut to {@link hideSizers}.
   */
  setHandlesVisible(visible) {
    for (let i = 0; i < this.bends.length; i += 1) {
      this.bends[i].node.style.display = visible ? "" : "none";
    }
    if (this.virtualBends) {
      for (let i = 0; i < this.virtualBends.length; i += 1) {
        this.virtualBends[i].node.style.display = visible ? "" : "none";
      }
    }
    this.labelShape.node.style.display = visible ? "" : "none";
    if (this.customHandles) {
      for (let i = 0; i < this.customHandles.length; i += 1) {
        this.customHandles[i].setVisible(visible);
      }
    }
  }
  /**
   * Updates and redraws the inner bends.
   *
   * @param p0 {@link Point} that represents the location of the first point.
   * @param pe {@link Point} that represents the location of the last point.
   */
  redrawInnerBends(p0, pe) {
    for (let i = 1; i < this.bends.length - 1; i += 1) {
      if (this.bends[i] != null) {
        if (this.abspoints[i] != null) {
          const { x } = this.abspoints[i];
          const { y } = this.abspoints[i];
          const b = this.bends[i].bounds;
          this.bends[i].node.style.visibility = "visible";
          this.bends[i].bounds = new Rectangle(Math.round(x - b.width / 2), Math.round(y - b.height / 2), b.width, b.height);
          if (this.manageLabelHandle) {
            this.checkLabelHandle(this.bends[i].bounds);
          } else if (this.handleImage == null && this.labelShape.visible && intersects$1(this.bends[i].bounds, this.labelShape.bounds)) {
            const w = HandleConfig.size + 3;
            const h = w;
            this.bends[i].bounds = new Rectangle(Math.round(x - w / 2), Math.round(y - h / 2), w, h);
          }
          this.bends[i].redraw();
        } else {
          this.bends[i].destroy();
        }
      }
    }
  }
  /**
   * Checks if the label handle intersects the given bounds and moves it if it
   * intersects.
   */
  checkLabelHandle(b) {
    const b2 = this.labelShape.bounds;
    if (intersects$1(b, b2)) {
      if (b.getCenterY() < b2.getCenterY()) {
        b2.y = b.y + b.height;
      } else {
        b2.y = b.y - b2.height;
      }
    }
  }
  /**
   * Redraws the preview.
   */
  drawPreview() {
    try {
      if (this.isLabel) {
        const b = this.labelShape.bounds;
        const bounds = new Rectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);
        if (!b.equals(bounds)) {
          this.labelShape.bounds = bounds;
          this.labelShape.redraw();
        }
      }
      if (this.shape != null && !equalPoints(this.shape.points, this.abspoints)) {
        this.shape.apply(this.state);
        this.shape.points = this.abspoints.slice();
        this.shape.scale = this.state.view.scale;
        this.shape.isDashed = this.isSelectionDashed();
        this.shape.stroke = this.getSelectionColor();
        this.shape.strokeWidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;
        this.shape.isShadow = false;
        this.shape.redraw();
      }
      this.updateParentHighlight();
    } catch (e) {
    }
  }
  /**
   * Refreshes the bends of this handler.
   */
  refresh() {
    if (this.state != null) {
      this.abspoints = this.getSelectionPoints(this.state);
      this.points = [];
      this.destroyBends(this.bends);
      this.bends = this.createBends();
      if (this.virtualBends) {
        this.destroyBends(this.virtualBends);
        this.virtualBends = this.createVirtualBends();
      }
      if (this.customHandles) {
        this.destroyBends(this.customHandles);
        this.customHandles = this.createCustomHandles();
      }
      if (this.labelShape != null && this.labelShape.node != null && this.labelShape.node.parentNode != null) {
        this.labelShape.node.parentNode.appendChild(this.labelShape.node);
      }
    }
  }
  /**
   * Returns true if {@link destroy} was called.
   */
  isDestroyed() {
    return this.shape == null;
  }
  /**
   * Destroys all elements in {@link bends}.
   */
  destroyBends(bends) {
    if (bends != null) {
      for (let i = 0; i < bends.length; i += 1) {
        if (bends[i] != null) {
          bends[i].destroy();
        }
      }
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes. This does
   * normally not need to be called as handlers are destroyed automatically
   * when the corresponding cell is deselected.
   */
  onDestroy() {
    this.state.view.graph.removeListener(this.escapeHandler);
    this.marker.destroy();
    this.marker = null;
    this.shape.destroy();
    this.shape = null;
    if (this.parentHighlight) {
      const parent = this.state.cell.getParent();
      const pstate = parent ? this.graph.view.getState(parent) : null;
      if (pstate && pstate.parentHighlight === this.parentHighlight) {
        pstate.parentHighlight = null;
      }
      this.parentHighlight.destroy();
      this.parentHighlight = null;
    }
    this.labelShape.destroy();
    this.labelShape = null;
    this.constraintHandler.onDestroy();
    this.constraintHandler = null;
    if (this.virtualBends) {
      this.destroyBends(this.virtualBends);
      this.virtualBends = [];
    }
    if (this.customHandles) {
      this.destroyBends(this.customHandles);
      this.customHandles = [];
    }
    this.destroyBends(this.bends);
    this.bends = [];
    this.removeHint();
  }
}
class EdgeHandlerCellMarker extends CellMarker {
  constructor(graph, edgeHandler, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {
    super(graph, validColor, invalidColor, hotspot);
    this.getCell = (me) => {
      let cell = super.getCell(me);
      if ((cell === this.edgeHandler.state.cell || !cell) && this.edgeHandler.currentPoint) {
        cell = this.edgeHandler.graph.getCellAt(this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y);
      }
      if (cell && !cell.isConnectable()) {
        const parent = cell.getParent();
        if (parent && parent.isVertex() && parent.isConnectable()) {
          cell = parent;
        }
      }
      if (cell) {
        if (this.graph.isSwimlane(cell) && this.edgeHandler.currentPoint && this.graph.hitsSwimlaneContent(cell, this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y) || !this.edgeHandler.isConnectableCell(cell) || cell === this.edgeHandler.state.cell || cell && !this.edgeHandler.graph.connectableEdges && cell.isEdge() || this.edgeHandler.state.cell.isAncestor(cell)) {
          cell = null;
        }
      }
      if (cell && !cell.isConnectable()) {
        cell = null;
      }
      return cell;
    };
    this.isValidState = (state) => {
      const cell = this.edgeHandler.state.cell.getTerminal(!this.edgeHandler.isSource);
      const cellState = this.edgeHandler.graph.view.getState(cell);
      const other = this.edgeHandler.graph.view.getTerminalPort(state, cellState, !this.edgeHandler.isSource);
      const otherCell = other ? other.cell : null;
      const source = this.edgeHandler.isSource ? state.cell : otherCell;
      const target = this.edgeHandler.isSource ? otherCell : state.cell;
      this.edgeHandler.error = this.edgeHandler.validateConnection(source, target);
      return !this.edgeHandler.error;
    };
    this.edgeHandler = edgeHandler;
  }
}
class VertexHandler {
  /**
   * Specifies if a rotation handle should be visible.
   *
   * This implementation returns {@link VertexHandlerConfig.rotationEnabled}.
   * @since 0.12.0
   */
  isRotationEnabled() {
    return VertexHandlerConfig.rotationEnabled;
  }
  /**
   * Constructs an event handler that allows to resize vertices and groups.
   *
   * @param state {@link CellState} of the cell to be resized.
   */
  constructor(state) {
    this.sizers = [];
    this.singleSizer = false;
    this.index = null;
    this.allowHandleBoundsCheck = true;
    this.handleImage = null;
    this.handlesVisible = true;
    this.tolerance = 0;
    this.parentHighlightEnabled = false;
    this.rotationRaster = true;
    this.rotationCursor = "crosshair";
    this.livePreview = false;
    this.movePreviewToFront = false;
    this.manageSizers = false;
    this.constrainGroupByChildren = false;
    this.rotationHandleVSpacing = -16;
    this.horizontalOffset = 0;
    this.verticalOffset = 0;
    this.minBounds = null;
    this.x0 = 0;
    this.y0 = 0;
    this.customHandles = [];
    this.inTolerance = false;
    this.startX = 0;
    this.startY = 0;
    this.rotationShape = null;
    this.currentAlpha = null;
    this.startAngle = 0;
    this.startDist = 0;
    this.ghostPreview = null;
    this.livePreviewActive = false;
    this.childOffsetX = 0;
    this.childOffsetY = 0;
    this.parentState = null;
    this.parentHighlight = null;
    this.unscaledBounds = null;
    this.preview = null;
    this.labelShape = null;
    this.edgeHandlers = [];
    this.EMPTY_POINT = new Point();
    this.state = state;
    this.graph = this.state.view.graph;
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
    this.selectionBorder = this.createSelectionShape(this.bounds);
    this.selectionBorder.dialect = DIALECT.SVG;
    this.selectionBorder.pointerEvents = false;
    this.selectionBorder.rotation = this.state.style.rotation ?? 0;
    this.selectionBorder.init(this.graph.getView().getOverlayPane());
    InternalEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);
    if (this.graph.isCellMovable(this.state.cell)) {
      this.selectionBorder.setCursor(CURSOR.MOVABLE_VERTEX);
    }
    const selectionHandler = this.getSelectionHandler();
    if (selectionHandler && (selectionHandler.maxCells <= 0 || this.graph.getSelectionCount() < selectionHandler.maxCells)) {
      const resizable = this.graph.isCellResizable(this.state.cell);
      this.sizers = [];
      if (resizable || this.graph.isLabelMovable(this.state.cell) && this.state.width >= 2 && this.state.height >= 2) {
        let i = 0;
        if (resizable) {
          if (!this.singleSizer) {
            this.sizers.push(this.createSizer("nw-resize", i++));
            this.sizers.push(this.createSizer("n-resize", i++));
            this.sizers.push(this.createSizer("ne-resize", i++));
            this.sizers.push(this.createSizer("w-resize", i++));
            this.sizers.push(this.createSizer("e-resize", i++));
            this.sizers.push(this.createSizer("sw-resize", i++));
            this.sizers.push(this.createSizer("s-resize", i++));
          }
          this.sizers.push(this.createSizer("se-resize", i++));
        }
        const geo = this.state.cell.getGeometry();
        if (geo != null && !geo.relative && !this.graph.isSwimlane(this.state.cell) && this.graph.isLabelMovable(this.state.cell)) {
          this.labelShape = this.createSizer(CURSOR.LABEL_HANDLE, InternalEvent.LABEL_HANDLE, HandleConfig.labelSize, HandleConfig.labelFillColor);
          this.sizers.push(this.labelShape);
        }
      } else if (this.graph.isCellMovable(this.state.cell) && !this.graph.isCellResizable(this.state.cell) && this.state.width < 2 && this.state.height < 2) {
        this.labelShape = this.createSizer(CURSOR.MOVABLE_VERTEX, InternalEvent.LABEL_HANDLE, void 0, HandleConfig.labelFillColor);
        this.sizers.push(this.labelShape);
      }
    }
    if (this.isRotationHandleVisible()) {
      this.rotationShape = this.createSizer(this.rotationCursor, InternalEvent.ROTATION_HANDLE, HandleConfig.size + 3, HandleConfig.fillColor);
      this.sizers.push(this.rotationShape);
    }
    this.customHandles = this.createCustomHandles();
    this.redraw();
    if (this.constrainGroupByChildren) {
      this.updateMinBounds();
    }
    this.escapeHandler = (_sender, _evt) => {
      if (this.livePreview && this.index != null) {
        this.state.view.graph.cellRenderer.redraw(this.state, true);
        this.state.view.invalidate(this.state.cell);
        this.state.invalid = false;
        this.state.view.validate();
      }
      this.reset();
    };
    this.state.view.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);
  }
  getSelectionHandler() {
    return this.graph.getPlugin("SelectionHandler");
  }
  /**
   * Returns `true` if the rotation handle should be showing.
   */
  isRotationHandleVisible() {
    const selectionHandler = this.getSelectionHandler();
    const selectionHandlerCheck = selectionHandler ? selectionHandler.maxCells <= 0 || this.graph.getSelectionCount() < selectionHandler.maxCells : true;
    return this.graph.isEnabled() && this.isRotationEnabled() && this.graph.isCellRotatable(this.state.cell) && selectionHandlerCheck;
  }
  /**
   * Returns `true` if the aspect ratio if the cell should be maintained.
   */
  isConstrainedEvent(me) {
    return isShiftDown(me.getEvent()) || this.state.style.aspect === "fixed";
  }
  /**
   * Returns `true` if the center of the vertex should be maintained during the resize.
   */
  isCenteredEvent(state, me) {
    return false;
  }
  /**
   * Returns an array of custom handles.
   *
   * This implementation returns an empty array.
   */
  createCustomHandles() {
    return [];
  }
  /**
   * Initializes the shapes required for this vertex handler.
   */
  updateMinBounds() {
    const children = this.graph.getChildCells(this.state.cell);
    if (children.length > 0) {
      this.minBounds = this.graph.view.getBounds(children);
      if (this.minBounds) {
        const s = this.state.view.scale;
        const t = this.state.view.translate;
        this.minBounds.x -= this.state.x;
        this.minBounds.y -= this.state.y;
        this.minBounds.x /= s;
        this.minBounds.y /= s;
        this.minBounds.width /= s;
        this.minBounds.height /= s;
        this.x0 = this.state.x / s - t.x;
        this.y0 = this.state.y / s - t.y;
      }
    }
  }
  /**
   * Returns the Rectangle that defines the bounds of the selection border.
   */
  getSelectionBounds(state) {
    return new Rectangle(Math.round(state.x), Math.round(state.y), Math.round(state.width), Math.round(state.height));
  }
  /**
   * Creates the shape used to draw the selection border.
   */
  createParentHighlightShape(bounds) {
    return this.createSelectionShape(bounds);
  }
  /**
   * Creates the shape used to draw the selection border.
   */
  createSelectionShape(bounds) {
    const shape = new RectangleShape(Rectangle.fromRectangle(bounds), NONE, this.getSelectionColor());
    shape.strokeWidth = this.getSelectionStrokeWidth();
    shape.isDashed = this.isSelectionDashed();
    return shape;
  }
  /**
   * Returns {@link VertexHandlerConfig.selectionColor}.
   */
  getSelectionColor() {
    return VertexHandlerConfig.selectionColor;
  }
  /**
   * Returns {@link VertexHandlerConfig.selectionStrokeWidth}.
   */
  getSelectionStrokeWidth() {
    return VertexHandlerConfig.selectionStrokeWidth;
  }
  /**
   * Returns {@link VertexHandlerConfig.selectionDashed}.
   */
  isSelectionDashed() {
    return VertexHandlerConfig.selectionDashed;
  }
  /**
   * Creates a sizer handle for the specified cursor and index and returns
   * the new {@link RectangleShape} that represents the handle.
   */
  createSizer(cursor, index, size = HandleConfig.size, fillColor = HandleConfig.fillColor) {
    const bounds = new Rectangle(0, 0, size, size);
    const sizer = this.createSizerShape(bounds, index, fillColor);
    if (sizer.bounds && sizer.isHtmlAllowed() && this.state.text && this.state.text.node.parentNode === this.graph.container) {
      sizer.bounds.height -= 1;
      sizer.bounds.width -= 1;
      sizer.dialect = DIALECT.STRICTHTML;
      sizer.init(this.graph.container);
    } else {
      sizer.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
      sizer.init(this.graph.getView().getOverlayPane());
    }
    InternalEvent.redirectMouseEvents(sizer.node, this.graph, this.state);
    if (this.graph.isEnabled()) {
      sizer.setCursor(cursor);
    }
    if (!this.isSizerVisible(index)) {
      sizer.visible = false;
    }
    return sizer;
  }
  /**
   * Returns `true` if the sizer for the given index is visible.
   *
   * This implementation returns `true` for all given indices.
   */
  isSizerVisible(_index) {
    return true;
  }
  /**
   * Creates the shape used for the sizer handle for the specified bounds an
   * index. Only images and rectangles should be returned if support for HTML
   * labels with not foreign objects is required.
   */
  createSizerShape(bounds, index, fillColor = HandleConfig.fillColor) {
    if (this.handleImage) {
      bounds = new Rectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);
      const shape = new ImageShape(bounds, this.handleImage.src);
      shape.preserveImageAspect = false;
      return shape;
    }
    const strokeColor = HandleConfig.strokeColor;
    if (index === InternalEvent.ROTATION_HANDLE) {
      return new EllipseShape(bounds, fillColor, strokeColor);
    }
    return new RectangleShape(bounds, fillColor, strokeColor);
  }
  /**
   * Helper method to create an {@link Rectangle} around the given center point
   * with a width and height of 2*s or 6, if no s is given.
   */
  moveSizerTo(shape, x, y) {
    if (shape && shape.bounds) {
      shape.bounds.x = Math.floor(x - shape.bounds.width / 2);
      shape.bounds.y = Math.floor(y - shape.bounds.height / 2);
      if (shape.node && shape.node.style.display !== "none") {
        shape.redraw();
      }
    }
  }
  /**
   * Returns the index of the handle for the given event. This returns the index
   * of the sizer from where the event originated or {@link InternalEvent.LABEL_HANDLE}.
   */
  getHandleForEvent(me) {
    const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;
    const hit = this.allowHandleBoundsCheck && tol > 0 ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
    const checkShape = (shape) => {
      const st = shape && shape.constructor !== ImageShape && this.allowHandleBoundsCheck ? shape.strokeWidth + shape.svgStrokeTolerance : null;
      const real = st ? new Rectangle(me.getGraphX() - Math.floor(st / 2), me.getGraphY() - Math.floor(st / 2), st, st) : hit;
      return shape && shape.bounds && (me.isSource(shape) || real && intersects$1(shape.bounds, real) && shape.node.style.display !== "none" && shape.node.style.visibility !== "hidden");
    };
    if (checkShape(this.rotationShape)) {
      return InternalEvent.ROTATION_HANDLE;
    }
    if (checkShape(this.labelShape)) {
      return InternalEvent.LABEL_HANDLE;
    }
    for (let i = 0; i < this.sizers.length; i += 1) {
      if (checkShape(this.sizers[i])) {
        return i;
      }
    }
    if (this.customHandles != null && this.isCustomHandleEvent(me)) {
      for (let i = this.customHandles.length - 1; i >= 0; i--) {
        if (checkShape(this.customHandles[i].shape)) {
          return InternalEvent.CUSTOM_HANDLE - i;
        }
      }
    }
    return null;
  }
  /**
   * Returns `true` if the given event allows custom handles to be changed.
   *
   * This implementation returns `true`.
   */
  isCustomHandleEvent(me) {
    return true;
  }
  /**
   * Handles the event if a handle has been clicked. By consuming the
   * event all subsequent events of the gesture are redirected to this
   * handler.
   */
  mouseDown(sender, me) {
    if (!me.isConsumed() && this.graph.isEnabled()) {
      const handle = this.getHandleForEvent(me);
      if (handle) {
        this.start(me.getGraphX(), me.getGraphY(), handle);
        me.consume();
      }
    }
  }
  /**
   * Called if {@link livePreview} is enabled to check if a border should be painted.
   *
   * This implementation returns `true` if the shape is transparent.
   */
  isLivePreviewBorder() {
    return this.state.shape && this.state.shape.fill === NONE && this.state.shape.stroke === NONE;
  }
  /**
   * Starts the handling of the mouse gesture.
   */
  start(x, y, index) {
    this.livePreviewActive = this.livePreview && this.state.cell.getChildCount() === 0;
    this.inTolerance = true;
    this.childOffsetX = 0;
    this.childOffsetY = 0;
    this.index = index;
    this.startX = x;
    this.startY = y;
    if (this.index <= InternalEvent.CUSTOM_HANDLE && this.isGhostPreview()) {
      this.ghostPreview = this.createGhostPreview();
    } else {
      const parent = this.state.cell.getParent();
      if (this.state.view.currentRoot !== parent && parent && (parent.isVertex() || parent.isEdge())) {
        this.parentState = this.state.view.graph.view.getState(parent);
      }
      this.selectionBorder.node.style.display = index === InternalEvent.ROTATION_HANDLE ? "inline" : "none";
      if (!this.livePreviewActive || this.isLivePreviewBorder()) {
        this.preview = this.createSelectionShape(this.bounds);
        if (!(Client.IS_SVG && (this.state.style.rotation ?? 0) != 0) && this.state.text != null && this.state.text.node.parentNode === this.graph.container) {
          this.preview.dialect = DIALECT.STRICTHTML;
          this.preview.init(this.graph.container);
        } else {
          this.preview.dialect = DIALECT.SVG;
          this.preview.init(this.graph.view.getOverlayPane());
        }
      }
      if (index === InternalEvent.ROTATION_HANDLE) {
        const pos = this.getRotationHandlePosition();
        const dx = pos.x - this.state.getCenterX();
        const dy = pos.y - this.state.getCenterY();
        this.startAngle = dx !== 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : 0;
        this.startDist = Math.sqrt(dx * dx + dy * dy);
      }
      if (this.livePreviewActive) {
        this.hideSizers();
        if (index === InternalEvent.ROTATION_HANDLE && this.rotationShape) {
          this.rotationShape.node.style.display = "";
        } else if (index === InternalEvent.LABEL_HANDLE && this.labelShape) {
          this.labelShape.node.style.display = "";
        } else if (this.sizers[index]) {
          this.sizers[index].node.style.display = "";
        } else if (index <= InternalEvent.CUSTOM_HANDLE) {
          this.customHandles[InternalEvent.CUSTOM_HANDLE - index].setVisible(true);
        }
        const edges = this.state.cell.getEdges();
        this.edgeHandlers = [];
        const selectionCellsHandler = this.graph.getPlugin("SelectionCellsHandler");
        for (let i = 0; i < edges.length; i += 1) {
          const handler = selectionCellsHandler == null ? void 0 : selectionCellsHandler.getHandler(edges[i]);
          if (handler) {
            this.edgeHandlers.push(handler);
          }
        }
      }
    }
  }
  /**
   * Starts the handling of the mouse gesture.
   */
  createGhostPreview() {
    const shape = this.graph.cellRenderer.createShape(this.state);
    shape.init(this.graph.view.getOverlayPane());
    shape.scale = this.state.view.scale;
    shape.bounds = this.bounds;
    shape.outline = true;
    return shape;
  }
  /**
   * Shortcut to {@link hideSizers}.
   */
  setHandlesVisible(visible) {
    this.handlesVisible = visible;
    for (let i = 0; i < this.sizers.length; i += 1) {
      this.sizers[i].node.style.display = visible ? "" : "none";
    }
    for (let i = 0; i < this.customHandles.length; i += 1) {
      this.customHandles[i].setVisible(visible);
    }
  }
  /**
   * Hides all sizers except.
   *
   * Starts the handling of the mouse gesture.
   */
  hideSizers() {
    this.setHandlesVisible(false);
  }
  /**
   * Checks if the coordinates for the given event are within the
   * {@link Graph#tolerance}. If the event is a mouse event then the tolerance is
   * ignored.
   */
  checkTolerance(me) {
    if (this.inTolerance && this.startX !== null && this.startY !== null) {
      if (isMouseEvent(me.getEvent()) || Math.abs(me.getGraphX() - this.startX) > this.graph.getEventTolerance() || Math.abs(me.getGraphY() - this.startY) > this.graph.getEventTolerance()) {
        this.inTolerance = false;
      }
    }
  }
  /**
   * Hook for subclasses do show details while the handler is active.
   */
  updateHint(me) {
    return;
  }
  /**
   * Hooks for subclasses to hide details when the handler gets inactive.
   */
  removeHint() {
    return;
  }
  /**
   * Hook for rounding the angle. This uses {@link Math.round}.
   */
  roundAngle(angle) {
    return Math.round(angle * 10) / 10;
  }
  /**
   * Hook for rounding the unscaled width or height. This uses {@link Math.round}.
   */
  roundLength(length) {
    return Math.round(length * 100) / 100;
  }
  /**
   * Handles the event by updating the preview.
   */
  mouseMove(sender, me) {
    if (!me.isConsumed() && this.index != null) {
      this.checkTolerance(me);
      if (!this.inTolerance) {
        if (this.index <= InternalEvent.CUSTOM_HANDLE) {
          if (this.customHandles != null) {
            this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);
            this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].active = true;
            if (this.ghostPreview != null) {
              this.ghostPreview.apply(this.state);
              this.ghostPreview.strokeWidth = this.getSelectionStrokeWidth() / this.ghostPreview.scale / this.ghostPreview.scale;
              this.ghostPreview.isDashed = this.isSelectionDashed();
              this.ghostPreview.stroke = this.getSelectionColor();
              this.ghostPreview.redraw();
              if (this.selectionBounds != null) {
                this.selectionBorder.node.style.display = "none";
              }
            } else {
              if (this.movePreviewToFront) {
                this.moveToFront();
              }
              this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].positionChanged();
            }
          }
        } else if (this.index === InternalEvent.LABEL_HANDLE) {
          this.moveLabel(me);
        } else {
          if (this.index === InternalEvent.ROTATION_HANDLE) {
            this.rotateVertex(me);
          } else {
            this.resizeVertex(me);
          }
          this.updateHint(me);
        }
      }
      me.consume();
    } else if (!this.graph.isMouseDown && this.getHandleForEvent(me)) {
      me.consume(false);
    }
  }
  /**
   * Returns `true` if a ghost preview should be used for custom handles.
   */
  isGhostPreview() {
    return this.state.cell.getChildCount() > 0;
  }
  /**
   * Moves the vertex.
   */
  moveLabel(me) {
    const point = new Point(me.getGraphX(), me.getGraphY());
    const tr = this.graph.view.translate;
    const { scale } = this.graph.view;
    if (this.graph.isGridEnabledEvent(me.getEvent())) {
      point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
      point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
    }
    const index = this.rotationShape ? this.sizers.length - 2 : this.sizers.length - 1;
    this.moveSizerTo(this.sizers[index], point.x, point.y);
  }
  /**
   * Rotates the vertex.
   */
  rotateVertex(me) {
    const point = new Point(me.getGraphX(), me.getGraphY());
    let dx = this.state.x + this.state.width / 2 - point.x;
    let dy = this.state.y + this.state.height / 2 - point.y;
    this.currentAlpha = dx !== 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : dy < 0 ? 180 : 0;
    if (dx > 0) {
      this.currentAlpha -= 180;
    }
    this.currentAlpha -= this.startAngle;
    if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {
      let raster;
      dx = point.x - this.state.getCenterX();
      dy = point.y - this.state.getCenterY();
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist - this.startDist < 2) {
        raster = 15;
      } else if (dist - this.startDist < 25) {
        raster = 5;
      } else {
        raster = 1;
      }
      this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;
    } else {
      this.currentAlpha = this.roundAngle(this.currentAlpha);
    }
    this.selectionBorder.rotation = this.currentAlpha;
    this.selectionBorder.redraw();
    if (this.livePreviewActive) {
      this.redrawHandles();
    }
  }
  /**
   * Resizes the vertex.
   */
  resizeVertex(me) {
    const ct = new Point(this.state.getCenterX(), this.state.getCenterY());
    const alpha = toRadians(this.state.style.rotation ?? 0);
    const point = new Point(me.getGraphX(), me.getGraphY());
    const tr = this.graph.view.translate;
    const { scale } = this.graph.view;
    let cos = Math.cos(-alpha);
    let sin = Math.sin(-alpha);
    let dx = point.x - this.startX;
    let dy = point.y - this.startY;
    const tx = cos * dx - sin * dy;
    const ty = sin * dx + cos * dy;
    dx = tx;
    dy = ty;
    const geo = this.state.cell.getGeometry();
    if (geo && this.index !== null) {
      this.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new Point(0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));
    }
    if (geo && !geo.relative) {
      let max = this.graph.getMaximumGraphBounds();
      if (max != null && this.parentState != null) {
        max = Rectangle.fromRectangle(max);
        max.x -= (this.parentState.x - tr.x * scale) / scale;
        max.y -= (this.parentState.y - tr.y * scale) / scale;
      }
      if (this.graph.isConstrainChild(this.state.cell)) {
        let tmp = this.graph.getCellContainmentArea(this.state.cell);
        if (tmp != null) {
          const overlap = this.graph.getOverlap(this.state.cell);
          if (overlap > 0) {
            tmp = Rectangle.fromRectangle(tmp);
            tmp.x -= tmp.width * overlap;
            tmp.y -= tmp.height * overlap;
            tmp.width += 2 * tmp.width * overlap;
            tmp.height += 2 * tmp.height * overlap;
          }
          if (!max) {
            max = tmp;
          } else {
            max = Rectangle.fromRectangle(max);
            max.intersect(tmp);
          }
        }
      }
      if (max && this.unscaledBounds) {
        if (this.unscaledBounds.x < max.x) {
          this.unscaledBounds.width -= max.x - this.unscaledBounds.x;
          this.unscaledBounds.x = max.x;
        }
        if (this.unscaledBounds.y < max.y) {
          this.unscaledBounds.height -= max.y - this.unscaledBounds.y;
          this.unscaledBounds.y = max.y;
        }
        if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {
          this.unscaledBounds.width -= this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;
        }
        if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {
          this.unscaledBounds.height -= this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;
        }
      }
    }
    if (this.unscaledBounds) {
      const old = this.bounds;
      this.bounds = new Rectangle((this.parentState ? this.parentState.x : tr.x * scale) + this.unscaledBounds.x * scale, (this.parentState ? this.parentState.y : tr.y * scale) + this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);
      if (geo && geo.relative && this.parentState) {
        this.bounds.x += this.state.x - this.parentState.x;
        this.bounds.y += this.state.y - this.parentState.y;
      }
      cos = Math.cos(alpha);
      sin = Math.sin(alpha);
      const c2 = new Point(this.bounds.getCenterX(), this.bounds.getCenterY());
      dx = c2.x - ct.x;
      dy = c2.y - ct.y;
      const dx2 = cos * dx - sin * dy;
      const dy2 = sin * dx + cos * dy;
      const dx3 = dx2 - dx;
      const dy3 = dy2 - dy;
      const dx4 = this.bounds.x - this.state.x;
      const dy4 = this.bounds.y - this.state.y;
      const dx5 = cos * dx4 - sin * dy4;
      const dy5 = sin * dx4 + cos * dy4;
      this.bounds.x += dx3;
      this.bounds.y += dy3;
      this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);
      this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);
      this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);
      this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);
      if (!this.state.cell.isCollapsed() && (dx3 !== 0 || dy3 !== 0)) {
        this.childOffsetX = this.state.x - this.bounds.x + dx5;
        this.childOffsetY = this.state.y - this.bounds.y + dy5;
      } else {
        this.childOffsetX = 0;
        this.childOffsetY = 0;
      }
      if (!old.equals(this.bounds)) {
        if (this.livePreviewActive) {
          this.updateLivePreview(me);
        }
        if (this.preview != null) {
          this.drawPreview();
        } else {
          this.updateParentHighlight();
        }
      }
    }
  }
  /**
   * Repaints the live preview.
   */
  updateLivePreview(me) {
    const { scale } = this.graph.view;
    const tr = this.graph.view.translate;
    const tempState = this.state.clone();
    this.state.x = this.bounds.x;
    this.state.y = this.bounds.y;
    this.state.origin = new Point(this.state.x / scale - tr.x, this.state.y / scale - tr.y);
    this.state.width = this.bounds.width;
    this.state.height = this.bounds.height;
    let off = this.state.absoluteOffset;
    off = new Point(off.x, off.y);
    this.state.absoluteOffset.x = 0;
    this.state.absoluteOffset.y = 0;
    const geo = this.state.cell.getGeometry();
    if (geo != null) {
      const offset = geo.offset || this.EMPTY_POINT;
      if (offset != null && !geo.relative) {
        this.state.absoluteOffset.x = this.state.view.scale * offset.x;
        this.state.absoluteOffset.y = this.state.view.scale * offset.y;
      }
      this.state.view.updateVertexLabelOffset(this.state);
    }
    this.state.view.graph.cellRenderer.redraw(this.state, true);
    this.state.view.invalidate(this.state.cell);
    this.state.invalid = false;
    this.state.view.validate();
    this.redrawHandles();
    if (this.movePreviewToFront) {
      this.moveToFront();
    }
    if (this.state.control != null && this.state.control.node != null) {
      this.state.control.node.style.visibility = "hidden";
    }
    this.state.setState(tempState);
  }
  /**
   * Handles the event by applying the changes to the geometry.
   */
  moveToFront() {
    if (this.state.text && this.state.text.node && this.state.text.node.nextSibling || this.state.shape && this.state.shape.node && this.state.shape.node.nextSibling && (!this.state.text || this.state.shape.node.nextSibling !== this.state.text.node)) {
      if (this.state.shape && this.state.shape.node && this.state.shape.node.parentNode) {
        this.state.shape.node.parentNode.appendChild(this.state.shape.node);
      }
      if (this.state.text && this.state.text.node && this.state.text.node.parentNode) {
        this.state.text.node.parentNode.appendChild(this.state.text.node);
      }
    }
  }
  /**
   * Handles the event by applying the changes to the geometry.
   */
  mouseUp(sender, me) {
    if (this.index != null && this.state != null) {
      const point = new Point(me.getGraphX(), me.getGraphY());
      const { index } = this;
      this.index = null;
      if (this.ghostPreview == null) {
        this.state.view.invalidate(this.state.cell, false, false);
        this.state.view.validate();
      }
      this.graph.batchUpdate(() => {
        if (index <= InternalEvent.CUSTOM_HANDLE) {
          if (this.customHandles != null) {
            const style = this.state.view.graph.getCellStyle(this.state.cell);
            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].active = false;
            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);
            if (this.customHandles != null && this.customHandles[InternalEvent.CUSTOM_HANDLE - index] != null) {
              this.state.style = style;
              this.customHandles[InternalEvent.CUSTOM_HANDLE - index].positionChanged();
            }
          }
        } else if (index === InternalEvent.ROTATION_HANDLE) {
          if (this.currentAlpha != null) {
            const delta = this.currentAlpha - (this.state.style.rotation ?? 0);
            if (delta !== 0) {
              this.rotateCell(this.state.cell, delta);
            }
          } else {
            this.rotateClick();
          }
        } else {
          const gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());
          const alpha = toRadians(this.state.style.rotation ?? 0);
          const cos = Math.cos(-alpha);
          const sin = Math.sin(-alpha);
          let dx = point.x - this.startX;
          let dy = point.y - this.startY;
          const tx = cos * dx - sin * dy;
          const ty = sin * dx + cos * dy;
          dx = tx;
          dy = ty;
          const s = this.graph.view.scale;
          const recurse = this.isRecursiveResize(this.state, me);
          this.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s), index, gridEnabled, this.isConstrainedEvent(me), recurse);
        }
      });
      me.consume();
      this.reset();
      this.redrawHandles();
    }
  }
  /**
   * Returns the `recursiveResize` status of the given state.
   * @param state the given {@link CellState}. This implementation takes the value of this state.
   * @param me the mouse event.
   */
  isRecursiveResize(state, me) {
    return this.graph.isRecursiveResize(this.state);
  }
  /**
   * Hook for subclasses to implement a single click on the rotation handle.
   * This code is executed as part of the model transaction.
   *
   * This implementation is empty.
   */
  rotateClick() {
    return;
  }
  /**
   * Rotates the given cell and its children by the given angle in degrees.
   *
   * @param cell {@link Cell} to be rotated.
   * @param angle Angle in degrees.
   * @param parent if set, consider the parent in the rotation computation.
   */
  rotateCell(cell, angle, parent) {
    if (angle !== 0) {
      const model = this.graph.getDataModel();
      if (cell.isVertex() || cell.isEdge()) {
        if (!cell.isEdge()) {
          const style = this.graph.getCurrentCellStyle(cell);
          const total = (style.rotation ?? 0) + angle;
          this.graph.setCellStyles("rotation", total, [cell]);
        }
        let geo = cell.getGeometry();
        if (geo && parent) {
          const pgeo = parent.getGeometry();
          if (pgeo != null && !parent.isEdge()) {
            geo = geo.clone();
            geo.rotate(angle, new Point(pgeo.width / 2, pgeo.height / 2));
            model.setGeometry(cell, geo);
          }
          if (cell.isVertex() && !geo.relative || cell.isEdge()) {
            const childCount = cell.getChildCount();
            for (let i = 0; i < childCount; i += 1) {
              this.rotateCell(cell.getChildAt(i), angle, cell);
            }
          }
        }
      }
    }
  }
  /**
   * Resets the state of this handler.
   */
  reset() {
    if (this.index !== null && this.sizers[this.index].node.style.display === "none") {
      this.sizers[this.index].node.style.display = "";
    }
    this.index = null;
    this.currentAlpha = null;
    if (this.preview) {
      this.preview.destroy();
      this.preview = null;
    }
    if (this.ghostPreview) {
      this.ghostPreview.destroy();
      this.ghostPreview = null;
    }
    if (this.livePreviewActive) {
      for (let i = 0; i < this.sizers.length; i += 1) {
        this.sizers[i].node.style.display = "";
      }
      if (this.state.control && this.state.control.node) {
        this.state.control.node.style.visibility = "";
      }
    }
    for (let i = 0; i < this.customHandles.length; i += 1) {
      if (this.customHandles[i].active) {
        this.customHandles[i].active = false;
        this.customHandles[i].reset();
      } else {
        this.customHandles[i].setVisible(true);
      }
    }
    this.selectionBorder.node.style.display = "inline";
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
    this.drawPreview();
    this.removeHint();
    this.redrawHandles();
    this.edgeHandlers = [];
    this.handlesVisible = true;
    this.unscaledBounds = null;
  }
  /**
   * Uses the given vector to change the bounds of the given cell
   * in the graph using {@link Graph#resizeCell}.
   */
  resizeCell(cell, dx, dy, index, gridEnabled, constrained, recurse) {
    let geo = cell.getGeometry();
    if (geo) {
      if (index === InternalEvent.LABEL_HANDLE && this.labelShape && this.labelShape.bounds) {
        const alpha = -toRadians(this.state.style.rotation ?? 0);
        const cos = Math.cos(alpha);
        const sin = Math.sin(alpha);
        const { scale } = this.graph.view;
        const pt = getRotatedPoint(new Point(Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale), Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale)), cos, sin);
        geo = geo.clone();
        if (geo.offset == null) {
          geo.offset = pt;
        } else {
          geo.offset.x += pt.x;
          geo.offset.y += pt.y;
        }
        this.graph.model.setGeometry(cell, geo);
      } else if (this.unscaledBounds) {
        const { scale } = this.graph.view;
        if (this.childOffsetX !== 0 || this.childOffsetY !== 0) {
          this.moveChildren(cell, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));
        }
        this.graph.resizeCell(cell, this.unscaledBounds, recurse);
      }
    }
  }
  /**
   * Moves the children of the given cell by the given vector.
   */
  moveChildren(cell, dx, dy) {
    const model = this.graph.getDataModel();
    const childCount = cell.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      const child = cell.getChildAt(i);
      let geo = child.getGeometry();
      if (geo != null) {
        geo = geo.clone();
        geo.translate(dx, dy);
        model.setGeometry(child, geo);
      }
    }
  }
  /**
   * Returns the union of the given bounds and location for the specified
   * handle index.
   *
   * To override this to limit the size of vertex via a minWidth/-Height style,
   * the following code can be used.
   *
   * ```javascript
   * let vertexHandlerUnion = union;
   * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>
   * {
   *   let result = vertexHandlerUnion.apply(this, arguments);
   *
   *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));
   *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));
   *
   *   return result;
   * };
   * ```
   *
   * The minWidth/-Height style can then be used as follows:
   *
   * ```javascript
   * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');
   * ```
   *
   * To override this to update the height for a wrapped text if the width of a vertex is
   * changed, the following can be used.
   *
   * ```javascript
   * let mxVertexHandlerUnion = union;
   * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>
   * {
   *   let result = mxVertexHandlerUnion.apply(this, arguments);
   *   let s = this.state;
   *
   *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&
   *       s.text != null && s.style.whiteSpace == 'wrap')
   *   {
   *     let label = this.graph.getLabel(s.cell);
   *     let fontSize = mxUtils.getNumber(s.style, 'fontSize', mxConstants.DEFAULT_FONTSIZE);
   *     let ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft
   *
   *     result.height = mxUtils.getSizeForString(label, fontSize, s.style.fontFamily, ww).height;
   *   }
   *
   *   return result;
   * };
   * ```
   */
  union(bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered) {
    gridEnabled = gridEnabled && this.graph.isGridEnabled();
    if (this.singleSizer) {
      let x = bounds.x + bounds.width + dx;
      let y = bounds.y + bounds.height + dy;
      if (gridEnabled) {
        x = this.graph.snap(x / scale) * scale;
        y = this.graph.snap(y / scale) * scale;
      }
      const rect = new Rectangle(bounds.x, bounds.y, 0, 0);
      rect.add(new Rectangle(x, y, 0, 0));
      return rect;
    }
    const w0 = bounds.width;
    const h0 = bounds.height;
    let left = bounds.x - tr.x * scale;
    let right = left + w0;
    let top = bounds.y - tr.y * scale;
    let bottom = top + h0;
    const cx = left + w0 / 2;
    const cy = top + h0 / 2;
    if (index > 4) {
      bottom += dy;
      if (gridEnabled) {
        bottom = this.graph.snap(bottom / scale) * scale;
      } else {
        bottom = Math.round(bottom / scale) * scale;
      }
    } else if (index < 3) {
      top += dy;
      if (gridEnabled) {
        top = this.graph.snap(top / scale) * scale;
      } else {
        top = Math.round(top / scale) * scale;
      }
    }
    if (index === 0 || index === 3 || index === 5) {
      left += dx;
      if (gridEnabled) {
        left = this.graph.snap(left / scale) * scale;
      } else {
        left = Math.round(left / scale) * scale;
      }
    } else if (index === 2 || index === 4 || index === 7) {
      right += dx;
      if (gridEnabled) {
        right = this.graph.snap(right / scale) * scale;
      } else {
        right = Math.round(right / scale) * scale;
      }
    }
    let width = right - left;
    let height = bottom - top;
    if (constrained) {
      const geo = this.state.cell.getGeometry();
      if (geo != null) {
        const aspect = geo.width / geo.height;
        if (index === 1 || index === 2 || index === 7 || index === 6) {
          width = height * aspect;
        } else {
          height = width / aspect;
        }
        if (index === 0) {
          left = right - width;
          top = bottom - height;
        }
      }
    }
    if (centered) {
      width += width - w0;
      height += height - h0;
      const cdx = cx - (left + width / 2);
      const cdy = cy - (top + height / 2);
      left += cdx;
      top += cdy;
      right += cdx;
      bottom += cdy;
    }
    if (width < 0) {
      left += width;
      width = Math.abs(width);
    }
    if (height < 0) {
      top += height;
      height = Math.abs(height);
    }
    const result = new Rectangle(left + tr.x * scale, top + tr.y * scale, width, height);
    if (this.minBounds != null) {
      result.width = Math.max(result.width, this.minBounds.x * scale + this.minBounds.width * scale + Math.max(0, this.x0 * scale - result.x));
      result.height = Math.max(result.height, this.minBounds.y * scale + this.minBounds.height * scale + Math.max(0, this.y0 * scale - result.y));
    }
    return result;
  }
  /**
   * Redraws the handles and the preview.
   */
  redraw(ignoreHandles) {
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
    this.drawPreview();
    if (!ignoreHandles) {
      this.redrawHandles();
    }
  }
  /**
   * Returns the padding to be used for drawing handles for the current <bounds>.
   */
  getHandlePadding() {
    const result = new Point(0, 0);
    let tol = this.tolerance;
    if (this.sizers.length > 0 && this.sizers[0].bounds && (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol || this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {
      tol /= 2;
      result.x = this.sizers[0].bounds.width + tol;
      result.y = this.sizers[0].bounds.height + tol;
    }
    return result;
  }
  /**
   * Returns the bounds used to paint the resize handles.
   */
  getSizerBounds() {
    return this.bounds;
  }
  /**
   * Redraws the handles. To hide certain handles the following code can be used.
   *
   * ```javascript
   * redrawHandles()
   * {
   *   mxVertexHandlerRedrawHandles.apply(this, arguments);
   *
   *   if (this.sizers != null && this.sizers.length > 7)
   *   {
   *     this.sizers[1].node.style.display = 'none';
   *     this.sizers[6].node.style.display = 'none';
   *   }
   * };
   * ```
   */
  redrawHandles() {
    let s = this.getSizerBounds();
    const tol = this.tolerance;
    this.horizontalOffset = 0;
    this.verticalOffset = 0;
    for (let i = 0; i < this.customHandles.length; i += 1) {
      const shape = this.customHandles[i].shape;
      if (shape) {
        const temp = shape.node.style.display;
        this.customHandles[i].redraw();
        shape.node.style.display = temp;
        shape.node.style.visibility = this.handlesVisible && this.isCustomHandleVisible(this.customHandles[i]) ? "" : "hidden";
      }
    }
    if (this.sizers.length > 0 && this.sizers[0]) {
      if (this.index === null && this.manageSizers && this.sizers.length >= 8) {
        const padding = this.getHandlePadding();
        this.horizontalOffset = padding.x;
        this.verticalOffset = padding.y;
        if (this.horizontalOffset !== 0 || this.verticalOffset !== 0) {
          s = new Rectangle(s.x, s.y, s.width, s.height);
          s.x -= this.horizontalOffset / 2;
          s.width += this.horizontalOffset;
          s.y -= this.verticalOffset / 2;
          s.height += this.verticalOffset;
        }
        if (this.sizers.length >= 8) {
          if (this.sizers[0].bounds && (s.width < 2 * this.sizers[0].bounds.width + 2 * tol || s.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {
            this.sizers[0].node.style.display = "none";
            this.sizers[2].node.style.display = "none";
            this.sizers[5].node.style.display = "none";
            this.sizers[7].node.style.display = "none";
          } else if (this.handlesVisible) {
            this.sizers[0].node.style.display = "";
            this.sizers[2].node.style.display = "";
            this.sizers[5].node.style.display = "";
            this.sizers[7].node.style.display = "";
          }
        }
      }
      const r = s.x + s.width;
      const b = s.y + s.height;
      if (this.singleSizer) {
        this.moveSizerTo(this.sizers[0], r, b);
      } else {
        const cx = s.x + s.width / 2;
        const cy = s.y + s.height / 2;
        if (this.sizers.length >= 8) {
          const crs = [
            "nw-resize",
            "n-resize",
            "ne-resize",
            "e-resize",
            "se-resize",
            "s-resize",
            "sw-resize",
            "w-resize"
          ];
          const alpha = toRadians(this.state.style.rotation ?? 0);
          const cos = Math.cos(alpha);
          const sin = Math.sin(alpha);
          const da = Math.round(alpha * 4 / Math.PI);
          const ct = new Point(s.getCenterX(), s.getCenterY());
          let pt = getRotatedPoint(new Point(s.x, s.y), cos, sin, ct);
          this.moveSizerTo(this.sizers[0], pt.x, pt.y);
          this.sizers[0].setCursor(crs[mod(0 + da, crs.length)]);
          pt.x = cx;
          pt.y = s.y;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[1], pt.x, pt.y);
          this.sizers[1].setCursor(crs[mod(1 + da, crs.length)]);
          pt.x = r;
          pt.y = s.y;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[2], pt.x, pt.y);
          this.sizers[2].setCursor(crs[mod(2 + da, crs.length)]);
          pt.x = s.x;
          pt.y = cy;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[3], pt.x, pt.y);
          this.sizers[3].setCursor(crs[mod(7 + da, crs.length)]);
          pt.x = r;
          pt.y = cy;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[4], pt.x, pt.y);
          this.sizers[4].setCursor(crs[mod(3 + da, crs.length)]);
          pt.x = s.x;
          pt.y = b;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[5], pt.x, pt.y);
          this.sizers[5].setCursor(crs[mod(6 + da, crs.length)]);
          pt.x = cx;
          pt.y = b;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[6], pt.x, pt.y);
          this.sizers[6].setCursor(crs[mod(5 + da, crs.length)]);
          pt.x = r;
          pt.y = b;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[7], pt.x, pt.y);
          this.sizers[7].setCursor(crs[mod(4 + da, crs.length)]);
          pt.x = cx + this.state.absoluteOffset.x;
          pt.y = cy + this.state.absoluteOffset.y;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[8], pt.x, pt.y);
        } else if (this.state.width >= 2 && this.state.height >= 2) {
          this.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);
        } else {
          this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);
        }
      }
    }
    if (this.rotationShape) {
      const alpha = toRadians(this.currentAlpha ?? this.state.style.rotation ?? 0);
      const cos = Math.cos(alpha);
      const sin = Math.sin(alpha);
      const ct = new Point(this.state.getCenterX(), this.state.getCenterY());
      const pt = getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);
      if (this.rotationShape.node != null) {
        this.moveSizerTo(this.rotationShape, pt.x, pt.y);
        this.rotationShape.node.style.visibility = this.state.view.graph.isEditing() || !this.handlesVisible ? "hidden" : "";
      }
    }
    if (this.selectionBorder != null) {
      this.selectionBorder.rotation = this.state.style.rotation ?? 0;
    }
    if (this.edgeHandlers != null) {
      for (let i = 0; i < this.edgeHandlers.length; i += 1) {
        this.edgeHandlers[i].redraw();
      }
    }
  }
  /**
   * Returns true if the given custom handle is visible.
   */
  isCustomHandleVisible(handle) {
    return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1;
  }
  /**
   * Returns an {@link Point} that defines the rotation handle position.
   */
  getRotationHandlePosition() {
    return new Point(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);
  }
  /**
   * Returns `true` if the parent highlight should be visible.
   *
   * This implementation always returns `true`.
   */
  isParentHighlightVisible() {
    const parent = this.state.cell.getParent();
    return parent ? !this.graph.isCellSelected(parent) : false;
  }
  /**
   * Updates the highlight of the parent if {@link parentHighlightEnabled} is `true`.
   */
  updateParentHighlight() {
    if (!this.isDestroyed()) {
      const visible = this.isParentHighlightVisible();
      const parent = this.state.cell.getParent();
      const pstate = parent ? this.graph.view.getState(parent) : null;
      if (this.parentHighlight) {
        if (parent && parent.isVertex() && visible) {
          const b = this.parentHighlight.bounds;
          if (pstate && b && (b.x !== pstate.x || b.y !== pstate.y || b.width !== pstate.width || b.height !== pstate.height)) {
            this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);
            this.parentHighlight.redraw();
          }
        } else {
          if (pstate != null && pstate.parentHighlight === this.parentHighlight) {
            pstate.parentHighlight = null;
          }
          this.parentHighlight.destroy();
          this.parentHighlight = null;
        }
      } else if (this.parentHighlightEnabled && visible) {
        if (parent && parent.isVertex() && pstate != null && pstate.parentHighlight == null) {
          this.parentHighlight = this.createParentHighlightShape(pstate);
          this.parentHighlight.dialect = DIALECT.SVG;
          this.parentHighlight.pointerEvents = false;
          this.parentHighlight.rotation = pstate.style.rotation ?? 0;
          this.parentHighlight.init(this.graph.getView().getOverlayPane());
          this.parentHighlight.redraw();
          pstate.parentHighlight = this.parentHighlight;
        }
      }
    }
  }
  /**
   * Redraws the preview.
   */
  drawPreview() {
    if (this.preview != null) {
      this.preview.bounds = this.bounds;
      if (this.preview.node.parentNode === this.graph.container) {
        this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);
        this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);
      }
      this.preview.rotation = this.state.style.rotation ?? 0;
      this.preview.redraw();
    }
    this.selectionBorder.bounds = this.getSelectionBorderBounds();
    this.selectionBorder.redraw();
    this.updateParentHighlight();
  }
  /**
   * Returns the bounds for the selection border.
   */
  getSelectionBorderBounds() {
    return this.bounds;
  }
  /**
   * Returns `true` if this handler was destroyed or not initialized.
   */
  isDestroyed() {
    return this.selectionBorder == null;
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    this.state.view.graph.removeListener(this.escapeHandler);
    this.escapeHandler = () => {
      return;
    };
    if (this.preview) {
      this.preview.destroy();
      this.preview = null;
    }
    if (this.parentHighlight) {
      const parent = this.state.cell.getParent();
      const pstate = parent ? this.graph.view.getState(parent) : null;
      if (pstate && pstate.parentHighlight === this.parentHighlight) {
        pstate.parentHighlight = null;
      }
      this.parentHighlight.destroy();
      this.parentHighlight = null;
    }
    if (this.ghostPreview) {
      this.ghostPreview.destroy();
      this.ghostPreview = null;
    }
    if (this.selectionBorder) {
      this.selectionBorder.destroy();
    }
    this.labelShape = null;
    this.removeHint();
    for (let i = 0; i < this.sizers.length; i += 1) {
      this.sizers[i].destroy();
    }
    this.sizers = [];
    for (let i = 0; i < this.customHandles.length; i += 1) {
      this.customHandles[i].destroy();
    }
    this.customHandles = [];
  }
}
class ElbowEdgeHandler extends EdgeHandler {
  constructor(state) {
    super(state);
    this.flipEnabled = true;
    this.doubleClickOrientationResource = isI18nEnabled() ? "doubleClickOrientation" : "";
  }
  /**
   * Overrides {@link EdgeHandler.createBends} to create custom bends.
   */
  createBends() {
    const bends = [];
    let bend = this.createHandleShape(0);
    this.initBend(bend);
    bend.setCursor(CURSOR.TERMINAL_HANDLE);
    bends.push(bend);
    bends.push(this.createVirtualBend((evt) => {
      if (!isConsumed(evt) && this.flipEnabled) {
        this.graph.flipEdge(this.state.cell);
        InternalEvent.consume(evt);
      }
    }));
    this.points.push(new Point(0, 0));
    bend = this.createHandleShape(2);
    this.initBend(bend);
    bend.setCursor(CURSOR.TERMINAL_HANDLE);
    bends.push(bend);
    return bends;
  }
  /**
   * Creates a virtual bend that supports double-clicking and calls {@link Graph#flipEdge}.
   */
  createVirtualBend(dblClickHandler) {
    const bend = this.createHandleShape();
    this.initBend(bend, dblClickHandler);
    bend.setCursor(this.getCursorForBend());
    if (!this.graph.isCellBendable(this.state.cell)) {
      bend.node.style.display = "none";
    }
    return bend;
  }
  /**
   * Returns the cursor to be used for the bend.
   */
  getCursorForBend() {
    return this.state.style.edgeStyle === EDGESTYLE.TOPTOBOTTOM || this.state.style.edgeStyle === EDGESTYLE.ELBOW && this.state.style.elbow === ELBOW.VERTICAL ? "row-resize" : "col-resize";
  }
  /**
   * Returns the tooltip for the given node.
   */
  getTooltipForNode(node) {
    let tip = null;
    if (this.bends != null && this.bends[1] != null && (node === this.bends[1].node || node.parentNode === this.bends[1].node)) {
      tip = this.doubleClickOrientationResource;
      tip = translate(tip) || tip;
    }
    return tip;
  }
  /**
   * Converts the given point in-place from screen to unscaled, untranslated
   * graph coordinates and applies the grid.
   *
   * @param point {@link Point} to be converted.
   * @param gridEnabled Boolean that specifies if the grid should be applied.
   */
  convertPoint(point, gridEnabled) {
    const scale = this.graph.getView().getScale();
    const tr = this.graph.getView().getTranslate();
    const { origin } = this.state;
    if (gridEnabled) {
      point.x = this.graph.snap(point.x);
      point.y = this.graph.snap(point.y);
    }
    point.x = Math.round(point.x / scale - tr.x - origin.x);
    point.y = Math.round(point.y / scale - tr.y - origin.y);
    return point;
  }
  /**
   * Updates and redraws the inner bends.
   *
   * @param p0 {@link Point} that represents the location of the first point.
   * @param pe {@link Point} that represents the location of the last point.
   */
  redrawInnerBends(p0, pe) {
    const g = this.state.cell.getGeometry();
    const pts = this.state.absolutePoints;
    let pt = null;
    if (pts.length > 1) {
      p0 = pts[1];
      pe = pts[pts.length - 2];
    } else if (g.points != null && g.points.length > 0) {
      pt = pts[0];
    }
    if (pt == null) {
      pt = new Point(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);
    } else {
      pt = new Point(this.graph.getView().scale * (pt.x + this.graph.getView().translate.x + this.state.origin.x), this.graph.getView().scale * (pt.y + this.graph.getView().translate.y + this.state.origin.y));
    }
    const b = this.bends[1].bounds;
    let w = b.width;
    let h = b.height;
    let bounds = new Rectangle(Math.round(pt.x - w / 2), Math.round(pt.y - h / 2), w, h);
    if (this.manageLabelHandle) {
      this.checkLabelHandle(bounds);
    } else if (this.handleImage == null && this.labelShape.visible && this.labelShape.bounds && intersects$1(bounds, this.labelShape.bounds)) {
      w = HandleConfig.size + 3;
      h = w;
      bounds = new Rectangle(Math.floor(pt.x - w / 2), Math.floor(pt.y - h / 2), w, h);
    }
    this.bends[1].bounds = bounds;
    this.bends[1].redraw();
    if (this.manageLabelHandle) {
      this.checkLabelHandle(this.bends[1].bounds);
    }
  }
}
class EdgeSegmentHandler extends ElbowEdgeHandler {
  constructor(state) {
    super(state);
    this.points = [];
  }
  /**
   * Returns the current absolute points.
   */
  getCurrentPoints() {
    let pts = this.state.absolutePoints;
    const tol = Math.max(1, this.graph.view.scale);
    if (pts.length === 2 && pts[0] && pts[1] || pts.length === 3 && pts[0] && pts[1] && pts[2] && (Math.abs(pts[0].x - pts[1].x) < tol && Math.abs(pts[1].x - pts[2].x) < tol || Math.abs(pts[0].y - pts[1].y) < tol && Math.abs(pts[1].y - pts[2].y) < tol)) {
      const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;
      const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;
      pts = [pts[0], new Point(cx, cy), new Point(cx, cy), pts[pts.length - 1]];
    }
    return pts;
  }
  /**
   * Updates the given preview state taking into account the state of the constraint handler.
   */
  getPreviewPoints(point) {
    if (this.isSource || this.isTarget) {
      return super.getPreviewPoints(point);
    }
    const pts = this.getCurrentPoints();
    let last = this.convertPoint(pts[0].clone(), false);
    point = this.convertPoint(point.clone(), false);
    let result = [];
    for (let i = 1; i < pts.length; i += 1) {
      const pt = this.convertPoint(pts[i].clone(), false);
      if (i === this.index) {
        if (Math.round(last.x - pt.x) === 0) {
          last.x = point.x;
          pt.x = point.x;
        }
        if (Math.round(last.y - pt.y) === 0) {
          last.y = point.y;
          pt.y = point.y;
        }
      }
      if (i < pts.length - 1) {
        result.push(pt);
      }
      last = pt;
    }
    if (result.length === 1) {
      const source = this.state.getVisibleTerminalState(true);
      const target = this.state.getVisibleTerminalState(false);
      const scale = this.state.view.getScale();
      const tr = this.state.view.getTranslate();
      const x = result[0].x * scale + tr.x;
      const y = result[0].y * scale + tr.y;
      if (source != null && contains(source, x, y) || target != null && contains(target, x, y)) {
        result = [point, point];
      }
    }
    return result;
  }
  /**
   * Overridden to perform optimization of the edge style result.
   */
  updatePreviewState(edge, point, terminalState, me) {
    super.updatePreviewState(edge, point, terminalState, me);
    if (!this.isSource && !this.isTarget) {
      point = this.convertPoint(point.clone(), false);
      const pts = edge.absolutePoints;
      let pt0 = pts[0];
      let pt1 = pts[1];
      let result = [];
      for (let i = 2; i < pts.length; i += 1) {
        const pt2 = pts[i];
        if ((Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) && (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {
          result.push(this.convertPoint(pt1.clone(), false));
        }
        pt0 = pt1;
        pt1 = pt2;
      }
      const source = this.state.getVisibleTerminalState(true);
      const target = this.state.getVisibleTerminalState(false);
      const rpts = this.state.absolutePoints;
      const end = pts[pts.length - 1];
      if (result.length === 0 && pts[0] && end && (Math.round(pts[0].x - end.x) === 0 || Math.round(pts[0].y - end.y) === 0)) {
        result = [point, point];
      } else if (pts.length === 5 && result.length === 2 && source != null && target != null && rpts != null && Math.round(rpts[0].x - rpts[rpts.length - 1].x) === 0) {
        const view = this.graph.getView();
        const scale = view.getScale();
        const tr = view.getTranslate();
        let y0 = view.getRoutingCenterY(source) / scale - tr.y;
        const sc = this.graph.getConnectionConstraint(edge, source, true);
        if (sc != null) {
          const pt = this.graph.getConnectionPoint(source, sc);
          if (pt != null) {
            this.convertPoint(pt, false);
            y0 = pt.y;
          }
        }
        let ye = view.getRoutingCenterY(target) / scale - tr.y;
        const tc = this.graph.getConnectionConstraint(edge, target, false);
        if (tc) {
          const pt = this.graph.getConnectionPoint(target, tc);
          if (pt != null) {
            this.convertPoint(pt, false);
            ye = pt.y;
          }
        }
        result = [new Point(point.x, y0), new Point(point.x, ye)];
      }
      this.points = result;
      edge.view.updateFixedTerminalPoints(edge, source, target);
      edge.view.updatePoints(edge, this.points, source, target);
      edge.view.updateFloatingTerminalPoints(edge, source, target);
    }
  }
  /**
   * Overriden to merge edge segments.
   */
  connect(edge, terminal, isSource, isClone, me) {
    const model = this.graph.getDataModel();
    let geo = edge.getGeometry();
    let result = null;
    if (geo != null && geo.points != null && geo.points.length > 0) {
      const pts = this.abspoints;
      let pt0 = pts[0];
      let pt1 = pts[1];
      result = [];
      for (let i = 2; i < pts.length; i += 1) {
        const pt2 = pts[i];
        if (pt0 && pt1 && pt2 && (Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) && (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {
          result.push(this.convertPoint(pt1.clone(), false));
        }
        pt0 = pt1;
        pt1 = pt2;
      }
    }
    this.graph.batchUpdate(() => {
      if (result != null) {
        geo = edge.getGeometry();
        if (geo != null) {
          geo = geo.clone();
          geo.points = result;
          model.setGeometry(edge, geo);
        }
      }
      edge = super.connect(edge, terminal, isSource, isClone, me);
    });
    return edge;
  }
  /**
   * Returns no tooltips.
   */
  getTooltipForNode(node) {
    return null;
  }
  /**
   * Adds custom bends for the center of each segment.
   */
  start(x, y, index) {
    super.start(x, y, index);
    if (this.bends != null && this.bends[index] != null && !this.isSource && !this.isTarget) {
      setOpacity(this.bends[index].node, 100);
    }
  }
  /**
   * Adds custom bends for the center of each segment.
   */
  createBends() {
    const bends = [];
    let bend = this.createHandleShape(0);
    this.initBend(bend);
    bend.setCursor(CURSOR.TERMINAL_HANDLE);
    bends.push(bend);
    const pts = this.getCurrentPoints();
    if (this.graph.isCellBendable(this.state.cell)) {
      if (this.points == null) {
        this.points = [];
      }
      for (let i = 0; i < pts.length - 1; i += 1) {
        bend = this.createVirtualBend();
        bends.push(bend);
        let horizontal = Math.round(pts[i].x - pts[i + 1].x) === 0;
        if (Math.round(pts[i].y - pts[i + 1].y) === 0 && i < pts.length - 2) {
          horizontal = Math.round(pts[i].x - pts[i + 2].x) === 0;
        }
        bend.setCursor(horizontal ? "col-resize" : "row-resize");
        this.points.push(new Point(0, 0));
      }
    }
    bend = this.createHandleShape(pts.length);
    this.initBend(bend);
    bend.setCursor(CURSOR.TERMINAL_HANDLE);
    bends.push(bend);
    return bends;
  }
  /**
   * Overridden to invoke <refresh> before the redraw.
   */
  redraw() {
    this.refresh();
    super.redraw();
  }
  /**
   * Updates the position of the custom bends.
   */
  redrawInnerBends(p0, pe) {
    if (this.graph.isCellBendable(this.state.cell)) {
      const pts = this.getCurrentPoints();
      if (pts != null && pts.length > 1) {
        let straight = false;
        if (pts.length === 4 && pts[0] && pts[1] && pts[2] && pts[3] && Math.round(pts[1].x - pts[2].x) === 0 && Math.round(pts[1].y - pts[2].y) === 0) {
          straight = true;
          if (Math.round(pts[0].y - pts[pts.length - 1].y) === 0) {
            const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;
            pts[1] = new Point(cx, pts[1].y);
            pts[2] = new Point(cx, pts[2].y);
          } else {
            const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;
            pts[1] = new Point(pts[1].x, cy);
            pts[2] = new Point(pts[2].x, cy);
          }
        }
        for (let i = 0; i < pts.length - 1; i += 1) {
          if (this.bends[i + 1] != null) {
            p0 = pts[i];
            pe = pts[i + 1];
            const pt = new Point(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);
            const b = this.bends[i + 1].bounds;
            this.bends[i + 1].bounds = new Rectangle(Math.floor(pt.x - b.width / 2), Math.floor(pt.y - b.height / 2), b.width, b.height);
            this.bends[i + 1].redraw();
            if (this.manageLabelHandle) {
              this.checkLabelHandle(this.bends[i + 1].bounds);
            }
          }
        }
        if (straight) {
          setOpacity(this.bends[1].node, EdgeHandlerConfig.virtualBendOpacity);
          setOpacity(this.bends[3].node, EdgeHandlerConfig.virtualBendOpacity);
        }
      }
    }
  }
}
class SelectionChange {
  constructor(graph, added = [], removed = []) {
    this.graph = graph;
    this.added = added.slice();
    this.removed = removed.slice();
  }
  /**
   * Changes the current root of the view.
   */
  execute() {
    const selectionModel = this.graph.getSelectionModel();
    for (const removed of this.removed) {
      selectionModel.cellRemoved(removed);
    }
    for (const added of this.added) {
      selectionModel.cellAdded(added);
    }
    [this.added, this.removed] = [this.removed, this.added];
    selectionModel.fireEvent(new EventObject(InternalEvent.CHANGE, { added: this.added, removed: this.removed }));
  }
}
class GraphSelectionModel extends EventSource {
  constructor(graph) {
    super();
    this.doneResource = isI18nEnabled() ? "done" : "";
    this.updatingSelectionResource = isI18nEnabled() ? "updatingSelection" : "";
    this.singleSelection = false;
    this.graph = graph;
    this.cells = [];
  }
  /**
   * Returns {@link singleSelection} as a boolean.
   */
  isSingleSelection() {
    return this.singleSelection;
  }
  /**
   * Sets the {@link singleSelection} flag.
   *
   * @param {boolean} singleSelection Boolean that specifies the new value for
   * {@link singleSelection}.
   */
  setSingleSelection(singleSelection) {
    this.singleSelection = singleSelection;
  }
  /**
   * Returns true if the given {@link Cell} is selected.
   */
  isSelected(cell) {
    return this.cells.indexOf(cell) >= 0;
  }
  /**
   * Returns true if no cells are currently selected.
   */
  isEmpty() {
    return this.cells.length === 0;
  }
  /**
   * Clears the selection and fires a {@link change} event if the selection was not
   * empty.
   */
  clear() {
    this.changeSelection(null, this.cells);
  }
  /**
   * Selects the specified {@link Cell} using {@link setCells}.
   *
   * @param cell {@link mxCell} to be selected.
   */
  setCell(cell) {
    this.setCells(cell ? [cell] : []);
  }
  /**
   * Selects the given array of {@link Cell} and fires a {@link change} event.
   *
   * @param cells Array of {@link Cell} to be selected.
   */
  setCells(cells) {
    if (this.singleSelection) {
      cells = [this.getFirstSelectableCell(cells)];
    }
    const tmp = [];
    for (let i = 0; i < cells.length; i += 1) {
      if (this.graph.isCellSelectable(cells[i])) {
        tmp.push(cells[i]);
      }
    }
    this.changeSelection(tmp, this.cells);
  }
  /**
   * Returns the first selectable cell in the given array of cells.
   */
  getFirstSelectableCell(cells) {
    for (let i = 0; i < cells.length; i += 1) {
      if (this.graph.isCellSelectable(cells[i])) {
        return cells[i];
      }
    }
    return null;
  }
  /**
   * Adds the given {@link Cell} to the selection and fires a {@link select} event.
   *
   * @param cell {@link mxCell} to add to the selection.
   */
  addCell(cell) {
    this.addCells([cell]);
  }
  /**
   * Adds the given array of {@link Cell} to the selection and fires a {@link select}
   * event.
   *
   * @param cells Array of {@link Cell} to add to the selection.
   */
  addCells(cells) {
    let remove2 = null;
    if (this.singleSelection) {
      remove2 = this.cells;
      const selectableCell = this.getFirstSelectableCell(cells);
      cells = selectableCell ? [selectableCell] : [];
    }
    const tmp = [];
    for (let i = 0; i < cells.length; i += 1) {
      if (!this.isSelected(cells[i]) && this.graph.isCellSelectable(cells[i])) {
        tmp.push(cells[i]);
      }
    }
    this.changeSelection(tmp, remove2);
  }
  /**
   * Removes the specified {@link Cell} from the selection and fires a {@link select}
   * event for the remaining cells.
   *
   * @param cell {@link mxCell} to remove from the selection.
   */
  removeCell(cell) {
    this.removeCells([cell]);
  }
  /**
   * Removes the specified {@link Cell} from the selection and fires a {@link select}
   * event for the remaining cells.
   *
   * @param cells {@link mxCell}s to remove from the selection.
   */
  removeCells(cells) {
    const tmp = [];
    for (let i = 0; i < cells.length; i += 1) {
      if (this.isSelected(cells[i])) {
        tmp.push(cells[i]);
      }
    }
    this.changeSelection(null, tmp);
  }
  /**
   * Adds/removes the specified arrays of {@link Cell} to/from the selection.
   *
   * @param added Array of {@link Cell} to add to the selection.
   * @param remove Array of {@link Cell} to remove from the selection.
   */
  changeSelection(added = null, removed = null) {
    if (added && added.length > 0 && added[0] || removed && removed.length > 0 && removed[0]) {
      const change = new SelectionChange(this.graph, added || [], removed || []);
      change.execute();
      const edit = new UndoableEdit(this.graph, false);
      edit.add(change);
      this.fireEvent(new EventObject(InternalEvent.UNDO, { edit }));
    }
  }
  /**
   * Inner callback to add the specified {@link Cell} to the selection. No event
   * is fired in this implementation.
   *
   * Paramters:
   *
   * @param cell {@link mxCell} to add to the selection.
   */
  cellAdded(cell) {
    if (!this.isSelected(cell)) {
      this.cells.push(cell);
    }
  }
  /**
   * Inner callback to remove the specified {@link Cell} from the selection. No
   * event is fired in this implementation.
   *
   * @param cell {@link mxCell} to remove from the selection.
   */
  cellRemoved(cell) {
    const index = this.cells.indexOf(cell);
    if (index >= 0) {
      this.cells.splice(index, 1);
    }
  }
}
class RhombusShape extends Shape {
  constructor(bounds, fill, stroke, strokewidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokewidth;
  }
  /**
   * Adds roundable support.
   */
  // isRoundable(): boolean;
  isRoundable() {
    return true;
  }
  /**
   * Generic painting implementation.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  paintVertexShape(c, x, y, w, h) {
    var _a;
    const hw = w / 2;
    const hh = h / 2;
    const arcSize = (((_a = this.style) == null ? void 0 : _a.arcSize) ?? LINE_ARCSIZE) / 2;
    c.begin();
    this.addPoints(c, [
      new Point(x + hw, y),
      new Point(x + w, y + hh),
      new Point(x + hw, y + h),
      new Point(x, y + hh)
    ], this.isRounded, arcSize, true);
    c.fillAndStroke();
  }
}
class CylinderShape extends Shape {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.maxHeight = 40;
    this.svgStrokeTolerance = 0;
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Redirects to redrawPath for subclasses to work.
   */
  paintVertexShape(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    this.redrawPath(c, x, y, w, h, false);
    c.fillAndStroke();
    if (!this.outline || !this.style || !(this.style.backgroundOutline ?? false)) {
      c.setShadow(false);
      c.begin();
      this.redrawPath(c, x, y, w, h, true);
      c.stroke();
    }
  }
  /**
   * Redirects to redrawPath for subclasses to work.
   */
  getCylinderSize(x, y, w, h) {
    return Math.min(this.maxHeight, Math.round(h / 5));
  }
  /**
   * Draws the path for this shape.
   */
  redrawPath(c, x, y, w, h, isForeground = false) {
    const dy = this.getCylinderSize(x, y, w, h);
    if (isForeground && this.fill !== NONE || !isForeground && this.fill === NONE) {
      c.moveTo(0, dy);
      c.curveTo(0, 2 * dy, w, 2 * dy, w, dy);
      if (!isForeground) {
        c.stroke();
        c.begin();
      }
    }
    if (!isForeground) {
      c.moveTo(0, dy);
      c.curveTo(0, -dy / 3, w, -dy / 3, w, dy);
      c.lineTo(w, h - dy);
      c.curveTo(w, h + dy / 3, 0, h + dy / 3, 0, h - dy);
      c.close();
    }
  }
}
class ActorShape extends Shape {
  constructor(bounds = null, fill = NONE, stroke = NONE, strokeWidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Redirects to redrawPath for subclasses to work.
   */
  paintVertexShape(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    this.redrawPath(c, x, y, w, h);
    c.fillAndStroke();
  }
  /**
   * Draws the path for this shape.
   */
  redrawPath(c, x, y, w, h) {
    const width = w / 3;
    c.moveTo(0, h);
    c.curveTo(0, 3 * h / 5, 0, 2 * h / 5, w / 2, 2 * h / 5);
    c.curveTo(w / 2 - width, 2 * h / 5, w / 2 - width, 0, w / 2, 0);
    c.curveTo(w / 2 + width, 0, w / 2 + width, 2 * h / 5, w / 2, 2 * h / 5);
    c.curveTo(w, 2 * h / 5, w, 3 * h / 5, w, h);
    c.close();
  }
}
class TriangleShape extends ActorShape {
  constructor() {
    super();
  }
  /**
   * Adds roundable support.
   * @returns {boolean}
   */
  isRoundable() {
    return true;
  }
  /**
   * Draws the path for this shape.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  redrawPath(c, x, y, w, h) {
    var _a;
    const arcSize = (((_a = this.style) == null ? void 0 : _a.arcSize) ?? LINE_ARCSIZE) / 2;
    this.addPoints(c, [new Point(0, 0), new Point(w, 0.5 * h), new Point(0, h)], this.isRounded, arcSize, true);
  }
}
class HexagonShape extends ActorShape {
  constructor() {
    super();
  }
  /**
   * Draws the path for this shape.
   */
  redrawPath(c, x, y, w, h) {
    var _a;
    const arcSize = (((_a = this.style) == null ? void 0 : _a.arcSize) ?? LINE_ARCSIZE) / 2;
    this.addPoints(c, [
      new Point(0.25 * w, 0),
      new Point(0.75 * w, 0),
      new Point(w, 0.5 * h),
      new Point(0.75 * w, h),
      new Point(0.25 * w, h),
      new Point(0, 0.5 * h)
    ], this.isRounded, arcSize, true);
  }
}
class CloudShape extends ActorShape {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Draws the path for this shape.
   */
  redrawPath(c, x, y, w, h) {
    c.moveTo(0.25 * w, 0.25 * h);
    c.curveTo(0.05 * w, 0.25 * h, 0, 0.5 * h, 0.16 * w, 0.55 * h);
    c.curveTo(0, 0.66 * h, 0.18 * w, 0.9 * h, 0.31 * w, 0.8 * h);
    c.curveTo(0.4 * w, h, 0.7 * w, h, 0.8 * w, 0.8 * h);
    c.curveTo(w, 0.8 * h, w, 0.6 * h, 0.875 * w, 0.5 * h);
    c.curveTo(w, 0.3 * h, 0.8 * w, 0.1 * h, 0.625 * w, 0.2 * h);
    c.curveTo(0.5 * w, 0.05 * h, 0.3 * w, 0.05 * h, 0.25 * w, 0.25 * h);
    c.close();
  }
}
class LineShape extends Shape {
  constructor(bounds, stroke, strokeWidth = 1, vertical = false) {
    super();
    this.bounds = bounds;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
    this.vertical = vertical;
  }
  /**
   * Redirects to redrawPath for subclasses to work.
   * @param {AbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  paintVertexShape(c, x, y, w, h) {
    c.begin();
    if (this.vertical) {
      const mid = x + w / 2;
      c.moveTo(mid, y);
      c.lineTo(mid, y + h);
    } else {
      const mid = y + h / 2;
      c.moveTo(x, mid);
      c.lineTo(x + w, mid);
    }
    c.stroke();
  }
}
class ArrowShape extends Shape {
  constructor(points, fill, stroke, strokeWidth = 1, arrowWidth = ARROW_WIDTH, spacing = ARROW_SPACING, endSize = ARROW_SIZE) {
    super();
    this.points = points;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
    this.arrowWidth = arrowWidth;
    this.spacing = spacing;
    this.endSize = endSize;
  }
  /**
   * Augments the bounding box with the edge width and markers.
   */
  augmentBoundingBox(bbox) {
    super.augmentBoundingBox(bbox);
    const w = Math.max(this.arrowWidth, this.endSize);
    bbox.grow((w / 2 + this.strokeWidth) * this.scale);
  }
  /**
   * Paints the line shape.
   */
  paintEdgeShape(c, pts) {
    const spacing = ARROW_SPACING;
    const width = ARROW_WIDTH;
    const arrow = ARROW_SIZE;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    const dx = pe.x - p0.x;
    const dy = pe.y - p0.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const length = dist - 2 * spacing - arrow;
    const nx = dx / dist;
    const ny = dy / dist;
    const basex = length * nx;
    const basey = length * ny;
    const floorx = width * ny / 3;
    const floory = -30 * nx / 3;
    const p0x = p0.x - floorx / 2 + spacing * nx;
    const p0y = p0.y - floory / 2 + spacing * ny;
    const p1x = p0x + floorx;
    const p1y = p0y + floory;
    const p2x = p1x + basex;
    const p2y = p1y + basey;
    const p3x = p2x + floorx;
    const p3y = p2y + floory;
    const p5x = p3x - 3 * floorx;
    const p5y = p3y - 3 * floory;
    c.begin();
    c.moveTo(p0x, p0y);
    c.lineTo(p1x, p1y);
    c.lineTo(p2x, p2y);
    c.lineTo(p3x, p3y);
    c.lineTo(pe.x - spacing * nx, pe.y - spacing * ny);
    c.lineTo(p5x, p5y);
    c.lineTo(p5x + floorx, p5y + floory);
    c.close();
    c.fillAndStroke();
  }
}
class ArrowConnectorShape extends Shape {
  constructor(points, fill, stroke, strokeWidth = 1, arrowWidth = ARROW_WIDTH, spacing = ARROW_SPACING, endSize = ARROW_SIZE / 5) {
    super();
    this.useSvgBoundingBox = true;
    this.points = points;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
    this.arrowWidth = arrowWidth;
    this.arrowSpacing = spacing;
    this.startSize = ARROW_SIZE / 5;
    this.endSize = endSize;
  }
  /**
   * Hook for subclassers.
   */
  isRoundable() {
    return true;
  }
  /**
   * Overrides mxShape to reset spacing.
   */
  resetStyles() {
    super.resetStyles();
    this.arrowSpacing = ARROW_SPACING;
  }
  /**
   * Overrides apply to get smooth transition from default start- and endsize.
   */
  apply(state) {
    super.apply(state);
    if (this.style && this.style.startSize != null && this.style.endSize != null) {
      this.startSize = this.style.startSize * 3;
      this.endSize = this.style.endSize * 3;
    }
  }
  /**
   * Augments the bounding box with the edge width and markers.
   */
  augmentBoundingBox(bbox) {
    super.augmentBoundingBox(bbox);
    let w = this.getEdgeWidth();
    if (this.isMarkerStart()) {
      w = Math.max(w, this.getStartArrowWidth());
    }
    if (this.isMarkerEnd()) {
      w = Math.max(w, this.getEndArrowWidth());
    }
    bbox.grow((w / 2 + this.strokeWidth) * this.scale);
  }
  /**
   * Paints the line shape.
   */
  paintEdgeShape(c, pts) {
    var _a;
    let strokeWidth = this.strokeWidth;
    if (this.outline) {
      strokeWidth = Math.max(1, ((_a = this.style) == null ? void 0 : _a.strokeWidth) ?? 0);
    }
    const startWidth = this.getStartArrowWidth() + strokeWidth;
    const endWidth = this.getEndArrowWidth() + strokeWidth;
    const edgeWidth = this.outline ? this.getEdgeWidth() + strokeWidth : this.getEdgeWidth();
    const openEnded = this.isOpenEnded();
    const markerStart = this.isMarkerStart();
    const markerEnd = this.isMarkerEnd();
    const spacing = openEnded ? 0 : this.arrowSpacing + strokeWidth / 2;
    const startSize = this.startSize + strokeWidth;
    const endSize = this.endSize + strokeWidth;
    const isRounded = this.isArrowRounded();
    const pe = pts[pts.length - 1];
    let i0 = 1;
    while (i0 < pts.length - 1 && pts[i0].x === pts[0].x && pts[i0].y === pts[0].y) {
      i0++;
    }
    const dx = pts[i0].x - pts[0].x;
    const dy = pts[i0].y - pts[0].y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist === 0) {
      return;
    }
    let nx = dx / dist;
    let nx2;
    let nx1 = nx;
    let ny = dy / dist;
    let ny2;
    let ny1 = ny;
    let orthx = edgeWidth * ny;
    let orthy = -edgeWidth * nx;
    const fns = [];
    if (isRounded) {
      c.setLineJoin("round");
    } else if (pts.length > 2) {
      c.setMiterLimit(1.42);
    }
    c.begin();
    const startNx = nx;
    const startNy = ny;
    if (markerStart && !openEnded) {
      this.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);
    } else {
      const outStartX = pts[0].x + orthx / 2 + spacing * nx;
      const outStartY = pts[0].y + orthy / 2 + spacing * ny;
      const inEndX = pts[0].x - orthx / 2 + spacing * nx;
      const inEndY = pts[0].y - orthy / 2 + spacing * ny;
      if (openEnded) {
        c.moveTo(outStartX, outStartY);
        fns.push(() => {
          c.lineTo(inEndX, inEndY);
        });
      } else {
        c.moveTo(inEndX, inEndY);
        c.lineTo(outStartX, outStartY);
      }
    }
    let dx1 = 0;
    let dy1 = 0;
    let dist1 = 0;
    for (let i = 0; i < pts.length - 2; i += 1) {
      const pos = relativeCcw(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, pts[i + 2].x, pts[i + 2].y);
      dx1 = pts[i + 2].x - pts[i + 1].x;
      dy1 = pts[i + 2].y - pts[i + 1].y;
      dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
      if (dist1 !== 0) {
        nx1 = dx1 / dist1;
        ny1 = dy1 / dist1;
        const tmp1 = nx * nx1 + ny * ny1;
        const tmp = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);
        nx2 = nx + nx1;
        ny2 = ny + ny1;
        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);
        if (dist2 !== 0) {
          nx2 /= dist2;
          ny2 /= dist2;
          const strokeWidthFactor = Math.max(tmp, Math.min(this.strokeWidth / 200 + 0.04, 0.35));
          const angleFactor = pos !== 0 && isRounded ? Math.max(0.1, strokeWidthFactor) : Math.max(tmp, 0.06);
          const outX = pts[i + 1].x + ny2 * edgeWidth / 2 / angleFactor;
          const outY = pts[i + 1].y - nx2 * edgeWidth / 2 / angleFactor;
          const inX = pts[i + 1].x - ny2 * edgeWidth / 2 / angleFactor;
          const inY = pts[i + 1].y + nx2 * edgeWidth / 2 / angleFactor;
          if (pos === 0 || !isRounded) {
            c.lineTo(outX, outY);
            ((x, y) => {
              fns.push(() => {
                c.lineTo(x, y);
              });
            })(inX, inY);
          } else if (pos === -1) {
            const c1x = inX + ny * edgeWidth;
            const c1y = inY - nx * edgeWidth;
            const c2x = inX + ny1 * edgeWidth;
            const c2y = inY - nx1 * edgeWidth;
            c.lineTo(c1x, c1y);
            c.quadTo(outX, outY, c2x, c2y);
            ((x, y) => {
              fns.push(() => {
                c.lineTo(x, y);
              });
            })(inX, inY);
          } else {
            c.lineTo(outX, outY);
            ((x, y) => {
              const c1x = outX - ny * edgeWidth;
              const c1y = outY + nx * edgeWidth;
              const c2x = outX - ny1 * edgeWidth;
              const c2y = outY + nx1 * edgeWidth;
              fns.push(() => {
                c.quadTo(x, y, c1x, c1y);
              });
              fns.push(() => {
                c.lineTo(c2x, c2y);
              });
            })(inX, inY);
          }
          nx = nx1;
          ny = ny1;
        }
      }
    }
    orthx = edgeWidth * ny1;
    orthy = -edgeWidth * nx1;
    if (markerEnd && !openEnded) {
      this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);
    } else {
      c.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);
      const inStartX = pe.x - spacing * nx1 - orthx / 2;
      const inStartY = pe.y - spacing * ny1 - orthy / 2;
      if (!openEnded) {
        c.lineTo(inStartX, inStartY);
      } else {
        c.moveTo(inStartX, inStartY);
        fns.splice(0, 0, () => {
          c.moveTo(inStartX, inStartY);
        });
      }
    }
    for (let i = fns.length - 1; i >= 0; i--) {
      fns[i]();
    }
    if (openEnded) {
      c.end();
      c.stroke();
    } else {
      c.close();
      c.fillAndStroke();
    }
    c.setShadow(false);
    c.setMiterLimit(4);
    if (isRounded) {
      c.setLineJoin("flat");
    }
    if (pts.length > 2) {
      c.setMiterLimit(4);
      if (markerStart && !openEnded) {
        c.begin();
        this.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);
        c.stroke();
        c.end();
      }
      if (markerEnd && !openEnded) {
        c.begin();
        this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);
        c.stroke();
        c.end();
      }
    }
  }
  /**
   * Paints the marker.
   */
  paintMarker(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove) {
    const widthArrowRatio = edgeWidth / arrowWidth;
    const orthx = edgeWidth * ny / 2;
    const orthy = -edgeWidth * nx / 2;
    const spaceX = (spacing + size) * nx;
    const spaceY = (spacing + size) * ny;
    if (initialMove) {
      c.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);
    } else {
      c.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);
    }
    c.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);
    c.lineTo(ptX + spacing * nx, ptY + spacing * ny);
    c.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);
    c.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);
  }
  /**
   * @returns whether the arrow is rounded
   */
  isArrowRounded() {
    return this.isRounded;
  }
  /**
   * @returns the width of the start arrow
   */
  getStartArrowWidth() {
    return ARROW_WIDTH;
  }
  /**
   * @returns the width of the end arrow
   */
  getEndArrowWidth() {
    return ARROW_WIDTH;
  }
  /**
   * @returns the width of the body of the edge
   */
  getEdgeWidth() {
    return ARROW_WIDTH / 3;
  }
  /**
   * @returns whether the ends of the shape are drawn
   */
  isOpenEnded() {
    return false;
  }
  /**
   * @returns whether the start marker is drawn
   */
  isMarkerStart() {
    var _a;
    return (((_a = this.style) == null ? void 0 : _a.startArrow) ?? NONE) !== NONE;
  }
  /**
   * @returns whether the end marker is drawn
   */
  isMarkerEnd() {
    var _a;
    return (((_a = this.style) == null ? void 0 : _a.endArrow) ?? NONE) !== NONE;
  }
}
class DoubleEllipseShape extends Shape {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Paints the background.
   */
  paintBackground(c, x, y, w, h) {
    c.ellipse(x, y, w, h);
    c.fillAndStroke();
  }
  /**
   * Paints the foreground.
   */
  paintForeground(c, x, y, w, h) {
    var _a;
    if (!this.outline) {
      const margin = ((_a = this.style) == null ? void 0 : _a.margin) ?? Math.min(3 + this.strokeWidth, Math.min(w / 5, h / 5));
      x += margin;
      y += margin;
      w -= 2 * margin;
      h -= 2 * margin;
      if (w > 0 && h > 0) {
        c.ellipse(x, y, w, h);
      }
      c.stroke();
    }
  }
  /**
   * @returns the bounds for the label.
   */
  getLabelBounds(rect) {
    var _a;
    const margin = ((_a = this.style) == null ? void 0 : _a.margin) ?? Math.min(3 + this.strokeWidth, Math.min(rect.width / 5 / this.scale, rect.height / 5 / this.scale)) * this.scale;
    return new Rectangle(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);
  }
}
class SwimlaneShape extends Shape {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.imageSize = 16;
    this.imageSrc = null;
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Adds roundable support.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @returns {boolean}
   */
  isRoundable(c, x, y, w, h) {
    return true;
  }
  /**
   * Returns the bounding box for the gradient box for this shape.
   */
  getTitleSize() {
    var _a;
    return Math.max(0, ((_a = this.style) == null ? void 0 : _a.startSize) ?? DEFAULT_STARTSIZE);
  }
  /**
   * Returns the bounding box for the gradient box for this shape.
   */
  getLabelBounds(rect) {
    var _a, _b;
    const start = this.getTitleSize();
    const bounds = new Rectangle(rect.x, rect.y, rect.width, rect.height);
    const horizontal = this.isHorizontal();
    const flipH = ((_a = this.style) == null ? void 0 : _a.flipH) ?? false;
    const flipV = ((_b = this.style) == null ? void 0 : _b.flipV) ?? false;
    const shapeVertical = this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH;
    const realHorizontal = horizontal == !shapeVertical;
    const realFlipH = !realHorizontal && flipH !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);
    const realFlipV = realHorizontal && flipV !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);
    if (!shapeVertical) {
      const tmp = Math.min(bounds.height, start * this.scale);
      if (realFlipH || realFlipV) {
        bounds.y += bounds.height - tmp;
      }
      bounds.height = tmp;
    } else {
      const tmp = Math.min(bounds.width, start * this.scale);
      if (realFlipH || realFlipV) {
        bounds.x += bounds.width - tmp;
      }
      bounds.width = tmp;
    }
    return bounds;
  }
  /**
   * Returns the bounding box for the gradient box for this shape.
   */
  getGradientBounds(c, x, y, w, h) {
    let start = this.getTitleSize();
    if (this.isHorizontal()) {
      start = Math.min(start, h);
      return new Rectangle(x, y, w, start);
    }
    start = Math.min(start, w);
    return new Rectangle(x, y, start, h);
  }
  /**
   * Returns the arcsize for the swimlane.
   */
  getSwimlaneArcSize(w, h, start) {
    var _a, _b, _c;
    if (((_a = this.style) == null ? void 0 : _a.absoluteArcSize) ?? false) {
      return Math.min(w / 2, Math.min(h / 2, ((_b = this.style) == null ? void 0 : _b.arcSize) ?? LINE_ARCSIZE / 2));
    }
    const f = (((_c = this.style) == null ? void 0 : _c.arcSize) ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;
    return start * f * 3;
  }
  /**
   * Paints the swimlane vertex shape.
   */
  isHorizontal() {
    var _a;
    return ((_a = this.style) == null ? void 0 : _a.horizontal) ?? true;
  }
  /**
   * Paints the swimlane vertex shape.
   */
  paintVertexShape(c, x, y, w, h) {
    var _a, _b, _c;
    let start = this.getTitleSize();
    const fill = ((_a = this.style) == null ? void 0 : _a.swimlaneFillColor) ?? NONE;
    const swimlaneLine = ((_b = this.style) == null ? void 0 : _b.swimlaneLine) ?? true;
    let r = 0;
    if (this.isHorizontal()) {
      start = Math.min(start, h);
    } else {
      start = Math.min(start, w);
    }
    c.translate(x, y);
    if (!this.isRounded) {
      this.paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine);
    } else {
      r = this.getSwimlaneArcSize(w, h, start);
      r = Math.min((this.isHorizontal() ? h : w) - start, Math.min(start, r));
      this.paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine);
    }
    const sep = ((_c = this.style) == null ? void 0 : _c.separatorColor) ?? NONE;
    this.paintSeparator(c, x, y, w, h, start, sep);
    if (this.imageSrc) {
      const bounds = this.getImageBounds(x, y, w, h);
      c.image(bounds.x - x, bounds.y - y, bounds.width, bounds.height, this.imageSrc, false, false, false);
    }
    if (this.glass) {
      c.setShadow(false);
      this.paintGlassEffect(c, 0, 0, w, start, r);
    }
  }
  /**
   * Paints the swimlane vertex shape.
   */
  paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine) {
    c.begin();
    let events = true;
    if (this.style && this.style.pointerEvents != null) {
      events = this.style.pointerEvents;
    }
    if (!events && this.fill === NONE) {
      c.pointerEvents = false;
    }
    if (this.isHorizontal()) {
      c.moveTo(0, start);
      c.lineTo(0, 0);
      c.lineTo(w, 0);
      c.lineTo(w, start);
      c.fillAndStroke();
      if (start < h) {
        if (fill === NONE || !events) {
          c.pointerEvents = false;
        }
        if (fill !== NONE) {
          c.setFillColor(fill);
        }
        c.begin();
        c.moveTo(0, start);
        c.lineTo(0, h);
        c.lineTo(w, h);
        c.lineTo(w, start);
        if (fill === NONE) {
          c.stroke();
        } else {
          c.fillAndStroke();
        }
      }
    } else {
      c.moveTo(start, 0);
      c.lineTo(0, 0);
      c.lineTo(0, h);
      c.lineTo(start, h);
      c.fillAndStroke();
      if (start < w) {
        if (fill === NONE || !events) {
          c.pointerEvents = false;
        }
        if (fill !== NONE) {
          c.setFillColor(fill);
        }
        c.begin();
        c.moveTo(start, 0);
        c.lineTo(w, 0);
        c.lineTo(w, h);
        c.lineTo(start, h);
        if (fill === NONE) {
          c.stroke();
        } else {
          c.fillAndStroke();
        }
      }
    }
    if (swimlaneLine) {
      this.paintDivider(c, x, y, w, h, start, fill === NONE);
    }
  }
  /**
   * Paints the swimlane vertex shape.
   */
  paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine) {
    c.begin();
    let events = true;
    if (this.style && this.style.pointerEvents != null) {
      events = this.style.pointerEvents;
    }
    if (!events && this.fill === NONE) {
      c.pointerEvents = false;
    }
    if (this.isHorizontal()) {
      c.moveTo(w, start);
      c.lineTo(w, r);
      c.quadTo(w, 0, w - Math.min(w / 2, r), 0);
      c.lineTo(Math.min(w / 2, r), 0);
      c.quadTo(0, 0, 0, r);
      c.lineTo(0, start);
      c.fillAndStroke();
      if (start < h) {
        if (fill === NONE || !events) {
          c.pointerEvents = false;
        }
        if (fill !== NONE) {
          c.setFillColor(fill);
        }
        c.begin();
        c.moveTo(0, start);
        c.lineTo(0, h - r);
        c.quadTo(0, h, Math.min(w / 2, r), h);
        c.lineTo(w - Math.min(w / 2, r), h);
        c.quadTo(w, h, w, h - r);
        c.lineTo(w, start);
        if (fill === NONE) {
          c.stroke();
        } else {
          c.fillAndStroke();
        }
      }
    } else {
      c.moveTo(start, 0);
      c.lineTo(r, 0);
      c.quadTo(0, 0, 0, Math.min(h / 2, r));
      c.lineTo(0, h - Math.min(h / 2, r));
      c.quadTo(0, h, r, h);
      c.lineTo(start, h);
      c.fillAndStroke();
      if (start < w) {
        if (fill === NONE || !events) {
          c.pointerEvents = false;
        }
        if (fill !== NONE) {
          c.setFillColor(fill);
        }
        c.begin();
        c.moveTo(start, h);
        c.lineTo(w - r, h);
        c.quadTo(w, h, w, h - Math.min(h / 2, r));
        c.lineTo(w, Math.min(h / 2, r));
        c.quadTo(w, 0, w - r, 0);
        c.lineTo(start, 0);
        if (fill === NONE) {
          c.stroke();
        } else {
          c.fillAndStroke();
        }
      }
    }
    if (swimlaneLine) {
      this.paintDivider(c, x, y, w, h, start, fill === NONE);
    }
  }
  /**
   * Paints the divider between swimlane title and content area.
   */
  paintDivider(c, x, y, w, h, start, shadow) {
    if (!shadow) {
      c.setShadow(false);
    }
    c.begin();
    if (this.isHorizontal()) {
      c.moveTo(0, start);
      c.lineTo(w, start);
    } else {
      c.moveTo(start, 0);
      c.lineTo(start, h);
    }
    c.stroke();
  }
  /**
   * Paints the vertical or horizontal separator line between swimlanes.
   */
  paintSeparator(c, x, y, w, h, start, color) {
    if (color !== NONE) {
      c.setStrokeColor(color);
      c.setDashed(true);
      c.begin();
      if (this.isHorizontal()) {
        c.moveTo(w, start);
        c.lineTo(w, h);
      } else {
        c.moveTo(start, 0);
        c.lineTo(w, 0);
      }
      c.stroke();
      c.setDashed(false);
    }
  }
  /**
   * Paints the swimlane vertex shape.
   */
  getImageBounds(x, y, w, h) {
    if (this.isHorizontal()) {
      return new Rectangle(x + w - this.imageSize, y, this.imageSize, this.imageSize);
    }
    return new Rectangle(x, y, this.imageSize, this.imageSize);
  }
}
class LabelShape extends RectangleShape {
  /**
   * Constructs a new label shape.
   *
   * @param bounds {@link Rectangle} that defines the bounds. This is stored in {@link bounds}.
   * @param fill String that defines the fill color. This is stored in {@link fill}.
   * @param stroke String that defines the stroke color. This is stored in {@link stroke}.
   * @param strokeWidth Optional integer that defines the stroke width. Default is 1. This is stored in {@link strokeWidth}.
   */
  constructor(bounds, fill, stroke, strokeWidth) {
    super(bounds, fill, stroke, strokeWidth);
    this.imageSize = DEFAULT_IMAGESIZE;
    this.imageSrc = null;
    this.spacing = 2;
    this.indicatorSize = 10;
    this.indicatorSpacing = 2;
    this.indicatorImageSrc = null;
  }
  /**
   * Initializes the shape and the <indicator>.
   */
  init(container) {
    super.init(container);
    if (this.indicatorShape) {
      this.indicator = new this.indicatorShape();
      this.indicator.dialect = this.dialect;
      this.indicator.init(this.node);
    }
  }
  /**
   * Reconfigures this shape. This will update the colors of the indicator
   * and reconfigure it if required.
   */
  redraw() {
    if (this.indicator) {
      this.indicator.fill = this.indicatorColor;
      this.indicator.stroke = this.indicatorStrokeColor;
      this.indicator.gradient = this.indicatorGradientColor;
      this.indicator.direction = this.indicatorDirection;
      this.indicator.redraw();
    }
    super.redraw();
  }
  /**
   * Returns true for non-rounded, non-rotated shapes with no glass gradient and
   * no indicator shape.
   */
  isHtmlAllowed() {
    return super.isHtmlAllowed() && this.indicatorColor === NONE && !!this.indicatorShape;
  }
  /**
   * Generic background painting implementation.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  paintForeground(c, x, y, w, h) {
    this.paintImage(c, x, y, w, h);
    this.paintIndicator(c, x, y, w, h);
    super.paintForeground(c, x, y, w, h);
  }
  /**
   * Generic background painting implementation.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  paintImage(c, x, y, w, h) {
    if (this.imageSrc) {
      const bounds = this.getImageBounds(x, y, w, h);
      c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.imageSrc, false, false, false);
    }
  }
  /**
   * Generic background painting implementation.
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  getImageBounds(x, y, w, h) {
    var _a, _b, _c, _d, _e;
    const align = ((_a = this.style) == null ? void 0 : _a.imageAlign) ?? ALIGN.LEFT;
    const valign = ((_b = this.style) == null ? void 0 : _b.verticalAlign) ?? ALIGN.MIDDLE;
    const width = ((_c = this.style) == null ? void 0 : _c.imageWidth) ?? DEFAULT_IMAGESIZE;
    const height = ((_d = this.style) == null ? void 0 : _d.imageHeight) ?? DEFAULT_IMAGESIZE;
    const spacing = ((_e = this.style) == null ? void 0 : _e.spacing) ?? this.spacing + 5;
    if (align === ALIGN.CENTER) {
      x += (w - width) / 2;
    } else if (align === ALIGN.RIGHT) {
      x += w - width - spacing;
    } else {
      x += spacing;
    }
    if (valign === ALIGN.TOP) {
      y += spacing;
    } else if (valign === ALIGN.BOTTOM) {
      y += h - height - spacing;
    } else {
      y += (h - height) / 2;
    }
    return new Rectangle(x, y, width, height);
  }
  /**
   * Generic background painting implementation.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  paintIndicator(c, x, y, w, h) {
    if (this.indicator) {
      this.indicator.bounds = this.getIndicatorBounds(x, y, w, h);
      this.indicator.paint(c);
    } else if (this.indicatorImageSrc) {
      const bounds = this.getIndicatorBounds(x, y, w, h);
      c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.indicatorImageSrc, false, false, false);
    }
  }
  /**
   * Generic background painting implementation.
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @returns {Rectangle}
   */
  getIndicatorBounds(x, y, w, h) {
    var _a, _b, _c, _d;
    const align = ((_a = this.style) == null ? void 0 : _a.imageAlign) ?? ALIGN.LEFT;
    const valign = ((_b = this.style) == null ? void 0 : _b.verticalAlign) ?? ALIGN.MIDDLE;
    const width = ((_c = this.style) == null ? void 0 : _c.indicatorWidth) ?? this.indicatorSize;
    const height = ((_d = this.style) == null ? void 0 : _d.indicatorHeight) ?? this.indicatorSize;
    const spacing = this.spacing + 5;
    if (align === ALIGN.RIGHT) {
      x += w - width - spacing;
    } else if (align === ALIGN.CENTER) {
      x += (w - width) / 2;
    } else {
      x += spacing;
    }
    if (valign === ALIGN.BOTTOM) {
      y += h - height - spacing;
    } else if (valign === ALIGN.TOP) {
      y += spacing;
    } else {
      y += (h - height) / 2;
    }
    return new Rectangle(x, y, width, height);
  }
  /**
   * Generic background painting implementation.
   */
  redrawHtmlShape() {
    super.redrawHtmlShape();
    while (this.node.hasChildNodes()) {
      this.node.removeChild(this.node.lastChild);
    }
    if (this.imageSrc && this.bounds) {
      const node = document.createElement("img");
      node.style.position = "relative";
      node.setAttribute("border", "0");
      const bounds = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
      bounds.x -= this.bounds.x;
      bounds.y -= this.bounds.y;
      node.style.left = `${Math.round(bounds.x)}px`;
      node.style.top = `${Math.round(bounds.y)}px`;
      node.style.width = `${Math.round(bounds.width)}px`;
      node.style.height = `${Math.round(bounds.height)}px`;
      node.src = this.imageSrc;
      this.node.appendChild(node);
    }
  }
}
let isDefaultElementsRegistered = false;
function registerDefaultShapes() {
  if (!isDefaultElementsRegistered) {
    const shapesToRegister = [
      [SHAPE.ACTOR, ActorShape],
      [SHAPE.ARROW, ArrowShape],
      [SHAPE.ARROW_CONNECTOR, ArrowConnectorShape],
      [SHAPE.CONNECTOR, ConnectorShape],
      [SHAPE.CLOUD, CloudShape],
      [SHAPE.CYLINDER, CylinderShape],
      [SHAPE.DOUBLE_ELLIPSE, DoubleEllipseShape],
      [SHAPE.ELLIPSE, EllipseShape],
      [SHAPE.HEXAGON, HexagonShape],
      [SHAPE.IMAGE, ImageShape],
      [SHAPE.LABEL, LabelShape],
      [SHAPE.LINE, LineShape],
      [SHAPE.RECTANGLE, RectangleShape],
      [SHAPE.RHOMBUS, RhombusShape],
      [SHAPE.SWIMLANE, SwimlaneShape],
      [SHAPE.TRIANGLE, TriangleShape]
    ];
    for (const [shapeName, shapeClass] of shapesToRegister) {
      CellRenderer.registerShape(shapeName, shapeClass);
    }
    isDefaultElementsRegistered = true;
  }
}
const EllipsePerimeter = (bounds, _vertex, next, orthogonal = false) => {
  const { x } = bounds;
  const { y } = bounds;
  const a = bounds.width / 2;
  const b = bounds.height / 2;
  const cx = x + a;
  const cy = y + b;
  const px = next.x;
  const py = next.y;
  const dx = parseInt(String(px - cx));
  const dy = parseInt(String(py - cy));
  if (dx === 0 && dy !== 0) {
    return new Point(cx, cy + b * dy / Math.abs(dy));
  }
  if (dx === 0 && dy === 0) {
    return new Point(px, py);
  }
  if (orthogonal) {
    if (py >= y && py <= y + bounds.height) {
      const ty = py - cy;
      let tx = Math.sqrt(a * a * (1 - ty * ty / (b * b))) || 0;
      if (px <= x) {
        tx = -tx;
      }
      return new Point(cx + tx, py);
    }
    if (px >= x && px <= x + bounds.width) {
      const tx = px - cx;
      let ty = Math.sqrt(b * b * (1 - tx * tx / (a * a))) || 0;
      if (py <= y) {
        ty = -ty;
      }
      return new Point(px, cy + ty);
    }
  }
  const d = dy / dx;
  const h = cy - d * cx;
  const e = a * a * d * d + b * b;
  const f = -2 * cx * e;
  const g = a * a * d * d * cx * cx + b * b * cx * cx - a * a * b * b;
  const det = Math.sqrt(f * f - 4 * e * g);
  const xout1 = (-f + det) / (2 * e);
  const xout2 = (-f - det) / (2 * e);
  const yout1 = d * xout1 + h;
  const yout2 = d * xout2 + h;
  const dist1 = Math.sqrt(Math.pow(xout1 - px, 2) + Math.pow(yout1 - py, 2));
  const dist2 = Math.sqrt(Math.pow(xout2 - px, 2) + Math.pow(yout2 - py, 2));
  let xout = 0;
  let yout = 0;
  if (dist1 < dist2) {
    xout = xout1;
    yout = yout1;
  } else {
    xout = xout2;
    yout = yout2;
  }
  return new Point(xout, yout);
};
const HexagonPerimeter = (bounds, vertex, next, orthogonal = false) => {
  var _a;
  const { x } = bounds;
  const { y } = bounds;
  const w = bounds.width;
  const h = bounds.height;
  const cx = bounds.getCenterX();
  const cy = bounds.getCenterY();
  const px = next.x;
  const py = next.y;
  const dx = px - cx;
  const dy = py - cy;
  const alpha = -Math.atan2(dy, dx);
  const pi = Math.PI;
  const pi2 = Math.PI / 2;
  let result = new Point(cx, cy);
  const direction = ((_a = vertex == null ? void 0 : vertex.style) == null ? void 0 : _a.direction) ?? DIRECTION.EAST;
  const vertical = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;
  let a = new Point();
  let b = new Point();
  if (px < x && py < y || px < x && py > y + h || px > x + w && py < y || px > x + w && py > y + h) {
    orthogonal = false;
  }
  if (orthogonal) {
    if (vertical) {
      if (px === cx) {
        if (py <= y) {
          return new Point(cx, y);
        }
        if (py >= y + h) {
          return new Point(cx, y + h);
        }
      } else if (px < x) {
        if (py === y + h / 4) {
          return new Point(x, y + h / 4);
        }
        if (py === y + 3 * h / 4) {
          return new Point(x, y + 3 * h / 4);
        }
      } else if (px > x + w) {
        if (py === y + h / 4) {
          return new Point(x + w, y + h / 4);
        }
        if (py === y + 3 * h / 4) {
          return new Point(x + w, y + 3 * h / 4);
        }
      } else if (px === x) {
        if (py < cy) {
          return new Point(x, y + h / 4);
        }
        if (py > cy) {
          return new Point(x, y + 3 * h / 4);
        }
      } else if (px === x + w) {
        if (py < cy) {
          return new Point(x + w, y + h / 4);
        }
        if (py > cy) {
          return new Point(x + w, y + 3 * h / 4);
        }
      }
      if (py === y) {
        return new Point(cx, y);
      }
      if (py === y + h) {
        return new Point(cx, y + h);
      }
      if (px < cx) {
        if (py > y + h / 4 && py < y + 3 * h / 4) {
          a = new Point(x, y);
          b = new Point(x, y + h);
        } else if (py < y + h / 4) {
          a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
          b = new Point(x + w, y - Math.floor(0.25 * h));
        } else if (py > y + 3 * h / 4) {
          a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
          b = new Point(x + w, y + Math.floor(1.25 * h));
        }
      } else if (px > cx) {
        if (py > y + h / 4 && py < y + 3 * h / 4) {
          a = new Point(x + w, y);
          b = new Point(x + w, y + h);
        } else if (py < y + h / 4) {
          a = new Point(x, y - Math.floor(0.25 * h));
          b = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
        } else if (py > y + 3 * h / 4) {
          a = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
          b = new Point(x, y + Math.floor(1.25 * h));
        }
      }
    } else {
      if (py === cy) {
        if (px <= x) {
          return new Point(x, y + h / 2);
        }
        if (px >= x + w) {
          return new Point(x + w, y + h / 2);
        }
      } else if (py < y) {
        if (px === x + w / 4) {
          return new Point(x + w / 4, y);
        }
        if (px === x + 3 * w / 4) {
          return new Point(x + 3 * w / 4, y);
        }
      } else if (py > y + h) {
        if (px === x + w / 4) {
          return new Point(x + w / 4, y + h);
        }
        if (px === x + 3 * w / 4) {
          return new Point(x + 3 * w / 4, y + h);
        }
      } else if (py === y) {
        if (px < cx) {
          return new Point(x + w / 4, y);
        }
        if (px > cx) {
          return new Point(x + 3 * w / 4, y);
        }
      } else if (py === y + h) {
        if (px < cx) {
          return new Point(x + w / 4, y + h);
        }
        if (py > cy) {
          return new Point(x + 3 * w / 4, y + h);
        }
      }
      if (px === x) {
        return new Point(x, cy);
      }
      if (px === x + w) {
        return new Point(x + w, cy);
      }
      if (py < cy) {
        if (px > x + w / 4 && px < x + 3 * w / 4) {
          a = new Point(x, y);
          b = new Point(x + w, y);
        } else if (px < x + w / 4) {
          a = new Point(x - Math.floor(0.25 * w), y + h);
          b = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
        } else if (px > x + 3 * w / 4) {
          a = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
          b = new Point(x + Math.floor(1.25 * w), y + h);
        }
      } else if (py > cy) {
        if (px > x + w / 4 && px < x + 3 * w / 4) {
          a = new Point(x, y + h);
          b = new Point(x + w, y + h);
        } else if (px < x + w / 4) {
          a = new Point(x - Math.floor(0.25 * w), y);
          b = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
        } else if (px > x + 3 * w / 4) {
          a = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
          b = new Point(x + Math.floor(1.25 * w), y);
        }
      }
    }
    let tx = cx;
    let ty = cy;
    if (px >= x && px <= x + w) {
      tx = px;
      if (py < cy) {
        ty = y + h;
      } else {
        ty = y;
      }
    } else if (py >= y && py <= y + h) {
      ty = py;
      if (px < cx) {
        tx = x + w;
      } else {
        tx = x;
      }
    }
    result = intersection(tx, ty, next.x, next.y, a.x, a.y, b.x, b.y);
  } else {
    if (vertical) {
      const beta = Math.atan2(h / 4, w / 2);
      if (alpha === beta) {
        return new Point(x + w, y + Math.floor(0.25 * h));
      }
      if (alpha === pi2) {
        return new Point(x + Math.floor(0.5 * w), y);
      }
      if (alpha === pi - beta) {
        return new Point(x, y + Math.floor(0.25 * h));
      }
      if (alpha === -beta) {
        return new Point(x + w, y + Math.floor(0.75 * h));
      }
      if (alpha === -pi2) {
        return new Point(x + Math.floor(0.5 * w), y + h);
      }
      if (alpha === -pi + beta) {
        return new Point(x, y + Math.floor(0.75 * h));
      }
      if (alpha < beta && alpha > -beta) {
        a = new Point(x + w, y);
        b = new Point(x + w, y + h);
      } else if (alpha > beta && alpha < pi2) {
        a = new Point(x, y - Math.floor(0.25 * h));
        b = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
      } else if (alpha > pi2 && alpha < pi - beta) {
        a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
        b = new Point(x + w, y - Math.floor(0.25 * h));
      } else if (alpha > pi - beta && alpha <= pi || alpha < -pi + beta && alpha >= -pi) {
        a = new Point(x, y);
        b = new Point(x, y + h);
      } else if (alpha < -beta && alpha > -pi2) {
        a = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
        b = new Point(x, y + Math.floor(1.25 * h));
      } else if (alpha < -pi2 && alpha > -pi + beta) {
        a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
        b = new Point(x + w, y + Math.floor(1.25 * h));
      }
    } else {
      const beta = Math.atan2(h / 2, w / 4);
      if (alpha === beta) {
        return new Point(x + Math.floor(0.75 * w), y);
      }
      if (alpha === pi - beta) {
        return new Point(x + Math.floor(0.25 * w), y);
      }
      if (alpha === pi || alpha === -pi) {
        return new Point(x, y + Math.floor(0.5 * h));
      }
      if (alpha === 0) {
        return new Point(x + w, y + Math.floor(0.5 * h));
      }
      if (alpha === -beta) {
        return new Point(x + Math.floor(0.75 * w), y + h);
      }
      if (alpha === -pi + beta) {
        return new Point(x + Math.floor(0.25 * w), y + h);
      }
      if (alpha > 0 && alpha < beta) {
        a = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
        b = new Point(x + Math.floor(1.25 * w), y + h);
      } else if (alpha > beta && alpha < pi - beta) {
        a = new Point(x, y);
        b = new Point(x + w, y);
      } else if (alpha > pi - beta && alpha < pi) {
        a = new Point(x - Math.floor(0.25 * w), y + h);
        b = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
      } else if (alpha < 0 && alpha > -beta) {
        a = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
        b = new Point(x + Math.floor(1.25 * w), y);
      } else if (alpha < -beta && alpha > -pi + beta) {
        a = new Point(x, y + h);
        b = new Point(x + w, y + h);
      } else if (alpha < -pi + beta && alpha > -pi) {
        a = new Point(x - Math.floor(0.25 * w), y);
        b = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
      }
    }
    result = intersection(cx, cy, next.x, next.y, a.x, a.y, b.x, b.y);
  }
  if (result == null) {
    return new Point(cx, cy);
  }
  return result;
};
const RectanglePerimeter = (bounds, _vertex, next, orthogonal = false) => {
  const cx = bounds.getCenterX();
  const cy = bounds.getCenterY();
  const dx = next.x - cx;
  const dy = next.y - cy;
  const alpha = Math.atan2(dy, dx);
  const p = new Point(0, 0);
  const pi = Math.PI;
  const pi2 = Math.PI / 2;
  const beta = pi2 - alpha;
  const t = Math.atan2(bounds.height, bounds.width);
  if (alpha < -pi + t || alpha > pi - t) {
    p.x = bounds.x;
    p.y = cy - bounds.width * Math.tan(alpha) / 2;
  } else if (alpha < -t) {
    p.y = bounds.y;
    p.x = cx - bounds.height * Math.tan(beta) / 2;
  } else if (alpha < t) {
    p.x = bounds.x + bounds.width;
    p.y = cy + bounds.width * Math.tan(alpha) / 2;
  } else {
    p.y = bounds.y + bounds.height;
    p.x = cx + bounds.height * Math.tan(beta) / 2;
  }
  if (orthogonal) {
    if (next.x >= bounds.x && next.x <= bounds.x + bounds.width) {
      p.x = next.x;
    } else if (next.y >= bounds.y && next.y <= bounds.y + bounds.height) {
      p.y = next.y;
    }
    if (next.x < bounds.x) {
      p.x = bounds.x;
    } else if (next.x > bounds.x + bounds.width) {
      p.x = bounds.x + bounds.width;
    }
    if (next.y < bounds.y) {
      p.y = bounds.y;
    } else if (next.y > bounds.y + bounds.height) {
      p.y = bounds.y + bounds.height;
    }
  }
  return p;
};
const RhombusPerimeter = (bounds, _vertex, next, orthogonal = false) => {
  const { x } = bounds;
  const { y } = bounds;
  const w = bounds.width;
  const h = bounds.height;
  const cx = x + w / 2;
  const cy = y + h / 2;
  const px = next.x;
  const py = next.y;
  if (cx === px) {
    if (cy > py) {
      return new Point(cx, y);
    }
    return new Point(cx, y + h);
  }
  if (cy === py) {
    if (cx > px) {
      return new Point(x, cy);
    }
    return new Point(x + w, cy);
  }
  let tx = cx;
  let ty = cy;
  if (orthogonal) {
    if (px >= x && px <= x + w) {
      tx = px;
    } else if (py >= y && py <= y + h) {
      ty = py;
    }
  }
  if (px < cx) {
    if (py < cy) {
      return intersection(px, py, tx, ty, cx, y, x, cy);
    }
    return intersection(px, py, tx, ty, cx, y + h, x, cy);
  }
  if (py < cy) {
    return intersection(px, py, tx, ty, cx, y, x + w, cy);
  }
  return intersection(px, py, tx, ty, cx, y + h, x + w, cy);
};
const TrianglePerimeter = (bounds, vertex, next, orthogonal = false) => {
  const direction = vertex != null ? vertex.style.direction : null;
  const vertical = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;
  const { x } = bounds;
  const { y } = bounds;
  const w = bounds.width;
  const h = bounds.height;
  let cx = x + w / 2;
  let cy = y + h / 2;
  let start = new Point(x, y);
  let corner = new Point(x + w, cy);
  let end = new Point(x, y + h);
  if (direction === DIRECTION.NORTH) {
    start = end;
    corner = new Point(cx, y);
    end = new Point(x + w, y + h);
  } else if (direction === DIRECTION.SOUTH) {
    corner = new Point(cx, y + h);
    end = new Point(x + w, y);
  } else if (direction === DIRECTION.WEST) {
    start = new Point(x + w, y);
    corner = new Point(x, cy);
    end = new Point(x + w, y + h);
  }
  let dx = next.x - cx;
  let dy = next.y - cy;
  const alpha = vertical ? Math.atan2(dx, dy) : Math.atan2(dy, dx);
  const t = vertical ? Math.atan2(w, h) : Math.atan2(h, w);
  let base = false;
  if (direction === DIRECTION.NORTH || direction === DIRECTION.WEST) {
    base = alpha > -t && alpha < t;
  } else {
    base = alpha < -Math.PI + t || alpha > Math.PI - t;
  }
  let result = null;
  if (base) {
    if (orthogonal && (vertical && next.x >= start.x && next.x <= end.x || !vertical && next.y >= start.y && next.y <= end.y)) {
      if (vertical) {
        result = new Point(next.x, start.y);
      } else {
        result = new Point(start.x, next.y);
      }
    } else if (direction === DIRECTION.NORTH) {
      result = new Point(x + w / 2 + h * Math.tan(alpha) / 2, y + h);
    } else if (direction === DIRECTION.SOUTH) {
      result = new Point(x + w / 2 - h * Math.tan(alpha) / 2, y);
    } else if (direction === DIRECTION.WEST) {
      result = new Point(x + w, y + h / 2 + w * Math.tan(alpha) / 2);
    } else {
      result = new Point(x, y + h / 2 - w * Math.tan(alpha) / 2);
    }
  } else {
    if (orthogonal) {
      const pt = new Point(cx, cy);
      if (next.y >= y && next.y <= y + h) {
        pt.x = vertical ? cx : direction === DIRECTION.WEST ? x + w : x;
        pt.y = next.y;
      } else if (next.x >= x && next.x <= x + w) {
        pt.x = next.x;
        pt.y = !vertical ? cy : direction === DIRECTION.NORTH ? y + h : y;
      }
      dx = next.x - pt.x;
      dy = next.y - pt.y;
      cx = pt.x;
      cy = pt.y;
    }
    if (vertical && next.x <= x + w / 2 || !vertical && next.y <= y + h / 2) {
      result = intersection(next.x, next.y, cx, cy, start.x, start.y, corner.x, corner.y);
    } else {
      result = intersection(next.x, next.y, cx, cy, corner.x, corner.y, end.x, end.y);
    }
  }
  if (result == null) {
    result = new Point(cx, cy);
  }
  return result;
};
const Perimeter = {
  /**
   * Describes a rectangular perimeter.
   */
  RectanglePerimeter,
  /**
   * Describes an elliptic perimeter.
   */
  EllipsePerimeter,
  /**
   * Describes a rhombus (aka diamond) perimeter.
   */
  RhombusPerimeter,
  /**
   * Describes a triangle perimeter.
   */
  TrianglePerimeter,
  /**
   * Describes a hexagon perimeter.
   */
  HexagonPerimeter
};
let isDefaultsRegistered = false;
const registerDefaultStyleElements = () => {
  if (!isDefaultsRegistered) {
    StyleRegistry.putValue(EDGESTYLE.ELBOW, EdgeStyle.ElbowConnector);
    StyleRegistry.putValue(EDGESTYLE.ENTITY_RELATION, EdgeStyle.EntityRelation);
    StyleRegistry.putValue(EDGESTYLE.LOOP, EdgeStyle.Loop);
    StyleRegistry.putValue(EDGESTYLE.MANHATTAN, EdgeStyle.ManhattanConnector);
    StyleRegistry.putValue(EDGESTYLE.ORTHOGONAL, EdgeStyle.OrthConnector);
    StyleRegistry.putValue(EDGESTYLE.SEGMENT, EdgeStyle.SegmentConnector);
    StyleRegistry.putValue(EDGESTYLE.SIDETOSIDE, EdgeStyle.SideToSide);
    StyleRegistry.putValue(EDGESTYLE.TOPTOBOTTOM, EdgeStyle.TopToBottom);
    StyleRegistry.putValue(PERIMETER.ELLIPSE, Perimeter.EllipsePerimeter);
    StyleRegistry.putValue(PERIMETER.HEXAGON, Perimeter.HexagonPerimeter);
    StyleRegistry.putValue(PERIMETER.RECTANGLE, Perimeter.RectanglePerimeter);
    StyleRegistry.putValue(PERIMETER.RHOMBUS, Perimeter.RhombusPerimeter);
    StyleRegistry.putValue(PERIMETER.TRIANGLE, Perimeter.TrianglePerimeter);
    isDefaultsRegistered = true;
  }
};
const getOpposites = (edges, terminal, includeSources = true, includeTargets = true) => {
  return edges.reduce((terminals, edge) => {
    const source = edge.getTerminal(true);
    const target = edge.getTerminal(false);
    if (source === terminal && target != null && target !== terminal && includeTargets) {
      terminals.push(target);
    } else if (target === terminal && source != null && source !== terminal && includeSources) {
      terminals.push(source);
    }
    return terminals;
  }, []);
};
const getTopmostCells = (cells) => {
  const dict = new Dictionary();
  const tmp = [];
  for (let i = 0; i < cells.length; i += 1) {
    dict.put(cells[i], true);
  }
  for (let i = 0; i < cells.length; i += 1) {
    const cell = cells[i];
    let topmost = true;
    let parent = cell.getParent();
    while (parent != null) {
      if (dict.get(parent)) {
        topmost = false;
        break;
      }
      parent = parent.getParent();
    }
    if (topmost) {
      tmp.push(cell);
    }
  }
  return tmp;
};
const getParents = (cells) => {
  const parents = [];
  const dict = new Dictionary();
  for (const cell of cells) {
    const parent = cell.getParent();
    if (parent != null && !dict.get(parent)) {
      dict.put(parent, true);
      parents.push(parent);
    }
  }
  return parents;
};
const cloneCell = (cell = null, includeChildren = true) => {
  if (!cell) {
    return null;
  }
  return cloneCells([cell], includeChildren)[0];
};
const cloneCells = (cells, includeChildren = true, mapping = {}) => {
  const clones = [];
  for (const cell of cells) {
    clones.push(cloneCellImpl(cell, mapping, includeChildren));
  }
  for (let i = 0; i < clones.length; i += 1) {
    if (clones[i] != null) {
      restoreClone(clones[i], cells[i], mapping);
    }
  }
  return clones;
};
const cloneCellImpl = (cell, mapping = {}, includeChildren = false) => {
  const identity = ObjectIdentity.get(cell);
  let clone2 = mapping ? mapping[identity] : null;
  if (clone2 == null) {
    clone2 = cell.clone();
    mapping[identity] = clone2;
    if (includeChildren) {
      const childCount = cell.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        const cloneChild = cloneCellImpl(cell.getChildAt(i), mapping, true);
        clone2.insert(cloneChild);
      }
    }
  }
  return clone2;
};
const restoreClone = (clone2, cell, mapping) => {
  const source = cell.getTerminal(true);
  if (source != null) {
    const tmp = mapping[ObjectIdentity.get(source)];
    if (tmp != null) {
      tmp.insertEdge(clone2, true);
    }
  }
  const target = cell.getTerminal(false);
  if (target != null) {
    const tmp = mapping[ObjectIdentity.get(target)];
    if (tmp != null) {
      tmp.insertEdge(clone2, false);
    }
  }
  const childCount = clone2.getChildCount();
  for (let i = 0; i < childCount; i += 1) {
    restoreClone(clone2.getChildAt(i), cell.getChildAt(i), mapping);
  }
};
const cellArrayUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cloneCell,
  cloneCells,
  getOpposites,
  getParents,
  getTopmostCells
}, Symbol.toStringTag, { value: "Module" }));
const CellsMixin = {
  cellsResizable: true,
  cellsBendable: true,
  cellsSelectable: true,
  cellsDisconnectable: true,
  autoSizeCells: false,
  autoSizeCellsOnAdd: false,
  cellsLocked: false,
  cellsCloneable: true,
  cellsDeletable: true,
  cellsMovable: true,
  extendParents: true,
  extendParentsOnAdd: true,
  extendParentsOnMove: false,
  getBoundingBox(cells) {
    let result = null;
    if (cells.length > 0) {
      for (const cell of cells) {
        if (cell.isVertex() || cell.isEdge()) {
          const bbox = this.getView().getBoundingBox(this.getView().getState(cell), true);
          if (bbox) {
            if (!result) {
              result = Rectangle.fromRectangle(bbox);
            } else {
              result.add(bbox);
            }
          }
        }
      }
    }
    return result;
  },
  removeStateForCell(cell) {
    for (const child of cell.getChildren()) {
      this.removeStateForCell(child);
    }
    this.getView().invalidate(cell, false, true);
    this.getView().removeState(cell);
  },
  /*****************************************************************************
   * Group: Cell styles
   *****************************************************************************/
  getCurrentCellStyle(cell, ignoreState = false) {
    const state = ignoreState ? null : this.getView().getState(cell);
    return state ? state.style : this.getCellStyle(cell);
  },
  getCellStyle(cell) {
    const cellStyle = cell.getStyle();
    const stylesheet = this.getStylesheet();
    const defaultStyle = cell.isEdge() ? stylesheet.getDefaultEdgeStyle() : stylesheet.getDefaultVertexStyle();
    const style = this.postProcessCellStyle(stylesheet.getCellStyle(cellStyle, defaultStyle ?? {}));
    return style;
  },
  postProcessCellStyle(style) {
    if (!style.image) {
      return style;
    }
    const key = style.image;
    let image = this.getImageFromBundles(key);
    if (image) {
      style.image = image;
    } else {
      image = key;
    }
    if (image && image.substring(0, 11) === "data:image/") {
      if (image.substring(0, 20) === "data:image/svg+xml,<") {
        image = image.substring(0, 19) + encodeURIComponent(image.substring(19));
      } else if (image.substring(0, 22) !== "data:image/svg+xml,%3C") {
        const comma = image.indexOf(",");
        if (comma > 0 && image.substring(comma - 7, comma + 1) !== ";base64,") {
          image = `${image.substring(0, comma)};base64,${image.substring(comma + 1)}`;
        }
      }
      style.image = image;
    }
    return style;
  },
  setCellStyle(style, cells) {
    cells = cells ?? this.getSelectionCells();
    this.batchUpdate(() => {
      for (const cell of cells) {
        this.getDataModel().setStyle(cell, style);
      }
    });
  },
  toggleCellStyle(key, defaultValue = false, cell) {
    cell = cell ?? this.getSelectionCell();
    return this.toggleCellStyles(key, defaultValue, [cell]);
  },
  toggleCellStyles(key, defaultValue = false, cells) {
    let value = false;
    cells = cells ?? this.getSelectionCells();
    if (cells.length > 0) {
      const style = this.getCurrentCellStyle(cells[0]);
      value = !(style[key] ?? defaultValue);
      this.setCellStyles(key, value, cells);
    }
    return value;
  },
  setCellStyles(key, value, cells) {
    cells = cells ?? this.getSelectionCells();
    setCellStyles(this.getDataModel(), cells, key, value);
  },
  toggleCellStyleFlags(key, flag, cells) {
    cells = cells ?? this.getSelectionCells();
    this.setCellStyleFlags(key, flag, null, cells);
  },
  setCellStyleFlags(key, flag, value = null, cells) {
    cells = cells ?? this.getSelectionCells();
    if (cells.length > 0) {
      if (value === null) {
        const style = this.getCurrentCellStyle(cells[0]);
        const current = style[key] || 0;
        value = !((current & flag) === flag);
      }
      setCellStyleFlags(this.getDataModel(), cells, key, flag, value);
    }
  },
  /*****************************************************************************
   * Group: Cell alignment and orientation
   *****************************************************************************/
  alignCells(align, cells, param = null) {
    cells = cells ?? this.getSelectionCells();
    if (cells.length > 1) {
      if (param === null) {
        for (const cell of cells) {
          const state = this.getView().getState(cell);
          if (state && !cell.isEdge()) {
            if (param === null) {
              if (align === ALIGN.CENTER) {
                param = state.x + state.width / 2;
                break;
              } else if (align === ALIGN.RIGHT) {
                param = state.x + state.width;
              } else if (align === ALIGN.TOP) {
                param = state.y;
              } else if (align === ALIGN.MIDDLE) {
                param = state.y + state.height / 2;
                break;
              } else if (align === ALIGN.BOTTOM) {
                param = state.y + state.height;
              } else {
                param = state.x;
              }
            } else if (align === ALIGN.RIGHT) {
              param = Math.max(param, state.x + state.width);
            } else if (align === ALIGN.TOP) {
              param = Math.min(param, state.y);
            } else if (align === ALIGN.BOTTOM) {
              param = Math.max(param, state.y + state.height);
            } else {
              param = Math.min(param, state.x);
            }
          }
        }
      }
      if (param !== null) {
        const s = this.getView().scale;
        this.batchUpdate(() => {
          const p = param;
          for (const cell of cells) {
            const state = this.getView().getState(cell);
            if (state != null) {
              let geo = cell.getGeometry();
              if (geo != null && !cell.isEdge()) {
                geo = geo.clone();
                if (align === ALIGN.CENTER) {
                  geo.x += (p - state.x - state.width / 2) / s;
                } else if (align === ALIGN.RIGHT) {
                  geo.x += (p - state.x - state.width) / s;
                } else if (align === ALIGN.TOP) {
                  geo.y += (p - state.y) / s;
                } else if (align === ALIGN.MIDDLE) {
                  geo.y += (p - state.y - state.height / 2) / s;
                } else if (align === ALIGN.BOTTOM) {
                  geo.y += (p - state.y - state.height) / s;
                } else {
                  geo.x += (p - state.x) / s;
                }
                this.resizeCell(cell, geo);
              }
            }
          }
          this.fireEvent(new EventObject(InternalEvent.ALIGN_CELLS, { align, cells }));
        });
      }
    }
    return cells;
  },
  /*****************************************************************************
   * Group: Cell cloning, insertion and removal
   *****************************************************************************/
  cloneCell(cell, allowInvalidEdges = false, mapping = {}, keepPosition = false) {
    return this.cloneCells([cell], allowInvalidEdges, mapping, keepPosition)[0];
  },
  cloneCells(cells, allowInvalidEdges = true, mapping = {}, keepPosition = false) {
    let clones;
    const dict = new Dictionary();
    const tmp = [];
    for (const cell of cells) {
      dict.put(cell, true);
      tmp.push(cell);
    }
    if (tmp.length > 0) {
      const { scale } = this.getView();
      const trans = this.getView().translate;
      const out = [];
      clones = cloneCells(cells, true, mapping);
      for (let i = 0; i < cells.length; i += 1) {
        const cell = cells[i];
        const clone2 = clones[i];
        if (!allowInvalidEdges && clone2.isEdge() && this.getEdgeValidationError(clone2, clone2.getTerminal(true), clone2.getTerminal(false)) !== null) ;
        else {
          out.push(clone2);
          const g = clone2.getGeometry();
          if (g) {
            const state = this.getView().getState(cell);
            const parent = cell.getParent();
            const pstate = parent ? this.getView().getState(parent) : null;
            if (state && pstate) {
              const dx = keepPosition ? 0 : pstate.origin.x;
              const dy = keepPosition ? 0 : pstate.origin.y;
              if (clone2.isEdge()) {
                const pts = state.absolutePoints;
                let src = cell.getTerminal(true);
                while (src && !dict.get(src)) {
                  src = src.getParent();
                }
                if (!src && pts[0]) {
                  g.setTerminalPoint(new Point(pts[0].x / scale - trans.x, pts[0].y / scale - trans.y), true);
                }
                let trg = cell.getTerminal(false);
                while (trg && !dict.get(trg)) {
                  trg = trg.getParent();
                }
                const n = pts.length - 1;
                const p = pts[n];
                if (!trg && p) {
                  g.setTerminalPoint(new Point(p.x / scale - trans.x, p.y / scale - trans.y), false);
                }
                const { points } = g;
                if (points) {
                  for (const point of points) {
                    point.x += dx;
                    point.y += dy;
                  }
                }
              } else {
                g.translate(dx, dy);
              }
            }
          }
        }
      }
      clones = out;
    } else {
      clones = [];
    }
    return clones;
  },
  addCell(cell, parent = null, index = null, source = null, target = null) {
    return this.addCells([cell], parent, index, source, target)[0];
  },
  addCells(cells, parent = null, index = null, source = null, target = null, absolute = false) {
    const p = parent ?? this.getDefaultParent();
    const i = index ?? p.getChildCount();
    this.batchUpdate(() => {
      this.cellsAdded(cells, p, i, source, target, absolute, true);
      this.fireEvent(new EventObject(InternalEvent.ADD_CELLS, { cells, p, i, source, target }));
    });
    return cells;
  },
  cellsAdded(cells, parent, index, source = null, target = null, absolute = false, constrain = false, extend = true) {
    this.batchUpdate(() => {
      const parentState = absolute ? this.getView().getState(parent) : null;
      const o1 = parentState ? parentState.origin : null;
      const zero = new Point(0, 0);
      cells.forEach((cell, i) => {
        const previous = cell.getParent();
        if (o1 && cell !== parent && parent !== previous) {
          const oldState = previous ? this.getView().getState(previous) : null;
          const o2 = oldState ? oldState.origin : zero;
          let geo = cell.getGeometry();
          if (geo) {
            const dx = o2.x - o1.x;
            const dy = o2.y - o1.y;
            geo = geo.clone();
            geo.translate(dx, dy);
            if (!geo.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {
              geo.x = Math.max(0, geo.x);
              geo.y = Math.max(0, geo.y);
            }
            this.getDataModel().setGeometry(cell, geo);
          }
        }
        if (parent === previous && index + i > parent.getChildCount()) {
          index--;
        }
        this.getDataModel().add(parent, cell, index + i);
        if (this.autoSizeCellsOnAdd) {
          this.autoSizeCell(cell, true);
        }
        if ((!extend || extend) && this.isExtendParentsOnAdd(cell) && this.isExtendParent(cell)) {
          this.extendParent(cell);
        }
        if (!constrain || constrain) {
          this.constrainChild(cell);
        }
        if (source) {
          this.cellConnected(cell, source, true);
        }
        if (target) {
          this.cellConnected(cell, target, false);
        }
      });
      this.fireEvent(new EventObject(InternalEvent.CELLS_ADDED, {
        cells,
        parent,
        index,
        source,
        target,
        absolute
      }));
    });
  },
  autoSizeCell(cell, recurse = true) {
    if (recurse) {
      for (const child of cell.getChildren()) {
        this.autoSizeCell(child);
      }
    }
    if (cell.isVertex() && this.isAutoSizeCell(cell)) {
      this.updateCellSize(cell);
    }
  },
  removeCells(cells = null, includeEdges = true) {
    if (!cells) {
      cells = this.getDeletableCells(this.getSelectionCells());
    }
    if (includeEdges) {
      cells = this.getDeletableCells(this.addAllEdges(cells));
    } else {
      cells = cells.slice();
      const edges = this.getDeletableCells(this.getAllEdges(cells));
      const dict = new Dictionary();
      for (const cell of cells) {
        dict.put(cell, true);
      }
      for (const edge of edges) {
        if (!this.getView().getState(edge) && !dict.get(edge)) {
          dict.put(edge, true);
          cells.push(edge);
        }
      }
    }
    this.batchUpdate(() => {
      this.cellsRemoved(cells);
      this.fireEvent(new EventObject(InternalEvent.REMOVE_CELLS, { cells, includeEdges }));
    });
    return cells ?? [];
  },
  cellsRemoved(cells) {
    if (cells.length > 0) {
      const { scale } = this.getView();
      const tr = this.getView().translate;
      this.batchUpdate(() => {
        const dict = new Dictionary();
        for (const cell of cells) {
          dict.put(cell, true);
        }
        for (const cell of cells) {
          const edges = this.getAllEdges([cell]);
          const disconnectTerminal = (edge, source) => {
            let geo = edge.getGeometry();
            if (geo) {
              const terminal = edge.getTerminal(source);
              let connected = false;
              let tmp = terminal;
              while (tmp) {
                if (cell === tmp) {
                  connected = true;
                  break;
                }
                tmp = tmp.getParent();
              }
              if (connected) {
                geo = geo.clone();
                const state = this.getView().getState(edge);
                if (state) {
                  const pts = state.absolutePoints;
                  const n = source ? 0 : pts.length - 1;
                  const p = pts[n];
                  geo.setTerminalPoint(new Point(p.x / scale - tr.x - state.origin.x, p.y / scale - tr.y - state.origin.y), source);
                } else if (terminal) {
                  const tstate = this.getView().getState(terminal);
                  if (tstate) {
                    geo.setTerminalPoint(new Point(tstate.getCenterX() / scale - tr.x, tstate.getCenterY() / scale - tr.y), source);
                  }
                }
                this.getDataModel().setGeometry(edge, geo);
                this.getDataModel().setTerminal(edge, null, source);
              }
            }
          };
          for (const edge of edges) {
            if (!dict.get(edge)) {
              dict.put(edge, true);
              disconnectTerminal(edge, true);
              disconnectTerminal(edge, false);
            }
          }
          this.getDataModel().remove(cell);
        }
        this.fireEvent(new EventObject(InternalEvent.CELLS_REMOVED, { cells }));
      });
    }
  },
  /*****************************************************************************
   * Group: Cell visibility
   *****************************************************************************/
  toggleCells(show2 = false, cells, includeEdges = true) {
    cells = cells ?? this.getSelectionCells();
    if (includeEdges) {
      cells = this.addAllEdges(cells);
    }
    this.batchUpdate(() => {
      this.cellsToggled(cells, show2);
      this.fireEvent(new EventObject(InternalEvent.TOGGLE_CELLS, { show: show2, cells, includeEdges }));
    });
    return cells;
  },
  cellsToggled(cells, show2 = false) {
    if (cells.length > 0) {
      this.batchUpdate(() => {
        for (const cell of cells) {
          this.getDataModel().setVisible(cell, show2);
        }
      });
    }
  },
  /*****************************************************************************
   * Group: Cell sizing
   *****************************************************************************/
  updateCellSize(cell, ignoreChildren = false) {
    this.batchUpdate(() => {
      this.cellSizeUpdated(cell, ignoreChildren);
      this.fireEvent(new EventObject(InternalEvent.UPDATE_CELL_SIZE, { cell, ignoreChildren }));
    });
    return cell;
  },
  cellSizeUpdated(cell, ignoreChildren = false) {
    this.batchUpdate(() => {
      const size = this.getPreferredSizeForCell(cell);
      let geo = cell.getGeometry();
      if (size && geo) {
        const collapsed = cell.isCollapsed();
        geo = geo.clone();
        if (this.isSwimlane(cell)) {
          const style = this.getCellStyle(cell);
          const cellStyle = cell.getStyle();
          if (style.horizontal ?? true) {
            cellStyle.startSize = size.height + 8;
            if (collapsed) {
              geo.height = size.height + 8;
            }
            geo.width = size.width;
          } else {
            cellStyle.startSize = size.width + 8;
            if (collapsed) {
              geo.width = size.width + 8;
            }
            geo.height = size.height;
          }
          this.getDataModel().setStyle(cell, cellStyle);
        } else {
          const state = this.getView().createState(cell);
          const align = state.style.align ?? ALIGN.CENTER;
          if (align === ALIGN.RIGHT) {
            geo.x += geo.width - size.width;
          } else if (align === ALIGN.CENTER) {
            geo.x += Math.round((geo.width - size.width) / 2);
          }
          const valign = state.getVerticalAlign();
          if (valign === ALIGN.BOTTOM) {
            geo.y += geo.height - size.height;
          } else if (valign === ALIGN.MIDDLE) {
            geo.y += Math.round((geo.height - size.height) / 2);
          }
          geo.width = size.width;
          geo.height = size.height;
        }
        if (!ignoreChildren && !collapsed) {
          const bounds = this.getView().getBounds(cell.getChildren());
          if (bounds != null) {
            const tr = this.getView().translate;
            const { scale } = this.getView();
            const width = (bounds.x + bounds.width) / scale - geo.x - tr.x;
            const height = (bounds.y + bounds.height) / scale - geo.y - tr.y;
            geo.width = Math.max(geo.width, width);
            geo.height = Math.max(geo.height, height);
          }
        }
        this.cellsResized([cell], [geo], false);
      }
    });
  },
  getPreferredSizeForCell(cell, textWidth = null) {
    let result = null;
    const state = this.getView().createState(cell);
    const { style } = state;
    if (!cell.isEdge()) {
      const fontSize = style.fontSize || DEFAULT_FONTSIZE;
      let dx = 0;
      let dy = 0;
      if (state.getImageSrc() || style.image) {
        if (style.shape === SHAPE.LABEL) {
          if (style.verticalAlign === ALIGN.MIDDLE) {
            dx += style.imageWidth || DEFAULT_IMAGESIZE;
          }
          if (style.align !== ALIGN.CENTER) {
            dy += style.imageHeight || DEFAULT_IMAGESIZE;
          }
        }
      }
      dx += 2 * (style.spacing || 0);
      dx += style.spacingLeft || 0;
      dx += style.spacingRight || 0;
      dy += 2 * (style.spacing || 0);
      dy += style.spacingTop || 0;
      dy += style.spacingBottom || 0;
      const image = this.getFoldingImage(state);
      if (image) {
        dx += image.width + 8;
      }
      let value = this.getCellRenderer().getLabelValue(state);
      if (value && value.length > 0) {
        if (!this.isHtmlLabel(state.cell)) {
          value = htmlEntities(value, false);
        }
        value = value.replace(/\n/g, "<br>");
        const size = getSizeForString(value, fontSize, style.fontFamily, textWidth, style.fontStyle);
        let width = size.width + dx;
        let height = size.height + dy;
        if (!(style.horizontal ?? true)) {
          const tmp = height;
          height = width;
          width = tmp;
        }
        if (this.isGridEnabled()) {
          width = this.snap(width + this.getGridSize() / 2);
          height = this.snap(height + this.getGridSize() / 2);
        }
        result = new Rectangle(0, 0, width, height);
      } else {
        const gs2 = 4 * this.getGridSize();
        result = new Rectangle(0, 0, gs2, gs2);
      }
    }
    return result;
  },
  resizeCell(cell, bounds, recurse = false) {
    return this.resizeCells([cell], [bounds], recurse)[0];
  },
  resizeCells(cells, bounds, recurse) {
    recurse = recurse ?? this.isRecursiveResize();
    this.batchUpdate(() => {
      const prev = this.cellsResized(cells, bounds, recurse);
      this.fireEvent(new EventObject(InternalEvent.RESIZE_CELLS, { cells, bounds, prev }));
    });
    return cells;
  },
  cellsResized(cells, bounds, recurse = false) {
    const prev = [];
    if (cells.length === bounds.length) {
      this.batchUpdate(() => {
        cells.forEach((cell, i) => {
          prev.push(this.cellResized(cell, bounds[i], false, recurse));
          if (this.isExtendParent(cell)) {
            this.extendParent(cell);
          }
          this.constrainChild(cell);
        });
        if (this.isResetEdgesOnResize()) {
          this.resetEdges(cells);
        }
        this.fireEvent(new EventObject(InternalEvent.CELLS_RESIZED, { cells, bounds, prev }));
      });
    }
    return prev;
  },
  cellResized(cell, bounds, ignoreRelative = false, recurse = false) {
    const prev = cell.getGeometry();
    if (prev && (prev.x !== bounds.x || prev.y !== bounds.y || prev.width !== bounds.width || prev.height !== bounds.height)) {
      const geo = prev.clone();
      if (!ignoreRelative && geo.relative) {
        const { offset } = geo;
        if (offset) {
          offset.x += bounds.x - geo.x;
          offset.y += bounds.y - geo.y;
        }
      } else {
        geo.x = bounds.x;
        geo.y = bounds.y;
      }
      geo.width = bounds.width;
      geo.height = bounds.height;
      if (!geo.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {
        geo.x = Math.max(0, geo.x);
        geo.y = Math.max(0, geo.y);
      }
      this.batchUpdate(() => {
        if (recurse) {
          this.resizeChildCells(cell, geo);
        }
        this.getDataModel().setGeometry(cell, geo);
        this.constrainChildCells(cell);
      });
    }
    return prev;
  },
  resizeChildCells(cell, newGeo) {
    const geo = cell.getGeometry();
    if (geo) {
      const dx = geo.width !== 0 ? newGeo.width / geo.width : 1;
      const dy = geo.height !== 0 ? newGeo.height / geo.height : 1;
      for (const child of cell.getChildren()) {
        this.scaleCell(child, dx, dy, true);
      }
    }
  },
  constrainChildCells(cell) {
    for (const child of cell.getChildren()) {
      this.constrainChild(child);
    }
  },
  scaleCell(cell, dx, dy, recurse = false) {
    let geo = cell.getGeometry();
    if (geo) {
      const style = this.getCurrentCellStyle(cell);
      geo = geo.clone();
      const { x } = geo;
      const { y } = geo;
      const w = geo.width;
      const h = geo.height;
      geo.scale(dx, dy, style.aspect === "fixed");
      if (style.resizeWidth) {
        geo.width = w * dx;
      } else if (!style.resizeWidth) {
        geo.width = w;
      }
      if (style.resizeHeight) {
        geo.height = h * dy;
      } else if (!style.resizeHeight) {
        geo.height = h;
      }
      if (!this.isCellMovable(cell)) {
        geo.x = x;
        geo.y = y;
      }
      if (!this.isCellResizable(cell)) {
        geo.width = w;
        geo.height = h;
      }
      if (cell.isVertex()) {
        this.cellResized(cell, geo, true, recurse);
      } else {
        this.getDataModel().setGeometry(cell, geo);
      }
    }
  },
  extendParent(cell) {
    const parent = cell.getParent();
    let p = parent ? parent.getGeometry() : null;
    if (parent && p && !parent.isCollapsed()) {
      const geo = cell.getGeometry();
      if (geo && !geo.relative && (p.width < geo.x + geo.width || p.height < geo.y + geo.height)) {
        p = p.clone();
        p.width = Math.max(p.width, geo.x + geo.width);
        p.height = Math.max(p.height, geo.y + geo.height);
        this.cellsResized([parent], [p], false);
      }
    }
  },
  // *************************************************************************************
  // Group: Cell moving
  // *************************************************************************************
  importCells(cells, dx, dy, target = null, evt = null, mapping = {}) {
    return this.moveCells(cells, dx, dy, true, target, evt, mapping);
  },
  moveCells(cells, dx = 0, dy = 0, clone2 = false, target = null, evt = null, mapping = {}) {
    if (dx !== 0 || dy !== 0 || clone2 || target) {
      cells = getTopmostCells(cells);
      const origCells = cells;
      this.batchUpdate(() => {
        const dict = new Dictionary();
        for (const cell of cells) {
          dict.put(cell, true);
        }
        const isSelected = (cell) => {
          while (cell) {
            if (dict.get(cell)) {
              return true;
            }
            cell = cell.getParent();
          }
          return false;
        };
        const checked = [];
        for (const cell of cells) {
          const geo = cell.getGeometry();
          const parent = cell.getParent();
          if (!geo || !geo.relative || parent && !parent.isEdge() || parent && !isSelected(parent.getTerminal(true)) && !isSelected(parent.getTerminal(false))) {
            checked.push(cell);
          }
        }
        cells = checked;
        if (clone2) {
          cells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);
          if (!target) {
            target = this.getDefaultParent();
          }
        }
        const previous = this.isAllowNegativeCoordinates();
        if (target) {
          this.setAllowNegativeCoordinates(true);
        }
        this.cellsMoved(cells, dx, dy, !clone2 && this.isDisconnectOnMove() && this.isAllowDanglingEdges(), !target, this.isExtendParentsOnMove() && !target);
        this.setAllowNegativeCoordinates(previous);
        if (target) {
          const index = target.getChildCount();
          this.cellsAdded(cells, target, index, null, null, true);
          if (clone2) {
            cells.forEach((cell, i) => {
              const geo = cell.getGeometry();
              const parent = origCells[i].getParent();
              if (geo && geo.relative && parent && parent.isEdge() && this.getDataModel().contains(parent)) {
                this.getDataModel().add(parent, cell);
              }
            });
          }
        }
        this.fireEvent(new EventObject(InternalEvent.MOVE_CELLS, {
          cells,
          dx,
          dy,
          clone: clone2,
          target,
          event: evt
        }));
      });
    }
    return cells;
  },
  cellsMoved(cells, dx, dy, disconnect = false, constrain = false, extend = false) {
    if (dx !== 0 || dy !== 0) {
      this.batchUpdate(() => {
        if (disconnect) {
          this.disconnectGraph(cells);
        }
        for (const cell of cells) {
          this.translateCell(cell, dx, dy);
          if (extend && this.isExtendParent(cell)) {
            this.extendParent(cell);
          } else if (constrain) {
            this.constrainChild(cell);
          }
        }
        if (this.isResetEdgesOnMove()) {
          this.resetEdges(cells);
        }
        this.fireEvent(new EventObject(InternalEvent.CELLS_MOVED, { cells, dx, dy, disconnect }));
      });
    }
  },
  translateCell(cell, dx, dy) {
    let geometry = cell.getGeometry();
    if (geometry) {
      geometry = geometry.clone();
      geometry.translate(dx, dy);
      if (!geometry.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {
        geometry.x = Math.max(0, geometry.x);
        geometry.y = Math.max(0, geometry.y);
      }
      if (geometry.relative && !cell.isEdge()) {
        const parent = cell.getParent();
        let angle = 0;
        if (parent.isVertex()) {
          const style = this.getCurrentCellStyle(parent);
          angle = style.rotation ?? 0;
        }
        if (angle !== 0) {
          const rad = toRadians(-angle);
          const cos = Math.cos(rad);
          const sin = Math.sin(rad);
          const pt = getRotatedPoint(new Point(dx, dy), cos, sin, new Point(0, 0));
          dx = pt.x;
          dy = pt.y;
        }
        if (!geometry.offset) {
          geometry.offset = new Point(dx, dy);
        } else {
          geometry.offset.x = geometry.offset.x + dx;
          geometry.offset.y = geometry.offset.y + dy;
        }
      }
      this.getDataModel().setGeometry(cell, geometry);
    }
  },
  getCellContainmentArea(cell) {
    if (!cell.isEdge()) {
      const parent = cell.getParent();
      if (parent && parent !== this.getDefaultParent()) {
        const g = parent.getGeometry();
        if (g) {
          let x = 0;
          let y = 0;
          let w = g.width;
          let h = g.height;
          if (this.isSwimlane(parent)) {
            const size = this.getStartSize(parent);
            const style = this.getCurrentCellStyle(parent);
            const dir = style.direction ?? DIRECTION.EAST;
            const flipH = style.flipH ?? false;
            const flipV = style.flipV ?? false;
            if (dir === DIRECTION.SOUTH || dir === DIRECTION.NORTH) {
              const tmp = size.width;
              size.width = size.height;
              size.height = tmp;
            }
            if (dir === DIRECTION.EAST && !flipV || dir === DIRECTION.NORTH && !flipH || dir === DIRECTION.WEST && flipV || dir === DIRECTION.SOUTH && flipH) {
              x = size.width;
              y = size.height;
            }
            w -= size.width;
            h -= size.height;
          }
          return new Rectangle(x, y, w, h);
        }
      }
    }
    return null;
  },
  constrainChild(cell, sizeFirst = true) {
    let geo = cell.getGeometry();
    if (geo && (this.isConstrainRelativeChildren() || !geo.relative)) {
      const parent = cell.getParent();
      let max = this.getMaximumGraphBounds();
      if (max && parent) {
        const off = this.getBoundingBoxFromGeometry([parent], false);
        if (off) {
          max = Rectangle.fromRectangle(max);
          max.x -= off.x;
          max.y -= off.y;
        }
      }
      if (this.isConstrainChild(cell)) {
        let tmp = this.getCellContainmentArea(cell);
        if (tmp) {
          const overlap = this.getOverlap(cell);
          if (overlap > 0) {
            tmp = Rectangle.fromRectangle(tmp);
            tmp.x -= tmp.width * overlap;
            tmp.y -= tmp.height * overlap;
            tmp.width += 2 * tmp.width * overlap;
            tmp.height += 2 * tmp.height * overlap;
          }
          if (!max) {
            max = tmp;
          } else {
            max = Rectangle.fromRectangle(max);
            max.intersect(tmp);
          }
        }
      }
      if (max) {
        const cells = [cell];
        if (!cell.isCollapsed()) {
          const desc = cell.getDescendants();
          for (const descItem of desc) {
            if (descItem.isVisible()) {
              cells.push(descItem);
            }
          }
        }
        const bbox = this.getBoundingBoxFromGeometry(cells, false);
        if (bbox) {
          geo = geo.clone();
          let dx = 0;
          if (geo.width > max.width) {
            dx = geo.width - max.width;
            geo.width -= dx;
          }
          if (bbox.x + bbox.width > max.x + max.width) {
            dx -= bbox.x + bbox.width - max.x - max.width - dx;
          }
          let dy = 0;
          if (geo.height > max.height) {
            dy = geo.height - max.height;
            geo.height -= dy;
          }
          if (bbox.y + bbox.height > max.y + max.height) {
            dy -= bbox.y + bbox.height - max.y - max.height - dy;
          }
          if (bbox.x < max.x) {
            dx -= bbox.x - max.x;
          }
          if (bbox.y < max.y) {
            dy -= bbox.y - max.y;
          }
          if (dx !== 0 || dy !== 0) {
            if (geo.relative) {
              if (!geo.offset) {
                geo.offset = new Point();
              }
              geo.offset.x += dx;
              geo.offset.y += dy;
            } else {
              geo.x += dx;
              geo.y += dy;
            }
          }
          this.getDataModel().setGeometry(cell, geo);
        }
      }
    }
  },
  /*****************************************************************************
   * Group: Cell retrieval
   *****************************************************************************/
  getChildCells(parent, vertices = false, edges = false) {
    parent = parent ?? this.getDefaultParent();
    const cells = parent.getChildCells(vertices, edges);
    const result = [];
    for (const cell of cells) {
      if (cell.isVisible()) {
        result.push(cell);
      }
    }
    return result;
  },
  getCellAt(x, y, parent = null, vertices = true, edges = true, ignoreFn = null) {
    if (!parent) {
      parent = this.getCurrentRoot();
      if (!parent) {
        parent = this.getDataModel().getRoot();
      }
    }
    if (parent) {
      const childCount = parent.getChildCount();
      for (let i = childCount - 1; i >= 0; i--) {
        const cell = parent.getChildAt(i);
        const result = this.getCellAt(x, y, cell, vertices, edges, ignoreFn);
        if (result) {
          return result;
        }
        if (cell.isVisible() && (edges && cell.isEdge() || vertices && cell.isVertex())) {
          const state = this.getView().getState(cell);
          if (state && (!ignoreFn || !ignoreFn(state, x, y)) && this.intersects(state, x, y)) {
            return cell;
          }
        }
      }
    }
    return null;
  },
  getCells(x, y, width, height, parent = null, result = [], intersection2 = null, ignoreFn = null, includeDescendants = false) {
    if (width > 0 || height > 0 || intersection2) {
      const model = this.getDataModel();
      const right = x + width;
      const bottom = y + height;
      if (!parent) {
        parent = this.getCurrentRoot();
        if (!parent) {
          parent = model.getRoot();
        }
      }
      if (parent) {
        for (const cell of parent.getChildren()) {
          const state = this.getView().getState(cell);
          if (state && cell.isVisible() && (!ignoreFn || !ignoreFn(state))) {
            const deg = state.style.rotation ?? 0;
            let box = state;
            if (deg !== 0) {
              box = getBoundingBox(box, deg);
            }
            const hit = intersection2 && cell.isVertex() && intersects$1(intersection2, box) || !intersection2 && (cell.isEdge() || cell.isVertex()) && box.x >= x && box.y + box.height <= bottom && box.y >= y && box.x + box.width <= right;
            if (hit) {
              result.push(cell);
            }
            if (!hit || includeDescendants) {
              this.getCells(x, y, width, height, cell, result, intersection2, ignoreFn, includeDescendants);
            }
          }
        }
      }
    }
    return result;
  },
  getCellsBeyond(x0, y0, parent = null, rightHalfpane = false, bottomHalfpane = false) {
    const result = [];
    if (rightHalfpane || bottomHalfpane) {
      if (!parent) {
        parent = this.getDefaultParent();
      }
      if (parent) {
        for (const child of parent.getChildren()) {
          const state = this.getView().getState(child);
          if (child.isVisible() && state) {
            if ((!rightHalfpane || state.x >= x0) && (!bottomHalfpane || state.y >= y0)) {
              result.push(child);
            }
          }
        }
      }
    }
    return result;
  },
  intersects(state, x, y) {
    const pts = state.absolutePoints;
    if (pts.length > 0) {
      const t2 = this.getEventTolerance() * this.getEventTolerance();
      let pt = pts[0];
      for (let i = 1; i < pts.length; i += 1) {
        const next = pts[i];
        if (pt && next) {
          const dist = ptSegDistSq(pt.x, pt.y, next.x, next.y, x, y);
          if (dist <= t2) {
            return true;
          }
        }
        pt = next;
      }
    } else {
      const alpha = toRadians(state.style.rotation ?? 0);
      if (alpha !== 0) {
        const cos = Math.cos(-alpha);
        const sin = Math.sin(-alpha);
        const cx = new Point(state.getCenterX(), state.getCenterY());
        const pt = getRotatedPoint(new Point(x, y), cos, sin, cx);
        x = pt.x;
        y = pt.y;
      }
      if (contains(state, x, y)) {
        return true;
      }
    }
    return false;
  },
  isValidAncestor(cell, parent, recurse = false) {
    return recurse ? parent.isAncestor(cell) : (cell == null ? void 0 : cell.getParent()) === parent;
  },
  /*****************************************************************************
   * Group: Graph behaviour
   *****************************************************************************/
  isCellLocked(cell) {
    const geometry = cell.getGeometry();
    return this.isCellsLocked() || !!geometry && cell.isVertex() && geometry.relative;
  },
  isCellsLocked() {
    return this.cellsLocked;
  },
  setCellsLocked(value) {
    this.cellsLocked = value;
  },
  getCloneableCells(cells) {
    return this.getDataModel().filterCells(cells, (cell) => {
      return this.isCellCloneable(cell);
    });
  },
  isCellCloneable(cell) {
    return this.isCellsCloneable() && (this.getCurrentCellStyle(cell).cloneable ?? true);
  },
  isCellsCloneable() {
    return this.cellsCloneable;
  },
  setCellsCloneable(value) {
    this.cellsCloneable = value;
  },
  getExportableCells(cells) {
    return this.getDataModel().filterCells(cells, (cell) => {
      return this.canExportCell(cell);
    });
  },
  canExportCell(_cell = null) {
    return this.isExportEnabled();
  },
  getImportableCells(cells) {
    return this.getDataModel().filterCells(cells, (cell) => {
      return this.canImportCell(cell);
    });
  },
  canImportCell(cell = null) {
    return this.isImportEnabled();
  },
  isCellSelectable(_cell) {
    return this.isCellsSelectable();
  },
  isCellsSelectable() {
    return this.cellsSelectable;
  },
  setCellsSelectable(value) {
    this.cellsSelectable = value;
  },
  getDeletableCells(cells) {
    return this.getDataModel().filterCells(cells, (cell) => {
      return this.isCellDeletable(cell);
    });
  },
  isCellDeletable(cell) {
    return this.isCellsDeletable() && (this.getCurrentCellStyle(cell).deletable ?? true);
  },
  isCellsDeletable() {
    return this.cellsDeletable;
  },
  setCellsDeletable(value) {
    this.cellsDeletable = value;
  },
  isCellRotatable(cell) {
    return this.getCurrentCellStyle(cell).rotatable ?? true;
  },
  getMovableCells(cells) {
    return this.getDataModel().filterCells(cells, (cell) => {
      return this.isCellMovable(cell);
    });
  },
  isCellMovable(cell) {
    return this.isCellsMovable() && !this.isCellLocked(cell) && (this.getCurrentCellStyle(cell).movable ?? true);
  },
  isCellsMovable() {
    return this.cellsMovable;
  },
  setCellsMovable(value) {
    this.cellsMovable = value;
  },
  isCellResizable(cell) {
    return this.isCellsResizable() && !this.isCellLocked(cell) && (this.getCurrentCellStyle(cell).resizable ?? true);
  },
  isCellsResizable() {
    return this.cellsResizable;
  },
  setCellsResizable(value) {
    this.cellsResizable = value;
  },
  isCellBendable(cell) {
    return this.isCellsBendable() && !this.isCellLocked(cell) && (this.getCurrentCellStyle(cell).bendable ?? true);
  },
  isCellsBendable() {
    return this.cellsBendable;
  },
  setCellsBendable(value) {
    this.cellsBendable = value;
  },
  isAutoSizeCell(cell) {
    return this.isAutoSizeCells() || (this.getCurrentCellStyle(cell).autoSize ?? false);
  },
  isAutoSizeCells() {
    return this.autoSizeCells;
  },
  setAutoSizeCells(value) {
    this.autoSizeCells = value;
  },
  isExtendParent(cell) {
    return !cell.isEdge() && this.isExtendParents();
  },
  isExtendParents() {
    return this.extendParents;
  },
  setExtendParents(value) {
    this.extendParents = value;
  },
  isExtendParentsOnAdd(cell) {
    return this.extendParentsOnAdd;
  },
  setExtendParentsOnAdd(value) {
    this.extendParentsOnAdd = value;
  },
  isExtendParentsOnMove() {
    return this.extendParentsOnMove;
  },
  setExtendParentsOnMove(value) {
    this.extendParentsOnMove = value;
  },
  /*****************************************************************************
   * Group: Graph appearance
   *****************************************************************************/
  getCursorForCell(_cell) {
    return null;
  },
  /*****************************************************************************
   * Group: Graph display
   *****************************************************************************/
  getCellBounds(cell, includeEdges = false, includeDescendants = false) {
    let cells = [cell];
    if (includeEdges) {
      cells = cells.concat(cell.getEdges());
    }
    let result = this.getView().getBounds(cells);
    if (includeDescendants) {
      for (const child of cell.getChildren()) {
        const tmp = this.getCellBounds(child, includeEdges, true);
        if (result && tmp) {
          result.add(tmp);
        } else {
          result = tmp;
        }
      }
    }
    return result;
  },
  getBoundingBoxFromGeometry(cells, includeEdges = false) {
    let result = null;
    let tmp = null;
    for (const cell of cells) {
      if (includeEdges || cell.isVertex()) {
        const geo = cell.getGeometry();
        if (geo) {
          let bbox = null;
          if (cell.isEdge()) {
            const addPoint = (pt) => {
              if (pt) {
                if (!tmp) {
                  tmp = new Rectangle(pt.x, pt.y, 0, 0);
                } else {
                  tmp.add(new Rectangle(pt.x, pt.y, 0, 0));
                }
              }
            };
            if (!cell.getTerminal(true)) {
              addPoint(geo.getTerminalPoint(true));
            }
            if (!cell.getTerminal(false)) {
              addPoint(geo.getTerminalPoint(false));
            }
            const pts = geo.points;
            if (pts && pts.length > 0) {
              tmp = new Rectangle(pts[0].x, pts[0].y, 0, 0);
              for (let j = 1; j < pts.length; j++) {
                addPoint(pts[j]);
              }
            }
            bbox = tmp;
          } else {
            const parent = cell.getParent();
            if (geo.relative && parent) {
              if (parent.isVertex() && parent !== this.getView().currentRoot) {
                tmp = this.getBoundingBoxFromGeometry([parent], false);
                if (tmp) {
                  bbox = new Rectangle(geo.x * tmp.width, geo.y * tmp.height, geo.width, geo.height);
                  if (cells.indexOf(parent) >= 0) {
                    bbox.x += tmp.x;
                    bbox.y += tmp.y;
                  }
                }
              }
            } else {
              bbox = Rectangle.fromRectangle(geo);
              if (parent && parent.isVertex() && cells.indexOf(parent) >= 0) {
                tmp = this.getBoundingBoxFromGeometry([parent], false);
                if (tmp) {
                  bbox.x += tmp.x;
                  bbox.y += tmp.y;
                }
              }
            }
            if (bbox && geo.offset) {
              bbox.x += geo.offset.x;
              bbox.y += geo.offset.y;
            }
            const style = this.getCurrentCellStyle(cell);
            if (bbox) {
              const angle = style.rotation ?? 0;
              if (angle !== 0) {
                bbox = getBoundingBox(bbox, angle);
              }
            }
          }
          if (bbox) {
            if (!result) {
              result = Rectangle.fromRectangle(bbox);
            } else {
              result.add(bbox);
            }
          }
        }
      }
    }
    return result;
  }
};
const ConnectionsMixin = {
  /*****************************************************************************
   * Group: Cell connecting and connection constraints
   *****************************************************************************/
  constrainChildren: true,
  constrainRelativeChildren: false,
  disconnectOnMove: true,
  cellsDisconnectable: true,
  getOutlineConstraint(point, terminalState, me) {
    if (terminalState.shape) {
      const bounds = this.getView().getPerimeterBounds(terminalState);
      const direction = terminalState.style.direction;
      if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {
        bounds.x += bounds.width / 2 - bounds.height / 2;
        bounds.y += bounds.height / 2 - bounds.width / 2;
        const tmp = bounds.width;
        bounds.width = bounds.height;
        bounds.height = tmp;
      }
      const alpha = toRadians(terminalState.shape.getShapeRotation());
      if (alpha !== 0) {
        const cos = Math.cos(-alpha);
        const sin = Math.sin(-alpha);
        const ct = new Point(bounds.getCenterX(), bounds.getCenterY());
        point = getRotatedPoint(point, cos, sin, ct);
      }
      let sx = 1;
      let sy = 1;
      let dx = 0;
      let dy = 0;
      if (terminalState.cell.isVertex()) {
        let flipH = terminalState.style.flipH;
        let flipV = terminalState.style.flipV;
        if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {
          const tmp = flipH;
          flipH = flipV;
          flipV = tmp;
        }
        if (flipH) {
          sx = -1;
          dx = -bounds.width;
        }
        if (flipV) {
          sy = -1;
          dy = -bounds.height;
        }
      }
      point = new Point((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);
      const x = bounds.width === 0 ? 0 : Math.round((point.x - bounds.x) * 1e3 / bounds.width) / 1e3;
      const y = bounds.height === 0 ? 0 : Math.round((point.y - bounds.y) * 1e3 / bounds.height) / 1e3;
      return new ConnectionConstraint(new Point(x, y), false);
    }
    return null;
  },
  getAllConnectionConstraints(terminal, source) {
    var _a, _b;
    return ((_b = (_a = terminal == null ? void 0 : terminal.shape) == null ? void 0 : _a.stencil) == null ? void 0 : _b.constraints) ?? null;
  },
  getConnectionConstraint(edge, terminal, source = false) {
    let point = null;
    const x = edge.style[source ? "exitX" : "entryX"];
    if (x !== void 0) {
      const y = edge.style[source ? "exitY" : "entryY"];
      if (y !== void 0) {
        point = new Point(x, y);
      }
    }
    let perimeter = false;
    let dx = 0;
    let dy = 0;
    if (point) {
      perimeter = edge.style[source ? "exitPerimeter" : "entryPerimeter"] || false;
      dx = edge.style[source ? "exitDx" : "entryDx"];
      dy = edge.style[source ? "exitDy" : "entryDy"];
      dx = Number.isFinite(dx) ? dx : 0;
      dy = Number.isFinite(dy) ? dy : 0;
    }
    return new ConnectionConstraint(point, perimeter, null, dx, dy);
  },
  setConnectionConstraint(edge, terminal, source = false, constraint = null) {
    if (constraint) {
      this.batchUpdate(() => {
        if (!constraint || !constraint.point) {
          this.setCellStyles(source ? "exitX" : "entryX", null, [edge]);
          this.setCellStyles(source ? "exitY" : "entryY", null, [edge]);
          this.setCellStyles(source ? "exitDx" : "entryDx", null, [edge]);
          this.setCellStyles(source ? "exitDy" : "entryDy", null, [edge]);
          this.setCellStyles(source ? "exitPerimeter" : "entryPerimeter", null, [edge]);
        } else if (constraint.point) {
          this.setCellStyles(source ? "exitX" : "entryX", constraint.point.x, [edge]);
          this.setCellStyles(source ? "exitY" : "entryY", constraint.point.y, [edge]);
          this.setCellStyles(source ? "exitDx" : "entryDx", constraint.dx, [edge]);
          this.setCellStyles(source ? "exitDy" : "entryDy", constraint.dy, [edge]);
          if (!constraint.perimeter) {
            this.setCellStyles(source ? "exitPerimeter" : "entryPerimeter", "0", [edge]);
          } else {
            this.setCellStyles(source ? "exitPerimeter" : "entryPerimeter", null, [edge]);
          }
        }
      });
    }
  },
  getConnectionPoint(vertex, constraint, round = true) {
    let point = null;
    if (constraint.point) {
      const bounds = this.getView().getPerimeterBounds(vertex);
      const cx = new Point(bounds.getCenterX(), bounds.getCenterY());
      const direction = vertex.style.direction;
      let r1 = 0;
      if (vertex.style.anchorPointDirection) {
        if (direction === DIRECTION.NORTH) {
          r1 += 270;
        } else if (direction === DIRECTION.WEST) {
          r1 += 180;
        } else if (direction === DIRECTION.SOUTH) {
          r1 += 90;
        }
        if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {
          bounds.rotate90();
        }
      }
      const { scale } = this.getView();
      point = new Point(bounds.x + constraint.point.x * bounds.width + constraint.dx * scale, bounds.y + constraint.point.y * bounds.height + constraint.dy * scale);
      let r2 = vertex.style.rotation || 0;
      if (constraint.perimeter) {
        if (r1 !== 0) {
          let cos = 0;
          let sin = 0;
          if (r1 === 90) {
            sin = 1;
          } else if (r1 === 180) {
            cos = -1;
          } else if (r1 === 270) {
            sin = -1;
          }
          point = getRotatedPoint(point, cos, sin, cx);
        }
        point = this.getView().getPerimeterPoint(vertex, point, false);
      } else {
        r2 += r1;
        if (vertex.cell.isVertex()) {
          let flipH = vertex.style.flipH;
          let flipV = vertex.style.flipV;
          if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {
            const temp = flipH;
            flipH = flipV;
            flipV = temp;
          }
          if (flipH) {
            point.x = 2 * bounds.getCenterX() - point.x;
          }
          if (flipV) {
            point.y = 2 * bounds.getCenterY() - point.y;
          }
        }
      }
      if (r2 !== 0 && point) {
        const rad = toRadians(r2);
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        point = getRotatedPoint(point, cos, sin, cx);
      }
    }
    if (round && point) {
      point.x = Math.round(point.x);
      point.y = Math.round(point.y);
    }
    return point;
  },
  connectCell(edge, terminal = null, source = false, constraint = null) {
    this.batchUpdate(() => {
      const previous = edge.getTerminal(source);
      this.cellConnected(edge, terminal, source, constraint);
      this.fireEvent(new EventObject(InternalEvent.CONNECT_CELL, "edge", edge, "terminal", terminal, "source", source, "previous", previous));
    });
    return edge;
  },
  cellConnected(edge, terminal, source = false, constraint = null) {
    this.batchUpdate(() => {
      const previous = edge.getTerminal(source);
      this.setConnectionConstraint(edge, terminal, source, constraint);
      if (this.isPortsEnabled()) {
        let id = null;
        if (terminal && this.isPort(terminal)) {
          id = terminal.getId();
          terminal = this.getTerminalForPort(terminal, source);
        }
        const key = source ? "sourcePort" : "targetPort";
        this.setCellStyles(key, id, [edge]);
      }
      this.getDataModel().setTerminal(edge, terminal, source);
      if (this.isResetEdgesOnConnect()) {
        this.resetEdge(edge);
      }
      this.fireEvent(new EventObject(InternalEvent.CELL_CONNECTED, "edge", edge, "terminal", terminal, "source", source, "previous", previous));
    });
  },
  disconnectGraph(cells) {
    this.batchUpdate(() => {
      const { scale, translate: tr } = this.getView();
      const dict = new Dictionary();
      for (let i = 0; i < cells.length; i += 1) {
        dict.put(cells[i], true);
      }
      for (const cell of cells) {
        if (cell.isEdge()) {
          let geo = cell.getGeometry();
          if (geo) {
            const state = this.getView().getState(cell);
            const parent = cell.getParent();
            const pstate = parent ? this.getView().getState(parent) : null;
            if (state && pstate) {
              geo = geo.clone();
              const dx = -pstate.origin.x;
              const dy = -pstate.origin.y;
              const pts = state.absolutePoints;
              let src = cell.getTerminal(true);
              if (src && this.isCellDisconnectable(cell, src, true)) {
                while (src && !dict.get(src)) {
                  src = src.getParent();
                }
                if (!src && pts[0]) {
                  geo.setTerminalPoint(new Point(pts[0].x / scale - tr.x + dx, pts[0].y / scale - tr.y + dy), true);
                  this.getDataModel().setTerminal(cell, null, true);
                }
              }
              let trg = cell.getTerminal(false);
              if (trg && this.isCellDisconnectable(cell, trg, false)) {
                while (trg && !dict.get(trg)) {
                  trg = trg.getParent();
                }
                if (!trg) {
                  const n = pts.length - 1;
                  const p = pts[n];
                  if (p) {
                    geo.setTerminalPoint(new Point(p.x / scale - tr.x + dx, p.y / scale - tr.y + dy), false);
                    this.getDataModel().setTerminal(cell, null, false);
                  }
                }
              }
              this.getDataModel().setGeometry(cell, geo);
            }
          }
        }
      }
    });
  },
  getConnections(cell, parent = null) {
    return this.getEdges(cell, parent, true, true, false);
  },
  isConstrainChild(cell) {
    return this.isConstrainChildren() && !!cell.getParent() && !cell.getParent().isEdge();
  },
  isConstrainChildren() {
    return this.constrainChildren;
  },
  setConstrainChildren(value) {
    this.constrainChildren = value;
  },
  isConstrainRelativeChildren() {
    return this.constrainRelativeChildren;
  },
  setConstrainRelativeChildren(value) {
    this.constrainRelativeChildren = value;
  },
  /*****************************************************************************
   * Group: Graph behaviour
   *****************************************************************************/
  isDisconnectOnMove() {
    return this.disconnectOnMove;
  },
  setDisconnectOnMove(value) {
    this.disconnectOnMove = value;
  },
  isCellDisconnectable(cell, terminal = null, source = false) {
    return this.isCellsDisconnectable() && !this.isCellLocked(cell);
  },
  isCellsDisconnectable() {
    return this.cellsDisconnectable;
  },
  setCellsDisconnectable(value) {
    this.cellsDisconnectable = value;
  },
  isValidSource(cell) {
    return cell == null && this.isAllowDanglingEdges() || cell != null && (!cell.isEdge() || this.isConnectableEdges()) && cell.isConnectable();
  },
  isValidTarget(cell) {
    return this.isValidSource(cell);
  },
  isValidConnection(source, target) {
    return this.isValidSource(source) && this.isValidTarget(target);
  },
  setConnectable(connectable) {
    const connectionHandler = this.getPlugin("ConnectionHandler");
    connectionHandler == null ? void 0 : connectionHandler.setEnabled(connectable);
  },
  isConnectable() {
    const connectionHandler = this.getPlugin("ConnectionHandler");
    return (connectionHandler == null ? void 0 : connectionHandler.isEnabled()) ?? false;
  }
};
const DragDropMixin = {
  dropEnabled: false,
  splitEnabled: true,
  autoScroll: true,
  isAutoScroll() {
    return this.autoScroll;
  },
  autoExtend: true,
  isAutoExtend() {
    return this.autoExtend;
  },
  /*****************************************************************************
   * Group: Graph behaviour
   *****************************************************************************/
  isDropEnabled() {
    return this.dropEnabled;
  },
  setDropEnabled(value) {
    this.dropEnabled = value;
  },
  /*****************************************************************************
   * Group: Split behaviour
   *****************************************************************************/
  isSplitEnabled() {
    return this.splitEnabled;
  },
  setSplitEnabled(value) {
    this.splitEnabled = value;
  },
  isSplitTarget(target, cells = [], evt) {
    if (target.isEdge() && cells.length === 1 && cells[0].isConnectable() && !this.getEdgeValidationError(target, target.getTerminal(true), cells[0])) {
      const src = target.getTerminal(true);
      const trg = target.getTerminal(false);
      return !cells[0].isAncestor(src) && !cells[0].isAncestor(trg);
    }
    return false;
  }
};
const EdgeMixin = {
  resetEdgesOnResize: false,
  isResetEdgesOnResize() {
    return this.resetEdgesOnResize;
  },
  resetEdgesOnMove: false,
  isResetEdgesOnMove() {
    return this.resetEdgesOnMove;
  },
  resetEdgesOnConnect: true,
  isResetEdgesOnConnect() {
    return this.resetEdgesOnConnect;
  },
  connectableEdges: false,
  allowDanglingEdges: true,
  cloneInvalidEdges: false,
  alternateEdgeStyle: {},
  edgeLabelsMovable: true,
  // ***************************************************************************
  // Group: Graph Behaviour
  // ***************************************************************************
  isEdgeLabelsMovable() {
    return this.edgeLabelsMovable;
  },
  setEdgeLabelsMovable(value) {
    this.edgeLabelsMovable = value;
  },
  setAllowDanglingEdges(value) {
    this.allowDanglingEdges = value;
  },
  isAllowDanglingEdges() {
    return this.allowDanglingEdges;
  },
  setConnectableEdges(value) {
    this.connectableEdges = value;
  },
  isConnectableEdges() {
    return this.connectableEdges;
  },
  setCloneInvalidEdges(value) {
    this.cloneInvalidEdges = value;
  },
  isCloneInvalidEdges() {
    return this.cloneInvalidEdges;
  },
  // ***************************************************************************
  // Group: Cell alignment and orientation
  // ***************************************************************************
  flipEdge(edge) {
    if (this.alternateEdgeStyle) {
      this.batchUpdate(() => {
        const style = edge.getStyle();
        if (Object.keys(style).length) {
          this.getDataModel().setStyle(edge, this.alternateEdgeStyle);
        } else {
          this.getDataModel().setStyle(edge, {});
        }
        this.resetEdge(edge);
        this.fireEvent(new EventObject(InternalEvent.FLIP_EDGE, { edge }));
      });
    }
    return edge;
  },
  splitEdge(edge, cells, newEdge, dx = 0, dy = 0, x, y, parent = null) {
    parent = parent ?? edge.getParent();
    const source = edge.getTerminal(true);
    this.batchUpdate(() => {
      if (!newEdge) {
        newEdge = this.cloneCell(edge);
        const state = this.getView().getState(edge);
        let geo = newEdge.getGeometry();
        if (geo && state) {
          const t = this.getView().translate;
          const s = this.getView().scale;
          const idx = findNearestSegment(state, (dx + t.x) * s, (dy + t.y) * s);
          geo.points = geo.points.slice(0, idx);
          geo = edge.getGeometry();
          if (geo) {
            geo = geo.clone();
            geo.points = geo.points.slice(idx);
            this.getDataModel().setGeometry(edge, geo);
          }
        }
      }
      this.cellsMoved(cells, dx, dy, false, false);
      this.cellsAdded(cells, parent, parent ? parent.getChildCount() : 0, null, null, true);
      this.cellsAdded([newEdge], parent, parent ? parent.getChildCount() : 0, source, cells[0], false);
      this.cellConnected(edge, cells[0], true);
      this.fireEvent(new EventObject(InternalEvent.SPLIT_EDGE, { edge, cells, newEdge, dx, dy }));
    });
    return newEdge;
  },
  insertEdge(...args) {
    let parent;
    let id;
    let value;
    let source;
    let target;
    let style;
    if (args.length === 1 && typeof args[0] === "object") {
      const params = args[0];
      parent = params.parent;
      id = params.id;
      value = params.value;
      source = params.source;
      target = params.target;
      style = params.style;
    } else {
      [parent, id, value, source, target, style] = args;
    }
    const edge = this.createEdge(parent, id, value, source, target, style);
    return this.addEdge(edge, parent, source, target);
  },
  createEdge(parent = null, id, value, source = null, target = null, style = {}) {
    const edge = new Cell(value, new Geometry(), style);
    edge.setId(id);
    edge.setEdge(true);
    edge.geometry.relative = true;
    return edge;
  },
  addEdge(edge, parent = null, source = null, target = null, index = null) {
    return this.addCell(edge, parent, index, source, target);
  },
  // ***************************************************************************
  // Group: Folding
  // ***************************************************************************
  addAllEdges(cells) {
    const allCells = cells.slice();
    return removeDuplicates(allCells.concat(this.getAllEdges(cells)));
  },
  getAllEdges(cells) {
    let edges = [];
    if (cells) {
      for (let i = 0; i < cells.length; i += 1) {
        const edgeCount = cells[i].getEdgeCount();
        for (let j = 0; j < edgeCount; j++) {
          edges.push(cells[i].getEdgeAt(j));
        }
        const children = cells[i].getChildren();
        edges = edges.concat(this.getAllEdges(children));
      }
    }
    return edges;
  },
  getIncomingEdges(cell, parent = null) {
    return this.getEdges(cell, parent, true, false, false);
  },
  getOutgoingEdges(cell, parent = null) {
    return this.getEdges(cell, parent, false, true, false);
  },
  getEdges(cell, parent = null, incoming = true, outgoing = true, includeLoops = true, recurse = false) {
    let edges = [];
    const isCollapsed = cell.isCollapsed();
    const childCount = cell.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      const child = cell.getChildAt(i);
      if (isCollapsed || !child.isVisible()) {
        edges = edges.concat(child.getEdges(incoming, outgoing));
      }
    }
    edges = edges.concat(cell.getEdges(incoming, outgoing));
    const result = [];
    for (let i = 0; i < edges.length; i += 1) {
      const state = this.getView().getState(edges[i]);
      const source = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i], true);
      const target = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i], false);
      if (includeLoops && source === target || source !== target && (incoming && target === cell && (!parent || this.isValidAncestor(source, parent, recurse)) || outgoing && source === cell && (!parent || this.isValidAncestor(target, parent, recurse)))) {
        result.push(edges[i]);
      }
    }
    return result;
  },
  // ***************************************************************************
  // Group: Cell retrieval
  // ***************************************************************************
  getChildEdges(parent) {
    return this.getChildCells(parent, false, true);
  },
  getEdgesBetween(source, target, directed = false) {
    const edges = this.getEdges(source);
    const result = [];
    for (let i = 0; i < edges.length; i += 1) {
      const state = this.getView().getState(edges[i]);
      const src = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i], true);
      const trg = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i], false);
      if (src === source && trg === target || !directed && src === target && trg === source) {
        result.push(edges[i]);
      }
    }
    return result;
  },
  // ***************************************************************************
  // Group: Cell moving
  // ***************************************************************************
  resetEdges(cells) {
    const dict = new Dictionary();
    for (let i = 0; i < cells.length; i += 1) {
      dict.put(cells[i], true);
    }
    this.batchUpdate(() => {
      for (let i = 0; i < cells.length; i += 1) {
        const edges = cells[i].getEdges();
        for (let j = 0; j < edges.length; j++) {
          const state = this.getView().getState(edges[j]);
          const source = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[j], true);
          const target = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[j], false);
          if (!dict.get(source) || !dict.get(target)) {
            this.resetEdge(edges[j]);
          }
        }
        this.resetEdges(cells[i].getChildren());
      }
    });
  },
  resetEdge(edge) {
    let geo = edge.getGeometry();
    if (geo && geo.points && geo.points.length > 0) {
      geo = geo.clone();
      geo.points = [];
      this.getDataModel().setGeometry(edge, geo);
    }
    return edge;
  }
};
const EditingMixin = {
  cellsEditable: true,
  /*****************************************************************************
   * Group: Cell in-place editing
   *****************************************************************************/
  startEditing(evt) {
    this.startEditingAtCell(null, evt);
  },
  startEditingAtCell(cell = null, evt) {
    if (!evt || !isMultiTouchEvent(evt)) {
      if (!cell) {
        cell = this.getSelectionCell();
        if (cell && !this.isCellEditable(cell)) {
          cell = null;
        }
      } else {
        this.fireEvent(new EventObject(InternalEvent.START_EDITING, { cell, event: evt }));
        const cellEditorHandler = this.getPlugin("CellEditorHandler");
        cellEditorHandler == null ? void 0 : cellEditorHandler.startEditing(cell, evt);
        this.fireEvent(new EventObject(InternalEvent.EDITING_STARTED, { cell, event: evt }));
      }
    }
  },
  getEditingValue(cell, evt) {
    return this.convertValueToString(cell);
  },
  stopEditing(cancel = false) {
    const cellEditorHandler = this.getPlugin("CellEditorHandler");
    cellEditorHandler == null ? void 0 : cellEditorHandler.stopEditing(cancel);
    this.fireEvent(new EventObject(InternalEvent.EDITING_STOPPED, { cancel }));
  },
  labelChanged(cell, value, evt) {
    this.batchUpdate(() => {
      const old = cell.value;
      this.cellLabelChanged(cell, value, this.isAutoSizeCell(cell));
      this.fireEvent(new EventObject(InternalEvent.LABEL_CHANGED, {
        cell,
        value,
        old,
        event: evt
      }));
    });
    return cell;
  },
  cellLabelChanged(cell, value, autoSize = false) {
    this.batchUpdate(() => {
      this.getDataModel().setValue(cell, value);
      if (autoSize) {
        this.cellSizeUpdated(cell, false);
      }
    });
  },
  /*****************************************************************************
   * Group: Graph behaviour
   *****************************************************************************/
  isEditing(cell = null) {
    const cellEditorHandler = this.getPlugin("CellEditorHandler");
    const editingCell = cellEditorHandler == null ? void 0 : cellEditorHandler.getEditingCell();
    return !cell ? !!editingCell : cell === editingCell;
  },
  isCellEditable(cell) {
    return this.isCellsEditable() && !this.isCellLocked(cell) && (this.getCurrentCellStyle(cell).editable ?? true);
  },
  isCellsEditable() {
    return this.cellsEditable;
  },
  setCellsEditable(value) {
    this.cellsEditable = value;
  }
};
const EventsMixin = {
  // TODO: Document me!
  lastTouchEvent: null,
  doubleClickCounter: 0,
  lastTouchCell: null,
  fireDoubleClick: null,
  tapAndHoldThread: null,
  lastMouseX: null,
  lastMouseY: null,
  isMouseTrigger: null,
  ignoreMouseEvents: null,
  mouseMoveRedirect: null,
  mouseUpRedirect: null,
  lastEvent: null,
  // FIXME: Check if this can be more specific - DOM events or mxEventObjects!
  escapeEnabled: true,
  invokesStopCellEditing: true,
  enterStopsCellEditing: false,
  isMouseDown: false,
  nativeDblClickEnabled: true,
  doubleTapEnabled: true,
  doubleTapTimeout: 500,
  doubleTapTolerance: 25,
  lastTouchX: 0,
  lastTouchY: 0,
  lastTouchTime: 0,
  tapAndHoldEnabled: true,
  tapAndHoldDelay: 500,
  tapAndHoldInProgress: false,
  tapAndHoldValid: false,
  initialTouchX: 0,
  initialTouchY: 0,
  tolerance: 4,
  isNativeDblClickEnabled() {
    return this.nativeDblClickEnabled;
  },
  getEventTolerance() {
    return this.tolerance;
  },
  setEventTolerance(tolerance) {
    this.tolerance = tolerance;
  },
  escape(evt) {
    this.fireEvent(new EventObject(InternalEvent.ESCAPE, { event: evt }));
  },
  click(me) {
    const evt = me.getEvent();
    let cell = me.getCell();
    const mxe = new EventObject(InternalEvent.CLICK, { event: evt, cell });
    if (me.isConsumed()) {
      mxe.consume();
    }
    this.fireEvent(mxe);
    if (this.isEnabled() && !isConsumed(evt) && !mxe.isConsumed()) {
      if (cell) {
        if (this.isTransparentClickEvent(evt)) {
          let active = false;
          const tmp = this.getCellAt(me.graphX, me.graphY, null, false, false, (state) => {
            const selected = this.isCellSelected(state.cell);
            active = active || selected;
            return !active || selected || state.cell !== cell && state.cell.isAncestor(cell);
          });
          if (tmp) {
            cell = tmp;
          }
        }
      } else if (this.isSwimlaneSelectionEnabled()) {
        cell = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());
        if (cell != null && (!this.isToggleEvent(evt) || !isAltDown(evt))) {
          let temp = cell;
          let swimlanes = [];
          while (temp != null) {
            temp = temp.getParent();
            const state = this.getView().getState(temp);
            if (this.isSwimlane(temp) && state != null) {
              swimlanes.push(temp);
            }
          }
          if (swimlanes.length > 0) {
            swimlanes = swimlanes.reverse();
            swimlanes.splice(0, 0, cell);
            swimlanes.push(cell);
            for (let i = 0; i < swimlanes.length - 1; i += 1) {
              if (this.isCellSelected(swimlanes[i])) {
                cell = swimlanes[this.isToggleEvent(evt) ? i : i + 1];
              }
            }
          }
        }
      }
      if (cell) {
        this.selectCellForEvent(cell, evt);
      } else if (!this.isToggleEvent(evt)) {
        this.clearSelection();
      }
    }
    return false;
  },
  dblClick(evt, cell = null) {
    const mxe = new EventObject(InternalEvent.DOUBLE_CLICK, { event: evt, cell });
    this.fireEvent(mxe);
    if (this.isEnabled() && !isConsumed(evt) && !mxe.isConsumed() && cell && this.isCellEditable(cell) && !this.isEditing(cell)) {
      this.startEditingAtCell(cell, evt);
      InternalEvent.consume(evt);
    }
  },
  tapAndHold(me) {
    const evt = me.getEvent();
    const mxe = new EventObject(InternalEvent.TAP_AND_HOLD, {
      event: evt,
      cell: me.getCell()
    });
    const panningHandler = this.getPlugin("PanningHandler");
    const connectionHandler = this.getPlugin("ConnectionHandler");
    this.fireEvent(mxe);
    if (mxe.isConsumed()) {
      panningHandler && (panningHandler.panningTrigger = false);
    }
    if (this.isEnabled() && !isConsumed(evt) && !mxe.isConsumed() && connectionHandler && connectionHandler.isEnabled()) {
      const cell = connectionHandler.marker.getCell(me);
      if (cell) {
        const state = this.getView().getState(cell);
        if (state) {
          connectionHandler.marker.currentColor = connectionHandler.marker.validColor;
          connectionHandler.marker.markedState = state;
          connectionHandler.marker.mark();
          connectionHandler.first = new Point(me.getGraphX(), me.getGraphY());
          connectionHandler.edgeState = connectionHandler.createEdgeState(me);
          connectionHandler.previous = state;
          connectionHandler.fireEvent(new EventObject(InternalEvent.START, { state: connectionHandler.previous }));
        }
      }
    }
  },
  addMouseListener(listener) {
    this.mouseListeners.push(listener);
  },
  removeMouseListener(listener) {
    for (let i = 0; i < this.mouseListeners.length; i += 1) {
      if (this.mouseListeners[i] === listener) {
        this.mouseListeners.splice(i, 1);
        break;
      }
    }
  },
  updateMouseEvent(me, evtName) {
    const pt = convertPoint(this.getContainer(), me.getX(), me.getY());
    me.graphX = pt.x - this.getPanDx();
    me.graphY = pt.y - this.getPanDy();
    if (!me.getCell() && this.isMouseDown && evtName === InternalEvent.MOUSE_MOVE) {
      const cell = this.getCellAt(pt.x, pt.y, null, true, true, (state) => {
        return !state.shape || state.shape.paintBackground !== this.paintBackground || state.style.pointerEvents || state.shape.fill !== NONE;
      });
      me.state = cell ? this.getView().getState(cell) : null;
    }
    return me;
  },
  getStateForTouchEvent(evt) {
    const x = getClientX(evt);
    const y = getClientY(evt);
    const pt = convertPoint(this.getContainer(), x, y);
    const cell = this.getCellAt(pt.x, pt.y);
    return cell ? this.getView().getState(cell) : null;
  },
  isEventIgnored(evtName, me, sender) {
    const mouseEvent = isMouseEvent(me.getEvent());
    let result = false;
    if (me.getEvent() === this.lastEvent) {
      result = true;
    } else {
      this.lastEvent = me.getEvent();
    }
    const eventSource = this.getEventSource();
    if (eventSource && evtName !== InternalEvent.MOUSE_MOVE) {
      InternalEvent.removeGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
      this.mouseMoveRedirect = null;
      this.mouseUpRedirect = null;
      this.setEventSource(null);
    } else if (!Client.IS_GC && eventSource && me.getSource() !== eventSource) {
      result = true;
    } else if (eventSource && Client.IS_TOUCH && evtName === InternalEvent.MOUSE_DOWN && !mouseEvent && !isPenEvent(me.getEvent())) {
      this.setEventSource(me.getSource());
      this.mouseMoveRedirect = (evt) => {
        this.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, this.getStateForTouchEvent(evt)));
      };
      this.mouseUpRedirect = (evt) => {
        this.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, this.getStateForTouchEvent(evt)));
      };
      InternalEvent.addGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
    }
    if (this.isSyntheticEventIgnored(evtName, me, sender)) {
      result = true;
    }
    if (!isPopupTrigger(this.lastEvent) && evtName !== InternalEvent.MOUSE_MOVE && this.lastEvent.detail === 2) {
      return true;
    }
    if (evtName === InternalEvent.MOUSE_UP && this.isMouseDown) {
      this.isMouseDown = false;
    } else if (evtName === InternalEvent.MOUSE_DOWN && !this.isMouseDown) {
      this.isMouseDown = true;
      this.isMouseTrigger = mouseEvent;
    } else if (!result && ((!Client.IS_FF || evtName !== InternalEvent.MOUSE_MOVE) && this.isMouseDown && this.isMouseTrigger !== mouseEvent || evtName === InternalEvent.MOUSE_DOWN && this.isMouseDown || evtName === InternalEvent.MOUSE_UP && !this.isMouseDown)) {
      result = true;
    }
    if (!result && evtName === InternalEvent.MOUSE_DOWN) {
      this.lastMouseX = me.getX();
      this.lastMouseY = me.getY();
    }
    return result;
  },
  isSyntheticEventIgnored(evtName, me, sender) {
    let result = false;
    const mouseEvent = isMouseEvent(me.getEvent());
    if (this.ignoreMouseEvents && mouseEvent && evtName !== InternalEvent.MOUSE_MOVE) {
      this.ignoreMouseEvents = evtName !== InternalEvent.MOUSE_UP;
      result = true;
    } else if (Client.IS_FF && !mouseEvent && evtName === InternalEvent.MOUSE_UP) {
      this.ignoreMouseEvents = true;
    }
    return result;
  },
  isEventSourceIgnored(evtName, me) {
    const source = me.getSource();
    if (!source)
      return true;
    const name = source.nodeName ? source.nodeName.toLowerCase() : "";
    const candidate = !isMouseEvent(me.getEvent()) || isLeftMouseButton(me.getEvent());
    return evtName === InternalEvent.MOUSE_DOWN && candidate && (name === "select" || name === "option" || name === "input" && // @ts-ignore type could exist
    source.type !== "checkbox" && // @ts-ignore type could exist
    source.type !== "radio" && // @ts-ignore type could exist
    source.type !== "button" && // @ts-ignore type could exist
    source.type !== "submit" && // @ts-ignore type could exist
    source.type !== "file");
  },
  getEventState(state) {
    return state;
  },
  fireMouseEvent(evtName, me, sender) {
    sender = sender ?? this;
    if (this.isEventSourceIgnored(evtName, me)) {
      const tooltipHandler = this.getPlugin("TooltipHandler");
      if (tooltipHandler) {
        tooltipHandler.hide();
      }
      return;
    }
    me = this.updateMouseEvent(me, evtName);
    if (!this.nativeDblClickEnabled && !isPopupTrigger(me.getEvent()) || this.doubleTapEnabled && Client.IS_TOUCH && (isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent()))) {
      const currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (evtName === InternalEvent.MOUSE_DOWN) {
        if (this.lastTouchEvent && this.lastTouchEvent !== me.getEvent() && currentTime - this.lastTouchTime < this.doubleTapTimeout && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance && this.doubleClickCounter < 2) {
          this.doubleClickCounter += 1;
          let doubleClickFired = false;
          if (evtName === InternalEvent.MOUSE_UP) {
            if (me.getCell() === this.lastTouchCell && this.lastTouchCell) {
              this.lastTouchTime = 0;
              const cell = this.lastTouchCell;
              this.lastTouchCell = null;
              this.dblClick(me.getEvent(), cell);
              doubleClickFired = true;
            }
          } else {
            this.fireDoubleClick = true;
            this.lastTouchTime = 0;
          }
          if (doubleClickFired) {
            InternalEvent.consume(me.getEvent());
            return;
          }
        } else if (!this.lastTouchEvent || this.lastTouchEvent !== me.getEvent()) {
          this.lastTouchCell = me.getCell();
          this.lastTouchX = me.getX();
          this.lastTouchY = me.getY();
          this.lastTouchTime = currentTime;
          this.lastTouchEvent = me.getEvent();
          this.doubleClickCounter = 0;
        }
      } else if ((this.isMouseDown || evtName === InternalEvent.MOUSE_UP) && this.fireDoubleClick) {
        this.fireDoubleClick = false;
        const cell = this.lastTouchCell;
        this.lastTouchCell = null;
        this.isMouseDown = false;
        const valid = cell || (isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) && (Client.IS_GC || Client.IS_SF);
        if (valid && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {
          this.dblClick(me.getEvent(), cell);
        } else {
          InternalEvent.consume(me.getEvent());
        }
        return;
      }
    }
    if (!this.isEventIgnored(evtName, me, sender)) {
      const state = me.getState();
      me.state = state ? this.getEventState(state) : null;
      this.fireEvent(new EventObject(InternalEvent.FIRE_MOUSE_EVENT, { eventName: evtName, event: me }));
      if (Client.IS_SF || Client.IS_GC || me.getEvent().target !== this.getContainer()) {
        const container = this.getContainer();
        if (evtName === InternalEvent.MOUSE_MOVE && this.isMouseDown && this.isAutoScroll() && !isMultiTouchEvent(me.getEvent())) {
          this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.isAutoExtend());
        } else if (evtName === InternalEvent.MOUSE_UP && this.isIgnoreScrollbars() && this.isTranslateToScrollPosition() && (container.scrollLeft !== 0 || container.scrollTop !== 0)) {
          const s = this.getView().scale;
          const tr = this.getView().translate;
          this.getView().setTranslate(tr.x - container.scrollLeft / s, tr.y - container.scrollTop / s);
          container.scrollLeft = 0;
          container.scrollTop = 0;
        }
        const mouseListeners = this.mouseListeners;
        if (!me.getEvent().preventDefault) {
          me.getEvent().returnValue = true;
        }
        for (const l of mouseListeners) {
          if (evtName === InternalEvent.MOUSE_DOWN) {
            l.mouseDown(sender, me);
          } else if (evtName === InternalEvent.MOUSE_MOVE) {
            l.mouseMove(sender, me);
          } else if (evtName === InternalEvent.MOUSE_UP) {
            l.mouseUp(sender, me);
          }
        }
        if (evtName === InternalEvent.MOUSE_UP) {
          this.click(me);
        }
      }
      if ((isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) && evtName === InternalEvent.MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress) {
        this.tapAndHoldInProgress = true;
        this.initialTouchX = me.getGraphX();
        this.initialTouchY = me.getGraphY();
        const handler = () => {
          if (this.tapAndHoldValid) {
            this.tapAndHold(me);
          }
          this.tapAndHoldInProgress = false;
          this.tapAndHoldValid = false;
        };
        if (this.tapAndHoldThread) {
          window.clearTimeout(this.tapAndHoldThread);
        }
        this.tapAndHoldThread = window.setTimeout(handler, this.tapAndHoldDelay);
        this.tapAndHoldValid = true;
      } else if (evtName === InternalEvent.MOUSE_UP) {
        this.tapAndHoldInProgress = false;
        this.tapAndHoldValid = false;
      } else if (this.tapAndHoldValid) {
        this.tapAndHoldValid = Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance && Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;
      }
      const cellEditorHandler = this.getPlugin("CellEditorHandler");
      if (evtName === InternalEvent.MOUSE_DOWN && this.isEditing() && !(cellEditorHandler == null ? void 0 : cellEditorHandler.isEventSource(me.getEvent()))) {
        this.stopEditing(!this.isInvokesStopCellEditing());
      }
      this.consumeMouseEvent(evtName, me, sender);
    }
  },
  consumeMouseEvent(evtName, me, sender) {
    if (evtName === InternalEvent.MOUSE_DOWN && isTouchEvent(me.getEvent())) {
      me.consume(false);
    }
  },
  fireGestureEvent(evt, cell = null) {
    this.lastTouchTime = 0;
    this.fireEvent(new EventObject(InternalEvent.GESTURE, { event: evt, cell }));
  },
  sizeDidChange() {
    const bounds = this.getGraphBounds();
    const border = this.getBorder();
    let width = Math.max(0, bounds.x) + bounds.width + 2 * border;
    let height = Math.max(0, bounds.y) + bounds.height + 2 * border;
    const minimumContainerSize = this.getMinimumContainerSize();
    if (minimumContainerSize) {
      width = Math.max(width, minimumContainerSize.width);
      height = Math.max(height, minimumContainerSize.height);
    }
    if (this.isResizeContainer()) {
      this.doResizeContainer(width, height);
    }
    if (this.isPreferPageSize() || this.isPageVisible()) {
      const size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));
      width = size.width * this.getView().scale;
      height = size.height * this.getView().scale;
    }
    const minimumGraphSize = this.getMinimumGraphSize();
    if (minimumGraphSize) {
      width = Math.max(width, minimumGraphSize.width * this.getView().scale);
      height = Math.max(height, minimumGraphSize.height * this.getView().scale);
    }
    width = Math.ceil(width);
    height = Math.ceil(height);
    const root = this.getView().getDrawPane().ownerSVGElement;
    if (root) {
      root.style.minWidth = `${Math.max(1, width)}px`;
      root.style.minHeight = `${Math.max(1, height)}px`;
      root.style.width = "100%";
      root.style.height = "100%";
    }
    this.updatePageBreaks(this.isPageBreaksVisible(), width, height);
    this.fireEvent(new EventObject(InternalEvent.SIZE, { bounds }));
  },
  isCloneEvent(evt) {
    return isControlDown(evt);
  },
  isTransparentClickEvent(evt) {
    return false;
  },
  isToggleEvent(evt) {
    return Client.IS_MAC ? isMetaDown(evt) : isControlDown(evt);
  },
  isGridEnabledEvent(evt) {
    return !isAltDown(evt);
  },
  isConstrainedEvent(evt) {
    return isShiftDown(evt);
  },
  isIgnoreTerminalEvent(_evt) {
    return false;
  },
  getPointForEvent(evt, addOffset = true) {
    const p = convertPoint(this.getContainer(), getClientX(evt), getClientY(evt));
    const s = this.getView().scale;
    const tr = this.getView().translate;
    const off = addOffset ? this.getGridSize() / 2 : 0;
    p.x = this.snap(p.x / s - tr.x - off);
    p.y = this.snap(p.y / s - tr.y - off);
    return p;
  },
  isEscapeEnabled() {
    return this.escapeEnabled;
  },
  setEscapeEnabled(value) {
    this.escapeEnabled = value;
  },
  isInvokesStopCellEditing() {
    return this.invokesStopCellEditing;
  },
  setInvokesStopCellEditing(value) {
    this.invokesStopCellEditing = value;
  },
  isEnterStopsCellEditing() {
    return this.enterStopsCellEditing;
  },
  setEnterStopsCellEditing(value) {
    this.enterStopsCellEditing = value;
  },
  getCursorForMouseEvent(me) {
    const cell = me.getCell();
    return cell ? this.getCursorForCell(cell) : null;
  }
};
const FoldingMixin = {
  collapseExpandResource: isI18nEnabled() ? "collapse-expand" : "",
  getCollapseExpandResource() {
    return this.collapseExpandResource;
  },
  isFoldingEnabled() {
    return this.options.foldingEnabled;
  },
  getFoldableCells(cells, collapse = false) {
    return this.getDataModel().filterCells(cells, (cell) => {
      return this.isCellFoldable(cell, collapse);
    });
  },
  isCellFoldable(cell, _collapse) {
    return cell.getChildCount() > 0 && (this.getCurrentCellStyle(cell).foldable ?? true);
  },
  getFoldingImage(state) {
    if (state != null && this.isFoldingEnabled() && !state.cell.isEdge()) {
      const tmp = state.cell.isCollapsed();
      if (this.isCellFoldable(state.cell, !tmp)) {
        return tmp ? this.options.collapsedImage : this.options.expandedImage;
      }
    }
    return null;
  },
  foldCells(collapse = false, recurse = false, cells = null, checkFoldable = false, _evt = null) {
    if (cells == null) {
      cells = this.getFoldableCells(this.getSelectionCells(), collapse);
    }
    this.stopEditing(false);
    this.batchUpdate(() => {
      this.cellsFolded(cells, collapse, recurse, checkFoldable);
      this.fireEvent(new EventObject(InternalEvent.FOLD_CELLS, "collapse", collapse, "recurse", recurse, "cells", cells));
    });
    return cells;
  },
  cellsFolded(cells = null, collapse = false, recurse = false, checkFoldable = false) {
    if (cells != null && cells.length > 0) {
      this.batchUpdate(() => {
        for (let i = 0; i < cells.length; i += 1) {
          if ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) && collapse !== cells[i].isCollapsed()) {
            this.getDataModel().setCollapsed(cells[i], collapse);
            this.swapBounds(cells[i], collapse);
            if (this.isExtendParent(cells[i])) {
              this.extendParent(cells[i]);
            }
            if (recurse) {
              const children = cells[i].getChildren();
              this.cellsFolded(children, collapse, recurse);
            }
            this.constrainChild(cells[i]);
          }
        }
        this.fireEvent(new EventObject(InternalEvent.CELLS_FOLDED, { cells, collapse, recurse }));
      });
    }
  },
  swapBounds(cell, willCollapse = false) {
    let geo = cell.getGeometry();
    if (geo != null) {
      geo = geo.clone();
      this.updateAlternateBounds(cell, geo, willCollapse);
      geo.swap();
      this.getDataModel().setGeometry(cell, geo);
    }
  },
  updateAlternateBounds(cell = null, geo = null, _willCollapse = false) {
    if (cell != null && geo != null) {
      const style = this.getCurrentCellStyle(cell);
      if (geo.alternateBounds == null) {
        let bounds = geo;
        if (this.options.collapseToPreferredSize) {
          const tmp = this.getPreferredSizeForCell(cell);
          if (tmp != null) {
            bounds = tmp;
            const startSize = style.startSize ?? 0;
            if (startSize > 0) {
              bounds.height = Math.max(bounds.height, startSize);
            }
          }
        }
        geo.alternateBounds = new Rectangle(0, 0, bounds.width, bounds.height);
      }
      if (geo.alternateBounds != null) {
        geo.alternateBounds.x = geo.x;
        geo.alternateBounds.y = geo.y;
        const alpha = toRadians(style.rotation || 0);
        if (alpha !== 0) {
          const dx = geo.alternateBounds.getCenterX() - geo.getCenterX();
          const dy = geo.alternateBounds.getCenterY() - geo.getCenterY();
          const cos = Math.cos(alpha);
          const sin = Math.sin(alpha);
          const dx2 = cos * dx - sin * dy;
          const dy2 = sin * dx + cos * dy;
          geo.alternateBounds.x += dx2 - dx;
          geo.alternateBounds.y += dy2 - dy;
        }
      }
    }
  }
};
const GroupingMixin = {
  groupCells(group, border = 0, cells) {
    if (!cells)
      cells = sortCells(this.getSelectionCells(), true);
    if (!cells)
      cells = this.getCellsForGroup(cells);
    if (group == null) {
      group = this.createGroupCell(cells);
    }
    const bounds = this.getBoundsForGroup(group, cells, border);
    if (cells.length > 1 && bounds != null) {
      let parent = group.getParent();
      if (parent == null) {
        parent = cells[0].getParent();
      }
      this.batchUpdate(() => {
        if (group.getGeometry() == null) {
          this.getDataModel().setGeometry(group, new Geometry());
        }
        let index = parent.getChildCount();
        this.cellsAdded([group], parent, index, null, null, false, false, false);
        index = group.getChildCount();
        this.cellsAdded(cells, group, index, null, null, false, false, false);
        this.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);
        this.cellsResized([group], [bounds], false);
        this.fireEvent(new EventObject(InternalEvent.GROUP_CELLS, { group, border, cells }));
      });
    }
    return group;
  },
  getCellsForGroup(cells) {
    const result = [];
    if (cells != null && cells.length > 0) {
      const parent = cells[0].getParent();
      result.push(cells[0]);
      for (let i = 1; i < cells.length; i += 1) {
        if (cells[i].getParent() === parent) {
          result.push(cells[i]);
        }
      }
    }
    return result;
  },
  getBoundsForGroup(group, children, border) {
    const result = this.getBoundingBoxFromGeometry(children, true);
    if (result != null) {
      if (this.isSwimlane(group)) {
        const size = this.getStartSize(group);
        result.x -= size.width;
        result.y -= size.height;
        result.width += size.width;
        result.height += size.height;
      }
      if (border != null) {
        result.x -= border;
        result.y -= border;
        result.width += 2 * border;
        result.height += 2 * border;
      }
    }
    return result;
  },
  createGroupCell(cells) {
    const group = new Cell("");
    group.setVertex(true);
    group.setConnectable(false);
    return group;
  },
  ungroupCells(cells) {
    let result = [];
    if (cells == null) {
      cells = this.getCellsForUngroup();
    }
    if (cells != null && cells.length > 0) {
      this.batchUpdate(() => {
        const _cells = cells;
        for (let i = 0; i < _cells.length; i += 1) {
          let children = _cells[i].getChildren();
          if (children != null && children.length > 0) {
            children = children.slice();
            const parent = _cells[i].getParent();
            const index = parent.getChildCount();
            this.cellsAdded(children, parent, index, null, null, true);
            result = result.concat(children);
            for (const child of children) {
              const state = this.getView().getState(child);
              let geo = child.getGeometry();
              if (state != null && geo != null && geo.relative) {
                geo = geo.clone();
                geo.x = state.origin.x;
                geo.y = state.origin.y;
                geo.relative = false;
                this.getDataModel().setGeometry(child, geo);
              }
            }
          }
        }
        this.removeCellsAfterUngroup(_cells);
        this.fireEvent(new EventObject(InternalEvent.UNGROUP_CELLS, { cells }));
      });
    }
    return result;
  },
  getCellsForUngroup() {
    const cells = this.getSelectionCells();
    const tmp = [];
    for (let i = 0; i < cells.length; i += 1) {
      if (cells[i].isVertex() && cells[i].getChildCount() > 0) {
        tmp.push(cells[i]);
      }
    }
    return tmp;
  },
  removeCellsAfterUngroup(cells) {
    this.cellsRemoved(this.addAllEdges(cells));
  },
  removeCellsFromParent(cells) {
    if (cells == null) {
      cells = this.getSelectionCells();
    }
    this.batchUpdate(() => {
      const parent = this.getDefaultParent();
      const index = parent.getChildCount();
      this.cellsAdded(cells, parent, index, null, null, true);
      this.fireEvent(new EventObject(InternalEvent.REMOVE_CELLS_FROM_PARENT, { cells }));
    });
    return cells;
  },
  updateGroupBounds(cells, border = 0, moveGroup = false, topBorder = 0, rightBorder = 0, bottomBorder = 0, leftBorder = 0) {
    if (cells == null) {
      cells = this.getSelectionCells();
    }
    border = border != null ? border : 0;
    moveGroup = moveGroup != null ? moveGroup : false;
    topBorder = topBorder != null ? topBorder : 0;
    rightBorder = rightBorder != null ? rightBorder : 0;
    bottomBorder = bottomBorder != null ? bottomBorder : 0;
    leftBorder = leftBorder != null ? leftBorder : 0;
    this.batchUpdate(() => {
      for (let i = cells.length - 1; i >= 0; i--) {
        let geo = cells[i].getGeometry();
        if (geo == null) {
          continue;
        }
        const children = this.getChildCells(cells[i]);
        if (children != null && children.length > 0) {
          const bounds = this.getBoundingBoxFromGeometry(children, true);
          if (bounds != null && bounds.width > 0 && bounds.height > 0) {
            const size = this.isSwimlane(cells[i]) ? this.getActualStartSize(cells[i], true) : new Rectangle();
            geo = geo.clone();
            if (moveGroup) {
              geo.x = Math.round(geo.x + bounds.x - border - size.x - leftBorder);
              geo.y = Math.round(geo.y + bounds.y - border - size.y - topBorder);
            }
            geo.width = Math.round(bounds.width + 2 * border + size.x + leftBorder + rightBorder + size.width);
            geo.height = Math.round(bounds.height + 2 * border + size.y + topBorder + bottomBorder + size.height);
            this.getDataModel().setGeometry(cells[i], geo);
            this.moveCells(children, border + size.x - bounds.x + leftBorder, border + size.y - bounds.y + topBorder);
          }
        }
      }
    });
    return cells;
  },
  /*****************************************************************************
   * Group: Drilldown
   *****************************************************************************/
  enterGroup(cell) {
    cell = cell || this.getSelectionCell();
    if (cell != null && this.isValidRoot(cell)) {
      this.getView().setCurrentRoot(cell);
      this.clearSelection();
    }
  },
  exitGroup() {
    const root = this.getDataModel().getRoot();
    const current = this.getCurrentRoot();
    if (current != null) {
      let next = current.getParent();
      while (next !== root && !this.isValidRoot(next) && next.getParent() !== root) {
        next = next.getParent();
      }
      if (next === root || next.getParent() === root) {
        this.getView().setCurrentRoot(null);
      } else {
        this.getView().setCurrentRoot(next);
      }
      const state = this.getView().getState(current);
      if (state != null) {
        this.setSelectionCell(current);
      }
    }
  }
};
const ImageMixin = {
  addImageBundle(bundle) {
    this.imageBundles.push(bundle);
  },
  removeImageBundle(bundle) {
    const tmp = [];
    for (let i = 0; i < this.imageBundles.length; i += 1) {
      if (this.imageBundles[i] !== bundle) {
        tmp.push(this.imageBundles[i]);
      }
    }
    this.imageBundles = tmp;
  },
  getImageFromBundles(key) {
    if (key) {
      for (let i = 0; i < this.imageBundles.length; i += 1) {
        const image = this.imageBundles[i].getImage(key);
        if (image) {
          return image;
        }
      }
    }
    return null;
  }
};
const LabelMixin = {
  getLabel(cell) {
    let result = "";
    if (this.isLabelsVisible() && cell != null) {
      const style = this.getCurrentCellStyle(cell);
      if (!(style.noLabel ?? false)) {
        result = this.convertValueToString(cell);
      }
    }
    return result;
  },
  isHtmlLabel(_cell) {
    return this.isHtmlLabels();
  },
  labelsVisible: true,
  isLabelsVisible() {
    return this.labelsVisible;
  },
  htmlLabels: false,
  isHtmlLabels() {
    return this.htmlLabels;
  },
  setHtmlLabels(value) {
    this.htmlLabels = value;
  },
  isWrapping(cell) {
    return this.getCurrentCellStyle(cell).whiteSpace === "wrap";
  },
  isLabelClipped(cell) {
    return this.getCurrentCellStyle(cell).overflow === "hidden";
  },
  isLabelMovable(cell) {
    return !this.isCellLocked(cell) && (cell.isEdge() && this.isEdgeLabelsMovable() || cell.isVertex() && this.isVertexLabelsMovable());
  }
};
const OrderMixin = {
  orderCells(back = false, cells) {
    if (!cells)
      cells = this.getSelectionCells();
    if (!cells) {
      cells = sortCells(this.getSelectionCells(), true);
    }
    this.batchUpdate(() => {
      this.cellsOrdered(cells, back);
      const event = new EventObject(InternalEvent.ORDER_CELLS, "back", back, "cells", cells);
      this.fireEvent(event);
    });
    return cells;
  },
  cellsOrdered(cells, back = false) {
    this.batchUpdate(() => {
      for (let i = 0; i < cells.length; i += 1) {
        const parent = cells[i].getParent();
        if (back) {
          this.getDataModel().add(parent, cells[i], i);
        } else {
          this.getDataModel().add(parent, cells[i], parent ? parent.getChildCount() - 1 : 0);
        }
      }
      this.fireEvent(new EventObject(InternalEvent.CELLS_ORDERED, { back, cells }));
    });
  }
};
class CellOverlay extends EventSource {
  constructor(image, tooltip = null, align = "right", verticalAlign = "bottom", offset = new Point(), cursor = "help") {
    super();
    this.align = "right";
    this.verticalAlign = "bottom";
    this.offset = new Point();
    this.cursor = "help";
    this.defaultOverlap = 0.5;
    this.image = image;
    this.tooltip = tooltip;
    this.align = align;
    this.verticalAlign = verticalAlign;
    this.offset = offset;
    this.cursor = cursor;
  }
  /**
   * Returns the bounds of the overlay for the given <CellState> as an
   * {@link Rectangle}. This should be overridden when using multiple overlays
   * per cell so that the overlays do not overlap.
   *
   * The following example will place the overlay along an edge (where
   * x=[-1..1] from the start to the end of the edge and y is the
   * orthogonal offset in px).
   *
   * ```javascript
   * overlay.getBounds = function(state)
   * {
   *   var bounds = getBounds.apply(this, arguments);
   *
   *   if (state.view.graph.getDataModel().isEdge(state.cell))
   *   {
   *     var pt = state.view.getPoint(state, {x: 0, y: 0, relative: true});
   *
   *     bounds.x = pt.x - bounds.width / 2;
   *     bounds.y = pt.y - bounds.height / 2;
   *   }
   *
   *   return bounds;
   * };
   * ```
   *
   * @param state <CellState> that represents the current state of the
   * associated cell.
   */
  getBounds(state) {
    const isEdge = state.cell.isEdge();
    const s = state.view.scale;
    let pt = null;
    const image = this.image;
    const w = image.width;
    const h = image.height;
    if (isEdge) {
      const pts = state.absolutePoints;
      if (pts.length % 2 === 1) {
        pt = pts[Math.floor(pts.length / 2)];
      } else {
        const idx = pts.length / 2;
        const p0 = pts[idx - 1];
        const p1 = pts[idx];
        pt = new Point(p0.x + (p1.x - p0.x) / 2, p0.y + (p1.y - p0.y) / 2);
      }
    } else {
      pt = new Point();
      if (this.align === "left") {
        pt.x = state.x;
      } else if (this.align === "center") {
        pt.x = state.x + state.width / 2;
      } else if (this.align === "right") {
        pt.x = state.x + state.width;
      } else {
        throw new Error();
      }
      if (this.verticalAlign === "top") {
        pt.y = state.y;
      } else if (this.verticalAlign === "middle") {
        pt.y = state.y + state.height / 2;
      } else if (this.verticalAlign === "bottom") {
        pt.y = state.y + state.height;
      } else {
        throw new Error();
      }
    }
    return new Rectangle(Math.round(pt.x - (w * this.defaultOverlap - this.offset.x) * s), Math.round(pt.y - (h * this.defaultOverlap - this.offset.y) * s), w * s, h * s);
  }
  /**
   * Returns the textual representation of the overlay to be used as the
   * tooltip. This implementation returns <tooltip>.
   */
  toString() {
    return this.tooltip;
  }
}
const OverlaysMixin = {
  addCellOverlay(cell, overlay) {
    cell.overlays.push(overlay);
    const state = this.getView().getState(cell);
    if (state) {
      this.getCellRenderer().redraw(state);
    }
    this.fireEvent(new EventObject(InternalEvent.ADD_OVERLAY, { cell, overlay }));
    return overlay;
  },
  getCellOverlays(cell) {
    return cell.overlays;
  },
  removeCellOverlay(cell, overlay = null) {
    if (!overlay) {
      this.removeCellOverlays(cell);
    } else {
      const index = cell.overlays.indexOf(overlay);
      if (index >= 0) {
        cell.overlays.splice(index, 1);
        const state = this.getView().getState(cell);
        if (state) {
          this.getCellRenderer().redraw(state);
        }
        this.fireEvent(new EventObject(InternalEvent.REMOVE_OVERLAY, { cell, overlay }));
      } else {
        overlay = null;
      }
    }
    return overlay;
  },
  removeCellOverlays(cell) {
    const { overlays } = cell;
    cell.overlays = [];
    const state = this.getView().getState(cell);
    if (state) {
      this.getCellRenderer().redraw(state);
    }
    for (let i = 0; i < overlays.length; i += 1) {
      this.fireEvent(new EventObject(InternalEvent.REMOVE_OVERLAY, "cell", cell, "overlay", overlays[i]));
    }
    return overlays;
  },
  clearCellOverlays(cell = null) {
    cell = cell ?? this.getDataModel().getRoot();
    if (!cell)
      return;
    this.removeCellOverlays(cell);
    const childCount = cell.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      const child = cell.getChildAt(i);
      this.clearCellOverlays(child);
    }
  },
  setCellWarning(cell, warning = null, img, isSelect = false) {
    img = img ?? this.getWarningImage();
    if (warning && warning.length > 0) {
      const overlay = new CellOverlay(img, `<font color=red>${warning}</font>`);
      if (isSelect) {
        overlay.addListener(InternalEvent.CLICK, (sender, evt) => {
          if (this.isEnabled()) {
            this.setSelectionCell(cell);
          }
        });
      }
      return this.addCellOverlay(cell, overlay);
    }
    this.removeCellOverlays(cell);
    return null;
  }
};
const PageBreaksMixin = {
  horizontalPageBreaks: null,
  verticalPageBreaks: null,
  updatePageBreaks(visible, _width, _height) {
    const { scale, translate: tr } = this.getView();
    const fmt = this.getPageFormat();
    const ps = scale * this.getPageScale();
    const bounds = new Rectangle(0, 0, fmt.width * ps, fmt.height * ps);
    const gb = Rectangle.fromRectangle(this.getGraphBounds());
    gb.width = Math.max(1, gb.width);
    gb.height = Math.max(1, gb.height);
    bounds.x = Math.floor((gb.x - tr.x * scale) / bounds.width) * bounds.width + tr.x * scale;
    bounds.y = Math.floor((gb.y - tr.y * scale) / bounds.height) * bounds.height + tr.y * scale;
    gb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;
    gb.height = Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;
    visible = visible && Math.min(bounds.width, bounds.height) > this.getMinPageBreakDist();
    const horizontalCount = visible ? Math.ceil(gb.height / bounds.height) + 1 : 0;
    const verticalCount = visible ? Math.ceil(gb.width / bounds.width) + 1 : 0;
    const right = (verticalCount - 1) * bounds.width;
    const bottom = (horizontalCount - 1) * bounds.height;
    if (this.horizontalPageBreaks == null && horizontalCount > 0) {
      this.horizontalPageBreaks = [];
    }
    if (this.verticalPageBreaks == null && verticalCount > 0) {
      this.verticalPageBreaks = [];
    }
    const drawPageBreaks = (breaks) => {
      if (breaks != null) {
        const count = breaks === this.horizontalPageBreaks ? horizontalCount : verticalCount;
        for (let i = 0; i <= count; i += 1) {
          const pts = breaks === this.horizontalPageBreaks ? [
            new Point(Math.round(bounds.x), Math.round(bounds.y + i * bounds.height)),
            new Point(Math.round(bounds.x + right), Math.round(bounds.y + i * bounds.height))
          ] : [
            new Point(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y)),
            new Point(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y + bottom))
          ];
          if (breaks[i] != null) {
            breaks[i].points = pts;
            breaks[i].redraw();
          } else {
            const pageBreak = new PolylineShape(pts, this.getPageBreakColor());
            pageBreak.dialect = this.getDialect();
            pageBreak.pointerEvents = false;
            pageBreak.isDashed = this.isPageBreakDashed();
            pageBreak.init(this.getView().backgroundPane);
            pageBreak.redraw();
            breaks[i] = pageBreak;
          }
        }
        for (let i = count; i < breaks.length; i += 1) {
          breaks[i].destroy();
        }
        breaks.splice(count, breaks.length - count);
      }
    };
    drawPageBreaks(this.horizontalPageBreaks);
    drawPageBreaks(this.verticalPageBreaks);
  }
};
const PanningMixin = {
  shiftPreview1: null,
  shiftPreview2: null,
  useScrollbarsForPanning: true,
  isUseScrollbarsForPanning() {
    return this.useScrollbarsForPanning;
  },
  timerAutoScroll: false,
  isTimerAutoScroll() {
    return this.timerAutoScroll;
  },
  allowAutoPanning: false,
  isAllowAutoPanning() {
    return this.allowAutoPanning;
  },
  panDx: 0,
  getPanDx() {
    return this.panDx;
  },
  setPanDx(dx) {
    this.panDx = dx;
  },
  panDy: 0,
  getPanDy() {
    return this.panDy;
  },
  setPanDy(dy) {
    this.panDy = dy;
  },
  panGraph(dx, dy) {
    const container = this.getContainer();
    if (this.useScrollbarsForPanning && hasScrollbars(container)) {
      container.scrollLeft = -dx;
      container.scrollTop = -dy;
    } else {
      const canvas = this.getView().getCanvas();
      if (dx === 0 && dy === 0) {
        canvas.removeAttribute("transform");
        if (this.shiftPreview1) {
          let child = this.shiftPreview1.firstChild;
          while (child) {
            const next = child.nextSibling;
            container.appendChild(child);
            child = next;
          }
          if (this.shiftPreview1.parentNode) {
            this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);
          }
          this.shiftPreview1 = null;
          container.appendChild(canvas.parentNode);
          const shiftPreview2 = this.shiftPreview2;
          child = shiftPreview2.firstChild;
          while (child) {
            const next = child.nextSibling;
            container.appendChild(child);
            child = next;
          }
          if (shiftPreview2.parentNode) {
            shiftPreview2.parentNode.removeChild(shiftPreview2);
          }
          this.shiftPreview2 = null;
        }
      } else {
        canvas.setAttribute("transform", `translate(${dx},${dy})`);
        if (!this.shiftPreview1) {
          this.shiftPreview1 = document.createElement("div");
          this.shiftPreview1.style.position = "absolute";
          this.shiftPreview1.style.overflow = "visible";
          this.shiftPreview2 = document.createElement("div");
          this.shiftPreview2.style.position = "absolute";
          this.shiftPreview2.style.overflow = "visible";
          let current = this.shiftPreview1;
          let child = container.firstChild;
          while (child) {
            const next = child.nextSibling;
            if (child !== canvas.parentNode) {
              current.appendChild(child);
            } else {
              current = this.shiftPreview2;
            }
            child = next;
          }
          if (this.shiftPreview1.firstChild) {
            container.insertBefore(this.shiftPreview1, canvas.parentNode);
          }
          if (this.shiftPreview2.firstChild) {
            container.appendChild(this.shiftPreview2);
          }
        }
        this.shiftPreview1.style.left = `${dx}px`;
        this.shiftPreview1.style.top = `${dy}px`;
        if (this.shiftPreview2) {
          this.shiftPreview2.style.left = `${dx}px`;
          this.shiftPreview2.style.top = `${dy}px`;
        }
      }
      this.panDx = dx;
      this.panDy = dy;
      this.fireEvent(new EventObject(InternalEvent.PAN));
    }
  },
  scrollCellToVisible(cell, center = false) {
    const x = -this.getView().translate.x;
    const y = -this.getView().translate.y;
    const state = this.getView().getState(cell);
    if (state) {
      const bounds = new Rectangle(x + state.x, y + state.y, state.width, state.height);
      if (center && this.getContainer()) {
        const w = this.getContainer().clientWidth;
        const h = this.getContainer().clientHeight;
        bounds.x = bounds.getCenterX() - w / 2;
        bounds.width = w;
        bounds.y = bounds.getCenterY() - h / 2;
        bounds.height = h;
      }
      const tr = new Point(this.getView().translate.x, this.getView().translate.y);
      if (this.scrollRectToVisible(bounds)) {
        const tr2 = new Point(this.getView().translate.x, this.getView().translate.y);
        this.getView().translate.x = tr.x;
        this.getView().translate.y = tr.y;
        this.getView().setTranslate(tr2.x, tr2.y);
      }
    }
  },
  scrollRectToVisible(rect) {
    let isChanged = false;
    const container = this.getContainer();
    const w = container.offsetWidth;
    const h = container.offsetHeight;
    const widthLimit = Math.min(w, rect.width);
    const heightLimit = Math.min(h, rect.height);
    if (hasScrollbars(container)) {
      rect.x += this.getView().translate.x;
      rect.y += this.getView().translate.y;
      let dx = container.scrollLeft - rect.x;
      const ddx = Math.max(dx - container.scrollLeft, 0);
      if (dx > 0) {
        container.scrollLeft -= dx + 2;
      } else {
        dx = rect.x + widthLimit - container.scrollLeft - container.clientWidth;
        if (dx > 0) {
          container.scrollLeft += dx + 2;
        }
      }
      let dy = container.scrollTop - rect.y;
      const ddy = Math.max(0, dy - container.scrollTop);
      if (dy > 0) {
        container.scrollTop -= dy + 2;
      } else {
        dy = rect.y + heightLimit - container.scrollTop - container.clientHeight;
        if (dy > 0) {
          container.scrollTop += dy + 2;
        }
      }
      if (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0)) {
        this.getView().setTranslate(ddx, ddy);
      }
    } else {
      const x = -this.getView().translate.x;
      const y = -this.getView().translate.y;
      const s = this.getView().scale;
      if (rect.x + widthLimit > x + w) {
        this.getView().translate.x -= (rect.x + widthLimit - w - x) / s;
        isChanged = true;
      }
      if (rect.y + heightLimit > y + h) {
        this.getView().translate.y -= (rect.y + heightLimit - h - y) / s;
        isChanged = true;
      }
      if (rect.x < x) {
        this.getView().translate.x += (x - rect.x) / s;
        isChanged = true;
      }
      if (rect.y < y) {
        this.getView().translate.y += (y - rect.y) / s;
        isChanged = true;
      }
      if (isChanged) {
        this.getView().refresh();
        const selectionCellsHandler = this.getPlugin("SelectionCellsHandler");
        if (selectionCellsHandler) {
          selectionCellsHandler.refresh();
        }
      }
    }
    return isChanged;
  },
  setPanning(enabled) {
    const panningHandler = this.getPlugin("PanningHandler");
    panningHandler && (panningHandler.panningEnabled = enabled);
  }
};
const PortsMixin = {
  portsEnabled: true,
  isPort(cell) {
    return false;
  },
  getTerminalForPort(cell, _source = false) {
    return cell.getParent();
  },
  isPortsEnabled() {
    return this.portsEnabled;
  },
  setPortsEnabled(value) {
    this.portsEnabled = value;
  }
};
const SelectionMixin = {
  selectionModel: null,
  getSelectionModel() {
    return this.selectionModel;
  },
  setSelectionModel(selectionModel) {
    this.selectionModel = selectionModel;
  },
  /*****************************************************************************
   * Selection
   *****************************************************************************/
  isCellSelected(cell) {
    return this.selectionModel.isSelected(cell);
  },
  isSelectionEmpty() {
    return this.selectionModel.isEmpty();
  },
  clearSelection() {
    this.selectionModel.clear();
  },
  getSelectionCount() {
    return this.selectionModel.cells.length;
  },
  getSelectionCell() {
    return this.selectionModel.cells[0];
  },
  getSelectionCells() {
    return this.selectionModel.cells.slice();
  },
  setSelectionCell(cell) {
    this.selectionModel.setCell(cell);
  },
  setSelectionCells(cells) {
    this.selectionModel.setCells(cells);
  },
  addSelectionCell(cell) {
    this.selectionModel.addCell(cell);
  },
  addSelectionCells(cells) {
    this.selectionModel.addCells(cells);
  },
  removeSelectionCell(cell) {
    this.selectionModel.removeCell(cell);
  },
  removeSelectionCells(cells) {
    this.selectionModel.removeCells(cells);
  },
  selectRegion(rect, evt) {
    const cells = this.getCells(rect.x, rect.y, rect.width, rect.height);
    this.selectCellsForEvent(cells, evt);
    return cells;
  },
  selectNextCell() {
    this.selectCell(true);
  },
  selectPreviousCell() {
    this.selectCell();
  },
  selectParentCell() {
    this.selectCell(false, true);
  },
  selectChildCell() {
    this.selectCell(false, false, true);
  },
  selectCell(isNext = false, isParent = false, isChild = false) {
    const cell = this.selectionModel.cells.length > 0 ? this.selectionModel.cells[0] : null;
    if (this.selectionModel.cells.length > 1) {
      this.selectionModel.clear();
    }
    const parent = cell ? cell.getParent() : this.getDefaultParent();
    const childCount = parent.getChildCount();
    if (!cell && childCount > 0) {
      const child = parent.getChildAt(0);
      this.setSelectionCell(child);
    } else if (parent && (!cell || isParent) && this.getView().getState(parent) && parent.getGeometry()) {
      if (this.getCurrentRoot() !== parent) {
        this.setSelectionCell(parent);
      }
    } else if (cell && isChild) {
      const tmp = cell.getChildCount();
      if (tmp > 0) {
        const child = cell.getChildAt(0);
        this.setSelectionCell(child);
      }
    } else if (childCount > 0) {
      let i = parent.getIndex(cell);
      if (isNext) {
        i++;
        const child = parent.getChildAt(i % childCount);
        this.setSelectionCell(child);
      } else {
        i--;
        const index = i < 0 ? childCount - 1 : i;
        const child = parent.getChildAt(index);
        this.setSelectionCell(child);
      }
    }
  },
  selectAll(parent, descendants = false) {
    parent = parent ?? this.getDefaultParent();
    const cells = descendants ? parent.filterDescendants((cell) => {
      return cell !== parent && !!this.getView().getState(cell);
    }) : parent.getChildren();
    this.setSelectionCells(cells);
  },
  selectVertices(parent, selectGroups = false) {
    this.selectCells(true, false, parent, selectGroups);
  },
  selectEdges(parent) {
    this.selectCells(false, true, parent);
  },
  selectCells(vertices = false, edges = false, parent, selectGroups = false) {
    parent = parent ?? this.getDefaultParent();
    const filter = (cell) => {
      const p = cell.getParent();
      return !!this.getView().getState(cell) && ((selectGroups || cell.getChildCount() === 0) && cell.isVertex() && vertices && p && !p.isEdge() || cell.isEdge() && edges);
    };
    const cells = parent.filterDescendants(filter);
    this.setSelectionCells(cells);
  },
  selectCellForEvent(cell, evt) {
    const isSelected = this.isCellSelected(cell);
    if (this.isToggleEvent(evt)) {
      if (isSelected) {
        this.removeSelectionCell(cell);
      } else {
        this.addSelectionCell(cell);
      }
    } else if (!isSelected || this.getSelectionCount() !== 1) {
      this.setSelectionCell(cell);
    }
  },
  selectCellsForEvent(cells, evt) {
    if (this.isToggleEvent(evt)) {
      this.addSelectionCells(cells);
    } else {
      this.setSelectionCells(cells);
    }
  },
  isSiblingSelected(cell) {
    const parent = cell.getParent();
    const childCount = parent.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      const child = parent.getChildAt(i);
      if (cell !== child && this.isCellSelected(child)) {
        return true;
      }
    }
    return false;
  },
  /*****************************************************************************
   * Selection state
   *****************************************************************************/
  getSelectionCellsForChanges(changes, ignoreFn = null) {
    const dict = new Dictionary();
    const cells = [];
    const addCell = (cell) => {
      if (!dict.get(cell) && this.getDataModel().contains(cell)) {
        if (cell.isEdge() || cell.isVertex()) {
          dict.put(cell, true);
          cells.push(cell);
        } else {
          const childCount = cell.getChildCount();
          for (let i = 0; i < childCount; i += 1) {
            addCell(cell.getChildAt(i));
          }
        }
      }
    };
    for (let i = 0; i < changes.length; i += 1) {
      const change = changes[i];
      if (change.constructor !== RootChange && (!ignoreFn || !ignoreFn(change))) {
        let cell = null;
        if (change instanceof ChildChange) {
          cell = change.child;
        } else if (change.cell && change.cell instanceof Cell) {
          cell = change.cell;
        }
        if (cell) {
          addCell(cell);
        }
      }
    }
    return cells;
  },
  updateSelection() {
    const cells = this.getSelectionCells();
    const removed = [];
    for (const cell of cells) {
      if (!this.getDataModel().contains(cell) || !cell.isVisible()) {
        removed.push(cell);
      } else {
        let par = cell.getParent();
        while (par && par !== this.getView().currentRoot) {
          if (par.isCollapsed() || !par.isVisible()) {
            removed.push(cell);
            break;
          }
          par = par.getParent();
        }
      }
    }
    this.removeSelectionCells(removed);
  }
};
const SnapMixin = {
  snapTolerance: 0,
  getSnapTolerance() {
    return this.snapTolerance;
  },
  gridSize: 10,
  gridEnabled: true,
  snap(value) {
    if (this.gridEnabled) {
      value = Math.round(value / this.gridSize) * this.gridSize;
    }
    return value;
  },
  snapDelta(delta, bounds, ignoreGrid = false, ignoreHorizontal = false, ignoreVertical = false) {
    const t = this.getView().translate;
    const s = this.getView().scale;
    if (!ignoreGrid && this.gridEnabled) {
      const tol = this.gridSize * s * 0.5;
      if (!ignoreHorizontal) {
        const tx = bounds.x - (this.snap(bounds.x / s - t.x) + t.x) * s;
        if (Math.abs(delta.x - tx) < tol) {
          delta.x = 0;
        } else {
          delta.x = this.snap(delta.x / s) * s - tx;
        }
      }
      if (!ignoreVertical) {
        const ty = bounds.y - (this.snap(bounds.y / s - t.y) + t.y) * s;
        if (Math.abs(delta.y - ty) < tol) {
          delta.y = 0;
        } else {
          delta.y = this.snap(delta.y / s) * s - ty;
        }
      }
    } else {
      const tol = 0.5 * s;
      if (!ignoreHorizontal) {
        const tx = bounds.x - (Math.round(bounds.x / s - t.x) + t.x) * s;
        if (Math.abs(delta.x - tx) < tol) {
          delta.x = 0;
        } else {
          delta.x = Math.round(delta.x / s) * s - tx;
        }
      }
      if (!ignoreVertical) {
        const ty = bounds.y - (Math.round(bounds.y / s - t.y) + t.y) * s;
        if (Math.abs(delta.y - ty) < tol) {
          delta.y = 0;
        } else {
          delta.y = Math.round(delta.y / s) * s - ty;
        }
      }
    }
    return delta;
  },
  isGridEnabled() {
    return this.gridEnabled;
  },
  setGridEnabled(value) {
    this.gridEnabled = value;
  },
  getGridSize() {
    return this.gridSize;
  },
  setGridSize(value) {
    this.gridSize = value;
  }
};
const SwimlaneMixin = {
  swimlaneSelectionEnabled: true,
  swimlaneNesting: true,
  swimlaneIndicatorColorAttribute: "fillColor",
  getSwimlane(cell = null) {
    while (cell && !this.isSwimlane(cell)) {
      cell = cell.getParent();
    }
    return cell;
  },
  getSwimlaneAt(x, y, parent) {
    if (!parent) {
      parent = this.getCurrentRoot();
      if (!parent) {
        parent = this.getDataModel().getRoot();
      }
    }
    if (parent) {
      const childCount = parent.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        const child = parent.getChildAt(i);
        if (child) {
          const result = this.getSwimlaneAt(x, y, child);
          if (result != null) {
            return result;
          }
          if (child.isVisible() && this.isSwimlane(child)) {
            const state = this.getView().getState(child);
            if (state && this.intersects(state, x, y)) {
              return child;
            }
          }
        }
      }
    }
    return null;
  },
  hitsSwimlaneContent(swimlane, x, y) {
    const state = this.getView().getState(swimlane);
    const size = this.getStartSize(swimlane);
    if (state) {
      const scale = this.getView().getScale();
      x -= state.x;
      y -= state.y;
      if (size.width > 0 && x > 0 && x > size.width * scale) {
        return true;
      }
      if (size.height > 0 && y > 0 && y > size.height * scale) {
        return true;
      }
    }
    return false;
  },
  getStartSize(swimlane, ignoreState = false) {
    const result = new Rectangle();
    const style = this.getCurrentCellStyle(swimlane, ignoreState);
    const size = style.startSize ?? DEFAULT_STARTSIZE;
    if (style.horizontal ?? true) {
      result.height = size;
    } else {
      result.width = size;
    }
    return result;
  },
  getSwimlaneDirection(style) {
    const dir = style.direction ?? DIRECTION.EAST;
    const flipH = style.flipH;
    const flipV = style.flipV;
    const h = style.horizontal ?? true;
    let n = h ? 0 : 3;
    if (dir === DIRECTION.NORTH) {
      n--;
    } else if (dir === DIRECTION.WEST) {
      n += 2;
    } else if (dir === DIRECTION.SOUTH) {
      n += 1;
    }
    const _mod = mod(n, 2);
    if (flipH && _mod === 1) {
      n += 2;
    }
    if (flipV && _mod === 0) {
      n += 2;
    }
    return [DIRECTION.NORTH, DIRECTION.EAST, DIRECTION.SOUTH, DIRECTION.WEST][mod(n, 4)];
  },
  getActualStartSize(swimlane, ignoreState = false) {
    const result = new Rectangle();
    if (this.isSwimlane(swimlane, ignoreState)) {
      const style = this.getCurrentCellStyle(swimlane, ignoreState);
      const size = style.startSize ?? DEFAULT_STARTSIZE;
      const dir = this.getSwimlaneDirection(style);
      if (dir === DIRECTION.NORTH) {
        result.y = size;
      } else if (dir === DIRECTION.WEST) {
        result.x = size;
      } else if (dir === DIRECTION.SOUTH) {
        result.height = size;
      } else {
        result.width = size;
      }
    }
    return result;
  },
  isSwimlane(cell, ignoreState = false) {
    if (cell && cell.getParent() !== this.getDataModel().getRoot() && !cell.isEdge()) {
      return this.getCurrentCellStyle(cell, ignoreState).shape === SHAPE.SWIMLANE;
    }
    return false;
  },
  isValidDropTarget(cell, cells, evt) {
    return cell && (this.isSplitEnabled() && this.isSplitTarget(cell, cells, evt) || !cell.isEdge() && (this.isSwimlane(cell) || cell.getChildCount() > 0 && !cell.isCollapsed()));
  },
  getDropTarget(cells, evt, cell = null, clone2 = false) {
    if (!this.isSwimlaneNesting()) {
      for (let i = 0; i < cells.length; i += 1) {
        if (this.isSwimlane(cells[i])) {
          return null;
        }
      }
    }
    const pt = convertPoint(this.getContainer(), getClientX(evt), getClientY(evt));
    pt.x -= this.getPanDx();
    pt.y -= this.getPanDy();
    const swimlane = this.getSwimlaneAt(pt.x, pt.y);
    if (!cell) {
      cell = swimlane;
    } else if (swimlane) {
      let tmp = swimlane.getParent();
      while (tmp && this.isSwimlane(tmp) && tmp !== cell) {
        tmp = tmp.getParent();
      }
      if (tmp === cell) {
        cell = swimlane;
      }
    }
    while (cell && !this.isValidDropTarget(cell, cells, evt) && !this.getDataModel().isLayer(cell)) {
      cell = cell.getParent();
    }
    let parentCell = cell;
    if (!clone2) {
      while (parentCell && cells.indexOf(parentCell) < 0) {
        parentCell = parentCell.getParent();
      }
    }
    return !this.getDataModel().isLayer(cell) && !parentCell ? cell : null;
  },
  isSwimlaneNesting() {
    return this.swimlaneNesting;
  },
  setSwimlaneNesting(value) {
    this.swimlaneNesting = value;
  },
  isSwimlaneSelectionEnabled() {
    return this.swimlaneSelectionEnabled;
  },
  setSwimlaneSelectionEnabled(value) {
    this.swimlaneSelectionEnabled = value;
  }
};
const TerminalMixin = {
  isTerminalPointMovable(cell, source) {
    return true;
  },
  getOpposites(edges, terminal = null, includeSources = true, includeTargets = true) {
    const terminals = [];
    const dict = new Dictionary();
    for (let i = 0; i < edges.length; i += 1) {
      const state = this.getView().getState(edges[i]);
      const source = state ? state.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i], true);
      const target = state ? state.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i], false);
      if (source === terminal && target && target !== terminal && includeTargets) {
        if (!dict.get(target)) {
          dict.put(target, true);
          terminals.push(target);
        }
      } else if (target === terminal && source && source !== terminal && includeSources) {
        if (!dict.get(source)) {
          dict.put(source, true);
          terminals.push(source);
        }
      }
    }
    return terminals;
  }
};
const TooltipMixin = {
  getTooltip(state, node, x, y) {
    let tip = null;
    if (state.control && (node === state.control.node || node.parentNode === state.control.node)) {
      tip = this.getCollapseExpandResource();
      tip = htmlEntities(translate(tip) || tip, true).replace(/\\n/g, "<br>");
    }
    if (!tip && state.overlays) {
      state.overlays.visit((id, shape) => {
        if (!tip && (node === shape.node || node.parentNode === shape.node)) {
          tip = shape.overlay ? shape.overlay.toString() ?? null : null;
        }
      });
    }
    if (!tip) {
      const selectionCellsHandler = this.getPlugin("SelectionCellsHandler");
      const handler = selectionCellsHandler == null ? void 0 : selectionCellsHandler.getHandler(state.cell);
      if (handler && "getTooltipForNode" in handler && typeof handler.getTooltipForNode === "function") {
        tip = handler.getTooltipForNode(node);
      }
    }
    if (!tip) {
      tip = this.getTooltipForCell(state.cell);
    }
    return tip;
  },
  getTooltipForCell(cell) {
    let tip = null;
    if (cell && "getTooltip" in cell) {
      tip = cell.getTooltip();
    } else {
      tip = this.convertValueToString(cell);
    }
    return tip;
  },
  setTooltips(enabled) {
    const tooltipHandler = this.getPlugin("TooltipHandler");
    tooltipHandler == null ? void 0 : tooltipHandler.setEnabled(enabled);
  }
};
const ValidationMixin = {
  validationAlert(message) {
    alert(message);
  },
  isEdgeValid(edge, source, target) {
    return !this.getEdgeValidationError(edge, source, target);
  },
  getEdgeValidationError(edge = null, source = null, target = null) {
    if (edge && !this.isAllowDanglingEdges() && (!source || !target)) {
      return "";
    }
    if (edge && !edge.getTerminal(true) && !edge.getTerminal(false)) {
      return null;
    }
    if (!this.isAllowLoops() && source === target && source) {
      return "";
    }
    if (!this.isValidConnection(source, target)) {
      return "";
    }
    if (source && target) {
      let error2 = "";
      if (!this.isMultigraph()) {
        const tmp = this.getDataModel().getEdgesBetween(source, target, true);
        if (tmp.length > 1 || tmp.length === 1 && tmp[0] !== edge) {
          error2 += `${translate(this.getAlreadyConnectedResource()) || this.getAlreadyConnectedResource()}
`;
        }
      }
      const sourceOut = source.getDirectedEdgeCount(true, edge);
      const targetIn = target.getDirectedEdgeCount(false, edge);
      for (const multiplicity of this.multiplicities) {
        const err2 = multiplicity.check(
          this,
          // needs to cast to Graph
          edge,
          source,
          target,
          sourceOut,
          targetIn
        );
        if (err2 != null) {
          error2 += err2;
        }
      }
      const err = this.validateEdge(edge, source, target);
      if (err != null) {
        error2 += err;
      }
      return error2.length > 0 ? error2 : null;
    }
    return this.isAllowDanglingEdges() ? null : "";
  },
  validateEdge(edge = null, source = null, target = null) {
    return null;
  },
  validateGraph(cell = null, context) {
    cell = cell ?? this.getDataModel().getRoot();
    if (!cell) {
      return "The root does not exist!";
    }
    context = context ?? {};
    let isValid = true;
    const childCount = cell.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      const tmp = cell.getChildAt(i);
      let ctx = context;
      if (this.isValidRoot(tmp)) {
        ctx = {};
      }
      const warn = this.validateGraph(tmp, ctx);
      if (warn) {
        this.setCellWarning(tmp, warn.replace(/\n/g, "<br>"));
      } else {
        this.setCellWarning(tmp, null);
      }
      isValid = isValid && warn == null;
    }
    let warning = "";
    if (cell && cell.isCollapsed() && !isValid) {
      warning += `${translate(this.getContainsValidationErrorsResource()) || this.getContainsValidationErrorsResource()}
`;
    }
    if (cell && cell.isEdge()) {
      warning += this.getEdgeValidationError(cell, cell.getTerminal(true), cell.getTerminal(false)) || "";
    } else {
      warning += this.getCellValidationError(cell) || "";
    }
    const err = this.validateCell(cell, context);
    if (err != null) {
      warning += err;
    }
    if (cell.getParent() == null) {
      this.getView().validate();
    }
    return warning.length > 0 || !isValid ? warning : null;
  },
  getCellValidationError(cell) {
    const outCount = cell.getDirectedEdgeCount(true);
    const inCount = cell.getDirectedEdgeCount(false);
    const value = cell.getValue();
    let error2 = "";
    for (let i = 0; i < this.multiplicities.length; i += 1) {
      const rule = this.multiplicities[i];
      if (rule.source && isNode(value, rule.type, rule.attr, rule.value) && (outCount > rule.max || outCount < rule.min)) {
        error2 += `${rule.countError}
`;
      } else if (!rule.source && isNode(value, rule.type, rule.attr, rule.value) && (inCount > rule.max || inCount < rule.min)) {
        error2 += `${rule.countError}
`;
      }
    }
    return error2.length > 0 ? error2 : null;
  },
  validateCell(cell, context) {
    return null;
  }
};
const VertexMixin = {
  vertexLabelsMovable: false,
  allowNegativeCoordinates: true,
  isAllowNegativeCoordinates() {
    return this.allowNegativeCoordinates;
  },
  setAllowNegativeCoordinates(value) {
    this.allowNegativeCoordinates = value;
  },
  insertVertex(...args) {
    var _a, _b, _c, _d;
    let parent;
    let id;
    let value;
    let x;
    let y;
    let width;
    let height;
    let style;
    let relative;
    let geometryClass;
    if (args.length === 1 && typeof args[0] === "object") {
      const params = args[0];
      parent = params.parent;
      id = params.id;
      value = params.value;
      x = "x" in params ? params.x : (_a = params.position) == null ? void 0 : _a[0];
      y = "y" in params ? params.y : (_b = params.position) == null ? void 0 : _b[1];
      width = "width" in params ? params.width : (_c = params.size) == null ? void 0 : _c[0];
      height = "height" in params ? params.height : (_d = params.size) == null ? void 0 : _d[1];
      style = params.style;
      relative = params.relative;
      geometryClass = params.geometryClass;
    } else {
      [parent, id, value, x, y, width, height, style, relative, geometryClass] = args;
    }
    const vertex = this.createVertex(parent, id, value, x, y, width, height, style, relative, geometryClass);
    return this.addCell(vertex, parent);
  },
  createVertex(_parent, id, value, x, y, width, height, style, relative = false, geometryClass = Geometry) {
    const geometry = new geometryClass(x, y, width, height);
    geometry.relative = relative;
    const vertex = new Cell(value, geometry, style);
    vertex.setId(id);
    vertex.setVertex(true);
    vertex.setConnectable(true);
    return vertex;
  },
  getChildVertices(parent) {
    return this.getChildCells(parent, true, false);
  },
  isVertexLabelsMovable() {
    return this.vertexLabelsMovable;
  },
  setVertexLabelsMovable(value) {
    this.vertexLabelsMovable = value;
  }
};
const ZoomMixin = {
  zoomFactor: 1.2,
  keepSelectionVisibleOnZoom: false,
  centerZoom: true,
  zoomIn() {
    this.zoom(this.zoomFactor);
  },
  zoomOut() {
    this.zoom(1 / this.zoomFactor);
  },
  zoomActual() {
    if (this.getView().scale === 1) {
      this.getView().setTranslate(0, 0);
    } else {
      this.getView().translate.x = 0;
      this.getView().translate.y = 0;
      this.getView().setScale(1);
    }
  },
  zoomTo(scale, center = false) {
    this.zoom(scale / this.getView().scale, center);
  },
  zoom(factor, center) {
    center = center ?? this.centerZoom;
    const scale = Math.round(this.getView().scale * factor * 100) / 100;
    const state = this.getView().getState(this.getSelectionCell());
    const container = this.getContainer();
    factor = scale / this.getView().scale;
    if (this.keepSelectionVisibleOnZoom && state != null) {
      const rect = new Rectangle(state.x * factor, state.y * factor, state.width * factor, state.height * factor);
      this.getView().scale = scale;
      if (!this.scrollRectToVisible(rect)) {
        this.getView().revalidate();
        this.getView().setScale(scale);
      }
    } else {
      const _hasScrollbars = hasScrollbars(this.getContainer());
      if (center && !_hasScrollbars) {
        let dx = container.offsetWidth;
        let dy = container.offsetHeight;
        if (factor > 1) {
          const f = (factor - 1) / (scale * 2);
          dx *= -f;
          dy *= -f;
        } else {
          const f = (1 / factor - 1) / (this.getView().scale * 2);
          dx *= f;
          dy *= f;
        }
        this.getView().scaleAndTranslate(scale, this.getView().translate.x + dx, this.getView().translate.y + dy);
      } else {
        const tx = this.getView().translate.x;
        const ty = this.getView().translate.y;
        const sl = container.scrollLeft;
        const st = container.scrollTop;
        this.getView().setScale(scale);
        if (_hasScrollbars) {
          let dx = 0;
          let dy = 0;
          if (center) {
            dx = container.offsetWidth * (factor - 1) / 2;
            dy = container.offsetHeight * (factor - 1) / 2;
          }
          container.scrollLeft = (this.getView().translate.x - tx) * this.getView().scale + Math.round(sl * factor + dx);
          container.scrollTop = (this.getView().translate.y - ty) * this.getView().scale + Math.round(st * factor + dy);
        }
      }
    }
  },
  zoomToRect(rect) {
    const container = this.getContainer();
    const scaleX = container.clientWidth / rect.width;
    const scaleY = container.clientHeight / rect.height;
    const aspectFactor = scaleX / scaleY;
    rect.x = Math.max(0, rect.x);
    rect.y = Math.max(0, rect.y);
    let rectRight = Math.min(container.scrollWidth, rect.x + rect.width);
    let rectBottom = Math.min(container.scrollHeight, rect.y + rect.height);
    rect.width = rectRight - rect.x;
    rect.height = rectBottom - rect.y;
    if (aspectFactor < 1) {
      const newHeight = rect.height / aspectFactor;
      const deltaHeightBuffer = (newHeight - rect.height) / 2;
      rect.height = newHeight;
      const upperBuffer = Math.min(rect.y, deltaHeightBuffer);
      rect.y -= upperBuffer;
      rectBottom = Math.min(container.scrollHeight, rect.y + rect.height);
      rect.height = rectBottom - rect.y;
    } else {
      const newWidth = rect.width * aspectFactor;
      const deltaWidthBuffer = (newWidth - rect.width) / 2;
      rect.width = newWidth;
      const leftBuffer = Math.min(rect.x, deltaWidthBuffer);
      rect.x -= leftBuffer;
      rectRight = Math.min(container.scrollWidth, rect.x + rect.width);
      rect.width = rectRight - rect.x;
    }
    const scale = container.clientWidth / rect.width;
    const newScale = this.getView().scale * scale;
    if (!hasScrollbars(this.getContainer())) {
      this.getView().scaleAndTranslate(newScale, this.getView().translate.x - rect.x / this.getView().scale, this.getView().translate.y - rect.y / this.getView().scale);
    } else {
      this.getView().setScale(newScale);
      container.scrollLeft = Math.round(rect.x * scale);
      container.scrollTop = Math.round(rect.y * scale);
    }
  }
};
const applyGraphMixins = (target) => {
  const mixIntoGraph = mixInto(target);
  for (const mixin of [
    CellsMixin,
    ConnectionsMixin,
    DragDropMixin,
    EdgeMixin,
    EditingMixin,
    EventsMixin,
    FoldingMixin,
    GroupingMixin,
    ImageMixin,
    LabelMixin,
    OrderMixin,
    PageBreaksMixin,
    OverlaysMixin,
    PanningMixin,
    PortsMixin,
    SelectionMixin,
    SnapMixin,
    SwimlaneMixin,
    TerminalMixin,
    TooltipMixin,
    ValidationMixin,
    VertexMixin,
    ZoomMixin
  ]) {
    mixIntoGraph(mixin);
  }
};
class CellEditorHandler {
  constructor(graph) {
    this.clearOnChange = false;
    this.bounds = null;
    this.resizeThread = null;
    this.textDirection = null;
    this.textarea = null;
    this.editingCell = null;
    this.trigger = null;
    this.modified = false;
    this.autoSize = true;
    this.selectText = true;
    this.emptyLabelText = Client.IS_FF ? "<br>" : "";
    this.escapeCancelsEditing = true;
    this.textNode = null;
    this.zIndex = 5;
    this.minResize = new Rectangle(0, 20);
    this.wordWrapPadding = 0;
    this.blurEnabled = false;
    this.initialValue = null;
    this.align = null;
    this.graph = graph;
    this.zoomHandler = () => {
      if (this.graph.isEditing()) {
        this.resize();
      }
    };
    this.changeHandler = (sender) => {
      if (this.editingCell && !this.graph.getView().getState(this.editingCell, false)) {
        this.stopEditing(true);
      }
    };
    this.graph.getView().addListener(InternalEvent.SCALE, this.zoomHandler);
    this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.zoomHandler);
    this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);
  }
  /**
   * Creates the <textarea> and installs the event listeners. The key handler
   * updates the {@link odified} state.
   */
  init() {
    this.textarea = document.createElement("div");
    this.textarea.className = "mxCellEditor mxPlainTextEditor";
    this.textarea.contentEditable = String(true);
    if (Client.IS_GC) {
      this.textarea.style.minHeight = "1em";
    }
    this.textarea.style.position = "absolute";
    this.installListeners(this.textarea);
  }
  /**
   * Called in <stopEditing> if cancel is false to invoke {@link Graph#labelChanged}.
   */
  // applyValue(state: CellState, value: string): void;
  applyValue(state, value) {
    this.graph.labelChanged(state.cell, value, this.trigger);
  }
  /**
   * Sets the temporary horizontal alignment for the current editing session.
   */
  setAlign(align) {
    if (this.textarea) {
      this.textarea.style.textAlign = align;
    }
    this.align = align;
    this.resize();
  }
  /**
   * Gets the initial editing value for the given cell.
   */
  getInitialValue(state, trigger) {
    let result = htmlEntities(this.graph.getEditingValue(state.cell, trigger), false);
    result = replaceTrailingNewlines(result, "<div><br></div>");
    return result.replace(/\n/g, "<br>");
  }
  /**
   * Returns the current editing value.
   */
  getCurrentValue(state) {
    if (!this.textarea)
      return null;
    return extractTextWithWhitespace(Array.from(this.textarea.childNodes));
  }
  /**
   * Returns true if <escapeCancelsEditing> is true and shift, control and meta
   * are not pressed.
   */
  // isCancelEditingKeyEvent(evt: Event): boolean;
  isCancelEditingKeyEvent(evt) {
    return this.escapeCancelsEditing || isShiftDown(evt) || isControlDown(evt) || isMetaDown(evt);
  }
  /**
   * Installs listeners for focus, change and standard key event handling.
   */
  // installListeners(elt: Element): void;
  installListeners(elt) {
    InternalEvent.addListener(elt, "dragstart", (evt) => {
      this.graph.stopEditing(false);
      InternalEvent.consume(evt);
    });
    InternalEvent.addListener(elt, "blur", (evt) => {
      if (this.blurEnabled) {
        this.focusLost();
      }
    });
    InternalEvent.addListener(elt, "keydown", (evt) => {
      if (!isConsumed(evt)) {
        if (this.isStopEditingEvent(evt)) {
          this.graph.stopEditing(false);
          InternalEvent.consume(evt);
        } else if (evt.keyCode === 27) {
          this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));
          InternalEvent.consume(evt);
        }
      }
    });
    const keypressHandler = (evt) => {
      if (this.editingCell != null) {
        if (this.clearOnChange && elt.innerHTML === this.getEmptyLabelText() && (!Client.IS_FF || evt.keyCode !== 8 && evt.keyCode !== 46)) {
          this.clearOnChange = false;
          elt.innerHTML = "";
        }
      }
    };
    InternalEvent.addListener(elt, "keypress", keypressHandler);
    InternalEvent.addListener(elt, "paste", keypressHandler);
    const keyupHandler = (evt) => {
      if (this.editingCell != null) {
        const textarea = this.textarea;
        if (textarea.innerHTML.length === 0 || textarea.innerHTML === "<br>") {
          textarea.innerHTML = this.getEmptyLabelText();
          this.clearOnChange = textarea.innerHTML.length > 0;
        } else {
          this.clearOnChange = false;
        }
      }
    };
    InternalEvent.addListener(elt, "input", keyupHandler);
    InternalEvent.addListener(elt, "cut", keyupHandler);
    InternalEvent.addListener(elt, "paste", keyupHandler);
    const evtName = "input";
    const resizeHandler = (evt) => {
      if (this.editingCell != null && this.autoSize && !isConsumed(evt)) {
        if (this.resizeThread != null) {
          window.clearTimeout(this.resizeThread);
        }
        this.resizeThread = window.setTimeout(() => {
          this.resizeThread = null;
          this.resize();
        }, 0);
      }
    };
    InternalEvent.addListener(elt, evtName, resizeHandler);
    InternalEvent.addListener(window, "resize", resizeHandler);
    InternalEvent.addListener(elt, "cut", resizeHandler);
    InternalEvent.addListener(elt, "paste", resizeHandler);
  }
  /**
   * Returns true if the given keydown event should stop cell editing. This
   * returns true if F2 is pressed of if {@link Graph#enterStopsCellEditing} is true
   * and enter is pressed without control or shift.
   */
  isStopEditingEvent(evt) {
    return evt.keyCode === 113 || this.graph.isEnterStopsCellEditing() && evt.keyCode === 13 && !isControlDown(evt) && !isShiftDown(evt);
  }
  /**
   * Returns true if this editor is the source for the given native event.
   */
  isEventSource(evt) {
    return getSource(evt) === this.textarea;
  }
  /**
   * Returns {@link odified}.
   */
  resize() {
    const state = this.editingCell ? this.graph.getView().getState(this.editingCell) : null;
    if (!state) {
      this.stopEditing(true);
    } else if (this.textarea != null) {
      const isEdge = state.cell.isEdge();
      const { scale } = this.graph.getView();
      let m = null;
      if (!this.autoSize || state.style.overflow === "fill") {
        this.bounds = this.getEditorBounds(state);
        this.textarea.style.width = `${Math.round(this.bounds.width / scale)}px`;
        this.textarea.style.height = `${Math.round(this.bounds.height / scale)}px`;
        this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x + 1))}px`;
        this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y + 1))}px`;
        if (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML !== this.getEmptyLabelText()) {
          this.textarea.style.wordWrap = WORD_WRAP;
          this.textarea.style.whiteSpace = "normal";
          if (state.style.overflow !== "fill") {
            this.textarea.style.width = `${Math.round(this.bounds.width / scale) + this.wordWrapPadding}px`;
          }
        } else {
          this.textarea.style.whiteSpace = "nowrap";
          if (state.style.overflow !== "fill") {
            this.textarea.style.width = "";
          }
        }
      } else {
        const lw = state.style.labelWidth ?? null;
        m = state.text != null && this.align == null ? state.text.margin : null;
        if (m == null) {
          m = getAlignmentAsPoint(this.align ?? state.style.align ?? ALIGN.CENTER, state.style.verticalAlign ?? ALIGN.MIDDLE);
        }
        if (isEdge) {
          this.bounds = new Rectangle(state.absoluteOffset.x, state.absoluteOffset.y, 0, 0);
          if (lw != null) {
            const tmp = (lw + 2) * scale;
            this.bounds.width = tmp;
            this.bounds.x += m.x * tmp;
          }
        } else {
          let bounds = Rectangle.fromRectangle(state);
          let hpos = state.style.labelPosition ?? ALIGN.CENTER;
          let vpos = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;
          bounds = state.shape != null && hpos === "center" && vpos === "middle" ? state.shape.getLabelBounds(bounds) : bounds;
          if (lw != null) {
            bounds.width = lw * scale;
          }
          if (!state.view.graph.cellRenderer.legacySpacing || state.style.overflow !== "width") {
            const dummy = new TextShape();
            const spacing = (state.style.spacing ?? 2) * scale;
            const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;
            const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;
            const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;
            const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;
            hpos = state.style.labelPosition != null ? state.style.labelPosition : "center";
            vpos = state.style.verticalLabelPosition != null ? state.style.verticalLabelPosition : "middle";
            bounds = new Rectangle(bounds.x + spacingLeft, bounds.y + spacingTop, bounds.width - (hpos === ALIGN.CENTER && lw == null ? spacingLeft + spacingRight : 0), bounds.height - (vpos === ALIGN.MIDDLE ? spacingTop + spacingBottom : 0));
          }
          this.bounds = new Rectangle(bounds.x + state.absoluteOffset.x, bounds.y + state.absoluteOffset.y, bounds.width, bounds.height);
        }
        if (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML !== this.getEmptyLabelText()) {
          this.textarea.style.wordWrap = WORD_WRAP;
          this.textarea.style.whiteSpace = "normal";
          const tmp = Math.round(this.bounds.width / scale) + this.wordWrapPadding;
          if (this.textarea.style.position !== "relative") {
            this.textarea.style.width = `${tmp}px`;
            if (this.textarea.scrollWidth > tmp) {
              this.textarea.style.width = `${this.textarea.scrollWidth}px`;
            }
          } else {
            this.textarea.style.maxWidth = `${tmp}px`;
          }
        } else {
          this.textarea.style.whiteSpace = "nowrap";
          this.textarea.style.width = "";
        }
        this.textarea.scrollWidth;
        this.textarea.scrollHeight;
        this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1)}px`;
        this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + (m.y === -1 ? 3 : 0)) + 1)}px`;
      }
      setPrefixedStyle(this.textarea.style, "transformOrigin", "0px 0px");
      setPrefixedStyle(this.textarea.style, "transform", `scale(${scale},${scale})${m == null ? "" : ` translate(${m.x * 100}%,${m.y * 100}%)`}`);
    }
  }
  /**
   * Called if the textarea has lost focus.
   */
  focusLost() {
    this.stopEditing(!this.graph.isInvokesStopCellEditing());
  }
  /**
   * Returns the background color for the in-place editor. This implementation
   * always returns NONE.
   */
  getBackgroundColor(state) {
    return NONE;
  }
  /**
   * Starts the editor for the given cell.
   *
   * @param cell <Cell> to start editing.
   * @param trigger Optional mouse event that triggered the editor.
   */
  startEditing(cell, trigger = null) {
    this.stopEditing(true);
    this.align = null;
    if (this.textarea == null) {
      this.init();
    }
    const tooltipHandler = this.graph.getPlugin("TooltipHandler");
    tooltipHandler == null ? void 0 : tooltipHandler.hideTooltip();
    const state = this.graph.getView().getState(cell);
    if (state) {
      const { scale } = this.graph.getView();
      const size = state.style.fontSize ?? DEFAULT_FONTSIZE;
      const family = state.style.fontFamily ?? DEFAULT_FONTFAMILY;
      const color = state.style.fontColor ?? "black";
      const align = state.style.align ?? ALIGN.LEFT;
      const bold = (state.style.fontStyle || 0) & FONT.BOLD;
      const italic = (state.style.fontStyle || 0) & FONT.ITALIC;
      const txtDecor = [];
      if ((state.style.fontStyle || 0) & FONT.UNDERLINE) {
        txtDecor.push("underline");
      }
      if ((state.style.fontStyle || 0) & FONT.STRIKETHROUGH) {
        txtDecor.push("line-through");
      }
      const textarea = this.textarea;
      textarea.style.lineHeight = String(LINE_HEIGHT);
      textarea.style.backgroundColor = this.getBackgroundColor(state) || "transparent";
      textarea.style.textDecoration = txtDecor.join(" ");
      textarea.style.fontWeight = bold ? "bold" : "normal";
      textarea.style.fontStyle = italic ? "italic" : "";
      textarea.style.fontSize = `${Math.round(size)}px`;
      textarea.style.zIndex = String(this.zIndex);
      textarea.style.fontFamily = family;
      textarea.style.textAlign = align;
      textarea.style.outline = "none";
      textarea.style.color = color;
      let dir = this.textDirection = state.style.textDirection ?? DEFAULT_TEXT_DIRECTION;
      if (dir === "auto") {
        if (state.text !== null && state.text.dialect !== DIALECT.STRICTHTML && !isNode(state.text.value)) {
          dir = state.text.getAutoDirection();
        }
      }
      if (dir === "ltr" || dir === "rtl") {
        textarea.setAttribute("dir", dir);
      } else {
        textarea.removeAttribute("dir");
      }
      textarea.innerHTML = this.getInitialValue(state, trigger) || "";
      this.initialValue = textarea.innerHTML;
      if (textarea.innerHTML.length === 0 || textarea.innerHTML === "<br>") {
        textarea.innerHTML = this.getEmptyLabelText();
        this.clearOnChange = true;
      } else {
        this.clearOnChange = textarea.innerHTML === this.getEmptyLabelText();
      }
      this.graph.container.appendChild(textarea);
      this.editingCell = cell;
      this.trigger = trigger;
      this.textNode = null;
      if (state.text !== null && this.isHideLabel(state)) {
        this.textNode = state.text.node;
        this.textNode.style.visibility = "hidden";
      }
      if (this.autoSize && (state.cell.isEdge() || state.style.overflow !== "fill")) {
        window.setTimeout(() => {
          this.resize();
        }, 0);
      }
      this.resize();
      try {
        textarea.focus();
        if (this.isSelectText() && textarea.innerHTML.length > 0 && (textarea.innerHTML !== this.getEmptyLabelText() || !this.clearOnChange)) {
          document.execCommand("selectAll", false);
        }
      } catch (e) {
      }
    }
  }
  /**
   * Returns <selectText>.
   */
  isSelectText() {
    return this.selectText;
  }
  /**
    clearSelection() {
      const selection = window.getSelection();
  
      if (selection) {
        if (selection.empty) {
          selection.empty();
        } else if (selection.removeAllRanges) {
          selection.removeAllRanges();
        }
      }
    }
  
    /**
     * Stops the editor and applies the value if cancel is false.
     */
  stopEditing(cancel = false) {
    if (this.editingCell) {
      if (this.textNode) {
        this.textNode.style.visibility = "visible";
        this.textNode = null;
      }
      const state = !cancel ? this.graph.view.getState(this.editingCell) : null;
      const textarea = this.textarea;
      const initial = this.initialValue;
      this.initialValue = null;
      this.editingCell = null;
      this.bounds = null;
      textarea.blur();
      clearSelection();
      if (textarea.parentNode) {
        textarea.parentNode.removeChild(textarea);
      }
      if (this.clearOnChange && textarea.innerHTML === this.getEmptyLabelText()) {
        textarea.innerHTML = "";
        this.clearOnChange = false;
      }
      if (state && (textarea.innerHTML !== initial || this.align !== null)) {
        this.prepareTextarea();
        const value = this.getCurrentValue(state);
        this.graph.batchUpdate(() => {
          if (value !== null) {
            this.applyValue(state, value);
          }
          if (this.align !== null) {
            this.graph.setCellStyles("align", this.align, [state.cell]);
          }
        });
      }
      this.trigger = null;
      if (this.textarea)
        InternalEvent.release(this.textarea);
      this.textarea = null;
      this.align = null;
    }
  }
  /**
   * Prepares the textarea for getting its value in <stopEditing>.
   * This implementation removes the extra trailing linefeed in Firefox.
   */
  prepareTextarea() {
    const textarea = this.textarea;
    if (textarea.lastChild && textarea.lastChild.nodeName === "BR") {
      textarea.removeChild(textarea.lastChild);
    }
  }
  /**
   * Returns true if the label should be hidden while the cell is being
   * edited.
   */
  isHideLabel(state = null) {
    return true;
  }
  /**
   * Returns the minimum width and height for editing the given state.
   */
  getMinimumSize(state) {
    const { scale } = this.graph.getView();
    const textarea = this.textarea;
    return new Rectangle(0, 0, state.text === null ? 30 : state.text.size * scale + 20, textarea.style.textAlign === "left" ? 120 : 40);
  }
  /**
   * Returns the {@link Rectangle} that defines the bounds of the editor.
   */
  getEditorBounds(state) {
    const isEdge = state.cell.isEdge();
    const { scale } = this.graph.getView();
    const minSize = this.getMinimumSize(state);
    const minWidth = minSize.width;
    const minHeight = minSize.height;
    let result = null;
    if (!isEdge && state.view.graph.cellRenderer.legacySpacing && state.style.overflow === "fill") {
      result = state.shape.getLabelBounds(Rectangle.fromRectangle(state));
    } else {
      const dummy = new TextShape();
      const spacing = (state.style.spacing ?? 0) * scale;
      const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;
      const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;
      const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;
      const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;
      result = new Rectangle(state.x, state.y, Math.max(minWidth, state.width - spacingLeft - spacingRight), Math.max(minHeight, state.height - spacingTop - spacingBottom));
      const hpos = state.style.labelPosition != null ? state.style.labelPosition : "center";
      const vpos = state.style.verticalLabelPosition != null ? state.style.verticalLabelPosition : "middle";
      result = state.shape != null && hpos === "center" && vpos === "middle" ? state.shape.getLabelBounds(result) : result;
      if (isEdge) {
        result.x = state.absoluteOffset.x;
        result.y = state.absoluteOffset.y;
        if (state.text != null && state.text.boundingBox != null) {
          if (state.text.boundingBox.x > 0) {
            result.x = state.text.boundingBox.x;
          }
          if (state.text.boundingBox.y > 0) {
            result.y = state.text.boundingBox.y;
          }
        }
      } else if (state.text != null && state.text.boundingBox != null) {
        result.x = Math.min(result.x, state.text.boundingBox.x);
        result.y = Math.min(result.y, state.text.boundingBox.y);
      }
      result.x += spacingLeft;
      result.y += spacingTop;
      if (state.text != null && state.text.boundingBox != null) {
        if (!isEdge) {
          result.width = Math.max(result.width, state.text.boundingBox.width);
          result.height = Math.max(result.height, state.text.boundingBox.height);
        } else {
          result.width = Math.max(minWidth, state.text.boundingBox.width);
          result.height = Math.max(minHeight, state.text.boundingBox.height);
        }
      }
      if (state.cell.isVertex()) {
        const horizontal = state.style.labelPosition ?? ALIGN.CENTER;
        if (horizontal === "left") {
          result.x -= state.width;
        } else if (horizontal === "right") {
          result.x += state.width;
        }
        const vertical = state.style.verticalLabelPosition != null ? state.style.verticalLabelPosition : "middle";
        if (vertical === "top") {
          result.y -= state.height;
        } else if (vertical === "bottom") {
          result.y += state.height;
        }
      }
    }
    return new Rectangle(Math.round(result.x), Math.round(result.y), Math.round(result.width), Math.round(result.height));
  }
  /**
   * Returns the initial label value to be used of the label of the given
   * cell is empty. This label is displayed and cleared on the first keystroke.
   * This implementation returns <emptyLabelText>.
   *
   * @param cell <Cell> for which a text for an empty editing box should be
   * returned.
   */
  getEmptyLabelText(cell = null) {
    return this.emptyLabelText ?? "";
  }
  /**
   * Returns the cell that is currently being edited or null if no cell is
   * being edited.
   */
  getEditingCell() {
    return this.editingCell;
  }
  /**
   * Destroys the editor and removes all associated resources.
   */
  onDestroy() {
    if (this.textarea) {
      InternalEvent.release(this.textarea);
      if (this.textarea.parentNode) {
        this.textarea.parentNode.removeChild(this.textarea);
      }
      this.textarea = null;
    }
    this.graph.getDataModel().removeListener(this.changeHandler);
    this.graph.getView().removeListener(this.zoomHandler);
  }
}
CellEditorHandler.pluginId = "CellEditorHandler";
class TooltipHandler {
  /**
   * Creates the tooltip element and appends it to the document body.
   *
   */
  init() {
    if (document.body) {
      this.div = document.createElement("div");
      this.div.className = "mxTooltip";
      this.div.style.visibility = "hidden";
      document.body.appendChild(this.div);
      InternalEvent.addGestureListeners(this.div, (evt) => {
        const source = getSource(evt);
        if (source && source.nodeName !== "A") {
          this.hideTooltip();
        }
      });
      InternalEvent.addListener(this.graph.getContainer(), "mouseleave", (evt) => {
        if (this.div !== evt.relatedTarget) {
          this.hide();
        }
      });
    }
  }
  /**
   * Constructs an event handler that displays tooltips.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   */
  constructor(graph) {
    this.zIndex = 10005;
    this.delay = 500;
    this.ignoreTouchEvents = true;
    this.hideOnHover = false;
    this.destroyed = false;
    this.lastX = 0;
    this.lastY = 0;
    this.state = null;
    this.stateSource = false;
    this.thread = null;
    this.enabled = false;
    this.graph = graph;
    this.graph.addMouseListener(this);
  }
  /**
   * Returns `true` if events are handled.
   *
   * This implementation returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling.
   *
   * This implementation updates {@link enabled}.
   */
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Returns {@link hideOnHover}.
   */
  isHideOnHover() {
    return this.hideOnHover;
  }
  /**
   * Sets <hideOnHover>.
   */
  setHideOnHover(value) {
    this.hideOnHover = value;
  }
  /**
   * Returns the <CellState> to be used for showing a tooltip for this event.
   */
  getStateForEvent(me) {
    return me.getState();
  }
  /**
   * Handles the event by initiating a rubberband selection. By consuming the
   * event all subsequent events of the gesture are redirected to this
   * handler.
   */
  mouseDown(sender, me) {
    this.reset(me, false);
    this.hideTooltip();
  }
  /**
   * Handles the event by updating the rubberband selection.
   */
  mouseMove(sender, me) {
    if (me.getX() !== this.lastX || me.getY() !== this.lastY) {
      this.reset(me, true);
      const state = this.getStateForEvent(me);
      if (this.isHideOnHover() || state !== this.state || me.getSource() !== this.node && (!this.stateSource || state != null && this.stateSource === (me.isSource(state.shape) || !me.isSource(state.text)))) {
        this.hideTooltip();
      }
    }
    this.lastX = me.getX();
    this.lastY = me.getY();
  }
  /**
   * Handles the event by resetting the tooltip timer or hiding the existing
   * tooltip.
   */
  mouseUp(sender, me) {
    this.reset(me, true);
    this.hideTooltip();
  }
  /**
   * Resets the timer.
   */
  resetTimer() {
    if (this.thread) {
      window.clearTimeout(this.thread);
      this.thread = null;
    }
  }
  /**
   * Resets and/or restarts the timer to trigger the display of the tooltip.
   */
  reset(me, restart, state = null) {
    if (!this.ignoreTouchEvents || isMouseEvent(me.getEvent())) {
      this.resetTimer();
      state = state ?? this.getStateForEvent(me);
      if (restart && this.isEnabled() && state && (!this.div || this.div.style.visibility == "hidden")) {
        const node = me.getSource();
        const x = me.getX();
        const y = me.getY();
        const stateSource = me.isSource(state.shape) || me.isSource(state.text);
        const popupMenuHandler = this.graph.getPlugin("PopupMenuHandler");
        this.thread = window.setTimeout(() => {
          if (state && node && !this.graph.isEditing() && popupMenuHandler && !popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown) {
            const tip = this.graph.getTooltip(state, node, x, y);
            this.show(tip, x, y);
            this.state = state;
            this.node = node;
            this.stateSource = stateSource;
          }
        }, this.delay);
      }
    }
  }
  /**
   * Hides the tooltip and resets the timer.
   */
  hide() {
    this.resetTimer();
    this.hideTooltip();
  }
  /**
   * Hides the tooltip.
   */
  hideTooltip() {
    if (this.div) {
      this.div.style.visibility = "hidden";
      this.div.innerHTML = "";
    }
  }
  /**
   * Shows the tooltip for the specified cell and optional index at the
   * specified location (with a vertical offset of 10 pixels).
   */
  show(tip, x, y) {
    if (!this.destroyed && tip && tip !== "") {
      const origin = getScrollOrigin();
      if (!this.div) {
        this.init();
      }
      this.div.style.zIndex = String(this.zIndex);
      this.div.style.left = `${x + origin.x}px`;
      this.div.style.top = `${y + TOOLTIP_VERTICAL_OFFSET + origin.y}px`;
      if (!isNode(tip)) {
        this.div.innerHTML = tip.replace(/\n/g, "<br>");
      } else {
        this.div.innerHTML = "";
        this.div.appendChild(tip);
      }
      this.div.style.visibility = "";
      fit(this.div);
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    var _a;
    if (!this.destroyed) {
      this.resetTimer();
      this.graph.removeMouseListener(this);
      if (this.div) {
        InternalEvent.release(this.div);
      }
      if ((_a = this.div) == null ? void 0 : _a.parentNode) {
        this.div.parentNode.removeChild(this.div);
      }
      this.destroyed = true;
      this.div = null;
    }
  }
}
TooltipHandler.pluginId = "TooltipHandler";
class SelectionCellsHandler extends EventSource {
  constructor(graph) {
    super();
    this.enabled = true;
    this.maxHandlers = 100;
    this.graph = graph;
    this.handlers = new Dictionary();
    this.graph.addMouseListener(this);
    this.refreshHandler = (sender, evt) => {
      if (this.isEnabled()) {
        this.refresh();
      }
    };
    this.graph.getSelectionModel().addListener(InternalEvent.CHANGE, this.refreshHandler);
    this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.refreshHandler);
    this.graph.getView().addListener(InternalEvent.SCALE, this.refreshHandler);
    this.graph.getView().addListener(InternalEvent.TRANSLATE, this.refreshHandler);
    this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.refreshHandler);
    this.graph.getView().addListener(InternalEvent.DOWN, this.refreshHandler);
    this.graph.getView().addListener(InternalEvent.UP, this.refreshHandler);
  }
  /**
   * Returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Sets <enabled>.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * Returns the handler for the given cell.
   */
  getHandler(cell) {
    return this.handlers.get(cell);
  }
  /**
   * Returns true if the given cell has a handler.
   */
  isHandled(cell) {
    return !!this.getHandler(cell);
  }
  /**
   * Resets all handlers.
   */
  reset() {
    this.handlers.visit((key, handler) => {
      handler.reset.apply(handler);
    });
  }
  /**
   * Reloads or updates all handlers.
   */
  getHandledSelectionCells() {
    return this.graph.getSelectionCells();
  }
  /**
   * Reloads or updates all handlers.
   */
  refresh() {
    const oldHandlers = this.handlers;
    this.handlers = new Dictionary();
    const tmp = sortCells(this.getHandledSelectionCells(), false);
    for (let i = 0; i < tmp.length; i += 1) {
      const state = this.graph.view.getState(tmp[i]);
      if (state) {
        let handler = oldHandlers.remove(tmp[i]);
        if (handler) {
          if (handler.state !== state) {
            handler.onDestroy();
            handler = null;
          } else if (!this.isHandlerActive(handler)) {
            if (handler.refresh)
              handler.refresh();
            handler.redraw();
          }
        }
        if (handler) {
          this.handlers.put(tmp[i], handler);
        }
      }
    }
    oldHandlers.visit((key, handler) => {
      this.fireEvent(new EventObject(InternalEvent.REMOVE, { state: handler.state }));
      handler.onDestroy();
    });
    for (let i = 0; i < tmp.length; i += 1) {
      const state = this.graph.view.getState(tmp[i]);
      if (state) {
        let handler = this.handlers.get(tmp[i]);
        if (!handler) {
          handler = this.graph.createHandler(state);
          this.fireEvent(new EventObject(InternalEvent.ADD, { state }));
          this.handlers.put(tmp[i], handler);
        } else {
          handler.updateParentHighlight();
        }
      }
    }
  }
  /**
   * Returns true if the given handler is active and should not be redrawn.
   */
  isHandlerActive(handler) {
    return handler.index !== null;
  }
  /**
   * Updates the handler for the given shape if one exists.
   */
  updateHandler(state) {
    let handler = this.handlers.remove(state.cell);
    if (handler) {
      const { index } = handler;
      const x = handler.startX;
      const y = handler.startY;
      handler.onDestroy();
      handler = this.graph.createHandler(state);
      if (handler) {
        this.handlers.put(state.cell, handler);
        if (index !== null) {
          handler.start(x, y, index);
        }
      }
    }
  }
  /**
   * Redirects the given event to the handlers.
   */
  mouseDown(sender, me) {
    if (this.graph.isEnabled() && this.isEnabled()) {
      this.handlers.visit((key, handler) => {
        handler.mouseDown(sender, me);
      });
    }
  }
  /**
   * Redirects the given event to the handlers.
   */
  mouseMove(sender, me) {
    if (this.graph.isEnabled() && this.isEnabled()) {
      this.handlers.visit((key, handler) => {
        handler.mouseMove(sender, me);
      });
    }
  }
  /**
   * Redirects the given event to the handlers.
   */
  mouseUp(sender, me) {
    if (this.graph.isEnabled() && this.isEnabled()) {
      this.handlers.visit((key, handler) => {
        handler.mouseUp(sender, me);
      });
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.refreshHandler);
    this.graph.getDataModel().removeListener(this.refreshHandler);
    this.graph.getView().removeListener(this.refreshHandler);
  }
}
SelectionCellsHandler.pluginId = "SelectionCellsHandler";
class MaxPopupMenu extends EventSource {
  constructor(factoryMethod) {
    super();
    this.activeRow = null;
    this.eventReceiver = null;
    this.submenuImage = `${Client.imageBasePath}/submenu.gif`;
    this.zIndex = 10006;
    this.useLeftButtonForPopup = false;
    this.enabled = true;
    this.itemCount = 0;
    this.autoExpand = false;
    this.smartSeparators = false;
    this.labels = true;
    this.willAddSeparator = false;
    this.containsItems = false;
    if (factoryMethod) {
      this.factoryMethod = factoryMethod;
    }
    this.table = document.createElement("table");
    this.table.className = "mxPopupMenu";
    this.tbody = document.createElement("tbody");
    this.table.appendChild(this.tbody);
    this.div = document.createElement("div");
    this.div.className = "mxPopupMenu";
    this.div.style.display = "inline";
    this.div.style.zIndex = String(this.zIndex);
    this.div.appendChild(this.table);
    InternalEvent.disableContextMenu(this.div);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates <enabled>.
   */
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Returns true if the given event is a popupmenu trigger for the optional
   * given cell.
   *
   * @param me {@link MouseEvent} that represents the mouse event.
   */
  isPopupTrigger(me) {
    return me.isPopupTrigger() || this.useLeftButtonForPopup && isLeftMouseButton(me.getEvent());
  }
  /**
   * Adds the given item to the given parent item. If no parent item is specified
   * then the item is added to the top-level menu. The return value may be used
   * as the parent argument, ie. as a submenu item. The return value is the table
   * row that represents the item.
   *
   * Paramters:
   *
   * title - String that represents the title of the menu item.
   * image - Optional URL for the image icon.
   * funct - Function associated that takes a mouseup or touchend event.
   * parent - Optional item returned by <addItem>.
   * iconCls - Optional string that represents the CSS class for the image icon.
   * IconsCls is ignored if image is given.
   * enabled - Optional boolean indicating if the item is enabled. Default is true.
   * active - Optional boolean indicating if the menu should implement any event handling.
   * Default is true.
   * noHover - Optional boolean to disable hover state.
   */
  addItem(title, image, funct, parent = null, iconCls = null, enabled = true, active = true, noHover = false) {
    var _a;
    parent = parent ?? this;
    this.itemCount++;
    if (parent.willAddSeparator) {
      if (parent.containsItems) {
        this.addSeparator(parent, true);
      }
      parent.willAddSeparator = false;
    }
    parent.containsItems = true;
    const tr = document.createElement("tr");
    tr.className = "mxPopupMenuItem";
    const col1 = document.createElement("td");
    col1.className = "mxPopupMenuIcon";
    if (image) {
      const img = document.createElement("img");
      img.src = image;
      col1.appendChild(img);
    } else if (iconCls) {
      const div = document.createElement("div");
      div.className = iconCls;
      col1.appendChild(div);
    }
    tr.appendChild(col1);
    if (this.labels) {
      const col2 = document.createElement("td");
      col2.className = `mxPopupMenuItem${!enabled ? " mxDisabled" : ""}`;
      write(col2, title);
      col2.align = "left";
      tr.appendChild(col2);
      const col3 = document.createElement("td");
      col3.className = `mxPopupMenuItem${!enabled ? " mxDisabled" : ""}`;
      col3.style.paddingRight = "6px";
      col3.style.textAlign = "right";
      tr.appendChild(col3);
      if (parent.div == null) {
        this.createSubmenu(parent);
      }
    }
    (_a = parent.tbody) == null ? void 0 : _a.appendChild(tr);
    if (active && enabled) {
      InternalEvent.addGestureListeners(tr, (evt) => {
        this.eventReceiver = tr;
        if (parent && parent.activeRow != tr && parent.activeRow != parent) {
          if (parent.activeRow && parent.activeRow.div.parentNode) {
            this.hideSubmenu(parent);
          }
          if (tr.div) {
            this.showSubmenu(parent, tr);
            parent.activeRow = tr;
          }
        }
        InternalEvent.consume(evt);
      }, (_evt) => {
        if (parent && parent.activeRow != tr && parent.activeRow != parent) {
          if (parent.activeRow && parent.activeRow.div.parentNode) {
            this.hideSubmenu(parent);
          }
          if (this.autoExpand && tr.div) {
            this.showSubmenu(parent, tr);
            parent.activeRow = tr;
          }
        }
        if (!noHover) {
          tr.className = "mxPopupMenuItemHover";
        }
      }, (evt) => {
        if (this.eventReceiver == tr) {
          if (parent && parent.activeRow != tr) {
            this.hideMenu();
          }
          funct == null ? void 0 : funct(evt);
        }
        this.eventReceiver = null;
        InternalEvent.consume(evt);
      });
      if (!noHover) {
        InternalEvent.addListener(tr, "mouseout", (_evt) => {
          tr.className = "mxPopupMenuItem";
        });
      }
    }
    return tr;
  }
  /**
   * Adds a checkmark to the given menuitem.
   */
  addCheckmark(item, img) {
    if (item.firstChild) {
      const td = item.firstChild.nextSibling;
      td.style.backgroundImage = `url('${img}')`;
      td.style.backgroundRepeat = "no-repeat";
      td.style.backgroundPosition = "2px 50%";
    }
  }
  /**
   * Creates the nodes required to add submenu items inside the given parent
   * item. This is called in <addItem> if a parent item is used for the first
   * time. This adds various DOM nodes and a <submenuImage> to the parent.
   *
   * @param parent An item returned by <addItem>.
   */
  createSubmenu(parent) {
    var _a, _b;
    parent.table = document.createElement("table");
    parent.table.className = "mxPopupMenu";
    parent.tbody = document.createElement("tbody");
    parent.table.appendChild(parent.tbody);
    parent.div = document.createElement("div");
    parent.div.className = "mxPopupMenu";
    parent.div.style.position = "absolute";
    parent.div.style.display = "inline";
    parent.div.style.zIndex = String(this.zIndex);
    parent.div.appendChild(parent.table);
    const img = document.createElement("img");
    img.setAttribute("src", this.submenuImage);
    if ((_b = (_a = parent.firstChild) == null ? void 0 : _a.nextSibling) == null ? void 0 : _b.nextSibling) {
      const td = parent.firstChild.nextSibling.nextSibling;
      td.appendChild(img);
    }
  }
  /**
   * Shows the submenu inside the given parent row.
   */
  showSubmenu(parent, row) {
    if (row.div) {
      row.div.style.left = `${parent.div.offsetLeft + row.offsetLeft + row.offsetWidth - 1}px`;
      row.div.style.top = `${parent.div.offsetTop + row.offsetTop}px`;
      document.body.appendChild(row.div);
      const left = row.div.offsetLeft;
      const width = row.div.offsetWidth;
      const offset = getDocumentScrollOrigin(document);
      const b = document.body;
      const d = document.documentElement;
      const right = offset.x + (b.clientWidth || d.clientWidth);
      if (left + width > right) {
        row.div.style.left = `${Math.max(0, parent.div.offsetLeft - width - 6)}px`;
      }
      fit(row.div);
    }
  }
  /**
   * Adds a horizontal separator in the given parent item or the top-level menu
   * if no parent is specified.
   *
   * @param parent Optional item returned by <addItem>.
   * @param force Optional boolean to ignore <smartSeparators>. Default is false.
   */
  addSeparator(parent = null, force = false) {
    parent = parent || this;
    if (this.smartSeparators && !force) {
      parent.willAddSeparator = true;
    } else if (parent.tbody) {
      parent.willAddSeparator = false;
      const tr = document.createElement("tr");
      const col1 = document.createElement("td");
      col1.className = "mxPopupMenuIcon";
      col1.style.padding = "0 0 0 0px";
      tr.appendChild(col1);
      const col2 = document.createElement("td");
      col2.style.padding = "0 0 0 0px";
      col2.setAttribute("colSpan", "2");
      const hr = document.createElement("hr");
      hr.setAttribute("size", "1");
      col2.appendChild(hr);
      tr.appendChild(col2);
      parent.tbody.appendChild(tr);
    }
  }
  /**
   * Shows the popup menu for the given event and cell.
   *
   * Example:
   *
   * ```javascript
   * graph.getPlugin('PanningHandler').popup(x, y, cell, evt)
   * {
   *   mxUtils.alert('Hello, World!');
   * }
   * ```
   */
  popup(x, y, cell, evt) {
    if (this.div && this.tbody && this.factoryMethod) {
      this.div.style.left = `${x}px`;
      this.div.style.top = `${y}px`;
      while (this.tbody.firstChild) {
        InternalEvent.release(this.tbody.firstChild);
        this.tbody.removeChild(this.tbody.firstChild);
      }
      this.itemCount = 0;
      this.factoryMethod(this, cell, evt);
      if (this.itemCount > 0) {
        this.showMenu();
        this.fireEvent(new EventObject(InternalEvent.SHOW));
      }
    }
  }
  /**
   * Returns true if the menu is showing.
   */
  isMenuShowing() {
    return this.div && this.div.parentNode == document.body;
  }
  /**
   * Shows the menu.
   */
  showMenu() {
    document.body.appendChild(this.div);
    fit(this.div);
  }
  /**
   * Removes the menu and all submenus.
   */
  hideMenu() {
    var _a;
    if (this.div) {
      (_a = this.div.parentNode) == null ? void 0 : _a.removeChild(this.div);
      this.hideSubmenu(this);
      this.containsItems = false;
      this.fireEvent(new EventObject(InternalEvent.HIDE));
    }
  }
  /**
   * Removes all submenus inside the given parent.
   *
   * @param parent An item returned by <addItem>.
   */
  hideSubmenu(parent) {
    var _a;
    if (parent.activeRow) {
      this.hideSubmenu(parent.activeRow);
      (_a = parent.activeRow.div.parentNode) == null ? void 0 : _a.removeChild(parent.activeRow.div);
      parent.activeRow = null;
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  destroy() {
    var _a;
    if (this.div) {
      InternalEvent.release(this.div);
      (_a = this.div.parentNode) == null ? void 0 : _a.removeChild(this.div);
    }
  }
}
class PopupMenuHandler extends MaxPopupMenu {
  constructor(graph) {
    super();
    this.inTolerance = false;
    this.popupTrigger = false;
    this.selectOnPopup = true;
    this.clearSelectionOnBackground = true;
    this.triggerX = null;
    this.triggerY = null;
    this.screenX = null;
    this.screenY = null;
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.gestureHandler = (sender, eo) => {
      this.inTolerance = false;
    };
    this.graph.addListener(InternalEvent.GESTURE, this.gestureHandler);
    this.init();
  }
  /**
   * Initializes the shapes required for this vertex handler.
   */
  init() {
    InternalEvent.addGestureListeners(this.div, (evt) => {
      const tooltipHandler = this.graph.getPlugin("TooltipHandler");
      tooltipHandler == null ? void 0 : tooltipHandler.hide();
    });
  }
  /**
   * Hook for returning if a cell should be selected for a given {@link MouseEvent}.
   * This implementation returns <selectOnPopup>.
   */
  isSelectOnPopup(me) {
    return this.selectOnPopup;
  }
  /**
   * Handles the event by initiating the panning. By consuming the event all
   * subsequent events of the gesture are redirected to this handler.
   */
  mouseDown(sender, me) {
    if (this.isEnabled() && !isMultiTouchEvent(me.getEvent())) {
      this.hideMenu();
      this.triggerX = me.getGraphX();
      this.triggerY = me.getGraphY();
      this.screenX = getMainEvent(me.getEvent()).screenX;
      this.screenY = getMainEvent(me.getEvent()).screenY;
      this.popupTrigger = this.isPopupTrigger(me);
      this.inTolerance = true;
    }
  }
  /**
   * Handles the event by updating the panning on the graph.
   */
  mouseMove(sender, me) {
    if (this.inTolerance && this.screenX != null && this.screenY != null) {
      if (Math.abs(getMainEvent(me.getEvent()).screenX - this.screenX) > this.graph.getEventTolerance() || Math.abs(getMainEvent(me.getEvent()).screenY - this.screenY) > this.graph.getEventTolerance()) {
        this.inTolerance = false;
      }
    }
  }
  /**
   * Handles the event by setting the translation on the view or showing the
   * popupmenu.
   */
  mouseUp(sender, me) {
    if (this.popupTrigger && this.inTolerance && this.triggerX != null && this.triggerY != null) {
      const cell = this.getCellForPopupEvent(me);
      if (this.graph.isEnabled() && this.isSelectOnPopup(me) && cell != null && !this.graph.isCellSelected(cell)) {
        this.graph.setSelectionCell(cell);
      } else if (this.clearSelectionOnBackground && cell == null) {
        this.graph.clearSelection();
      }
      const tooltipHandler = this.graph.getPlugin("TooltipHandler");
      tooltipHandler == null ? void 0 : tooltipHandler.hide();
      const origin = getScrollOrigin();
      this.popup(me.getX() + origin.x + 1, me.getY() + origin.y + 1, cell, me.getEvent());
      me.consume();
    }
    this.popupTrigger = false;
    this.inTolerance = false;
  }
  /**
   * Hook to return the cell for the mouse up popup trigger handling.
   */
  getCellForPopupEvent(me) {
    return me.getCell();
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.gestureHandler);
    super.destroy();
  }
}
PopupMenuHandler.pluginId = "PopupMenuHandler";
class ConnectionHandler extends EventSource {
  /**
   * Constructs an event handler that connects vertices using the specified
   * factory method to create the new edges.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   * @param factoryMethod Optional function to create the edge. The function takes
   * the source and target {@link Cell} as the first and second argument and an
   * optional cell style from the preview as the third argument. It returns
   * the {@link Cell} that represents the new edge.
   */
  constructor(graph, factoryMethod = null) {
    super();
    this.previous = null;
    this.iconState = null;
    this.icons = [];
    this.cell = null;
    this.currentPoint = null;
    this.sourceConstraint = null;
    this.shape = null;
    this.icon = null;
    this.originalPoint = null;
    this.currentState = null;
    this.selectedIcon = null;
    this.waypoints = [];
    this.factoryMethod = null;
    this.moveIconFront = false;
    this.moveIconBack = false;
    this.connectImage = null;
    this.targetConnectImage = false;
    this.enabled = false;
    this.select = true;
    this.createTarget = false;
    this.error = null;
    this.waypointsEnabled = false;
    this.ignoreMouseDown = false;
    this.first = null;
    this.connectIconOffset = new Point(0, TOOLTIP_VERTICAL_OFFSET);
    this.edgeState = null;
    this.mouseDownCounter = 0;
    this.movePreviewAway = false;
    this.outlineConnect = false;
    this.livePreview = false;
    this.cursor = null;
    this.insertBeforeSource = false;
    this.graph = graph;
    this.factoryMethod = factoryMethod;
    this.graph.addMouseListener(this);
    this.marker = this.createMarker();
    this.constraintHandler = new ConstraintHandler(this.graph);
    this.changeHandler = (sender) => {
      if (this.iconState) {
        this.iconState = this.graph.getView().getState(this.iconState.cell);
      }
      if (this.iconState) {
        this.redrawIcons(this.icons, this.iconState);
        this.constraintHandler.reset();
      } else if (this.previous && !this.graph.view.getState(this.previous.cell)) {
        this.reset();
      }
    };
    this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);
    this.graph.getView().addListener(InternalEvent.SCALE, this.changeHandler);
    this.graph.getView().addListener(InternalEvent.TRANSLATE, this.changeHandler);
    this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.changeHandler);
    this.drillHandler = (sender) => {
      this.reset();
    };
    this.graph.addListener(InternalEvent.START_EDITING, this.drillHandler);
    this.graph.getView().addListener(InternalEvent.DOWN, this.drillHandler);
    this.graph.getView().addListener(InternalEvent.UP, this.drillHandler);
    this.escapeHandler = () => {
      this.reset();
    };
    this.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates <enabled>.
   *
   * @param enabled Boolean that specifies the new enabled state.
   */
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Returns <insertBeforeSource> for non-loops and false for loops.
   *
   * @param edge <Cell> that represents the edge to be inserted.
   * @param source <Cell> that represents the source terminal.
   * @param target <Cell> that represents the target terminal.
   * @param evt Mousedown event of the connect gesture.
   * @param dropTarget <Cell> that represents the cell under the mouse when it was
   * released.
   */
  isInsertBefore(edge, source, target, evt, dropTarget) {
    return this.insertBeforeSource && source !== target;
  }
  /**
   * Returns <createTarget>.
   *
   * @param evt Current active native pointer event.
   */
  isCreateTarget(evt) {
    return this.createTarget;
  }
  /**
   * Sets <createTarget>.
   */
  setCreateTarget(value) {
    this.createTarget = value;
  }
  /**
   * Creates the preview shape for new connections.
   */
  createShape() {
    const shape = this.livePreview && this.edgeState ? this.graph.cellRenderer.createShape(this.edgeState) : new PolylineShape([], INVALID_COLOR);
    if (shape && shape.node) {
      shape.dialect = DIALECT.SVG;
      shape.scale = this.graph.view.scale;
      shape.pointerEvents = false;
      shape.isDashed = true;
      shape.init(this.graph.getView().getOverlayPane());
      InternalEvent.redirectMouseEvents(shape.node, this.graph, null);
    }
    return shape;
  }
  /**
   * Returns true if the given cell is connectable. This is a hook to
   * disable floating connections. This implementation returns true.
   */
  isConnectableCell(cell) {
    return true;
  }
  /**
   * Creates and returns the {@link CellMarker} used in {@link arker}.
   */
  createMarker() {
    return new ConnectionHandlerCellMarker(this.graph, this);
  }
  /**
   * Starts a new connection for the given state and coordinates.
   */
  start(state, x, y, edgeState) {
    this.previous = state;
    this.first = new Point(x, y);
    this.edgeState = edgeState ?? this.createEdgeState();
    this.marker.currentColor = this.marker.validColor;
    this.marker.markedState = state;
    this.marker.mark();
    this.fireEvent(new EventObject(InternalEvent.START, { state: this.previous }));
  }
  /**
   * Returns true if the source terminal has been clicked and a new
   * connection is currently being previewed.
   */
  isConnecting() {
    return !!this.first && !!this.shape;
  }
  /**
   * Returns {@link Graph#isValidSource} for the given source terminal.
   *
   * @param cell <Cell> that represents the source terminal.
   * @param me {@link MouseEvent} that is associated with this call.
   */
  isValidSource(cell, me) {
    return this.graph.isValidSource(cell);
  }
  /**
   * Returns true. The call to {@link Graph#isValidTarget} is implicit by calling
   * {@link Graph#getEdgeValidationError} in <validateConnection>. This is an
   * additional hook for disabling certain targets in this specific handler.
   *
   * @param cell <Cell> that represents the target terminal.
   */
  isValidTarget(cell) {
    return true;
  }
  /**
   * Returns the error message or an empty string if the connection for the
   * given source target pair is not valid. Otherwise it returns null. This
   * implementation uses {@link Graph#getEdgeValidationError}.
   *
   * @param source <Cell> that represents the source terminal.
   * @param target <Cell> that represents the target terminal.
   */
  validateConnection(source, target) {
    if (!this.isValidTarget(target)) {
      return "";
    }
    return this.graph.getEdgeValidationError(null, source, target);
  }
  /**
   * Hook to return the {@link Image} used for the connection icon of the given
   * {@link CellState}. This implementation returns {@link connectImage}.
   *
   * @param state {@link CellState} whose connect image should be returned.
   */
  getConnectImage(state) {
    return this.connectImage;
  }
  /**
   * Returns true if the state has a HTML label in the graph's container, otherwise
   * it returns {@link oveIconFront}.
   *
   * @param state <CellState> whose connect icons should be returned.
   */
  isMoveIconToFrontForState(state) {
    if (state.text && state.text.node.parentNode === this.graph.container) {
      return true;
    }
    return this.moveIconFront;
  }
  /**
   * Creates the array {@link ImageShape}s that represent the connect icons for
   * the given {@link CellState}.
   *
   * @param state {@link CellState} whose connect icons should be returned.
   */
  createIcons(state) {
    const image = this.getConnectImage(state);
    if (image) {
      this.iconState = state;
      const icons = [];
      const bounds = new Rectangle(0, 0, image.width, image.height);
      const icon = new ImageShape(bounds, image.src, void 0, void 0, 0);
      icon.preserveImageAspect = false;
      if (this.isMoveIconToFrontForState(state)) {
        icon.dialect = DIALECT.STRICTHTML;
        icon.init(this.graph.container);
      } else {
        icon.dialect = DIALECT.SVG;
        icon.init(this.graph.getView().getOverlayPane());
        if (this.moveIconBack && icon.node.parentNode && icon.node.previousSibling) {
          icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);
        }
      }
      icon.node.style.cursor = CURSOR.CONNECT;
      const getState = () => {
        return this.currentState ?? state;
      };
      const mouseDown = (evt) => {
        if (!isConsumed(evt)) {
          this.icon = icon;
          this.graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, getState()));
        }
      };
      InternalEvent.redirectMouseEvents(icon.node, this.graph, getState, mouseDown);
      icons.push(icon);
      this.redrawIcons(icons, this.iconState);
      return icons;
    }
    return [];
  }
  /**
   * Redraws the given array of {@link ImageShapes}.
   *
   * @param icons Array of {@link ImageShapes} to be redrawn.
   */
  redrawIcons(icons, state) {
    if (icons[0] && icons[0].bounds) {
      const pos = this.getIconPosition(icons[0], state);
      icons[0].bounds.x = pos.x;
      icons[0].bounds.y = pos.y;
      icons[0].redraw();
    }
  }
  // TODO: Document me! ===========================================================================================================
  getIconPosition(icon, state) {
    const { scale } = this.graph.getView();
    let cx = state.getCenterX();
    let cy = state.getCenterY();
    if (this.graph.isSwimlane(state.cell)) {
      const size = this.graph.getStartSize(state.cell);
      cx = size.width !== 0 ? state.x + size.width * scale / 2 : cx;
      cy = size.height !== 0 ? state.y + size.height * scale / 2 : cy;
      const alpha = toRadians(state.style.rotation ?? 0);
      if (alpha !== 0) {
        const cos = Math.cos(alpha);
        const sin = Math.sin(alpha);
        const ct = new Point(state.getCenterX(), state.getCenterY());
        const pt = getRotatedPoint(new Point(cx, cy), cos, sin, ct);
        cx = pt.x;
        cy = pt.y;
      }
    }
    return new Point(cx - icon.bounds.width / 2, cy - icon.bounds.height / 2);
  }
  /**
   * Destroys the connect icons and resets the respective state.
   */
  destroyIcons() {
    for (let i = 0; i < this.icons.length; i += 1) {
      this.icons[i].destroy();
    }
    this.icons = [];
    this.icon = null;
    this.selectedIcon = null;
    this.iconState = null;
  }
  /**
   * Returns true if the given mouse down event should start this handler. The
   * This implementation returns true if the event does not force marquee
   * selection, and the currentConstraint and currentFocus of the
   * <constraintHandler> are not null, or <previous> and <error> are not null and
   * <icons> is null or <icons> and <icon> are not null.
   */
  isStartEvent(me) {
    return this.constraintHandler.currentFocus !== null && this.constraintHandler.currentConstraint !== null || this.previous !== null && this.error === null && (this.icons.length === 0 || this.icon !== null);
  }
  /**
   * Handles the event by initiating a new connection.
   */
  mouseDown(sender, me) {
    this.mouseDownCounter += 1;
    if (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() && !this.isConnecting() && this.isStartEvent(me)) {
      if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus && this.constraintHandler.currentPoint) {
        this.sourceConstraint = this.constraintHandler.currentConstraint;
        this.previous = this.constraintHandler.currentFocus;
        this.first = this.constraintHandler.currentPoint.clone();
      } else {
        this.first = new Point(me.getGraphX(), me.getGraphY());
      }
      this.edgeState = this.createEdgeState(me);
      this.mouseDownCounter = 1;
      if (this.waypointsEnabled && !this.shape) {
        this.waypoints = [];
        this.shape = this.createShape();
        if (this.edgeState) {
          this.shape.apply(this.edgeState);
        }
      }
      if (!this.previous && this.edgeState && this.edgeState.cell.geometry) {
        const pt = this.graph.getPointForEvent(me.getEvent());
        this.edgeState.cell.geometry.setTerminalPoint(pt, true);
      }
      this.fireEvent(new EventObject(InternalEvent.START, { state: this.previous }));
      me.consume();
    }
    this.selectedIcon = this.icon;
    this.icon = null;
  }
  /**
   * Returns true if a tap on the given source state should immediately start
   * connecting. This implementation returns true if the state is not movable
   * in the graph.
   */
  isImmediateConnectSource(state) {
    return !this.graph.isCellMovable(state.cell);
  }
  /**
   * Hook to return an <CellState> which may be used during the preview.
   * This implementation returns null.
   *
   * Use the following code to create a preview for an existing edge style:
   *
   * ```javascript
   * graph.getPlugin('ConnectionHandler').createEdgeState(me)
   * {
   *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');
   *
   *   return new CellState(this.graph.view, edge, this.graph.getCellStyle(edge));
   * };
   * ```
   */
  createEdgeState(me) {
    return null;
  }
  /**
   * Returns true if <outlineConnect> is true and the source of the event is the outline shape
   * or shift is pressed.
   */
  isOutlineConnectEvent(me) {
    if (!this.currentPoint)
      return false;
    const offset = getOffset(this.graph.container);
    const evt = me.getEvent();
    const clientX = getClientX(evt);
    const clientY = getClientY(evt);
    const doc = document.documentElement;
    const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
    const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;
    return this.outlineConnect && !isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX !== clientX || gridY !== clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));
  }
  /**
   * Updates the current state for a given mouse move event by using
   * the {@link arker}.
   */
  updateCurrentState(me, point) {
    this.constraintHandler.update(me, !this.first, false, !this.first || me.isSource(this.marker.highlight.shape) ? null : point);
    if (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) {
      if (this.marker.highlight && this.marker.highlight.state && this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell && this.marker.highlight.shape) {
        if (this.marker.highlight.shape.stroke !== "transparent") {
          this.marker.highlight.shape.stroke = "transparent";
          this.marker.highlight.repaint();
        }
      } else {
        this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent");
      }
      if (this.previous) {
        this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);
        if (!this.error) {
          this.currentState = this.constraintHandler.currentFocus;
        }
        if (this.error || this.currentState && !this.isCellEnabled(this.currentState.cell)) {
          this.constraintHandler.reset();
        }
      }
    } else {
      if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
        this.marker.reset();
        this.currentState = null;
      } else {
        this.marker.process(me);
        this.currentState = this.marker.getValidState();
      }
      if (this.currentState != null && !this.isCellEnabled(this.currentState.cell)) {
        this.constraintHandler.reset();
        this.marker.reset();
        this.currentState = null;
      }
      const outline = this.isOutlineConnectEvent(me);
      if (this.currentState != null && outline) {
        if (me.isSource(this.marker.highlight.shape)) {
          point = new Point(me.getGraphX(), me.getGraphY());
        }
        const constraint = this.graph.getOutlineConstraint(point, this.currentState, me);
        this.constraintHandler.setFocus(me, this.currentState, false);
        this.constraintHandler.currentConstraint = constraint;
        this.constraintHandler.currentPoint = point;
      }
      if (this.outlineConnect) {
        if (this.marker.highlight != null && this.marker.highlight.shape != null) {
          const s = this.graph.view.scale;
          if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
            this.marker.highlight.shape.stroke = OUTLINE_HIGHLIGHT_COLOR;
            this.marker.highlight.shape.strokeWidth = OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;
            this.marker.highlight.repaint();
          } else if (this.marker.hasValidState()) {
            const cell = me.getCell();
            if (cell && cell.isConnectable() && this.marker.getValidState() !== me.getState()) {
              this.marker.highlight.shape.stroke = "transparent";
              this.currentState = null;
            } else {
              this.marker.highlight.shape.stroke = DEFAULT_VALID_COLOR;
            }
            this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;
            this.marker.highlight.repaint();
          }
        }
      }
    }
  }
  /**
   * Returns true if the given cell does not allow new connections to be created.
   */
  isCellEnabled(cell) {
    return true;
  }
  /**
   * Converts the given point from screen coordinates to model coordinates.
   */
  convertWaypoint(point) {
    const scale = this.graph.getView().getScale();
    const tr = this.graph.getView().getTranslate();
    point.x = point.x / scale - tr.x;
    point.y = point.y / scale - tr.y;
  }
  /**
   * Called to snap the given point to the current preview. This snaps to the
   * first point of the preview if alt is not pressed.
   */
  snapToPreview(me, point) {
    if (!isAltDown(me.getEvent()) && this.previous) {
      const tol = this.graph.getGridSize() * this.graph.view.scale / 2;
      const tmp = this.sourceConstraint && this.first ? this.first : new Point(this.previous.getCenterX(), this.previous.getCenterY());
      if (Math.abs(tmp.x - me.getGraphX()) < tol) {
        point.x = tmp.x;
      }
      if (Math.abs(tmp.y - me.getGraphY()) < tol) {
        point.y = tmp.y;
      }
    }
  }
  /**
   * Handles the event by updating the preview edge or by highlighting
   * a possible source or target terminal.
   */
  mouseMove(sender, me) {
    if (!me.isConsumed() && (this.ignoreMouseDown || this.first || !this.graph.isMouseDown)) {
      if (!this.isEnabled() && this.currentState) {
        this.destroyIcons();
        this.currentState = null;
      }
      const view = this.graph.getView();
      const { scale } = view;
      const tr = view.translate;
      let point = new Point(me.getGraphX(), me.getGraphY());
      this.error = null;
      if (this.graph.isGridEnabledEvent(me.getEvent())) {
        point = new Point((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale, (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);
      }
      this.snapToPreview(me, point);
      this.currentPoint = point;
      if ((this.first || this.isEnabled() && this.graph.isEnabled()) && (this.shape || !this.first || Math.abs(me.getGraphX() - this.first.x) > this.graph.getEventTolerance() || Math.abs(me.getGraphY() - this.first.y) > this.graph.getEventTolerance())) {
        this.updateCurrentState(me, point);
      }
      if (this.first) {
        let constraint = null;
        let current = point;
        if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus && this.constraintHandler.currentPoint) {
          constraint = this.constraintHandler.currentConstraint;
          current = this.constraintHandler.currentPoint.clone();
        } else if (this.previous && !this.graph.isIgnoreTerminalEvent(me.getEvent()) && isShiftDown(me.getEvent())) {
          if (Math.abs(this.previous.getCenterX() - point.x) < Math.abs(this.previous.getCenterY() - point.y)) {
            point.x = this.previous.getCenterX();
          } else {
            point.y = this.previous.getCenterY();
          }
        }
        let pt2 = this.first;
        if (this.selectedIcon && this.selectedIcon.bounds) {
          const w = this.selectedIcon.bounds.width;
          const h = this.selectedIcon.bounds.height;
          if (this.currentState && this.targetConnectImage) {
            const pos = this.getIconPosition(this.selectedIcon, this.currentState);
            this.selectedIcon.bounds.x = pos.x;
            this.selectedIcon.bounds.y = pos.y;
          } else {
            const bounds = new Rectangle(me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, w, h);
            this.selectedIcon.bounds = bounds;
          }
          this.selectedIcon.redraw();
        }
        if (this.edgeState) {
          this.updateEdgeState(current, constraint);
          current = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];
          pt2 = this.edgeState.absolutePoints[0];
        } else {
          if (this.currentState) {
            if (!this.constraintHandler.currentConstraint) {
              const tmp = this.getTargetPerimeterPoint(this.currentState, me);
              if (tmp != null) {
                current = tmp;
              }
            }
          }
          if (!this.sourceConstraint && this.previous) {
            const next = this.waypoints.length > 0 ? this.waypoints[0] : current;
            const tmp = this.getSourcePerimeterPoint(this.previous, next, me);
            if (tmp) {
              pt2 = tmp;
            }
          }
        }
        if (!this.currentState && this.movePreviewAway && current) {
          let tmp = pt2;
          if (this.edgeState && this.edgeState.absolutePoints.length >= 2) {
            const tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];
            if (tmp2) {
              tmp = tmp2;
            }
          }
          if (tmp) {
            const dx = current.x - tmp.x;
            const dy = current.y - tmp.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len === 0) {
              return;
            }
            this.originalPoint = current.clone();
            current.x -= dx * 4 / len;
            current.y -= dy * 4 / len;
          }
        } else {
          this.originalPoint = null;
        }
        if (!this.shape) {
          const dx = Math.abs(me.getGraphX() - this.first.x);
          const dy = Math.abs(me.getGraphY() - this.first.y);
          if (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance()) {
            this.shape = this.createShape();
            if (this.edgeState) {
              this.shape.apply(this.edgeState);
            }
            this.updateCurrentState(me, point);
          }
        }
        if (this.shape) {
          if (this.edgeState) {
            this.shape.points = this.edgeState.absolutePoints;
          } else {
            let pts = [pt2];
            if (this.waypoints.length > 0) {
              pts = pts.concat(this.waypoints);
            }
            pts.push(current);
            this.shape.points = pts;
          }
          this.drawPreview();
        }
        if (this.cursor) {
          this.graph.container.style.cursor = this.cursor;
        }
        InternalEvent.consume(me.getEvent());
        me.consume();
      } else if (!this.isEnabled() || !this.graph.isEnabled()) {
        this.constraintHandler.reset();
      } else if (this.previous !== this.currentState && !this.edgeState) {
        this.destroyIcons();
        if (this.currentState && !this.error && !this.constraintHandler.currentConstraint) {
          this.icons = this.createIcons(this.currentState);
          if (this.icons.length === 0) {
            this.currentState.setCursor(CURSOR.CONNECT);
            me.consume();
          }
        }
        this.previous = this.currentState;
      } else if (this.previous === this.currentState && this.currentState != null && this.icons.length === 0 && !this.graph.isMouseDown) {
        me.consume();
      }
      if (!this.graph.isMouseDown && this.currentState != null && this.icons != null) {
        let hitsIcon = false;
        const target = me.getSource();
        for (let i = 0; i < this.icons.length && !hitsIcon; i += 1) {
          hitsIcon = target === this.icons[i].node || // @ts-ignore parentNode should exist.
          !!target && target.parentNode === this.icons[i].node;
        }
        if (!hitsIcon) {
          this.updateIcons(this.currentState, this.icons, me);
        }
      }
    } else {
      this.constraintHandler.reset();
    }
  }
  /**
   * Updates <edgeState>.
   */
  updateEdgeState(current, constraint) {
    if (!this.edgeState)
      return;
    if (this.sourceConstraint && this.sourceConstraint.point) {
      this.edgeState.style.exitX = this.sourceConstraint.point.x;
      this.edgeState.style.exitY = this.sourceConstraint.point.y;
    }
    if (constraint && constraint.point) {
      this.edgeState.style.entryX = constraint.point.x;
      this.edgeState.style.entryY = constraint.point.y;
    } else {
      this.edgeState.style.entryX = 0;
      this.edgeState.style.entryY = 0;
    }
    this.edgeState.absolutePoints = [null, this.currentState != null ? null : current];
    if (this.sourceConstraint) {
      this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);
    }
    if (this.currentState != null) {
      if (constraint == null) {
        constraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);
      }
      this.edgeState.setAbsoluteTerminalPoint(null, false);
      this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);
    }
    const realPoints = [];
    for (let i = 0; i < this.waypoints.length; i += 1) {
      const pt = this.waypoints[i].clone();
      this.convertWaypoint(pt);
      realPoints[i] = pt;
    }
    this.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);
    this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);
  }
  /**
   * Returns the perimeter point for the given target state.
   *
   * @param state <CellState> that represents the target cell state.
   * @param _me {@link MouseEvent} that represents the mouse move.
   */
  getTargetPerimeterPoint(state, _me) {
    let result = null;
    const { view } = state;
    const targetPerimeter = view.getPerimeterFunction(state);
    if (targetPerimeter && this.previous && this.edgeState) {
      const next = this.waypoints.length > 0 ? this.waypoints[this.waypoints.length - 1] : new Point(this.previous.getCenterX(), this.previous.getCenterY());
      const tmp = targetPerimeter(view.getPerimeterBounds(state), this.edgeState, next, false);
      if (tmp) {
        result = tmp;
      }
    } else {
      result = new Point(state.getCenterX(), state.getCenterY());
    }
    return result;
  }
  /**
   * Hook to update the icon position(s) based on a mouseOver event. This is
   * an empty implementation.
   *
   * @param state <CellState> that represents the target cell state.
   * @param next {@link Point} that represents the next point along the previewed edge.
   * @param me {@link MouseEvent} that represents the mouse move.
   */
  getSourcePerimeterPoint(state, next, me) {
    let result = null;
    const { view } = state;
    const sourcePerimeter = view.getPerimeterFunction(state);
    const c = new Point(state.getCenterX(), state.getCenterY());
    if (sourcePerimeter) {
      const theta = state.style.rotation ?? 0;
      const rad = -theta * (Math.PI / 180);
      if (theta !== 0) {
        next = getRotatedPoint(new Point(next.x, next.y), Math.cos(rad), Math.sin(rad), c);
      }
      let tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);
      if (tmp) {
        if (theta !== 0) {
          tmp = getRotatedPoint(new Point(tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);
        }
        result = tmp;
      }
    } else {
      result = c;
    }
    return result;
  }
  /**
   * Hook to update the icon position(s) based on a mouseOver event. This is
   * an empty implementation.
   *
   * @param state <CellState> under the mouse.
   * @param icons Array of currently displayed icons.
   * @param me {@link MouseEvent} that contains the mouse event.
   */
  updateIcons(state, icons, me) {
  }
  /**
   * Returns true if the given mouse up event should stop this handler. The
   * connection will be created if <error> is null. Note that this is only
   * called if <waypointsEnabled> is true. This implemtation returns true
   * if there is a cell state in the given event.
   */
  isStopEvent(me) {
    return !!me.getState();
  }
  /**
   * Adds the waypoint for the given event to <waypoints>.
   */
  addWaypointForEvent(me) {
    if (!this.first)
      return;
    let point = convertPoint(this.graph.container, me.getX(), me.getY());
    const dx = Math.abs(point.x - this.first.x);
    const dy = Math.abs(point.y - this.first.y);
    const addPoint = this.waypoints.length > 0 || this.mouseDownCounter > 1 && (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance());
    if (addPoint) {
      const { scale } = this.graph.view;
      point = new Point(this.graph.snap(me.getGraphX() / scale) * scale, this.graph.snap(me.getGraphY() / scale) * scale);
      this.waypoints.push(point);
    }
  }
  /**
   * Returns true if the connection for the given constraints is valid. This
   * implementation returns true if the constraints are not pointing to the
   * same fixed connection point.
   */
  checkConstraints(c1, c2) {
    return !c1 || !c2 || !c1.point || !c2.point || !c1.point.equals(c2.point) || c1.dx !== c2.dx || c1.dy !== c2.dy || c1.perimeter !== c2.perimeter;
  }
  /**
   * Handles the event by inserting the new connection.
   */
  mouseUp(sender, me) {
    if (!me.isConsumed() && this.isConnecting()) {
      if (this.waypointsEnabled && !this.isStopEvent(me)) {
        this.addWaypointForEvent(me);
        me.consume();
        return;
      }
      const c1 = this.sourceConstraint;
      const c2 = this.constraintHandler.currentConstraint;
      const source = this.previous ? this.previous.cell : null;
      let target = null;
      if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus) {
        target = this.constraintHandler.currentFocus.cell;
      }
      if (!target && this.currentState) {
        target = this.currentState.cell;
      }
      if (!this.error && (!source || !target || source !== target || this.checkConstraints(c1, c2))) {
        this.connect(source, target, me.getEvent(), me.getCell());
      } else {
        if (this.previous != null && this.marker.validState != null && this.previous.cell === this.marker.validState.cell) {
          this.graph.selectCellForEvent(this.marker.validState.cell, me.getEvent());
        }
        if (this.error != null && this.error.length > 0) {
          this.graph.validationAlert(this.error);
        }
      }
      this.destroyIcons();
      me.consume();
    }
    if (this.first != null) {
      this.reset();
    }
  }
  /**
   * Resets the state of this handler.
   */
  reset() {
    if (this.shape != null) {
      this.shape.destroy();
      this.shape = null;
    }
    if (this.cursor != null && this.graph.container != null) {
      this.graph.container.style.cursor = "";
    }
    this.destroyIcons();
    this.marker.reset();
    this.constraintHandler.reset();
    this.originalPoint = null;
    this.currentPoint = null;
    this.edgeState = null;
    this.previous = null;
    this.error = null;
    this.sourceConstraint = null;
    this.mouseDownCounter = 0;
    this.first = null;
    this.fireEvent(new EventObject(InternalEvent.RESET));
  }
  /**
   * Redraws the preview edge using the color and width returned by
   * <getEdgeColor> and <getEdgeWidth>.
   */
  drawPreview() {
    this.updatePreview(this.error === null);
    if (this.shape)
      this.shape.redraw();
  }
  /**
   * Returns the color used to draw the preview edge. This returns green if
   * there is no edge validation error and red otherwise.
   *
   * @param valid Boolean indicating if the color for a valid edge should be
   * returned.
   */
  updatePreview(valid) {
    if (this.shape) {
      this.shape.strokeWidth = this.getEdgeWidth(valid);
      this.shape.stroke = this.getEdgeColor(valid);
    }
  }
  /**
   * Returns the color used to draw the preview edge. This returns green if
   * there is no edge validation error and red otherwise.
   *
   * @param valid Boolean indicating if the color for a valid edge should be
   * returned.
   */
  getEdgeColor(valid) {
    return valid ? VALID_COLOR : INVALID_COLOR;
  }
  /**
   * Returns the width used to draw the preview edge. This returns 3 if
   * there is no edge validation error and 1 otherwise.
   *
   * @param valid Boolean indicating if the width for a valid edge should be
   * returned.
   */
  getEdgeWidth(valid) {
    return valid ? 3 : 1;
  }
  /**
   * Connects the given source and target using a new edge. This
   * implementation uses <createEdge> to create the edge.
   *
   * @param source <Cell> that represents the source terminal.
   * @param target <Cell> that represents the target terminal.
   * @param evt Mousedown event of the connect gesture.
   * @param dropTarget <Cell> that represents the cell under the mouse when it was
   * released.
   */
  connect(source, target, evt, dropTarget = null) {
    var _a, _b, _c, _d;
    if (target || this.isCreateTarget(evt) || this.graph.isAllowDanglingEdges()) {
      const model = this.graph.getDataModel();
      let terminalInserted = false;
      let edge = null;
      model.beginUpdate();
      try {
        if (source && !target && !this.graph.isIgnoreTerminalEvent(evt) && this.isCreateTarget(evt)) {
          target = this.createTargetVertex(evt, source);
          if (target) {
            dropTarget = this.graph.getDropTarget([target], evt, dropTarget);
            terminalInserted = true;
            if (dropTarget == null || !dropTarget.isEdge()) {
              const pstate = dropTarget ? this.graph.getView().getState(dropTarget) : null;
              if (pstate) {
                const tmp = target.getGeometry();
                if (tmp) {
                  tmp.x -= pstate.origin.x;
                  tmp.y -= pstate.origin.y;
                }
              }
            } else {
              dropTarget = this.graph.getDefaultParent();
            }
            this.graph.addCell(target, dropTarget);
          }
        }
        let parent = this.graph.getDefaultParent();
        if (source && target && source.getParent() === target.getParent() && ((_a = source.getParent()) == null ? void 0 : _a.getParent()) !== model.getRoot()) {
          parent = source.getParent();
          if (source.geometry && source.geometry.relative && target.geometry && target.geometry.relative) {
            parent = parent.getParent();
          }
        }
        let value = null;
        let style = {};
        if ((_b = this.edgeState) == null ? void 0 : _b.cell) {
          value = this.edgeState.cell.value;
          style = this.edgeState.cell.style ?? {};
        }
        edge = this.insertEdge(parent, "", value, source, target, style);
        if (edge && source) {
          this.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);
          this.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);
          if ((_d = (_c = this.edgeState) == null ? void 0 : _c.cell) == null ? void 0 : _d.geometry) {
            model.setGeometry(edge, this.edgeState.cell.geometry);
          }
          parent = source.getParent();
          if (this.isInsertBefore(edge, source, target, evt, dropTarget)) {
            const index = null;
            let tmp = source;
            while (tmp && tmp.parent != null && tmp.geometry != null && tmp.geometry.relative && tmp.parent !== edge.parent) {
              tmp = tmp.getParent();
            }
            if (tmp != null && tmp.parent != null && tmp.parent === edge.parent) {
              model.add(parent, edge, tmp.parent.getIndex(tmp));
            }
          }
          let geo = edge.getGeometry();
          if (geo == null) {
            geo = new Geometry();
            geo.relative = true;
            model.setGeometry(edge, geo);
          }
          if (this.waypoints.length > 0) {
            const s = this.graph.view.scale;
            const tr = this.graph.view.translate;
            geo.points = [];
            for (let i = 0; i < this.waypoints.length; i += 1) {
              const pt = this.waypoints[i];
              geo.points.push(new Point(pt.x / s - tr.x, pt.y / s - tr.y));
            }
          }
          if (!target && this.currentPoint) {
            const t = this.graph.view.translate;
            const s = this.graph.view.scale;
            const pt = this.originalPoint != null ? new Point(this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y) : new Point(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);
            pt.x -= this.graph.getPanDx() / this.graph.view.scale;
            pt.y -= this.graph.getPanDy() / this.graph.view.scale;
            geo.setTerminalPoint(pt, false);
          }
          this.fireEvent(new EventObject(InternalEvent.CONNECT, "cell", edge, "terminal", target, "event", evt, "target", dropTarget, "terminalInserted", terminalInserted));
        }
      } catch (e) {
        GlobalConfig.logger.show();
        const errorMessage = `Error in ConnectionHandler: ${e instanceof Error ? e.message + "\n" + e.stack : "unknown cause"}`;
        GlobalConfig.logger.debug(errorMessage);
      } finally {
        model.endUpdate();
      }
      if (this.select) {
        this.selectCells(edge, terminalInserted ? target : null);
      }
    }
  }
  /**
   * Selects the given edge after adding a new connection. The target argument
   * contains the target vertex if one has been inserted.
   */
  selectCells(edge, target) {
    this.graph.setSelectionCell(edge);
  }
  /**
   * Creates, inserts and returns the new edge for the given parameters. This
   * implementation does only use <createEdge> if <factoryMethod> is defined,
   * otherwise {@link Graph#insertEdge} will be used.
   */
  insertEdge(parent, id, value, source, target, style) {
    if (!this.factoryMethod) {
      return this.graph.insertEdge(parent, id, value, source, target, style);
    }
    let edge = this.createEdge(value, source, target, style);
    edge = this.graph.addEdge(edge, parent, source, target);
    return edge;
  }
  /**
   * Hook method for creating new vertices on the fly if no target was
   * under the mouse. This is only called if <createTarget> is true and
   * returns null.
   *
   * @param evt Mousedown event of the connect gesture.
   * @param source <Cell> that represents the source terminal.
   */
  createTargetVertex(evt, source) {
    let geo = source.getGeometry();
    while (geo && geo.relative) {
      source = source.getParent();
      geo = source.getGeometry();
    }
    const clone2 = this.graph.cloneCell(source);
    geo = clone2.getGeometry();
    if (geo && this.currentPoint) {
      const t = this.graph.view.translate;
      const s = this.graph.view.scale;
      const point = new Point(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);
      geo.x = Math.round(point.x - geo.width / 2 - this.graph.getPanDx() / s);
      geo.y = Math.round(point.y - geo.height / 2 - this.graph.getPanDy() / s);
      const tol = this.getAlignmentTolerance();
      if (tol > 0) {
        const sourceState = this.graph.view.getState(source);
        if (sourceState != null) {
          const x = sourceState.x / s - t.x;
          const y = sourceState.y / s - t.y;
          if (Math.abs(x - geo.x) <= tol) {
            geo.x = Math.round(x);
          }
          if (Math.abs(y - geo.y) <= tol) {
            geo.y = Math.round(y);
          }
        }
      }
    }
    return clone2;
  }
  /**
   * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.
   */
  getAlignmentTolerance(evt) {
    return this.graph.isGridEnabled() ? this.graph.getGridSize() / 2 : this.graph.getSnapTolerance();
  }
  /**
   * Creates and returns a new edge using <factoryMethod> if one exists. If
   * no factory method is defined, then a new default edge is returned. The
   * source and target arguments are informal, the actual connection is
   * setup later by the caller of this function.
   *
   * @param value Value to be used for creating the edge.
   * @param source <Cell> that represents the source terminal.
   * @param target <Cell> that represents the target terminal.
   * @param style Optional style from the preview edge.
   */
  createEdge(value, source, target, style = {}) {
    let edge = null;
    if (this.factoryMethod != null) {
      edge = this.factoryMethod(source, target, style);
    }
    if (edge == null) {
      edge = new Cell(value || "");
      edge.setEdge(true);
      edge.setStyle(style);
      const geo = new Geometry();
      geo.relative = true;
      edge.setGeometry(geo);
    }
    return edge;
  }
  /**
   * Destroys the handler and all its resources and DOM nodes. This should be
   * called on all instances. It is called automatically for the built-in
   * instance created for each {@link Graph}.
   */
  onDestroy() {
    this.graph.removeMouseListener(this);
    if (this.shape) {
      this.shape.destroy();
      this.shape = null;
    }
    if (this.marker) {
      this.marker.destroy();
      this.marker = null;
    }
    if (this.constraintHandler) {
      this.constraintHandler.onDestroy();
    }
    if (this.changeHandler) {
      this.graph.getDataModel().removeListener(this.changeHandler);
      this.graph.getView().removeListener(this.changeHandler);
    }
    if (this.drillHandler) {
      this.graph.removeListener(this.drillHandler);
      this.graph.getView().removeListener(this.drillHandler);
    }
    if (this.escapeHandler) {
      this.graph.removeListener(this.escapeHandler);
    }
  }
}
ConnectionHandler.pluginId = "ConnectionHandler";
class ConnectionHandlerCellMarker extends CellMarker {
  constructor(graph, connectionHandler, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {
    super(graph, validColor, invalidColor, hotspot);
    this.hotspotEnabled = true;
    this.connectionHandler = connectionHandler;
  }
  // Overrides to return cell at location only if valid (so that
  // there is no highlight for invalid cells)
  getCell(me) {
    let cell = super.getCell(me);
    this.connectionHandler.error = null;
    if (!cell && this.connectionHandler.currentPoint) {
      cell = this.connectionHandler.graph.getCellAt(this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y);
    }
    if (cell && !cell.isConnectable() && this.connectionHandler.cell) {
      const parent = this.connectionHandler.cell.getParent();
      if (parent && parent.isVertex() && parent.isConnectable()) {
        cell = parent;
      }
    }
    if (cell) {
      if (this.connectionHandler.graph.isSwimlane(cell) && this.connectionHandler.currentPoint != null && this.connectionHandler.graph.hitsSwimlaneContent(cell, this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y) || !this.connectionHandler.isConnectableCell(cell)) {
        cell = null;
      }
    }
    if (cell) {
      if (this.connectionHandler.isConnecting()) {
        if (this.connectionHandler.previous) {
          this.connectionHandler.error = this.connectionHandler.validateConnection(this.connectionHandler.previous.cell, cell);
          if (this.connectionHandler.error !== null && this.connectionHandler.error.length === 0) {
            cell = null;
            if (this.connectionHandler.isCreateTarget(me.getEvent())) {
              this.connectionHandler.error = null;
            }
          }
        }
      } else if (!this.connectionHandler.isValidSource(cell, me)) {
        cell = null;
      }
    } else if (this.connectionHandler.isConnecting() && !this.connectionHandler.isCreateTarget(me.getEvent()) && !this.connectionHandler.graph.isAllowDanglingEdges()) {
      this.connectionHandler.error = "";
    }
    return cell;
  }
  // Sets the highlight color according to validateConnection
  isValidState(state) {
    if (this.connectionHandler.isConnecting()) {
      return !this.connectionHandler.error;
    }
    return super.isValidState(state);
  }
  // Overrides to use marker color only in highlight mode or for
  // target selection
  getMarkerColor(evt, state, isValid) {
    return !this.connectionHandler.connectImage || this.connectionHandler.isConnecting() ? super.getMarkerColor(evt, state, isValid) : NONE;
  }
  // Overrides to use hotspot only for source selection otherwise
  // intersects always returns true when over a cell
  intersects(state, evt) {
    if (this.connectionHandler.connectImage || this.connectionHandler.isConnecting()) {
      return true;
    }
    return super.intersects(state, evt);
  }
}
class Guide {
  constructor(graph, states) {
    this.states = [];
    this.horizontal = true;
    this.vertical = true;
    this.guideX = null;
    this.guideY = null;
    this.rounded = false;
    this.tolerance = 2;
    this.graph = graph;
    this.setStates(states);
  }
  /**
   * Sets the {@link CellState}s that should be used for alignment.
   */
  setStates(states) {
    this.states = states;
  }
  /**
   * Returns true if the guide should be enabled for the given native event. This
   * implementation always returns true.
   */
  isEnabledForEvent(evt) {
    return true;
  }
  /**
   * Returns the tolerance for the guides. Default value is gridSize / 2.
   */
  getGuideTolerance(gridEnabled = false) {
    return gridEnabled && this.graph.isGridEnabled() ? this.graph.getGridSize() / 2 : this.tolerance;
  }
  /**
   * Returns the mxShape to be used for painting the respective guide. This
   * implementation returns a new, dashed and crisp {@link PolylineShape} using
   * {@link GUIDE_COLOR} and {@link GUIDE_STROKEWIDTH} as the format.
   *
   * @param horizontal Boolean that specifies which guide should be created.
   */
  createGuideShape(horizontal = false) {
    const guide = new PolylineShape([], GUIDE_COLOR, GUIDE_STROKEWIDTH);
    guide.isDashed = true;
    return guide;
  }
  /**
   * Returns true if the given state should be ignored.
   * @param state
   */
  isStateIgnored(state) {
    return false;
  }
  /**
   * Moves the <bounds> by the given {@link Point} and returnt the snapped point.
   */
  move(bounds = null, delta, gridEnabled = false, clone2 = false) {
    if ((this.horizontal || this.vertical) && bounds) {
      const { scale } = this.graph.getView();
      const tt = this.getGuideTolerance(gridEnabled) * scale;
      const b = bounds.clone();
      b.x += delta.x;
      b.y += delta.y;
      let overrideX = false;
      let stateX = null;
      let valueX = null;
      let overrideY = false;
      let stateY = null;
      let valueY = null;
      let ttX = tt;
      let ttY = tt;
      const left = b.x;
      const right = b.x + b.width;
      const center = b.getCenterX();
      const top = b.y;
      const bottom = b.y + b.height;
      const middle = b.getCenterY();
      const snapX = (x, state, centerAlign) => {
        let override = false;
        if (centerAlign && Math.abs(x - center) < ttX) {
          delta.x = x - bounds.getCenterX();
          ttX = Math.abs(x - center);
          override = true;
        } else if (!centerAlign) {
          if (Math.abs(x - left) < ttX) {
            delta.x = x - bounds.x;
            ttX = Math.abs(x - left);
            override = true;
          } else if (Math.abs(x - right) < ttX) {
            delta.x = x - bounds.x - bounds.width;
            ttX = Math.abs(x - right);
            override = true;
          }
        }
        if (override) {
          stateX = state;
          valueX = x;
          if (!this.guideX) {
            this.guideX = this.createGuideShape(true);
            this.guideX.dialect = DIALECT.SVG;
            this.guideX.pointerEvents = false;
            this.guideX.init(this.graph.getView().getOverlayPane());
          }
        }
        overrideX = overrideX || override;
      };
      const snapY = (y, state, centerAlign) => {
        let override = false;
        if (centerAlign && Math.abs(y - middle) < ttY) {
          delta.y = y - bounds.getCenterY();
          ttY = Math.abs(y - middle);
          override = true;
        } else if (!centerAlign) {
          if (Math.abs(y - top) < ttY) {
            delta.y = y - bounds.y;
            ttY = Math.abs(y - top);
            override = true;
          } else if (Math.abs(y - bottom) < ttY) {
            delta.y = y - bounds.y - bounds.height;
            ttY = Math.abs(y - bottom);
            override = true;
          }
        }
        if (override) {
          stateY = state;
          valueY = y;
          if (!this.guideY) {
            this.guideY = this.createGuideShape(false);
            this.guideY.dialect = DIALECT.SVG;
            this.guideY.pointerEvents = false;
            this.guideY.init(this.graph.getView().getOverlayPane());
          }
        }
        overrideY = overrideY || override;
      };
      for (let i = 0; i < this.states.length; i += 1) {
        const state = this.states[i];
        if (state && !this.isStateIgnored(state)) {
          if (this.horizontal) {
            snapX(state.getCenterX(), state, true);
            snapX(state.x, state, false);
            snapX(state.x + state.width, state, false);
            if (!state.cell) {
              snapX(state.getCenterX(), state, false);
            }
          }
          if (this.vertical) {
            snapY(state.getCenterY(), state, true);
            snapY(state.y, state, false);
            snapY(state.y + state.height, state, false);
            if (!state.cell) {
              snapY(state.getCenterY(), state, false);
            }
          }
        }
      }
      this.graph.snapDelta(delta, bounds, !gridEnabled, overrideX, overrideY);
      delta = this.getDelta(bounds, stateX, delta.x, stateY, delta.y);
      const c = this.graph.container;
      if (!overrideX && this.guideX) {
        this.guideX.node.style.visibility = "hidden";
      } else if (this.guideX) {
        let minY = null;
        let maxY = null;
        if (stateX) {
          minY = Math.min(bounds.y + delta.y - this.graph.getPanDy(), stateX.y);
          maxY = Math.max(
            bounds.y + bounds.height + delta.y - this.graph.getPanDy(),
            // @ts-ignore stateX! doesn't work for some reason...
            stateX.y + stateX.height
          );
        }
        if (minY !== null && maxY !== null) {
          this.guideX.points = [new Point(valueX, minY), new Point(valueX, maxY)];
        } else {
          this.guideX.points = [
            new Point(valueX, -this.graph.getPanDy()),
            new Point(valueX, c.scrollHeight - 3 - this.graph.getPanDy())
          ];
        }
        this.guideX.stroke = this.getGuideColor(stateX, true);
        this.guideX.node.style.visibility = "visible";
        this.guideX.redraw();
      }
      if (!overrideY && this.guideY != null) {
        this.guideY.node.style.visibility = "hidden";
      } else if (this.guideY != null) {
        let minX = null;
        let maxX = null;
        if (stateY != null && bounds != null) {
          minX = Math.min(bounds.x + delta.x - this.graph.getPanDx(), stateY.x);
          maxX = Math.max(
            bounds.x + bounds.width + delta.x - this.graph.getPanDx(),
            // @ts-ignore
            stateY.x + stateY.width
          );
        }
        if (minX != null && maxX != null && valueY !== null) {
          this.guideY.points = [new Point(minX, valueY), new Point(maxX, valueY)];
        } else if (valueY !== null) {
          this.guideY.points = [
            new Point(-this.graph.getPanDx(), valueY),
            new Point(c.scrollWidth - 3 - this.graph.getPanDx(), valueY)
          ];
        }
        this.guideY.stroke = this.getGuideColor(stateY, false);
        this.guideY.node.style.visibility = "visible";
        this.guideY.redraw();
      }
    }
    return delta;
  }
  /**
   * Rounds to pixels for virtual states (eg. page guides)
   */
  getDelta(bounds, stateX = null, dx, stateY = null, dy) {
    const s = this.graph.view.scale;
    if (this.rounded || stateX != null && stateX.cell == null) {
      dx = Math.round((bounds.x + dx) / s) * s - bounds.x;
    }
    if (this.rounded || stateY != null && stateY.cell == null) {
      dy = Math.round((bounds.y + dy) / s) * s - bounds.y;
    }
    return new Point(dx, dy);
  }
  /**
   * Hides all current guides.
   */
  getGuideColor(state, horizontal) {
    return GUIDE_COLOR;
  }
  /**
   * Hides all current guides.
   */
  hide() {
    this.setVisible(false);
  }
  /**
   * Shows or hides the current guides.
   */
  setVisible(visible) {
    if (this.guideX) {
      this.guideX.node.style.visibility = visible ? "visible" : "hidden";
    }
    if (this.guideY) {
      this.guideY.node.style.visibility = visible ? "visible" : "hidden";
    }
  }
  /**
   * Destroys all resources that this object uses.
   */
  destroy() {
    if (this.guideX) {
      this.guideX.destroy();
      this.guideX = null;
    }
    if (this.guideY) {
      this.guideY.destroy();
      this.guideY = null;
    }
  }
}
class SelectionHandler {
  /**
   * Constructs an event handler that creates handles for the selection cells.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   */
  constructor(graph) {
    this.refreshThread = null;
    this.maxCells = 50;
    this.enabled = true;
    this.highlightEnabled = true;
    this.cloneEnabled = true;
    this.moveEnabled = true;
    this.guidesEnabled = false;
    this.handlesVisible = true;
    this.guide = null;
    this.currentDx = 0;
    this.currentDy = 0;
    this.updateCursor = true;
    this.selectEnabled = true;
    this.removeCellsFromParent = true;
    this.removeEmptyParents = false;
    this.connectOnDrop = false;
    this.scrollOnMove = true;
    this.minimumSize = 6;
    this.previewColor = "black";
    this.htmlPreview = false;
    this.shape = null;
    this.scaleGrid = false;
    this.rotationEnabled = true;
    this.maxLivePreview = 0;
    this.allowLivePreview = Client.IS_SVG;
    this.cell = null;
    this.delayedSelection = false;
    this.first = null;
    this.cells = null;
    this.bounds = null;
    this.pBounds = null;
    this.allCells = new Dictionary();
    this.cellWasClicked = false;
    this.cloning = false;
    this.cellCount = 0;
    this.target = null;
    this.suspended = false;
    this.livePreviewActive = false;
    this.livePreviewUsed = false;
    this.highlight = null;
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.panHandler = () => {
      if (!this.suspended) {
        this.updatePreview();
        this.updateHint();
      }
    };
    this.graph.addListener(InternalEvent.PAN, this.panHandler);
    this.escapeHandler = (sender, evt) => {
      this.reset();
    };
    this.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);
    this.refreshHandler = (sender, evt) => {
      if (this.refreshThread) {
        window.clearTimeout(this.refreshThread);
      }
      this.refreshThread = window.setTimeout(() => {
        var _a;
        this.refreshThread = null;
        if (this.first && !this.suspended && this.cells) {
          const dx = this.currentDx;
          const dy = this.currentDy;
          this.currentDx = 0;
          this.currentDy = 0;
          this.updatePreview();
          this.bounds = this.graph.getView().getBounds(this.cells);
          this.pBounds = this.getPreviewBounds(this.cells);
          if (this.pBounds == null && !this.livePreviewUsed) {
            this.reset();
          } else {
            this.currentDx = dx;
            this.currentDy = dy;
            this.updatePreview();
            this.updateHint();
            if (this.livePreviewUsed) {
              this.setHandlesVisibleForCells(((_a = this.getSelectionCellsHandler()) == null ? void 0 : _a.getHandledSelectionCells()) ?? [], false, true);
              this.updatePreview();
            }
          }
        }
      }, 0);
    };
    this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.refreshHandler);
    this.graph.addListener(InternalEvent.REFRESH, this.refreshHandler);
    this.keyHandler = (e) => {
      if (this.graph.container != null && this.graph.container.style.visibility !== "hidden" && this.first != null && !this.suspended) {
        const clone2 = this.graph.isCloneEvent(e) && this.graph.isCellsCloneable() && this.isCloneEnabled();
        if (clone2 !== this.cloning) {
          this.cloning = clone2;
          this.checkPreview();
          this.updatePreview();
        }
      }
    };
    if (typeof document !== "undefined") {
      InternalEvent.addListener(document, "keydown", this.keyHandler);
      InternalEvent.addListener(document, "keyup", this.keyHandler);
    }
  }
  /**
   * Returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Sets <enabled>.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * Returns <cloneEnabled>.
   */
  isCloneEnabled() {
    return this.cloneEnabled;
  }
  /**
   * Sets <cloneEnabled>.
   *
   * @param value Boolean that specifies the new clone enabled state.
   */
  setCloneEnabled(value) {
    this.cloneEnabled = value;
  }
  /**
   * Returns {@link oveEnabled}.
   */
  isMoveEnabled() {
    return this.moveEnabled;
  }
  /**
   * Sets {@link oveEnabled}.
   */
  setMoveEnabled(value) {
    this.moveEnabled = value;
  }
  /**
   * Returns <selectEnabled>.
   */
  isSelectEnabled() {
    return this.selectEnabled;
  }
  /**
   * Sets <selectEnabled>.
   */
  setSelectEnabled(value) {
    this.selectEnabled = value;
  }
  /**
   * Returns <removeCellsFromParent>.
   */
  isRemoveCellsFromParent() {
    return this.removeCellsFromParent;
  }
  /**
   * Sets <removeCellsFromParent>.
   */
  setRemoveCellsFromParent(value) {
    this.removeCellsFromParent = value;
  }
  /**
   * Returns true if the given cell and parent should propagate
   * selection state to the parent.
   */
  isPropagateSelectionCell(cell, immediate, me) {
    const parent = cell.getParent();
    if (immediate) {
      const geo = cell.isEdge() ? null : cell.getGeometry();
      return !this.graph.isSiblingSelected(cell) && geo && geo.relative || !this.graph.isSwimlane(parent);
    }
    return (!this.graph.isToggleEvent(me.getEvent()) || !this.graph.isSiblingSelected(cell) && !this.graph.isCellSelected(cell) && !this.graph.isSwimlane(parent) || this.graph.isCellSelected(parent)) && (this.graph.isToggleEvent(me.getEvent()) || !this.graph.isCellSelected(parent));
  }
  /**
   * Hook to return initial cell for the given event.
   */
  getInitialCellForEvent(me) {
    let state = me.getState();
    if ((!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) && state && !this.graph.isCellSelected(state.cell)) {
      let parent = state.cell.getParent();
      let next = parent ? this.graph.view.getState(parent) : null;
      while (next && !this.graph.isCellSelected(next.cell) && (next.cell.isVertex() || next.cell.isEdge()) && this.isPropagateSelectionCell(state.cell, true, me)) {
        state = next;
        parent = state.cell.getParent();
        next = parent ? this.graph.view.getState(parent) : null;
      }
    }
    return state ? state.cell : null;
  }
  /**
   * Hook to return true for delayed selections.
   */
  isDelayedSelection(cell, me) {
    let c = cell;
    const selectionCellsHandler = this.getSelectionCellsHandler();
    if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {
      while (c) {
        if (selectionCellsHandler == null ? void 0 : selectionCellsHandler.isHandled(c)) {
          const cellEditorHandler = this.graph.getPlugin("CellEditorHandler");
          return (cellEditorHandler == null ? void 0 : cellEditorHandler.getEditingCell()) !== c;
        }
        c = c.getParent();
      }
    }
    return this.graph.isToggleEvent(me.getEvent()) && !isAltDown(me.getEvent());
  }
  /**
   * Implements the delayed selection for the given mouse event.
   */
  selectDelayed(me) {
    const popupMenuHandler = this.graph.getPlugin("PopupMenuHandler");
    if (!popupMenuHandler || !popupMenuHandler.isPopupTrigger(me)) {
      let cell = me.getCell();
      if (cell === null) {
        cell = this.cell;
      }
      if (cell)
        this.selectCellForEvent(cell, me);
    }
  }
  /**
   * Selects the given cell for the given {@link MouseEvent}.
   */
  selectCellForEvent(cell, me) {
    const state = this.graph.view.getState(cell);
    if (state) {
      if (me.isSource(state.control)) {
        this.graph.selectCellForEvent(cell, me.getEvent());
      } else {
        if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {
          let parent = cell.getParent();
          while (parent && this.graph.view.getState(parent) && (parent.isVertex() || parent.isEdge()) && this.isPropagateSelectionCell(cell, false, me)) {
            cell = parent;
            parent = cell.getParent();
          }
        }
        this.graph.selectCellForEvent(cell, me.getEvent());
      }
    }
    return cell;
  }
  /**
   * Consumes the given mouse event. NOTE: This may be used to enable click
   * events for links in labels on iOS as follows as consuming the initial
   * touchStart disables firing the subsequent click evnent on the link.
   *
   * <code>
   * consumeMouseEvent(evtName, me)
   * {
   *   var source = mxEvent.getSource(me.getEvent());
   *
   *   if (!mxEvent.isTouchEvent(me.getEvent()) || source.nodeName != 'A')
   *   {
   *     me.consume();
   *   }
   * }
   * </code>
   */
  consumeMouseEvent(evtName, me) {
    me.consume();
  }
  /**
   * Handles the event by selecing the given cell and creating a handle for
   * it. By consuming the event all subsequent events of the gesture are
   * redirected to this handler.
   */
  mouseDown(sender, me) {
    if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && me.getState() && !isMultiTouchEvent(me.getEvent())) {
      const cell = this.getInitialCellForEvent(me);
      if (cell) {
        this.delayedSelection = this.isDelayedSelection(cell, me);
        this.cell = null;
        if (this.isSelectEnabled() && !this.delayedSelection) {
          this.graph.selectCellForEvent(cell, me.getEvent());
        }
        if (this.isMoveEnabled()) {
          const geo = cell.getGeometry();
          if (geo && this.graph.isCellMovable(cell) && (!cell.isEdge() || this.graph.getSelectionCount() > 1 || geo.points && geo.points.length > 0 || !cell.getTerminal(true) || !cell.getTerminal(false) || this.graph.isAllowDanglingEdges() || this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable())) {
            this.start(cell, me.getX(), me.getY());
          } else if (this.delayedSelection) {
            this.cell = cell;
          }
          this.cellWasClicked = true;
          this.consumeMouseEvent(InternalEvent.MOUSE_DOWN, me);
        }
      }
    }
  }
  /**
   * Creates an array of cell states which should be used as guides.
   */
  getGuideStates() {
    const parent = this.graph.getDefaultParent();
    const filter = (cell) => {
      const geo = cell.getGeometry();
      return !!this.graph.view.getState(cell) && cell.isVertex() && !!geo && !geo.relative;
    };
    return this.graph.view.getCellStates(parent.filterDescendants(filter));
  }
  /**
   * Returns the cells to be modified by this handler. This implementation
   * returns all selection cells that are movable, or the given initial cell if
   * the given cell is not selected and movable. This handles the case of moving
   * unselectable or unselected cells.
   *
   * @param initialCell <Cell> that triggered this handler.
   */
  getCells(initialCell) {
    if (!this.delayedSelection && this.graph.isCellMovable(initialCell)) {
      return [initialCell];
    }
    return this.graph.getMovableCells(this.graph.getSelectionCells());
  }
  /**
   * Returns the {@link Rectangle} used as the preview bounds for
   * moving the given cells.
   */
  getPreviewBounds(cells) {
    const bounds = this.getBoundingBox(cells);
    if (bounds) {
      bounds.width = Math.max(0, bounds.width - 1);
      bounds.height = Math.max(0, bounds.height - 1);
      if (bounds.width < this.minimumSize) {
        const dx = this.minimumSize - bounds.width;
        bounds.x -= dx / 2;
        bounds.width = this.minimumSize;
      } else {
        bounds.x = Math.round(bounds.x);
        bounds.width = Math.ceil(bounds.width);
      }
      if (bounds.height < this.minimumSize) {
        const dy = this.minimumSize - bounds.height;
        bounds.y -= dy / 2;
        bounds.height = this.minimumSize;
      } else {
        bounds.y = Math.round(bounds.y);
        bounds.height = Math.ceil(bounds.height);
      }
    }
    return bounds;
  }
  /**
   * Returns the union of the {@link CellStates} for the given array of {@link Cells}.
   * For vertices, this method uses the bounding box of the corresponding shape
   * if one exists. The bounding box of the corresponding text label and all
   * controls and overlays are ignored. See also: {@link GraphView#getBounds} and
   * {@link Graph#getBoundingBox}.
   *
   * @param cells Array of {@link Cells} whose bounding box should be returned.
   */
  getBoundingBox(cells) {
    let result = null;
    if (cells.length > 0) {
      for (let i = 0; i < cells.length; i += 1) {
        if (cells[i].isVertex() || cells[i].isEdge()) {
          const state = this.graph.view.getState(cells[i]);
          if (state) {
            let bbox = null;
            if (cells[i].isVertex() && state.shape && state.shape.boundingBox) {
              bbox = state.shape.boundingBox;
            }
            if (bbox) {
              if (!result) {
                result = Rectangle.fromRectangle(bbox);
              } else {
                result.add(bbox);
              }
            }
          }
        }
      }
    }
    return result;
  }
  /**
   * Creates the shape used to draw the preview for the given bounds.
   */
  createPreviewShape(bounds) {
    const shape = new RectangleShape(bounds, NONE, this.previewColor);
    shape.isDashed = true;
    if (this.htmlPreview) {
      shape.dialect = DIALECT.STRICTHTML;
      shape.init(this.graph.container);
    } else {
      shape.dialect = DIALECT.SVG;
      shape.init(this.graph.getView().getOverlayPane());
      shape.pointerEvents = false;
      if (Client.IS_IOS) {
        shape.getSvgScreenOffset = () => {
          return 0;
        };
      }
    }
    return shape;
  }
  createGuide() {
    return new Guide(this.graph, this.getGuideStates());
  }
  /**
   * Starts the handling of the mouse gesture.
   */
  start(cell, x, y, cells) {
    this.cell = cell;
    this.first = convertPoint(this.graph.container, x, y);
    this.cells = cells ? cells : this.getCells(this.cell);
    this.bounds = this.graph.getView().getBounds(this.cells);
    this.pBounds = this.getPreviewBounds(this.cells);
    this.cloning = false;
    this.cellCount = 0;
    for (let i = 0; i < this.cells.length; i += 1) {
      this.cellCount += this.addStates(this.cells[i], this.allCells);
    }
    if (this.guidesEnabled) {
      this.guide = this.createGuide();
      const parent = cell.getParent();
      const ignore = parent.getChildCount() < 2;
      const connected = new Dictionary();
      const opps = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);
      for (let i = 0; i < opps.length; i += 1) {
        const state = this.graph.view.getState(opps[i]);
        if (state && !connected.get(state)) {
          connected.put(state, true);
        }
      }
      this.guide.isStateIgnored = (state) => {
        const p = state.cell.getParent();
        return !!state.cell && (!this.cloning && !!this.isCellMoving(state.cell) || state.cell !== (this.target || parent) && !ignore && !connected.get(state) && (!this.target || this.target.getChildCount() >= 2) && p !== (this.target || parent));
      };
    }
  }
  /**
   * Adds the states for the given cell recursively to the given dictionary.
   * @param cell
   * @param dict
   */
  addStates(cell, dict) {
    const state = this.graph.view.getState(cell);
    let count = 0;
    if (state && !dict.get(cell)) {
      dict.put(cell, state);
      count++;
      const childCount = cell.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        count += this.addStates(cell.getChildAt(i), dict);
      }
    }
    return count;
  }
  /**
   * Returns true if the given cell is currently being moved.
   */
  isCellMoving(cell) {
    return this.allCells.get(cell);
  }
  /**
   * Returns true if the guides should be used for the given {@link MouseEvent}.
   * This implementation returns {@link Guide#isEnabledForEvent}.
   */
  useGuidesForEvent(me) {
    return this.guide ? this.guide.isEnabledForEvent(me.getEvent()) && !this.graph.isConstrainedEvent(me.getEvent()) : true;
  }
  /**
   * Snaps the given vector to the grid and returns the given mxPoint instance.
   */
  snap(vector) {
    const scale = this.scaleGrid ? this.graph.view.scale : 1;
    vector.x = this.graph.snap(vector.x / scale) * scale;
    vector.y = this.graph.snap(vector.y / scale) * scale;
    return vector;
  }
  /**
   * Returns an {@link Point} that represents the vector for moving the cells
   * for the given {@link MouseEvent}.
   */
  getDelta(me) {
    const point = convertPoint(this.graph.container, me.getX(), me.getY());
    if (!this.first)
      return new Point();
    return new Point(point.x - this.first.x - this.graph.getPanDx(), point.y - this.first.y - this.graph.getPanDy());
  }
  /**
   * Hook for subclassers do show details while the handler is active.
   */
  updateHint(me) {
    return;
  }
  /**
   * Hooks for subclassers to hide details when the handler gets inactive.
   */
  removeHint() {
    return;
  }
  /**
   * Hook for rounding the unscaled vector. This uses Math.round.
   */
  roundLength(length) {
    return Math.round(length * 100) / 100;
  }
  /**
   * Returns true if the given cell is a valid drop target.
   */
  isValidDropTarget(target, me) {
    return this.cell ? this.cell.getParent() !== target : false;
  }
  /**
   * Updates the preview if cloning state has changed.
   */
  checkPreview() {
    if (this.livePreviewActive && this.cloning) {
      this.resetLivePreview();
      this.livePreviewActive = false;
    } else if (this.maxLivePreview >= this.cellCount && !this.livePreviewActive && this.allowLivePreview) {
      if (!this.cloning || !this.livePreviewActive) {
        this.livePreviewActive = true;
        this.livePreviewUsed = true;
      }
    } else if (!this.livePreviewUsed && !this.shape && this.bounds) {
      this.shape = this.createPreviewShape(this.bounds);
    }
  }
  /**
   * Handles the event by highlighting possible drop targets and updating the
   * preview.
   */
  mouseMove(sender, me) {
    const { graph } = this;
    if (!me.isConsumed() && graph.isMouseDown && this.cell && this.first && this.bounds && !this.suspended) {
      if (isMultiTouchEvent(me.getEvent())) {
        this.reset();
        return;
      }
      let delta = this.getDelta(me);
      const tol = graph.getEventTolerance();
      if (this.shape || this.livePreviewActive || Math.abs(delta.x) > tol || Math.abs(delta.y) > tol) {
        if (!this.highlight) {
          this.highlight = new CellHighlight(this.graph, DROP_TARGET_COLOR, 3);
        }
        const clone2 = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
        const gridEnabled = graph.isGridEnabledEvent(me.getEvent());
        const cell = me.getCell();
        let hideGuide = true;
        let target = null;
        this.cloning = clone2;
        if (graph.isDropEnabled() && this.highlightEnabled && this.cells) {
          target = graph.getDropTarget(this.cells, me.getEvent(), cell, clone2);
        }
        let state = target ? graph.getView().getState(target) : null;
        let highlight = false;
        if (state && (clone2 || target && this.isValidDropTarget(target, me))) {
          if (this.target !== target) {
            this.target = target;
            this.setHighlightColor(DROP_TARGET_COLOR);
          }
          highlight = true;
        } else {
          this.target = null;
          if (this.connectOnDrop && cell && this.cells && this.cells.length === 1 && cell.isVertex() && cell.isConnectable()) {
            state = graph.getView().getState(cell);
            if (state) {
              const error2 = graph.getEdgeValidationError(null, this.cell, cell);
              const color = error2 === null ? VALID_COLOR : INVALID_CONNECT_TARGET_COLOR;
              this.setHighlightColor(color);
              highlight = true;
            }
          }
        }
        if (state && highlight) {
          this.highlight.highlight(state);
        } else {
          this.highlight.hide();
        }
        if (this.guide && this.useGuidesForEvent(me)) {
          delta = this.guide.move(this.bounds, delta, gridEnabled, clone2);
          hideGuide = false;
        } else {
          delta = this.graph.snapDelta(delta, this.bounds, !gridEnabled, false, false);
        }
        if (this.guide && hideGuide) {
          this.guide.hide();
        }
        if (graph.isConstrainedEvent(me.getEvent())) {
          if (Math.abs(delta.x) > Math.abs(delta.y)) {
            delta.y = 0;
          } else {
            delta.x = 0;
          }
        }
        this.checkPreview();
        if (this.currentDx !== delta.x || this.currentDy !== delta.y) {
          this.currentDx = delta.x;
          this.currentDy = delta.y;
          this.updatePreview();
        }
      }
      this.updateHint(me);
      this.consumeMouseEvent(InternalEvent.MOUSE_MOVE, me);
      InternalEvent.consume(me.getEvent());
    } else if ((this.isMoveEnabled() || this.isCloneEnabled()) && this.updateCursor && !me.isConsumed() && (me.getState() || me.sourceState) && !graph.isMouseDown) {
      let cursor = graph.getCursorForMouseEvent(me);
      const cell = me.getCell();
      if (!cursor && cell && graph.isEnabled() && graph.isCellMovable(cell)) {
        if (cell.isEdge()) {
          cursor = CURSOR.MOVABLE_EDGE;
        } else {
          cursor = CURSOR.MOVABLE_VERTEX;
        }
      }
      if (cursor && me.sourceState) {
        me.sourceState.setCursor(cursor);
      }
    }
  }
  /**
   * Updates the bounds of the preview shape.
   */
  updatePreview(remote = false) {
    var _a;
    if (this.livePreviewUsed && !remote) {
      if (this.cells) {
        this.setHandlesVisibleForCells(((_a = this.getSelectionCellsHandler()) == null ? void 0 : _a.getHandledSelectionCells()) ?? [], false);
        this.updateLivePreview(this.currentDx, this.currentDy);
      }
    } else {
      this.updatePreviewShape();
    }
  }
  /**
   * Updates the bounds of the preview shape.
   */
  updatePreviewShape() {
    if (this.shape && this.pBounds) {
      this.shape.bounds = new Rectangle(Math.round(this.pBounds.x + this.currentDx), Math.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);
      this.shape.redraw();
    }
  }
  /**
   * Updates the bounds of the preview shape.
   */
  updateLivePreview(dx, dy) {
    if (!this.suspended) {
      const states = [];
      if (this.allCells) {
        this.allCells.visit((key, state) => {
          const realState = state ? this.graph.view.getState(state.cell) : null;
          if (realState !== state && state) {
            state.destroy();
            if (realState) {
              this.allCells.put(state.cell, realState);
            } else {
              this.allCells.remove(state.cell);
            }
            state = realState;
          }
          if (state) {
            const tempState = state.clone();
            states.push([state, tempState]);
            if (state.shape) {
              if (state.shape.originalPointerEvents === null) {
                state.shape.originalPointerEvents = state.shape.pointerEvents;
              }
              state.shape.pointerEvents = false;
              if (state.text) {
                if (state.text.originalPointerEvents === null) {
                  state.text.originalPointerEvents = state.text.pointerEvents;
                }
                state.text.pointerEvents = false;
              }
            }
            if (state.cell.isVertex()) {
              state.x += dx;
              state.y += dy;
              if (!this.cloning) {
                state.view.graph.cellRenderer.redraw(state, true);
                state.view.invalidate(state.cell);
                state.invalid = false;
                if (state.control && state.control.node) {
                  state.control.node.style.visibility = "hidden";
                }
              } else if (state.text) {
                state.text.updateBoundingBox();
                if (state.text.boundingBox) {
                  state.text.boundingBox.x += dx;
                  state.text.boundingBox.y += dy;
                }
                if (state.text.unrotatedBoundingBox) {
                  state.text.unrotatedBoundingBox.x += dx;
                  state.text.unrotatedBoundingBox.y += dy;
                }
              }
            }
          }
        });
      }
      if (states.length === 0) {
        this.reset();
      } else {
        const s = this.graph.view.scale;
        for (let i = 0; i < states.length; i += 1) {
          const state = states[i][0];
          if (state.cell.isEdge()) {
            const geometry = state.cell.getGeometry();
            const points = [];
            if (geometry && geometry.points) {
              for (let j = 0; j < geometry.points.length; j++) {
                if (geometry.points[j]) {
                  points.push(new Point(geometry.points[j].x + dx / s, geometry.points[j].y + dy / s));
                }
              }
            }
            let source = state.visibleSourceState;
            let target = state.visibleTargetState;
            const pts = states[i][1].absolutePoints;
            if (source == null || !this.isCellMoving(source.cell)) {
              const pt0 = pts[0];
              if (pt0) {
                state.setAbsoluteTerminalPoint(new Point(pt0.x + dx, pt0.y + dy), true);
                source = null;
              }
            } else {
              state.view.updateFixedTerminalPoint(state, source, true, this.graph.getConnectionConstraint(state, source, true));
            }
            if (target == null || !this.isCellMoving(target.cell)) {
              const ptn = pts[pts.length - 1];
              if (ptn) {
                state.setAbsoluteTerminalPoint(new Point(ptn.x + dx, ptn.y + dy), false);
                target = null;
              }
            } else {
              state.view.updateFixedTerminalPoint(state, target, false, this.graph.getConnectionConstraint(state, target, false));
            }
            state.view.updatePoints(state, points, source, target);
            state.view.updateFloatingTerminalPoints(state, source, target);
            state.view.updateEdgeLabelOffset(state);
            state.invalid = false;
            if (!this.cloning) {
              state.view.graph.cellRenderer.redraw(state, true);
            }
          }
        }
        this.graph.view.validate();
        this.redrawHandles(states);
        this.resetPreviewStates(states);
      }
    }
  }
  /**
   * Redraws the preview shape for the given states array.
   */
  redrawHandles(states) {
    const selectionCellsHandler = this.getSelectionCellsHandler();
    for (let i = 0; i < states.length; i += 1) {
      const handler = selectionCellsHandler == null ? void 0 : selectionCellsHandler.getHandler(states[i][0].cell);
      handler == null ? void 0 : handler.redraw(true);
    }
  }
  /**
   * Resets the given preview states array.
   */
  resetPreviewStates(states) {
    for (let i = 0; i < states.length; i += 1) {
      states[i][0].setState(states[i][1]);
    }
  }
  /**
   * Suspends the livew preview.
   */
  suspend() {
    if (!this.suspended) {
      if (this.livePreviewUsed) {
        this.updateLivePreview(0, 0);
      }
      if (this.shape) {
        this.shape.node.style.visibility = "hidden";
      }
      if (this.guide) {
        this.guide.setVisible(false);
      }
      this.suspended = true;
    }
  }
  /**
   * Suspends the livew preview.
   */
  resume() {
    if (this.suspended) {
      this.suspended = false;
      if (this.livePreviewUsed) {
        this.livePreviewActive = true;
      }
      if (this.shape) {
        this.shape.node.style.visibility = "visible";
      }
      if (this.guide) {
        this.guide.setVisible(true);
      }
    }
  }
  /**
   * Resets the livew preview.
   */
  resetLivePreview() {
    this.allCells.visit((key, state) => {
      if (state.shape && state.shape.originalPointerEvents !== null) {
        state.shape.pointerEvents = state.shape.originalPointerEvents;
        state.shape.originalPointerEvents = null;
        state.shape.bounds = null;
        if (state.text && state.text.originalPointerEvents !== null) {
          state.text.pointerEvents = state.text.originalPointerEvents;
          state.text.originalPointerEvents = null;
        }
      }
      if (state.control && state.control.node && state.control.node.style.visibility === "hidden") {
        state.control.node.style.visibility = "";
      }
      if (!this.cloning) {
        if (state.text) {
          state.text.updateBoundingBox();
        }
      }
      state.view.invalidate(state.cell);
    });
    this.graph.view.validate();
  }
  /**
   * Sets whether the handles attached to the given cells are visible.
   *
   * @param cells Array of {@link Cell}s.
   * @param visible Boolean that specifies if the handles should be visible.
   * @param force Forces an update of the handler regardless of the last used value.
   */
  setHandlesVisibleForCells(cells, visible, force = false) {
    if (force || this.handlesVisible !== visible) {
      this.handlesVisible = visible;
      const selectionCellsHandler = this.getSelectionCellsHandler();
      for (let i = 0; i < cells.length; i += 1) {
        const handler = selectionCellsHandler == null ? void 0 : selectionCellsHandler.getHandler(cells[i]);
        if (handler) {
          handler.setHandlesVisible(visible);
          if (visible) {
            handler.redraw();
          }
        }
      }
    }
  }
  /**
   * Sets the color of the rectangle used to highlight drop targets.
   *
   * @param color String that represents the new highlight color.
   */
  setHighlightColor(color) {
    if (this.highlight) {
      this.highlight.setHighlightColor(color);
    }
  }
  /**
   * Handles the event by applying the changes to the selection cells.
   */
  mouseUp(sender, me) {
    if (!me.isConsumed()) {
      if (this.livePreviewUsed) {
        this.resetLivePreview();
      }
      if (this.cell && this.first && (this.shape || this.livePreviewUsed) && isNumeric(this.currentDx) && isNumeric(this.currentDy)) {
        const { graph } = this;
        const cell = me.getCell();
        if (this.connectOnDrop && !this.target && cell && cell.isVertex() && cell.isConnectable() && graph.isEdgeValid(null, this.cell, cell)) {
          const connectionHandler = graph.getPlugin("ConnectionHandler");
          connectionHandler == null ? void 0 : connectionHandler.connect(this.cell, cell, me.getEvent());
        } else {
          const clone2 = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
          const { scale } = graph.getView();
          const dx = this.roundLength(this.currentDx / scale);
          const dy = this.roundLength(this.currentDy / scale);
          const target = this.target;
          if (target && graph.isSplitEnabled() && this.cells && graph.isSplitTarget(target, this.cells, me.getEvent())) {
            graph.splitEdge(target, this.cells, null, dx, dy, me.getGraphX(), me.getGraphY());
          } else if (this.cells) {
            this.moveCells(this.cells, dx, dy, clone2, this.target, me.getEvent());
          }
        }
      } else if (this.isSelectEnabled() && this.delayedSelection && this.cell != null) {
        this.selectDelayed(me);
      }
    }
    if (this.cellWasClicked) {
      this.consumeMouseEvent(InternalEvent.MOUSE_UP, me);
    }
    this.reset();
  }
  /**
   * Resets the state of this handler.
   */
  reset() {
    var _a;
    if (this.livePreviewUsed) {
      this.resetLivePreview();
      this.setHandlesVisibleForCells(((_a = this.getSelectionCellsHandler()) == null ? void 0 : _a.getHandledSelectionCells()) ?? [], true);
    }
    this.destroyShapes();
    this.removeHint();
    this.delayedSelection = false;
    this.livePreviewActive = false;
    this.livePreviewUsed = false;
    this.cellWasClicked = false;
    this.suspended = false;
    this.currentDx = 0;
    this.currentDy = 0;
    this.cellCount = 0;
    this.cloning = false;
    this.allCells.clear();
    this.pBounds = null;
    this.target = null;
    this.first = null;
    this.cells = null;
    this.cell = null;
  }
  /**
   * Returns true if the given cells should be removed from the parent for the specified
   * mousereleased event.
   */
  shouldRemoveCellsFromParent(parent, cells, evt) {
    if (parent.isVertex()) {
      const pState = this.graph.getView().getState(parent);
      if (pState) {
        let pt = convertPoint(this.graph.container, getClientX(evt), getClientY(evt));
        const alpha = toRadians(pState.style.rotation ?? 0);
        if (alpha !== 0) {
          const cos = Math.cos(-alpha);
          const sin = Math.sin(-alpha);
          const cx = new Point(pState.getCenterX(), pState.getCenterY());
          pt = getRotatedPoint(pt, cos, sin, cx);
        }
        return !contains(pState, pt.x, pt.y);
      }
    }
    return false;
  }
  /**
   * Moves the given cells by the specified amount.
   */
  moveCells(cells, dx, dy, clone2, target, evt) {
    if (!this.cell)
      return;
    if (clone2) {
      cells = this.graph.getCloneableCells(cells);
    }
    const parent = this.cell.getParent();
    if (!target && parent && this.isRemoveCellsFromParent() && this.shouldRemoveCellsFromParent(parent, cells, evt)) {
      target = this.graph.getDefaultParent();
    }
    clone2 = !!clone2 && !this.graph.isCellLocked(target || this.graph.getDefaultParent());
    this.graph.batchUpdate(() => {
      const parents = [];
      if (!clone2 && target && this.removeEmptyParents) {
        const dict = new Dictionary();
        for (let i = 0; i < cells.length; i += 1) {
          dict.put(cells[i], true);
        }
        for (let i = 0; i < cells.length; i += 1) {
          const par = cells[i].getParent();
          if (par && !dict.get(par)) {
            dict.put(par, true);
            parents.push(par);
          }
        }
      }
      cells = this.graph.moveCells(cells, dx, dy, clone2, target, evt);
      const temp = [];
      for (let i = 0; i < parents.length; i += 1) {
        if (this.shouldRemoveParent(parents[i])) {
          temp.push(parents[i]);
        }
      }
      this.graph.removeCells(temp, false);
    });
    if (clone2) {
      this.graph.setSelectionCells(cells);
    }
    if (this.isSelectEnabled() && this.scrollOnMove) {
      this.graph.scrollCellToVisible(cells[0]);
    }
  }
  /**
   * Returns true if the given parent should be removed after removal of child cells.
   */
  shouldRemoveParent(parent) {
    const state = this.graph.view.getState(parent);
    return state != null && (state.cell.isEdge() || state.cell.isVertex()) && this.graph.isCellDeletable(state.cell) && state.cell.getChildCount() === 0 && state.isTransparentState();
  }
  /**
   * Destroy the preview and highlight shapes.
   */
  destroyShapes() {
    if (this.shape) {
      this.shape.destroy();
      this.shape = null;
    }
    if (this.guide) {
      this.guide.destroy();
      this.guide = null;
    }
    if (this.highlight) {
      this.highlight.destroy();
      this.highlight = null;
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.panHandler);
    this.graph.removeListener(this.escapeHandler);
    this.graph.getDataModel().removeListener(this.refreshHandler);
    this.graph.removeListener(this.refreshHandler);
    InternalEvent.removeListener(document, "keydown", this.keyHandler);
    InternalEvent.removeListener(document, "keyup", this.keyHandler);
    this.destroyShapes();
    this.removeHint();
  }
  getSelectionCellsHandler() {
    return this.graph.getPlugin("SelectionCellsHandler");
  }
}
SelectionHandler.pluginId = "SelectionHandler";
class PanningManager {
  constructor(graph) {
    this.damper = 1 / 6;
    this.delay = 10;
    this.handleMouseOut = true;
    this.border = 0;
    this.thread = null;
    this.active = false;
    this.tdx = 0;
    this.tdy = 0;
    this.t0x = 0;
    this.t0y = 0;
    this.dx = 0;
    this.dy = 0;
    this.scrollbars = false;
    this.scrollLeft = 0;
    this.scrollTop = 0;
    this.thread = null;
    this.active = false;
    this.tdx = 0;
    this.tdy = 0;
    this.t0x = 0;
    this.t0y = 0;
    this.dx = 0;
    this.dy = 0;
    this.scrollbars = false;
    this.scrollLeft = 0;
    this.scrollTop = 0;
    this.mouseListener = {
      mouseDown: (sender, me) => {
        return;
      },
      mouseMove: (sender, me) => {
        return;
      },
      mouseUp: (sender, me) => {
        if (this.active) {
          this.stop();
        }
      }
    };
    graph.addMouseListener(this.mouseListener);
    this.mouseUpListener = () => {
      if (this.active) {
        this.stop();
      }
    };
    InternalEvent.addListener(document, "mouseup", this.mouseUpListener);
    const createThread = () => {
      this.scrollbars = hasScrollbars(graph.container);
      this.scrollLeft = graph.container.scrollLeft;
      this.scrollTop = graph.container.scrollTop;
      return window.setInterval(() => {
        this.tdx -= this.dx;
        this.tdy -= this.dy;
        if (this.scrollbars) {
          const left = -graph.container.scrollLeft - Math.ceil(this.dx);
          const top = -graph.container.scrollTop - Math.ceil(this.dy);
          graph.panGraph(left, top);
          graph.setPanDx(this.scrollLeft - graph.container.scrollLeft);
          graph.setPanDy(this.scrollTop - graph.container.scrollTop);
          graph.fireEvent(new EventObject(InternalEvent.PAN));
        } else {
          graph.panGraph(this.getDx(), this.getDy());
        }
      }, this.delay);
    };
    this.isActive = () => {
      return this.active;
    };
    this.getDx = () => {
      return Math.round(this.tdx);
    };
    this.getDy = () => {
      return Math.round(this.tdy);
    };
    this.start = () => {
      this.t0x = graph.view.translate.x;
      this.t0y = graph.view.translate.y;
      this.active = true;
    };
    this.panTo = (x, y, w = 0, h = 0) => {
      if (!this.active) {
        this.start();
      }
      this.scrollLeft = graph.container.scrollLeft;
      this.scrollTop = graph.container.scrollTop;
      const c = graph.container;
      this.dx = x + w - c.scrollLeft - c.clientWidth;
      if (this.dx < 0 && Math.abs(this.dx) < this.border) {
        this.dx = this.border + this.dx;
      } else if (this.handleMouseOut) {
        this.dx = Math.max(this.dx, 0);
      } else {
        this.dx = 0;
      }
      if (this.dx == 0) {
        this.dx = x - c.scrollLeft;
        if (this.dx > 0 && this.dx < this.border) {
          this.dx -= this.border;
        } else if (this.handleMouseOut) {
          this.dx = Math.min(0, this.dx);
        } else {
          this.dx = 0;
        }
      }
      this.dy = y + h - c.scrollTop - c.clientHeight;
      if (this.dy < 0 && Math.abs(this.dy) < this.border) {
        this.dy = this.border + this.dy;
      } else if (this.handleMouseOut) {
        this.dy = Math.max(this.dy, 0);
      } else {
        this.dy = 0;
      }
      if (this.dy == 0) {
        this.dy = y - c.scrollTop;
        if (this.dy > 0 && this.dy < this.border) {
          this.dy -= this.border;
        } else if (this.handleMouseOut) {
          this.dy = Math.min(0, this.dy);
        } else {
          this.dy = 0;
        }
      }
      if (this.dx != 0 || this.dy != 0) {
        this.dx *= this.damper;
        this.dy *= this.damper;
        if (this.thread == null) {
          this.thread = createThread();
        }
      } else if (this.thread != null) {
        window.clearInterval(this.thread);
        this.thread = null;
      }
    };
    this.stop = () => {
      if (this.active) {
        this.active = false;
        if (this.thread != null) {
          window.clearInterval(this.thread);
          this.thread = null;
        }
        this.tdx = 0;
        this.tdy = 0;
        if (!this.scrollbars) {
          const px = graph.getPanDx();
          const py = graph.getPanDy();
          if (px != 0 || py != 0) {
            graph.panGraph(0, 0);
            graph.view.setTranslate(this.t0x + px / graph.view.scale, this.t0y + py / graph.view.scale);
          }
        } else {
          graph.setPanDx(0);
          graph.setPanDy(0);
          graph.fireEvent(new EventObject(InternalEvent.PAN));
        }
      }
    };
    this.destroy = () => {
      graph.removeMouseListener(this.mouseListener);
      InternalEvent.removeListener(document, "mouseup", this.mouseUpListener);
    };
  }
}
class PanningHandler extends EventSource {
  constructor(graph) {
    super();
    this.getPanningManager = () => this.panningManager;
    this.useLeftButtonForPanning = false;
    this.usePopupTrigger = true;
    this.ignoreCell = false;
    this.previewEnabled = true;
    this.useGrid = false;
    this.panningEnabled = false;
    this.pinchEnabled = true;
    this.initialScale = 0;
    this.maxScale = 8;
    this.minScale = 0.01;
    this.dx = 0;
    this.dy = 0;
    this.startX = 0;
    this.startY = 0;
    this.dx0 = 0;
    this.dy0 = 0;
    this.panningTrigger = false;
    this.active = false;
    this.mouseDownEvent = null;
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.forcePanningHandler = (sender, eo) => {
      const evtName = eo.getProperty("eventName");
      const me = eo.getProperty("event");
      if (evtName === InternalEvent.MOUSE_DOWN && this.isForcePanningEvent(me)) {
        this.start(me);
        this.active = true;
        this.fireEvent(new EventObject(InternalEvent.PAN_START, { event: me }));
        me.consume();
      }
    };
    this.graph.addListener(InternalEvent.FIRE_MOUSE_EVENT, this.forcePanningHandler);
    this.gestureHandler = (sender, eo) => {
      if (this.isPinchEnabled()) {
        const evt = eo.getProperty("event");
        if (!isConsumed(evt) && evt.type === "gesturestart") {
          this.initialScale = this.graph.view.scale;
          if (!this.active && this.mouseDownEvent) {
            this.start(this.mouseDownEvent);
            this.mouseDownEvent = null;
          }
        } else if (evt.type === "gestureend" && this.initialScale !== 0) {
          this.initialScale = 0;
        }
        if (this.initialScale !== 0) {
          this.zoomGraph(evt);
        }
      }
    };
    this.graph.addListener(InternalEvent.GESTURE, this.gestureHandler);
    this.mouseUpListener = () => {
      if (this.active) {
        this.reset();
      }
    };
    InternalEvent.addListener(document, "mouseup", this.mouseUpListener);
    this.panningManager = new PanningManager(graph);
  }
  /**
   * Returns true if the handler is currently active.
   */
  isActive() {
    return this.active || this.initialScale !== null;
  }
  /**
   * Returns <panningEnabled>.
   */
  isPanningEnabled() {
    return this.panningEnabled;
  }
  /**
   * Sets <panningEnabled>.
   */
  setPanningEnabled(value) {
    this.panningEnabled = value;
  }
  /**
   * Returns <pinchEnabled>.
   */
  isPinchEnabled() {
    return this.pinchEnabled;
  }
  /**
   * Sets <pinchEnabled>.
   */
  setPinchEnabled(value) {
    this.pinchEnabled = value;
  }
  /**
   * Returns true if the given event is a panning trigger for the optional
   * given cell. This returns true if control-shift is pressed or if
   * <usePopupTrigger> is true and the event is a popup trigger.
   */
  isPanningTrigger(me) {
    const evt = me.getEvent();
    return this.useLeftButtonForPanning && !me.getState() && isLeftMouseButton(evt) || isControlDown(evt) && isShiftDown(evt) || this.usePopupTrigger && isPopupTrigger(evt);
  }
  /**
   * Returns true if the given {@link MouseEvent} should start panning. This
   * implementation always returns true if <ignoreCell> is true or for
   * multi touch events.
   */
  isForcePanningEvent(me) {
    return this.ignoreCell || isMultiTouchEvent(me.getEvent());
  }
  /**
   * Handles the event by initiating the panning. By consuming the event all
   * subsequent events of the gesture are redirected to this handler.
   */
  mouseDown(sender, me) {
    this.mouseDownEvent = me;
    if (!me.isConsumed() && this.isPanningEnabled() && !this.active && this.isPanningTrigger(me)) {
      this.start(me);
      this.consumePanningTrigger(me);
    }
  }
  /**
   * Starts panning at the given event.
   */
  start(me) {
    this.dx0 = -this.graph.container.scrollLeft;
    this.dy0 = -this.graph.container.scrollTop;
    this.startX = me.getX();
    this.startY = me.getY();
    this.dx = 0;
    this.dy = 0;
    this.panningTrigger = true;
  }
  /**
   * Consumes the given {@link MouseEvent} if it was a panning trigger in
   * {@link ouseDown}. The default is to invoke {@link MouseEvent#consume}. Note that this
   * will block any further event processing. If you haven't disabled built-in
   * context menus and require immediate selection of the cell on mouseDown in
   * Safari and/or on the Mac, then use the following code:
   *
   * ```javascript
   * consumePanningTrigger(me)
   * {
   *   if (me.evt.preventDefault)
   *   {
   *     me.evt.preventDefault();
   *   }
   *
   *   // Stops event processing in IE
   *   me.evt.returnValue = false;
   *
   *   // Sets local consumed state
   *   if (!Client.IS_SF && !Client.IS_MAC)
   *   {
   *     me.consumed = true;
   *   }
   * };
   * ```
   */
  consumePanningTrigger(me) {
    me.consume();
  }
  /**
   * Handles the event by updating the panning on the graph.
   */
  mouseMove(sender, me) {
    this.dx = me.getX() - this.startX;
    this.dy = me.getY() - this.startY;
    if (this.active) {
      if (this.previewEnabled) {
        if (this.useGrid) {
          this.dx = this.graph.snap(this.dx);
          this.dy = this.graph.snap(this.dy);
        }
        this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);
      }
      this.fireEvent(new EventObject(InternalEvent.PAN, { event: me }));
    } else if (this.panningTrigger) {
      const tmp = this.active;
      this.active = Math.abs(this.dx) > this.graph.getSnapTolerance() || Math.abs(this.dy) > this.graph.getSnapTolerance();
      if (!tmp && this.active) {
        this.fireEvent(new EventObject(InternalEvent.PAN_START, { event: me }));
      }
    }
    if (this.active || this.panningTrigger) {
      me.consume();
    }
  }
  /**
   * Handles the event by setting the translation on the view or showing the
   * popupmenu.
   */
  mouseUp(sender, me) {
    if (this.active) {
      if (this.dx !== 0 && this.dy !== 0) {
        if (!this.graph.isUseScrollbarsForPanning() || !hasScrollbars(this.graph.container)) {
          const { scale } = this.graph.getView();
          const t = this.graph.getView().translate;
          this.graph.panGraph(0, 0);
          this.panGraph(t.x + this.dx / scale, t.y + this.dy / scale);
        }
        me.consume();
      }
      this.fireEvent(new EventObject(InternalEvent.PAN_END, { event: me }));
    }
    this.reset();
  }
  /**
   * Zooms the graph to the given value and consumed the event if needed.
   */
  zoomGraph(evt) {
    let value = Math.round(this.initialScale * evt.scale * 100) / 100;
    value = Math.max(this.minScale, value);
    value = Math.min(this.maxScale, value);
    if (this.graph.view.scale !== value) {
      this.graph.zoomTo(value);
      InternalEvent.consume(evt);
    }
  }
  /**
   * Handles the event by setting the translation on the view or showing the
   * popupmenu.
   */
  reset() {
    this.panningTrigger = false;
    this.mouseDownEvent = null;
    this.active = false;
    this.dx = 0;
    this.dy = 0;
  }
  /**
   * Pans {@link graph} by the given amount.
   */
  panGraph(dx, dy) {
    this.graph.getView().setTranslate(dx, dy);
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.forcePanningHandler);
    this.graph.removeListener(this.gestureHandler);
    InternalEvent.removeListener(document, "mouseup", this.mouseUpListener);
  }
}
PanningHandler.pluginId = "PanningHandler";
function keep2digits(value) {
  return Number(value.toFixed(2));
}
class FitPlugin {
  /**
   * Constructs the plugin that provides `fit` methods.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   */
  constructor(graph) {
    this.graph = graph;
    this.maxFitScale = 8;
  }
  /**
   * Fit and center the graph within its container.
   *
   * @param options Optional options to customize the fit behavior.
   * @returns The current scale in the view.
   */
  fitCenter(options) {
    const margin = (options == null ? void 0 : options.margin) ?? 2;
    const { container, view } = this.graph;
    const clientWidth = container.clientWidth - 2 * margin;
    const clientHeight = container.clientHeight - 2 * margin;
    const bounds = this.graph.getGraphBounds();
    const originalScale = view.scale;
    const width = bounds.width / originalScale;
    const height = bounds.height / originalScale;
    let newScale = Math.min(this.maxFitScale ?? Infinity, clientWidth / width, clientHeight / height);
    const translateX = Math.floor(view.translate.x + (container.clientWidth - width * newScale) / (2 * newScale) - bounds.x / originalScale);
    const translateY = Math.floor(view.translate.y + (container.clientHeight - height * newScale) / (2 * newScale) - bounds.y / originalScale);
    newScale = keep2digits(newScale);
    view.scaleAndTranslate(newScale, translateX, translateY);
    return newScale;
  }
  /** Do nothing here. */
  onDestroy() {
  }
}
FitPlugin.pluginId = "fit";
class RubberBandHandler {
  constructor(graph) {
    this.first = null;
    this.destroyed = false;
    this.dragHandler = null;
    this.dropHandler = null;
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.defaultOpacity = 20;
    this.enabled = true;
    this.div = null;
    this.sharedDiv = null;
    this.currentX = 0;
    this.currentY = 0;
    this.fadeOut = false;
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.forceRubberbandHandler = (sender, evt) => {
      const evtName = evt.getProperty("eventName");
      const me = evt.getProperty("event");
      if (evtName === InternalEvent.MOUSE_DOWN && this.isForceRubberbandEvent(me)) {
        const offset = getOffset(this.graph.container);
        const origin = getScrollOrigin(this.graph.container);
        origin.x -= offset.x;
        origin.y -= offset.y;
        this.start(me.getX() + origin.x, me.getY() + origin.y);
        me.consume(false);
      }
    };
    this.graph.addListener(InternalEvent.FIRE_MOUSE_EVENT, this.forceRubberbandHandler);
    this.panHandler = () => {
      this.repaint();
    };
    this.graph.addListener(InternalEvent.PAN, this.panHandler);
    this.gestureHandler = (sender, eo) => {
      if (this.first) {
        this.reset();
      }
    };
    this.graph.addListener(InternalEvent.GESTURE, this.gestureHandler);
  }
  /**
   * Creates the rubberband selection shape.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation updates{@link enabled}.
   */
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Returns true if the given {@link MouseEvent} should start rubberband selection.
   * This implementation returns true if the alt key is pressed.
   */
  isForceRubberbandEvent(me) {
    return isAltDown(me.getEvent());
  }
  /**
   * Handles the event by initiating a rubberband selection.
   * By consuming the event all subsequent events of the gesture are redirected to this handler.
   */
  mouseDown(sender, me) {
    if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && !me.getState() && !isMultiTouchEvent(me.getEvent())) {
      const offset = getOffset(this.graph.container);
      const origin = getScrollOrigin(this.graph.container);
      origin.x -= offset.x;
      origin.y -= offset.y;
      this.start(me.getX() + origin.x, me.getY() + origin.y);
      me.consume(false);
    }
  }
  /**
   * Creates the rubberband selection shape.
   */
  start(x, y) {
    this.first = new Point(x, y);
    const { container } = this.graph;
    function createMouseEvent(evt) {
      const me = new InternalMouseEvent(evt);
      const pt = convertPoint(container, me.getX(), me.getY());
      me.graphX = pt.x;
      me.graphY = pt.y;
      return me;
    }
    this.dragHandler = (evt) => {
      this.mouseMove(this.graph, createMouseEvent(evt));
    };
    this.dropHandler = (evt) => {
      this.mouseUp(this.graph, createMouseEvent(evt));
    };
    if (Client.IS_FF) {
      InternalEvent.addGestureListeners(document, null, this.dragHandler, this.dropHandler);
    }
  }
  /**
   * Handles the event by updating the rubberband selection.
   */
  mouseMove(sender, me) {
    if (!me.isConsumed() && this.first) {
      const origin = getScrollOrigin(this.graph.container);
      const offset = getOffset(this.graph.container);
      origin.x -= offset.x;
      origin.y -= offset.y;
      const x = me.getX() + origin.x;
      const y = me.getY() + origin.y;
      const dx = this.first.x - x;
      const dy = this.first.y - y;
      const tol = this.graph.getEventTolerance();
      if (this.div || Math.abs(dx) > tol || Math.abs(dy) > tol) {
        if (!this.div) {
          this.div = this.createShape();
        }
        clearSelection();
        this.update(x, y);
        me.consume();
      }
    }
  }
  /**
   * Creates the rubberband selection shape.
   */
  createShape() {
    if (!this.sharedDiv) {
      this.sharedDiv = document.createElement("div");
      this.sharedDiv.className = "mxRubberband";
      setOpacity(this.sharedDiv, this.defaultOpacity);
    }
    this.graph.container.appendChild(this.sharedDiv);
    const result = this.sharedDiv;
    if (Client.IS_SVG && this.fadeOut) {
      this.sharedDiv = null;
    }
    return result;
  }
  /**
   * Returns true if this handler is active.
   */
  isActive(sender, me) {
    return this.div && this.div.style.display !== "none";
  }
  /**
   * Handles the event by selecting the region of the rubberband using {@link Graph#selectRegion}.
   */
  mouseUp(sender, me) {
    const active = this.isActive();
    this.reset();
    if (active) {
      this.execute(me.getEvent());
      me.consume();
    }
  }
  /**
   * Resets the state of this handler and selects the current region for the given event.
   */
  execute(evt) {
    const rect = new Rectangle(this.x, this.y, this.width, this.height);
    this.graph.selectRegion(rect, evt);
  }
  /**
   * Resets the state of the rubberband selection.
   */
  reset() {
    if (this.div) {
      if (Client.IS_SVG && this.fadeOut) {
        const temp = this.div;
        setPrefixedStyle(temp.style, "transition", "all 0.2s linear");
        temp.style.pointerEvents = "none";
        temp.style.opacity = String(0);
        window.setTimeout(() => {
          if (temp.parentNode)
            temp.parentNode.removeChild(temp);
        }, 200);
      } else {
        if (this.div.parentNode)
          this.div.parentNode.removeChild(this.div);
      }
    }
    InternalEvent.removeGestureListeners(document, null, this.dragHandler, this.dropHandler);
    this.dragHandler = null;
    this.dropHandler = null;
    this.currentX = 0;
    this.currentY = 0;
    this.first = null;
    this.div = null;
  }
  /**
   * Sets <currentX> and <currentY> and calls {@link repaint}.
   */
  update(x, y) {
    this.currentX = x;
    this.currentY = y;
    this.repaint();
  }
  /**
   * Computes the bounding box and updates the style of the `div`.
   */
  repaint() {
    if (this.div && this.first) {
      const x = this.currentX - this.graph.getPanDx();
      const y = this.currentY - this.graph.getPanDy();
      this.x = Math.min(this.first.x, x);
      this.y = Math.min(this.first.y, y);
      this.width = Math.max(this.first.x, x) - this.x;
      this.height = Math.max(this.first.y, y) - this.y;
      const dx = 0;
      const dy = 0;
      this.div.style.left = `${this.x + dx}px`;
      this.div.style.top = `${this.y + dy}px`;
      this.div.style.width = `${Math.max(1, this.width)}px`;
      this.div.style.height = `${Math.max(1, this.height)}px`;
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   * This does normally not need to be called, it is called automatically when the window unloads.
   */
  onDestroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.graph.removeMouseListener(this);
      this.graph.removeListener(this.forceRubberbandHandler);
      this.graph.removeListener(this.panHandler);
      this.reset();
      if (this.sharedDiv) {
        this.sharedDiv = null;
      }
    }
  }
}
RubberBandHandler.pluginId = "RubberBandHandler";
const getDefaultPlugins = () => [
  CellEditorHandler,
  TooltipHandler,
  SelectionCellsHandler,
  PopupMenuHandler,
  ConnectionHandler,
  SelectionHandler,
  PanningHandler,
  FitPlugin
];
class Graph extends EventSource {
  // ===================================================================================================================
  // Group: "Create Class Instance" factory functions.
  // These can be overridden in subclasses of Graph to allow the Graph to instantiate user-defined implementations with
  // custom behavior.
  // ===================================================================================================================
  /**
   * Creates a new {@link CellRenderer} to be used in this graph.
   */
  createCellRenderer() {
    return new CellRenderer();
  }
  /**
   * Hooks to create a new {@link EdgeHandler} for the given {@link CellState}.
   *
   * @param state {@link CellState} to create the handler for.
   */
  createEdgeHandlerInstance(state) {
    return new EdgeHandler(state);
  }
  /**
   * Hooks to create a new {@link EdgeSegmentHandler} for the given {@link CellState}.
   *
   * @param state {@link CellState} to create the handler for.
   */
  createEdgeSegmentHandler(state) {
    return new EdgeSegmentHandler(state);
  }
  /**
   * Hooks to create a new {@link ElbowEdgeHandler} for the given {@link CellState}.
   *
   * @param state {@link CellState} to create the handler for.
   */
  createElbowEdgeHandler(state) {
    return new ElbowEdgeHandler(state);
  }
  /**
   * Creates a new {@link GraphDataModel} to be used in this graph.
   */
  createGraphDataModel() {
    return new GraphDataModel();
  }
  /**
   * Creates a new {@link GraphView} to be used in this graph.
   */
  createGraphView() {
    return new GraphView(this);
  }
  /**
   * Creates a new {@link GraphSelectionModel} to be used in this graph.
   */
  createSelectionModel() {
    return new GraphSelectionModel(this);
  }
  /**
   * Creates a new {@link Stylesheet} to be used in this graph.
   */
  createStylesheet() {
    return new Stylesheet();
  }
  /**
   * Hooks to create a new {@link VertexHandler} for the given {@link CellState}.
   *
   * @param state {@link CellState} to create the handler for.
   */
  createVertexHandler(state) {
    return new VertexHandler(state);
  }
  // ===================================================================================================================
  // Group: Main graph constructor and functions
  // ===================================================================================================================
  registerDefaults() {
    registerDefaultShapes();
    registerDefaultStyleElements();
    registerDefaultEdgeMarkers();
  }
  constructor(container, model, plugins = getDefaultPlugins(), stylesheet = null) {
    super();
    this.destroyed = false;
    this.graphModelChangeListener = null;
    this.paintBackground = null;
    this.isConstrainedMoving = false;
    this.cells = [];
    this.imageBundles = [];
    this.mouseListeners = [];
    this.multiplicities = [];
    this.plugins = {};
    this.renderHint = null;
    this.dialect = "svg";
    this.defaultOverlap = 0.5;
    this.defaultParent = null;
    this.backgroundImage = null;
    this.pageVisible = false;
    this.pageBreaksVisible = false;
    this.pageBreakColor = "gray";
    this.pageBreakDashed = true;
    this.minPageBreakDist = 20;
    this.preferPageSize = false;
    this.pageFormat = new Rectangle(...PAGE_FORMAT_A4_PORTRAIT);
    this.pageScale = 1.5;
    this.enabled = true;
    this.exportEnabled = true;
    this.importEnabled = true;
    this.ignoreScrollbars = false;
    this.translateToScrollPosition = false;
    this.maximumGraphBounds = null;
    this.minimumGraphSize = null;
    this.minimumContainerSize = null;
    this.maximumContainerSize = null;
    this.resizeContainer = false;
    this.border = 0;
    this.keepEdgesInForeground = false;
    this.keepEdgesInBackground = false;
    this.recursiveResize = false;
    this.resetViewOnRootChange = true;
    this.allowLoops = false;
    this.defaultLoopStyle = EdgeStyle.Loop;
    this.multigraph = true;
    this.minFitScale = 0.1;
    this.maxFitScale = 8;
    this.warningImage = new ImageBox(`${Client.imageBasePath}/warning${Client.IS_MAC ? ".png" : ".gif"}`, 16, 16);
    this.alreadyConnectedResource = isI18nEnabled() ? "alreadyConnected" : "";
    this.containsValidationErrorsResource = isI18nEnabled() ? "containsValidationErrors" : "";
    this.options = {
      foldingEnabled: true,
      collapsedImage: new ImageBox(`${Client.imageBasePath}/collapsed.gif`, 9, 9),
      expandedImage: new ImageBox(`${Client.imageBasePath}/expanded.gif`, 9, 9),
      collapseToPreferredSize: true
    };
    this.getContainer = () => this.container;
    this.getPlugin = (id) => this.plugins[id];
    this.getCellRenderer = () => this.cellRenderer;
    this.getDialect = () => this.dialect;
    this.isPageVisible = () => this.pageVisible;
    this.isPageBreaksVisible = () => this.pageBreaksVisible;
    this.getPageBreakColor = () => this.pageBreakColor;
    this.isPageBreakDashed = () => this.pageBreakDashed;
    this.getMinPageBreakDist = () => this.minPageBreakDist;
    this.isPreferPageSize = () => this.preferPageSize;
    this.getPageFormat = () => this.pageFormat;
    this.getPageScale = () => this.pageScale;
    this.isExportEnabled = () => this.exportEnabled;
    this.isImportEnabled = () => this.importEnabled;
    this.isIgnoreScrollbars = () => this.ignoreScrollbars;
    this.isTranslateToScrollPosition = () => this.translateToScrollPosition;
    this.getMinimumGraphSize = () => this.minimumGraphSize;
    this.setMinimumGraphSize = (size) => this.minimumGraphSize = size;
    this.getMinimumContainerSize = () => this.minimumContainerSize;
    this.setMinimumContainerSize = (size) => this.minimumContainerSize = size;
    this.getAlreadyConnectedResource = () => this.alreadyConnectedResource;
    this.getContainsValidationErrorsResource = () => this.containsValidationErrorsResource;
    this.registerDefaults();
    this.container = container ?? document.createElement("div");
    this.model = model ?? this.createGraphDataModel();
    this.cellRenderer = this.createCellRenderer();
    this.setStylesheet(stylesheet ?? this.createStylesheet());
    this.view = this.createGraphView();
    this.graphModelChangeListener = (sender, evt) => {
      this.graphModelChanged(evt.getProperty("edit").changes);
    };
    this.getDataModel().addListener(InternalEvent.CHANGE, this.graphModelChangeListener);
    this.view.init();
    this.sizeDidChange();
    this.setSelectionModel(this.createSelectionModel());
    plugins.forEach((p) => this.plugins[p.pluginId] = new p(this));
    this.view.revalidate();
  }
  getWarningImage() {
    return this.warningImage;
  }
  /**
   * Updates the model in a transaction.
   *
   * @param fn the update to be performed in the transaction.
   *
   * @see {@link GraphDataModel.batchUpdate}
   */
  batchUpdate(fn) {
    this.getDataModel().batchUpdate(fn);
  }
  /**
   * Returns the {@link GraphDataModel} that contains the cells.
   */
  getDataModel() {
    return this.model;
  }
  /**
   * Returns the {@link GraphView} that contains the {@link mxCellStates}.
   */
  getView() {
    return this.view;
  }
  /**
   * Returns the {@link Stylesheet} that defines the style.
   */
  getStylesheet() {
    return this.stylesheet;
  }
  /**
   * Sets the {@link Stylesheet} that defines the style.
   */
  setStylesheet(stylesheet) {
    this.stylesheet = stylesheet;
  }
  /**
   * Called when the graph model changes. Invokes {@link processChange} on each
   * item of the given array to update the view accordingly.
   *
   * @param changes Array that contains the individual changes.
   */
  graphModelChanged(changes) {
    for (const change of changes) {
      this.processChange(change);
    }
    this.updateSelection();
    this.view.validate();
    this.sizeDidChange();
  }
  /**
   * Processes the given change and invalidates the respective cached data
   * in {@link GraphView}. This fires a {@link root} event if the root has changed in the
   * model.
   *
   * @param {(RootChange|ChildChange|TerminalChange|GeometryChange|ValueChange|StyleChange)} change - Object that represents the change on the model.
   */
  processChange(change) {
    if (change instanceof RootChange) {
      this.clearSelection();
      this.setDefaultParent(null);
      if (change.previous)
        this.removeStateForCell(change.previous);
      if (this.resetViewOnRootChange) {
        this.view.scale = 1;
        this.view.translate.x = 0;
        this.view.translate.y = 0;
      }
      this.fireEvent(new EventObject(InternalEvent.ROOT));
    } else if (change instanceof ChildChange) {
      const newParent = change.child.getParent();
      this.view.invalidate(change.child, true, true);
      if (!newParent || !this.getDataModel().contains(newParent) || newParent.isCollapsed()) {
        this.view.invalidate(change.child, true, true);
        this.removeStateForCell(change.child);
        if (this.view.currentRoot == change.child) {
          this.home();
        }
      }
      if (newParent != change.previous) {
        if (newParent != null) {
          this.view.invalidate(newParent, false, false);
        }
        if (change.previous != null) {
          this.view.invalidate(change.previous, false, false);
        }
      }
    } else if (change instanceof TerminalChange || change instanceof GeometryChange) {
      if (change instanceof TerminalChange || change.previous == null && change.geometry != null || change.previous != null && !change.previous.equals(change.geometry)) {
        this.view.invalidate(change.cell);
      }
    } else if (change instanceof ValueChange) {
      this.view.invalidate(change.cell, false, false);
    } else if (change instanceof StyleChange) {
      this.view.invalidate(change.cell, true, true);
      const state = this.view.getState(change.cell);
      if (state != null) {
        state.invalidStyle = true;
      }
    } else if (change.cell != null && change.cell instanceof Cell) {
      this.removeStateForCell(change.cell);
    }
  }
  /**
   * Scrolls the graph to the given point, extending the graph container if
   * specified.
   */
  scrollPointToVisible(x, y, extend = false, border = 20) {
    const panningHandler = this.getPlugin("PanningHandler");
    if (!this.isTimerAutoScroll() && (this.ignoreScrollbars || hasScrollbars(this.container))) {
      const c = this.container;
      if (x >= c.scrollLeft && y >= c.scrollTop && x <= c.scrollLeft + c.clientWidth && y <= c.scrollTop + c.clientHeight) {
        let dx = c.scrollLeft + c.clientWidth - x;
        if (dx < border) {
          const old = c.scrollLeft;
          c.scrollLeft += border - dx;
          if (extend && old === c.scrollLeft) {
            const root = this.view.getDrawPane().ownerSVGElement;
            const width = c.scrollWidth + border - dx;
            root.style.width = `${width}px`;
            c.scrollLeft += border - dx;
          }
        } else {
          dx = x - c.scrollLeft;
          if (dx < border) {
            c.scrollLeft -= border - dx;
          }
        }
        let dy = c.scrollTop + c.clientHeight - y;
        if (dy < border) {
          const old = c.scrollTop;
          c.scrollTop += border - dy;
          if (old == c.scrollTop && extend) {
            const root = this.view.getDrawPane().ownerSVGElement;
            const height = c.scrollHeight + border - dy;
            root.style.height = `${height}px`;
            c.scrollTop += border - dy;
          }
        } else {
          dy = y - c.scrollTop;
          if (dy < border) {
            c.scrollTop -= border - dy;
          }
        }
      }
    } else if (this.isAllowAutoPanning() && panningHandler && !panningHandler.isActive()) {
      panningHandler.getPanningManager().panTo(x + this.getPanDx(), y + this.getPanDy());
    }
  }
  /**
   * Returns the size of the border and padding on all four sides of the
   * container. The left, top, right and bottom borders are stored in the x, y,
   * width and height of the returned {@link Rectangle}, respectively.
   */
  getBorderSizes() {
    const css = getCurrentStyle(this.container);
    return new Rectangle(parseCssNumber(css.paddingLeft) + (css.borderLeftStyle != "none" ? parseCssNumber(css.borderLeftWidth) : 0), parseCssNumber(css.paddingTop) + (css.borderTopStyle != "none" ? parseCssNumber(css.borderTopWidth) : 0), parseCssNumber(css.paddingRight) + (css.borderRightStyle != "none" ? parseCssNumber(css.borderRightWidth) : 0), parseCssNumber(css.paddingBottom) + (css.borderBottomStyle != "none" ? parseCssNumber(css.borderBottomWidth) : 0));
  }
  /**
   * Returns the preferred size of the background page if {@link preferPageSize} is true.
   */
  getPreferredPageSize(bounds, width, height) {
    const tr = this.view.translate;
    const fmt = this.pageFormat;
    const ps = this.pageScale;
    const page = new Rectangle(0, 0, Math.ceil(fmt.width * ps), Math.ceil(fmt.height * ps));
    const hCount = this.pageBreaksVisible ? Math.ceil(width / page.width) : 1;
    const vCount = this.pageBreaksVisible ? Math.ceil(height / page.height) : 1;
    return new Rectangle(0, 0, hCount * page.width + 2 + tr.x, vCount * page.height + 2 + tr.y);
  }
  /**
   * Scales the graph such that the complete diagram fits into {@link Graph.container} and returns the current scale in the view.
   * To fit an initial graph prior to rendering, set {@link GraphView.rendering} to `false` prior to changing the model
   * and execute the following after changing the model.
   *
   * ```javascript
   * graph.view.rendering = false;
   * // here, change the model
   * graph.fit();
   * graph.view.rendering = true;
   * graph.refresh();
   * ```
   *
   * To fit and center the graph, use {@link FitPlugin.fitCenter}.
   *
   * @param border Optional number that specifies the border. Default is {@link border}.
   * @param keepOrigin Optional boolean that specifies if the translate should be changed. Default is `false`.
   * @param margin Optional margin in pixels. Default is `0`.
   * @param enabled Optional boolean that specifies if the scale should be set or just returned. Default is `true`.
   * @param ignoreWidth Optional boolean that specifies if the width should be ignored. Default is `false`.
   * @param ignoreHeight Optional boolean that specifies if the height should be ignored. Default is `false`.
   * @param maxHeight Optional maximum height.
   */
  fit(border = this.getBorder(), keepOrigin = false, margin = 0, enabled = true, ignoreWidth = false, ignoreHeight = false, maxHeight = null) {
    const { container, view } = this;
    if (container) {
      const cssBorder = this.getBorderSizes();
      let w1 = container.offsetWidth - cssBorder.x - cssBorder.width - 1;
      let h1 = maxHeight != null ? maxHeight : container.offsetHeight - cssBorder.y - cssBorder.height - 1;
      let bounds = view.getGraphBounds();
      if (bounds.width > 0 && bounds.height > 0) {
        if (keepOrigin && bounds.x != null && bounds.y != null) {
          bounds = bounds.clone();
          bounds.width += bounds.x;
          bounds.height += bounds.y;
          bounds.x = 0;
          bounds.y = 0;
        }
        const originalScale = view.scale;
        let w2 = bounds.width / originalScale;
        let h2 = bounds.height / originalScale;
        if (this.backgroundImage) {
          w2 = Math.max(w2, this.backgroundImage.width - bounds.x / originalScale);
          h2 = Math.max(h2, this.backgroundImage.height - bounds.y / originalScale);
        }
        const b = (keepOrigin ? border : 2 * border) + margin + 1;
        w1 -= b;
        h1 -= b;
        let newScale = ignoreWidth ? h1 / h2 : ignoreHeight ? w1 / w2 : Math.min(w1 / w2, h1 / h2);
        if (this.minFitScale != null) {
          newScale = Math.max(newScale, this.minFitScale);
        }
        if (this.maxFitScale != null) {
          newScale = Math.min(newScale, this.maxFitScale);
        }
        if (enabled) {
          if (!keepOrigin) {
            if (!hasScrollbars(container)) {
              const x0 = bounds.x != null ? Math.floor(view.translate.x - bounds.x / originalScale + border / newScale + margin / 2) : border;
              const y0 = bounds.y != null ? Math.floor(view.translate.y - bounds.y / originalScale + border / newScale + margin / 2) : border;
              view.scaleAndTranslate(newScale, x0, y0);
            } else {
              view.setScale(newScale);
              const newBounds = this.getGraphBounds();
              if (newBounds.x != null) {
                container.scrollLeft = newBounds.x;
              }
              if (newBounds.y != null) {
                container.scrollTop = newBounds.y;
              }
            }
          } else if (view.scale != newScale) {
            view.setScale(newScale);
          }
        } else {
          return newScale;
        }
      }
    }
    return view.scale;
  }
  /**
   * Resizes the container for the given graph width and height.
   */
  doResizeContainer(width, height) {
    if (this.maximumContainerSize != null) {
      width = Math.min(this.maximumContainerSize.width, width);
      height = Math.min(this.maximumContainerSize.height, height);
    }
    const container = this.container;
    container.style.width = `${Math.ceil(width)}px`;
    container.style.height = `${Math.ceil(height)}px`;
  }
  /*****************************************************************************
   * Group: UNCLASSIFIED
   *****************************************************************************/
  /**
   * Creates a new handler for the given cell state. This implementation
   * returns a new {@link EdgeHandler} of the corresponding cell is an edge,
   * otherwise it returns an {@link VertexHandler}.
   *
   * @param state {@link CellState} whose handler should be created.
   */
  createHandler(state) {
    let result = null;
    if (state.cell.isEdge()) {
      const source = state.getVisibleTerminalState(true);
      const target = state.getVisibleTerminalState(false);
      const geo = state.cell.getGeometry();
      const edgeStyle = this.getView().getEdgeStyle(state, geo ? geo.points || void 0 : void 0, source, target);
      result = this.createEdgeHandler(state, edgeStyle);
    } else {
      result = this.createVertexHandler(state);
    }
    return result;
  }
  /**
   * Hooks to create a new {@link EdgeHandler} for the given {@link CellState}.
   *
   * @param state {@link CellState} to create the handler for.
   * @param edgeStyle the {@link EdgeStyleFunction} that let choose the actual edge handler.
   */
  createEdgeHandler(state, edgeStyle) {
    let result = null;
    if (edgeStyle == EdgeStyle.ElbowConnector || edgeStyle == EdgeStyle.Loop || edgeStyle == EdgeStyle.SideToSide || edgeStyle == EdgeStyle.TopToBottom) {
      result = this.createElbowEdgeHandler(state);
    } else if (edgeStyle == EdgeStyle.ManhattanConnector || edgeStyle == EdgeStyle.OrthConnector || edgeStyle == EdgeStyle.SegmentConnector) {
      result = this.createEdgeSegmentHandler(state);
    } else {
      result = this.createEdgeHandlerInstance(state);
    }
    return result;
  }
  /*****************************************************************************
   * Group: Drilldown
   *****************************************************************************/
  /**
   * Returns the current root of the displayed cell hierarchy. This is a
   * shortcut to {@link GraphView.currentRoot} in {@link GraphView}.
   */
  getCurrentRoot() {
    return this.view.currentRoot;
  }
  /**
   * Returns the translation to be used if the given cell is the root cell as
   * an {@link Point}. This implementation returns null.
   *
   * To keep the children at their absolute position while stepping into groups,
   * this function can be overridden as follows.
   *
   * @example
   * ```javascript
   * var offset = new mxPoint(0, 0);
   *
   * while (cell != null)
   * {
   *   var geo = this.model.getGeometry(cell);
   *
   *   if (geo != null)
   *   {
   *     offset.x -= geo.x;
   *     offset.y -= geo.y;
   *   }
   *
   *   cell = this.model.getParent(cell);
   * }
   *
   * return offset;
   * ```
   *
   * @param cell {@link mxCell} that represents the root.
   */
  getTranslateForRoot(cell) {
    return null;
  }
  /**
   * Returns the offset to be used for the cells inside the given cell. The
   * root and layer cells may be identified using {@link GraphDataModel.isRoot} and
   * {@link GraphDataModel.isLayer}. For all other current roots, the
   * {@link GraphView.currentRoot} field points to the respective cell, so that
   * the following holds: cell == this.view.currentRoot. This implementation
   * returns null.
   *
   * @param cell {@link mxCell} whose offset should be returned.
   */
  getChildOffsetForCell(cell) {
    return null;
  }
  /**
   * Uses the root of the model as the root of the displayed cell hierarchy
   * and selects the previous root.
   */
  home() {
    const current = this.getCurrentRoot();
    if (current != null) {
      this.view.setCurrentRoot(null);
      const state = this.view.getState(current);
      if (state != null) {
        this.setSelectionCell(current);
      }
    }
  }
  /**
   * Returns true if the given cell is a valid root for the cell display
   * hierarchy. This implementation returns true for all non-null values.
   *
   * @param cell {@link mxCell} which should be checked as a possible root.
   */
  isValidRoot(cell) {
    return !!cell;
  }
  /*****************************************************************************
   * Group: Graph display
   *****************************************************************************/
  /**
   * Returns the bounds of the visible graph. Shortcut to
   * {@link GraphView.getGraphBounds}. See also: {@link getBoundingBoxFromGeometry}.
   */
  getGraphBounds() {
    return this.view.getGraphBounds();
  }
  /**
   * Returns the bounds inside which the diagram should be kept as an
   * {@link Rectangle}.
   */
  getMaximumGraphBounds() {
    return this.maximumGraphBounds;
  }
  /**
   * Clears all cell states or the states for the hierarchy starting at the
   * given cell and validates the graph. This fires a refresh event as the
   * last step.
   *
   * @param cell Optional {@link Cell} for which the cell states should be cleared.
   */
  refresh(cell = null) {
    if (cell) {
      this.view.clear(cell, false);
    } else {
      this.view.clear(void 0, true);
    }
    this.view.validate();
    this.sizeDidChange();
    this.fireEvent(new EventObject(InternalEvent.REFRESH));
  }
  /**
   * Centers the graph in the container.
   *
   * @param horizontal Optional boolean that specifies if the graph should be centered
   * horizontally. Default is `true`.
   * @param vertical Optional boolean that specifies if the graph should be centered
   * vertically. Default is `true`.
   * @param cx Optional float that specifies the horizontal center. Default is `0.5`.
   * @param cy Optional float that specifies the vertical center. Default is `0.5`.
   */
  center(horizontal = true, vertical = true, cx = 0.5, cy = 0.5) {
    const container = this.container;
    const _hasScrollbars = hasScrollbars(this.container);
    const padding = 2 * this.getBorder();
    const cw = container.clientWidth - padding;
    const ch = container.clientHeight - padding;
    const bounds = this.getGraphBounds();
    const t = this.view.translate;
    const s = this.view.scale;
    let dx = horizontal ? cw - bounds.width : 0;
    let dy = vertical ? ch - bounds.height : 0;
    if (!_hasScrollbars) {
      this.view.setTranslate(horizontal ? Math.floor(t.x - bounds.x / s + dx * cx / s) : t.x, vertical ? Math.floor(t.y - bounds.y / s + dy * cy / s) : t.y);
    } else {
      bounds.x -= t.x;
      bounds.y -= t.y;
      const sw = container.scrollWidth;
      const sh = container.scrollHeight;
      if (sw > cw) {
        dx = 0;
      }
      if (sh > ch) {
        dy = 0;
      }
      this.view.setTranslate(Math.floor(dx / 2 - bounds.x), Math.floor(dy / 2 - bounds.y));
      container.scrollLeft = (sw - cw) / 2;
      container.scrollTop = (sh - ch) / 2;
    }
  }
  /**
   * Returns `true` if perimeter points should be computed such that the resulting edge has only horizontal or vertical segments.
   *
   * @param edge {@link CellState} that represents the edge.
   */
  isOrthogonal(edge) {
    const orthogonal = edge.style.orthogonal;
    if (!isNullish(orthogonal)) {
      return orthogonal;
    }
    const edgeStyle = this.view.getEdgeStyle(edge);
    return [
      EdgeStyle.EntityRelation,
      EdgeStyle.ElbowConnector,
      EdgeStyle.ManhattanConnector,
      EdgeStyle.OrthConnector,
      EdgeStyle.SegmentConnector,
      EdgeStyle.SideToSide,
      EdgeStyle.TopToBottom
    ].includes(edgeStyle);
  }
  /*****************************************************************************
   * Group: Graph appearance
   *****************************************************************************/
  /**
   * Returns the {@link backgroundImage} as an {@link Image}.
   */
  getBackgroundImage() {
    return this.backgroundImage;
  }
  /**
   * Sets the new {@link backgroundImage}.
   *
   * @param image New {@link Image} to be used for the background.
   */
  setBackgroundImage(image) {
    this.backgroundImage = image;
  }
  /**
   * Returns the textual representation for the given cell.
   *
   * This implementation returns the node name or string-representation of the user object.
   *
   *
   * The following returns the label attribute from the cells user object if it is an XML node.
   *
   * @example
   * ```javascript
   * graph.convertValueToString = function(cell)
   * {
   * 	return cell.getAttribute('label');
   * }
   * ```
   *
   * See also: {@link cellLabelChanged}.
   *
   * @param cell {@link Cell} whose textual representation should be returned.
   */
  convertValueToString(cell) {
    const value = cell.getValue();
    if (value != null) {
      if (isNode(value)) {
        return value.nodeName;
      }
      if (typeof value.toString === "function") {
        return value.toString();
      }
    }
    return "";
  }
  /**
   * Returns the string to be used as the link for the given cell.
   *
   * This implementation returns null.
   *
   * @param cell {@link Cell} whose link should be returned.
   */
  getLinkForCell(cell) {
    return null;
  }
  /**
   * Returns the value of {@link border}.
   */
  getBorder() {
    return this.border;
  }
  /**
   * Sets the value of {@link border}.
   *
   * @param value Positive integer that represents the border to be used.
   */
  setBorder(value) {
    this.border = value;
  }
  /*****************************************************************************
   * Group: Graph behaviour
   *****************************************************************************/
  /**
   * Returns {@link resizeContainer}.
   */
  isResizeContainer() {
    return this.resizeContainer;
  }
  /**
   * Sets {@link resizeContainer}.
   *
   * @param value Boolean indicating if the container should be resized.
   */
  setResizeContainer(value) {
    this.resizeContainer = value;
  }
  /**
   * Returns true if the graph is {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Specifies if the graph should allow any interactions. This
   * implementation updates {@link enabled}.
   *
   * @param value Boolean indicating if the graph should be enabled.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * Returns {@link multigraph} as a boolean.
   */
  isMultigraph() {
    return this.multigraph;
  }
  /**
   * Specifies if the graph should allow multiple connections between the
   * same pair of vertices.
   *
   * @param value Boolean indicating if the graph allows multiple connections
   * between the same pair of vertices.
   */
  setMultigraph(value) {
    this.multigraph = value;
  }
  /**
   * Returns {@link allowLoops} as a boolean.
   */
  isAllowLoops() {
    return this.allowLoops;
  }
  /**
   * Specifies if loops are allowed.
   *
   * @param value Boolean indicating if loops are allowed.
   */
  setAllowLoops(value) {
    this.allowLoops = value;
  }
  /**
   * Returns {@link recursiveResize}.
   *
   * @param state {@link CellState} that is being resized.
   */
  isRecursiveResize(state = null) {
    return this.recursiveResize;
  }
  /**
   * Sets {@link recursiveResize}.
   *
   * @param value New boolean value for {@link recursiveResize}.
   */
  setRecursiveResize(value) {
    this.recursiveResize = value;
  }
  /**
   * Returns a decimal number representing the amount of the width and height
   * of the given cell that is allowed to overlap its parent. A value of 0
   * means all children must stay inside the parent, 1 means the child is
   * allowed to be placed outside of the parent such that it touches one of
   * the parents sides. If {@link isAllowOverlapParent} returns false for the given
   * cell, then this method returns 0.
   *
   * @param cell {@link mxCell} for which the overlap ratio should be returned.
   */
  getOverlap(cell) {
    return this.isAllowOverlapParent(cell) ? this.defaultOverlap : 0;
  }
  /**
   * Returns true if the given cell is allowed to be placed outside of the
   * parents area.
   *
   * @param cell {@link mxCell} that represents the child to be checked.
   */
  isAllowOverlapParent(cell) {
    return false;
  }
  /*****************************************************************************
   * Group: Cell retrieval
   *****************************************************************************/
  /**
   * Returns {@link defaultParent} or {@link GraphView.currentRoot} or the first child
   * child of {@link GraphDataModel.root} if both are null. The value returned by
   * this function should be used as the parent for new cells (aka default
   * layer).
   */
  getDefaultParent() {
    let parent = this.getCurrentRoot();
    if (!parent) {
      parent = this.defaultParent;
      if (!parent) {
        const root = this.getDataModel().getRoot();
        parent = root.getChildAt(0);
      }
    }
    return parent;
  }
  /**
   * Sets the {@link defaultParent} to the given cell. Set this to null to return
   * the first child of the root in getDefaultParent.
   */
  setDefaultParent(cell) {
    this.defaultParent = cell;
  }
  /**
   * Destroys the graph and all its resources.
   */
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      Object.values(this.plugins).forEach((p) => p.onDestroy());
      this.view.destroy();
      if (this.model && this.graphModelChangeListener) {
        this.getDataModel().removeListener(this.graphModelChangeListener);
        this.graphModelChangeListener = null;
      }
    }
  }
}
applyGraphMixins(Graph);
class LayoutManager extends EventSource {
  constructor(graph) {
    super();
    this.bubbling = true;
    this.enabled = true;
    this.undoHandler = (sender, evt) => {
      if (this.isEnabled()) {
        this.beforeUndo(evt.getProperty("edit"));
      }
    };
    this.moveHandler = (sender, evt) => {
      if (this.isEnabled()) {
        this.cellsMoved(evt.getProperty("cells"), evt.getProperty("event"));
      }
    };
    this.resizeHandler = (sender, evt) => {
      if (this.isEnabled()) {
        this.cellsResized(evt.getProperty("cells"), evt.getProperty("bounds"), evt.getProperty("previous"));
      }
    };
    this.setGraph(graph);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates {@link enabled}.
   *
   * @param enabled Boolean that specifies the new enabled state.
   */
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Returns true if a layout should bubble, that is, if the parent layout
   * should be executed whenever a cell layout (layout of the children of
   * a cell) has been executed. This implementation returns {@link bubbling}.
   */
  isBubbling() {
    return this.bubbling;
  }
  /**
   * Sets {@link bubbling}.
   */
  setBubbling(value) {
    this.bubbling = value;
  }
  /**
   * Returns the graph that this layout operates on.
   */
  getGraph() {
    return this.graph;
  }
  /**
   * Sets the graph that the layouts operate on.
   */
  setGraph(graph) {
    if (this.graph) {
      const model = this.graph.getDataModel();
      model.removeListener(this.undoHandler);
      this.graph.removeListener(this.moveHandler);
      this.graph.removeListener(this.resizeHandler);
    }
    this.graph = graph;
    if (this.graph) {
      const model = this.graph.getDataModel();
      model.addListener(InternalEvent.BEFORE_UNDO, this.undoHandler);
      this.graph.addListener(InternalEvent.MOVE_CELLS, this.moveHandler);
      this.graph.addListener(InternalEvent.RESIZE_CELLS, this.resizeHandler);
    }
  }
  /**
   * Returns true if the given cell has a layout. This implementation invokes
   * <getLayout> with {@link Event#LAYOUT_CELLS} as the eventName. Override this
   * if creating layouts in <getLayout> is expensive and return true if
   * <getLayout> will return a layout for the given cell for
   * {@link Event#BEGIN_UPDATE} or {@link Event#END_UPDATE}.
   */
  hasLayout(cell) {
    return !!this.getLayout(cell, InternalEvent.LAYOUT_CELLS);
  }
  /**
   * Returns the layout for the given cell and eventName. Possible
   * event names are {@link InternalEvent.MOVE_CELLS} and {@link InternalEvent.RESIZE_CELLS}
   * for callbacks on when cells are moved or resized and
   * {@link InternalEvent.BEGIN_UPDATE} and {@link InternalEvent.END_UPDATE} for the capture
   * and bubble phase of the layout after any changes of the model.
   */
  getLayout(cell, eventName) {
    return null;
  }
  /**
   * Called from {@link undoHandler}.
   *
   * @param cell Array of {@link Cell} that have been moved.
   * @param evt Mouse event that represents the mousedown.
   *
   * TODO: what is undoableEdit type?
   */
  beforeUndo(undoableEdit) {
    this.executeLayoutForCells(this.getCellsForChanges(undoableEdit.changes));
  }
  /**
   * Called from {@link moveHandler}.
   *
   * @param cell Array of {@link Cell} that have been moved.
   * @param evt Mouse event that represents the mousedown.
   */
  cellsMoved(cells, evt) {
    if (cells.length > 0 && evt) {
      const point = convertPoint(this.getGraph().container, getClientX(evt), getClientY(evt));
      for (let i = 0; i < cells.length; i += 1) {
        const layout = this.getLayout(cells[i].getParent(), InternalEvent.MOVE_CELLS);
        if (layout) {
          layout.moveCell(cells[i], point.x, point.y);
        }
      }
    }
  }
  /**
   * Called from {@link resizeHandler}.
   *
   * @param cell Array of {@link Cell} that have been resized.
   * @param bounds {@link mxRectangle} taht represents the new bounds.
   */
  cellsResized(cells = null, bounds = null, prev = null) {
    if (cells && bounds) {
      for (let i = 0; i < cells.length; i += 1) {
        const layout = this.getLayout(cells[i].getParent(), InternalEvent.RESIZE_CELLS);
        if (layout) {
          layout.resizeCell(cells[i], bounds[i], prev == null ? void 0 : prev[i]);
        }
      }
    }
  }
  /**
   * Returns the cells for which a layout should be executed.
   */
  getCellsForChanges(changes) {
    let result = [];
    for (const change of changes) {
      if (change instanceof RootChange) {
        return [];
      }
      result = result.concat(this.getCellsForChange(change));
    }
    return result;
  }
  /**
   * Executes all layouts which have been scheduled during the
   * changes.
   * @param change  mxChildChange|mxTerminalChange|mxVisibleChange|...
   */
  getCellsForChange(change) {
    if (change instanceof ChildChange) {
      return this.addCellsWithLayout(change.child, this.addCellsWithLayout(change.previous));
    }
    if (change instanceof TerminalChange || change instanceof GeometryChange) {
      return this.addCellsWithLayout(change.cell);
    }
    if (change instanceof VisibleChange || change instanceof StyleChange) {
      return this.addCellsWithLayout(change.cell);
    }
    return [];
  }
  /**
   * Adds all ancestors of the given cell that have a layout.
   */
  addCellsWithLayout(cell, result = []) {
    return this.addDescendantsWithLayout(cell, this.addAncestorsWithLayout(cell, result));
  }
  /**
   * Adds all ancestors of the given cell that have a layout.
   */
  addAncestorsWithLayout(cell, result = []) {
    if (cell) {
      const layout = this.hasLayout(cell);
      if (layout) {
        result.push(cell);
      }
      if (this.isBubbling()) {
        this.addAncestorsWithLayout(cell.getParent(), result);
      }
    }
    return result;
  }
  /**
   * Adds all descendants of the given cell that have a layout.
   */
  addDescendantsWithLayout(cell, result = []) {
    if (cell && this.hasLayout(cell)) {
      for (let i = 0; i < cell.getChildCount(); i += 1) {
        const child = cell.getChildAt(i);
        if (this.hasLayout(child)) {
          result.push(child);
          this.addDescendantsWithLayout(child, result);
        }
      }
    }
    return result;
  }
  /**
   * Executes the given layout on the given parent.
   */
  executeLayoutForCells(cells) {
    const sorted = sortCells(cells, false);
    this.layoutCells(sorted, true);
    this.layoutCells(sorted.reverse(), false);
  }
  /**
   * Executes all layouts which have been scheduled during the changes.
   */
  layoutCells(cells, bubble = false) {
    if (cells.length > 0) {
      const model = this.getGraph().getDataModel();
      model.batchUpdate(() => {
        let last = null;
        for (const cell of cells) {
          if (cell !== model.getRoot() && cell !== last) {
            this.executeLayout(cell, bubble);
            last = cell;
          }
        }
        this.fireEvent(new EventObject(InternalEvent.LAYOUT_CELLS, { cells }));
      });
    }
  }
  /**
   * Executes the given layout on the given parent.
   */
  executeLayout(cell, bubble = false) {
    const layout = this.getLayout(cell, bubble ? InternalEvent.BEGIN_UPDATE : InternalEvent.END_UPDATE);
    if (layout) {
      layout.execute(cell);
    }
  }
  /**
   * Removes all handlers from the {@link graph} and deletes the reference to it.
   */
  destroy() {
    this.setGraph(null);
  }
}
class Outline {
  constructor(source, container = null) {
    this.sizer = null;
    this.selectionBorder = null;
    this.updateHandler = null;
    this.refreshHandler = null;
    this.panHandler = null;
    this.active = null;
    this.bounds = null;
    this.zoom = false;
    this.startX = null;
    this.startY = null;
    this.dx0 = null;
    this.dy0 = null;
    this.index = null;
    this.outline = null;
    this.graphRenderHint = "exact";
    this.enabled = true;
    this.showViewport = true;
    this.border = 10;
    this.sizerSize = 8;
    this.labelsVisible = false;
    this.updateOnPan = false;
    this.sizerImage = null;
    this.minScale = 1e-4;
    this.suspended = false;
    this.source = source;
    if (container != null) {
      this.init(container);
    }
  }
  /**
   * Initializes the outline inside the given container.
   */
  init(container) {
    this.outline = this.createGraph(container);
    const outlineGraphModelChanged = this.outline.graphModelChanged;
    this.outline.graphModelChanged = (changes) => {
      if (!this.suspended && this.outline != null) {
        outlineGraphModelChanged.apply(this.outline, [changes]);
      }
    };
    this.outline.labelsVisible = this.labelsVisible;
    this.outline.setEnabled(false);
    this.updateHandler = (sender, evt) => {
      if (!this.suspended && !this.active) {
        this.update();
      }
    };
    this.source.getDataModel().addListener(InternalEvent.CHANGE, this.updateHandler);
    this.outline.addMouseListener(this);
    const view = this.source.getView();
    view.addListener(InternalEvent.SCALE, this.updateHandler);
    view.addListener(InternalEvent.TRANSLATE, this.updateHandler);
    view.addListener(InternalEvent.SCALE_AND_TRANSLATE, this.updateHandler);
    view.addListener(InternalEvent.DOWN, this.updateHandler);
    view.addListener(InternalEvent.UP, this.updateHandler);
    InternalEvent.addListener(this.source.container, "scroll", this.updateHandler);
    this.panHandler = (sender, evt) => {
      if (this.updateOnPan) {
        this.updateHandler(sender, evt);
      }
    };
    this.source.addListener(InternalEvent.PAN, this.panHandler);
    this.refreshHandler = (sender) => {
      const outline = this.outline;
      outline == null ? void 0 : outline.setStylesheet(this.source.getStylesheet());
      outline == null ? void 0 : outline.refresh();
    };
    this.source.addListener(InternalEvent.REFRESH, this.refreshHandler);
    this.bounds = new Rectangle(0, 0, 0, 0);
    this.selectionBorder = new RectangleShape(this.bounds, NONE, OUTLINE_COLOR, OUTLINE_STROKEWIDTH);
    this.selectionBorder.dialect = this.outline.dialect;
    this.selectionBorder.init(this.outline.getView().getOverlayPane());
    const selectionBorderNode = this.selectionBorder.node;
    const handler = (evt) => {
      const t = getSource(evt);
      const redirect = (evt2) => {
        const outline2 = this.outline;
        outline2 == null ? void 0 : outline2.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt2));
      };
      const redirect2 = (evt2) => {
        const outline2 = this.outline;
        InternalEvent.removeGestureListeners(t, null, redirect, redirect2);
        outline2 == null ? void 0 : outline2.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt2));
      };
      const outline = this.outline;
      InternalEvent.addGestureListeners(t, null, redirect, redirect2);
      outline == null ? void 0 : outline.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));
    };
    InternalEvent.addGestureListeners(this.selectionBorder.node, handler);
    const sizer = this.sizer = this.createSizer();
    const sizerNode = sizer.node;
    sizer.init(this.outline.getView().getOverlayPane());
    if (this.enabled) {
      sizerNode.style.cursor = "nwse-resize";
    }
    InternalEvent.addGestureListeners(this.sizer.node, handler);
    selectionBorderNode.style.display = this.showViewport ? "" : "none";
    sizerNode.style.display = selectionBorderNode.style.display;
    selectionBorderNode.style.cursor = "move";
    this.update(false);
  }
  /**
   * Creates the {@link graph} used in the outline.
   */
  createGraph(container) {
    const graph = new Graph(
      container,
      this.source.getDataModel(),
      // TODO review the list of plugins for the Graph of an Outline
      // we could pass an empty array or a selection of plugins
      // it may be necessary to make the plugins array configurable to allow custom plugins and improve tree-shaking
      getDefaultPlugins(),
      this.source.getStylesheet()
    );
    graph.options.foldingEnabled = false;
    graph.autoScroll = false;
    return graph;
  }
  /**
   * Returns true if events are handled. This implementation
   * returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates {@link enabled}.
   *
   * @param value Boolean that specifies the new enabled state.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * Enables or disables the zoom handling by showing or hiding the respective
   * handle.
   *
   * @param value Boolean that specifies the new enabled state.
   */
  setZoomEnabled(value) {
    this.sizer.node.style.visibility = value ? "visible" : "hidden";
  }
  /**
   * Invokes {@link update} and revalidate the outline. This method is deprecated.
   */
  refresh() {
    this.update(true);
  }
  /**
   * Creates the shape used as the sizer.
   */
  // createSizer(): mxShape;
  createSizer() {
    const outline = this.outline;
    if (this.sizerImage != null) {
      const sizer2 = new ImageShape(new Rectangle(0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src);
      outline && (sizer2.dialect = outline.dialect);
      return sizer2;
    }
    const sizer = new RectangleShape(new Rectangle(0, 0, this.sizerSize, this.sizerSize), OUTLINE_HANDLE_FILLCOLOR, OUTLINE_HANDLE_STROKECOLOR);
    outline && (sizer.dialect = outline.dialect);
    return sizer;
  }
  /**
   * Returns the size of the source container.
   */
  getSourceContainerSize() {
    return new Rectangle(0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);
  }
  /**
   * Returns the offset for drawing the outline graph.
   */
  getOutlineOffset(scale) {
    return null;
  }
  /**
   * Returns the offset for drawing the outline graph.
   */
  getSourceGraphBounds() {
    return this.source.getGraphBounds();
  }
  /**
   * Updates the outline.
   */
  update(revalidate = false) {
    if (this.source != null && this.source.container != null && this.outline != null && this.outline.container != null) {
      const sourceScale = this.source.view.scale;
      const scaledGraphBounds = this.getSourceGraphBounds();
      const unscaledGraphBounds = new Rectangle(scaledGraphBounds.x / sourceScale + this.source.panDx, scaledGraphBounds.y / sourceScale + this.source.panDy, scaledGraphBounds.width / sourceScale, scaledGraphBounds.height / sourceScale);
      const unscaledFinderBounds = new Rectangle(0, 0, this.source.container.clientWidth / sourceScale, this.source.container.clientHeight / sourceScale);
      const union = unscaledGraphBounds.clone();
      union.add(unscaledFinderBounds);
      const size = this.getSourceContainerSize();
      const completeWidth = Math.max(size.width / sourceScale, union.width);
      const completeHeight = Math.max(size.height / sourceScale, union.height);
      const availableWidth = Math.max(0, this.outline.container.clientWidth - this.border);
      const availableHeight = Math.max(0, this.outline.container.clientHeight - this.border);
      const outlineScale = Math.min(availableWidth / completeWidth, availableHeight / completeHeight);
      let scale = Number.isNaN(outlineScale) ? this.minScale : Math.max(this.minScale, outlineScale);
      if (scale > 0) {
        if (this.outline.getView().scale !== scale) {
          this.outline.getView().scale = scale;
          revalidate = true;
        }
        const navView = this.outline.getView();
        if (navView.currentRoot !== this.source.getView().currentRoot) {
          navView.setCurrentRoot(this.source.getView().currentRoot);
        }
        const t = this.source.view.translate;
        let tx = t.x + this.source.panDx;
        let ty = t.y + this.source.panDy;
        const off = this.getOutlineOffset(scale);
        if (off != null) {
          tx += off.x;
          ty += off.y;
        }
        if (unscaledGraphBounds.x < 0) {
          tx -= unscaledGraphBounds.x;
        }
        if (unscaledGraphBounds.y < 0) {
          ty -= unscaledGraphBounds.y;
        }
        if (navView.translate.x !== tx || navView.translate.y !== ty) {
          navView.translate.x = tx;
          navView.translate.y = ty;
          revalidate = true;
        }
        const t2 = navView.translate;
        scale = this.source.getView().scale;
        const scale2 = scale / navView.scale;
        const scale3 = 1 / navView.scale;
        const { container } = this.source;
        this.bounds = new Rectangle((t2.x - t.x - this.source.panDx) / scale3, (t2.y - t.y - this.source.panDy) / scale3, container.clientWidth / scale2, container.clientHeight / scale2);
        this.bounds.x += this.source.container.scrollLeft * navView.scale / scale;
        this.bounds.y += this.source.container.scrollTop * navView.scale / scale;
        const selectionBorder = this.selectionBorder;
        let b = selectionBorder.bounds;
        if (b.x !== this.bounds.x || b.y !== this.bounds.y || b.width !== this.bounds.width || b.height !== this.bounds.height) {
          selectionBorder.bounds = this.bounds;
          selectionBorder.redraw();
        }
        const sizer = this.sizer;
        b = sizer.bounds;
        const b2 = new Rectangle(this.bounds.x + this.bounds.width - b.width / 2, this.bounds.y + this.bounds.height - b.height / 2, b.width, b.height);
        if (b.x !== b2.x || b.y !== b2.y || b.width !== b2.width || b.height !== b2.height) {
          sizer.bounds = b2;
          if (sizer.node.style.visibility !== "hidden") {
            sizer.redraw();
          }
        }
        if (revalidate) {
          this.outline.view.revalidate();
        }
      }
    }
  }
  /**
   * Handles the event by starting a translation or zoom.
   */
  mouseDown(sender, me) {
    if (this.enabled && this.showViewport) {
      const tol = !isMouseEvent(me.getEvent()) ? this.source.tolerance : 0;
      const hit = tol > 0 ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
      this.zoom = me.isSource(this.sizer) || // @ts-ignore
      hit != null && intersects(this.sizer.bounds, hit);
      this.startX = me.getX();
      this.startY = me.getY();
      this.active = true;
      const sourceContainer = this.source.container;
      if (this.source.useScrollbarsForPanning && hasScrollbars(this.source.container)) {
        this.dx0 = sourceContainer.scrollLeft;
        this.dy0 = sourceContainer.scrollTop;
      } else {
        this.dx0 = 0;
        this.dy0 = 0;
      }
    }
    me.consume();
  }
  /**
   * Handles the event by previewing the viewrect in {@link graph} and updating the
   * rectangle that represents the viewrect in the outline.
   */
  mouseMove(sender, me) {
    if (this.active) {
      const myBounds = this.bounds;
      const sizer = this.sizer;
      const sizerNode = sizer.node;
      const selectionBorder = this.selectionBorder;
      const selectionBorderNode = selectionBorder.node;
      const source = this.source;
      const outline = this.outline;
      selectionBorderNode.style.display = this.showViewport ? "" : "none";
      sizerNode.style.display = selectionBorderNode.style.display;
      const delta = this.getTranslateForEvent(me);
      let dx = delta.x;
      let dy = delta.y;
      let bounds = null;
      if (outline && !this.zoom) {
        const { scale } = outline.getView();
        bounds = new Rectangle(myBounds.x + dx, myBounds.y + dy, myBounds.width, myBounds.height);
        selectionBorder.bounds = bounds;
        selectionBorder.redraw();
        dx /= scale;
        dx *= source.getView().scale;
        dy /= scale;
        dy *= source.getView().scale;
        source.panGraph(-dx - this.dx0, -dy - this.dy0);
      } else {
        const { container } = this.source;
        const viewRatio = container.clientWidth / container.clientHeight;
        dy = dx / viewRatio;
        bounds = new Rectangle(myBounds.x, myBounds.y, Math.max(1, myBounds.width + dx), Math.max(1, myBounds.height + dy));
        selectionBorder.bounds = bounds;
        selectionBorder.redraw();
      }
      const b = sizer.bounds;
      sizer.bounds = new Rectangle(bounds.x + bounds.width - b.width / 2, bounds.y + bounds.height - b.height / 2, b.width, b.height);
      if (sizerNode.style.visibility !== "hidden") {
        sizer.redraw();
      }
      me.consume();
    }
  }
  /**
   * Gets the translate for the given mouse event. Here is an example to limit
   * the outline to stay within positive coordinates:
   *
   * @example
   * ```javascript
   * outline.getTranslateForEvent(me)
   * {
   *   var pt = new mxPoint(me.getX() - this.startX, me.getY() - this.startY);
   *
   *   if (!this.zoom)
   *   {
   *     var tr = this.source.view.translate;
   *     pt.x = Math.max(tr.x * this.outline.view.scale, pt.x);
   *     pt.y = Math.max(tr.y * this.outline.view.scale, pt.y);
   *   }
   *
   *   return pt;
   * };
   * ```
   */
  getTranslateForEvent(me) {
    return new Point(me.getX() - this.startX, me.getY() - this.startY);
  }
  /**
   * Handles the event by applying the translation or zoom to {@link graph}.
   */
  mouseUp(sender, me) {
    if (this.active) {
      const delta = this.getTranslateForEvent(me);
      let dx = delta.x;
      let dy = delta.y;
      const source = this.source;
      const outline = this.outline;
      const selectionBorder = this.selectionBorder;
      if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
        if (!this.zoom) {
          if (outline && (!source.useScrollbarsForPanning || !hasScrollbars(source.container))) {
            source.panGraph(0, 0);
            dx /= outline.getView().scale;
            dy /= outline.getView().scale;
            const t = source.getView().translate;
            source.getView().setTranslate(t.x - dx, t.y - dy);
          }
        } else {
          const w = selectionBorder.bounds.width;
          const { scale } = source.getView();
          source.zoomTo(Math.max(this.minScale, scale - dx * scale / w), false);
        }
        this.update();
        me.consume();
      }
      this.index = null;
      this.active = false;
    }
  }
  /**
   * Destroy this outline and removes all listeners from {@link source}.
   */
  destroy() {
    if (this.source != null) {
      this.source.removeListener(this.panHandler);
      this.source.removeListener(this.refreshHandler);
      this.source.getDataModel().removeListener(this.updateHandler);
      this.source.getView().removeListener(this.updateHandler);
      InternalEvent.removeListener(this.source.container, "scroll", this.updateHandler);
      this.source = null;
    }
    if (this.outline != null) {
      this.outline.removeMouseListener(this);
      this.outline.destroy();
      this.outline = null;
    }
    if (this.selectionBorder != null) {
      this.selectionBorder.destroy();
      this.selectionBorder = null;
    }
    if (this.sizer != null) {
      this.sizer.destroy();
      this.sizer = null;
    }
  }
}
class PrintPreview {
  constructor(graph, scale = null, pageFormat = null, border = null, x0 = 0, y0 = 0, borderColor = null, title = "Printer-friendly version", pageSelector = null) {
    this.border = 0;
    this.marginTop = 0;
    this.marginBottom = 0;
    this.x0 = 0;
    this.y0 = 0;
    this.autoOrigin = true;
    this.printOverlays = false;
    this.printControls = false;
    this.printBackgroundImage = false;
    this.backgroundColor = "#ffffff";
    this.wnd = null;
    this.targetWindow = null;
    this.pageCount = 0;
    this.clipping = true;
    this.graph = graph;
    this.scale = scale != null ? scale : 1 / graph.pageScale;
    this.border = border != null ? border : 0;
    this.pageFormat = Rectangle.fromRectangle(pageFormat != null ? pageFormat : graph.pageFormat);
    this.title = title;
    this.x0 = x0;
    this.y0 = y0;
    this.borderColor = borderColor;
    this.pageSelector = pageSelector != null ? pageSelector : true;
  }
  /**
   * Returns {@link wnd}.
   */
  getWindow() {
    return this.wnd;
  }
  /**
   * Returns the string that should go before the HTML tag in the print preview
   * page. This implementation returns an X-UA meta tag for IE5 in quirks mode,
   * IE8 in IE8 standards mode and edge in IE9 standards mode.
   */
  getDoctype() {
    const dt = "";
    return dt;
  }
  /**
   * Adds the given graph to the existing print preview.
   *
   * @param css Optional CSS string to be used in the head section.
   * @param targetWindow Optional window that should be used for rendering. If
   * this is specified then no HEAD tag, CSS and BODY tag will be written.
   */
  appendGraph(graph, scale, x0, y0, forcePageBreaks, keepOpen) {
    this.graph = graph;
    this.scale = scale != null ? scale : 1 / graph.pageScale;
    this.x0 = x0;
    this.y0 = y0;
    this.open(null, null, forcePageBreaks, keepOpen);
  }
  /**
   * Shows the print preview window. The window is created here if it does
   * not exist.
   *
   * @param css Optional CSS string to be used in the head section.
   * @param targetWindow Optional window that should be used for rendering. If
   * this is specified then no HEAD tag, CSS and BODY tag will be written.
   */
  open(css = null, targetWindow = null, forcePageBreaks = false, keepOpen = false) {
    const previousInitializeOverlay = this.graph.cellRenderer.initializeOverlay;
    let div = null;
    try {
      if (this.printOverlays) {
        this.graph.cellRenderer.initializeOverlay = (state, overlay) => {
          overlay.init(state.view.getDrawPane());
        };
      }
      if (this.printControls) {
        this.graph.cellRenderer.initControl = (state, control, handleEvents, clickHandler) => {
          control.dialect = state.view.graph.dialect;
          control.init(state.view.getDrawPane());
          return null;
        };
      }
      this.wnd = targetWindow != null ? targetWindow : this.wnd;
      let isNewWindow = false;
      if (this.wnd == null) {
        isNewWindow = true;
        this.wnd = window.open();
      }
      if (!this.wnd) {
        throw new Error("Create new window not allowed");
      }
      const doc = this.wnd.document;
      if (isNewWindow) {
        const dt = this.getDoctype();
        if (dt != null && dt.length > 0) {
          doc.writeln(dt);
        }
        if (document.compatMode === "CSS1Compat") {
          doc.writeln("<!DOCTYPE html>");
        }
        doc.writeln("<html>");
        doc.writeln("<head>");
        this.writeHead(doc, css);
        doc.writeln("</head>");
        doc.writeln('<body class="mxPage">');
      }
      const bounds = this.graph.getGraphBounds().clone();
      const currentScale = this.graph.getView().getScale();
      const sc = currentScale / this.scale;
      const tr = this.graph.getView().getTranslate();
      if (!this.autoOrigin) {
        this.x0 -= tr.x * this.scale;
        this.y0 -= tr.y * this.scale;
        bounds.width += bounds.x;
        bounds.height += bounds.y;
        bounds.x = 0;
        bounds.y = 0;
        this.border = 0;
      }
      const availableWidth = this.pageFormat.width - this.border * 2;
      const availableHeight = this.pageFormat.height - this.border * 2;
      this.pageFormat.height += this.marginTop + this.marginBottom;
      bounds.width /= sc;
      bounds.height /= sc;
      const hpages = Math.max(1, Math.ceil((bounds.width + this.x0) / availableWidth));
      const vpages = Math.max(1, Math.ceil((bounds.height + this.y0) / availableHeight));
      this.pageCount = hpages * vpages;
      const writePageSelector = () => {
        if (this.pageSelector && (vpages > 1 || hpages > 1)) {
          const table = this.createPageSelector(vpages, hpages);
          doc.body.appendChild(table);
        }
      };
      const addPage = (div2, addBreak) => {
        if (this.borderColor != null) {
          div2.style.borderColor = this.borderColor;
          div2.style.borderStyle = "solid";
          div2.style.borderWidth = "1px";
        }
        div2.style.background = this.backgroundColor;
        if (forcePageBreaks || addBreak) {
          div2.style.pageBreakAfter = "always";
        }
        if (isNewWindow && Client.IS_EDGE) {
          doc.writeln(div2.outerHTML);
          div2.parentNode.removeChild(div2);
        } else if (Client.IS_EDGE) {
          let clone2 = doc.createElement("div");
          clone2.innerHTML = div2.outerHTML;
          clone2 = clone2.getElementsByTagName("div")[0];
          doc.body.appendChild(clone2);
          div2.parentNode.removeChild(div2);
        } else {
          div2.parentNode.removeChild(div2);
          doc.body.appendChild(div2);
        }
        if (forcePageBreaks || addBreak) {
          this.addPageBreak(doc);
        }
      };
      const cov = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);
      if (cov) {
        for (const page of cov) {
          addPage(page, true);
        }
      }
      const apx = this.getAppendices(this.pageFormat.width, this.pageFormat.height);
      for (let i = 0; i < vpages; i += 1) {
        const dy = i * availableHeight / this.scale - this.y0 / this.scale + (bounds.y - tr.y * currentScale) / currentScale;
        for (let j = 0; j < hpages; j++) {
          if (this.wnd == null) {
            return null;
          }
          const dx = j * availableWidth / this.scale - this.x0 / this.scale + (bounds.x - tr.x * currentScale) / currentScale;
          const pageNum = i * hpages + j + 1;
          const clip = new Rectangle(dx, dy, availableWidth, availableHeight);
          div = this.renderPage(this.pageFormat.width, this.pageFormat.height, 0, 0, (div2) => {
            this.addGraphFragment(-dx, -dy, this.scale, pageNum, div2, clip);
            if (this.printBackgroundImage) {
              this.insertBackgroundImage(div2, -dx, -dy);
            }
          }, pageNum);
          div.setAttribute("id", `mxPage-${pageNum}`);
          addPage(div, apx != null || i < vpages - 1 || j < hpages - 1);
        }
      }
      if (apx) {
        for (const [index, page] of apx.entries()) {
          addPage(page, index < apx.length - 1);
        }
      }
      if (isNewWindow && !keepOpen) {
        this.closeDocument();
        writePageSelector();
      }
      this.wnd.focus();
    } catch (e) {
      if (div != null && div.parentNode != null) {
        div.parentNode.removeChild(div);
      }
    } finally {
      this.graph.cellRenderer.initializeOverlay = previousInitializeOverlay;
    }
    return this.wnd;
  }
  /**
   * Adds a page break to the given document.
   */
  addPageBreak(doc) {
    const hr = doc.createElement("hr");
    hr.className = "mxPageBreak";
    doc.body.appendChild(hr);
  }
  /**
   * Writes the closing tags for body and page after calling {@link writePostfix}.
   */
  closeDocument() {
    try {
      if (this.wnd != null && this.wnd.document != null) {
        const doc = this.wnd.document;
        this.writePostfix(doc);
        doc.writeln("</body>");
        doc.writeln("</html>");
        doc.close();
        InternalEvent.release(doc.body);
      }
    } catch (e) {
    }
  }
  /**
   * Writes the HEAD section into the given document, without the opening and closing HEAD tags.
   */
  writeHead(doc, css) {
    if (this.title != null) {
      doc.writeln(`<title>${this.title}</title>`);
    }
    addLinkToHead("stylesheet", `${Client.basePath}/css/common.css`, doc);
    doc.writeln('<style type="text/css">');
    doc.writeln("@media print {");
    doc.writeln("  * { -webkit-print-color-adjust: exact; }");
    doc.writeln("  table.mxPageSelector { display: none; }");
    doc.writeln("  hr.mxPageBreak { display: none; }");
    doc.writeln("}");
    doc.writeln("@media screen {");
    doc.writeln("  table.mxPageSelector { position: fixed; right: 10px; top: 10px;font-family: Arial; font-size:10pt; border: solid 1px darkgray;background: white; border-collapse:collapse; }");
    doc.writeln("  table.mxPageSelector td { border: solid 1px gray; padding:4px; }");
    doc.writeln("  body.mxPage { background: gray; }");
    doc.writeln("}");
    if (css != null) {
      doc.writeln(css);
    }
    doc.writeln("</style>");
  }
  /**
   * Called before closing the body of the page. This implementation is empty.
   */
  writePostfix(doc) {
  }
  /**
   * Creates the page selector table.
   */
  createPageSelector(vpages, hpages) {
    if (!this.wnd) {
      throw new Error("Popup window not created");
    }
    const doc = this.wnd.document;
    const table = doc.createElement("table");
    table.className = "mxPageSelector";
    table.setAttribute("border", "0");
    const tbody = doc.createElement("tbody");
    for (let i = 0; i < vpages; i += 1) {
      const row = doc.createElement("tr");
      for (let j = 0; j < hpages; j++) {
        const pageNum = i * hpages + j + 1;
        const cell = doc.createElement("td");
        const a = doc.createElement("a");
        a.setAttribute("href", `#mxPage-${pageNum}`);
        if (Client.IS_NS && !Client.IS_SF && !Client.IS_GC) {
          const js = `let page = document.getElementById('mxPage-${pageNum}');page.scrollIntoView(true);event.preventDefault();`;
          a.setAttribute("onclick", js);
        }
        write(a, String(pageNum));
        cell.appendChild(a);
        row.appendChild(cell);
      }
      tbody.appendChild(row);
    }
    table.appendChild(tbody);
    return table;
  }
  /**
   * Creates a DIV that prints a single page of the given
   * graph using the given scale and returns the DIV that
   * represents the page.
   *
   * @param w Width of the page in pixels.
   * @param h Height of the page in pixels.
   * @param dx Optional horizontal page offset in pixels (used internally).
   * @param dy Optional vertical page offset in pixels (used internally).
   * @param content Callback that adds the HTML content to the inner div of a page.
   * Takes the inner div as the argument.
   * @param pageNumber Integer representing the page number.
   */
  renderPage(w, h, dx, dy, content, pageNumber) {
    let div = document.createElement("div");
    let arg = null;
    try {
      if (dx !== 0 || dy !== 0) {
        div.style.position = "relative";
        div.style.width = `${w}px`;
        div.style.height = `${h}px`;
        div.style.pageBreakInside = "avoid";
        const innerDiv = document.createElement("div");
        innerDiv.style.position = "relative";
        innerDiv.style.top = `${this.border}px`;
        innerDiv.style.left = `${this.border}px`;
        innerDiv.style.width = `${w - 2 * this.border}px`;
        innerDiv.style.height = `${h - 2 * this.border}px`;
        innerDiv.style.overflow = "hidden";
        const viewport = document.createElement("div");
        viewport.style.position = "relative";
        viewport.style.marginLeft = `${dx}px`;
        viewport.style.marginTop = `${dy}px`;
        innerDiv.appendChild(viewport);
        div.appendChild(innerDiv);
        document.body.appendChild(div);
        arg = viewport;
      } else {
        div.style.width = `${w}px`;
        div.style.height = `${h}px`;
        div.style.overflow = "hidden";
        div.style.pageBreakInside = "avoid";
        const innerDiv = document.createElement("div");
        innerDiv.style.width = `${w - 2 * this.border}px`;
        innerDiv.style.height = `${h - 2 * this.border}px`;
        innerDiv.style.overflow = "hidden";
        innerDiv.style.top = `${this.border}px`;
        innerDiv.style.left = `${this.border}px`;
        div.appendChild(innerDiv);
        document.body.appendChild(div);
        arg = innerDiv;
      }
    } catch (e) {
      if (div && div.parentNode) {
        div.parentNode.removeChild(div);
      }
      div = null;
      throw e;
    }
    content(arg);
    return div;
  }
  /**
   * Returns the root cell for painting the graph.
   */
  getRoot() {
    let root = this.graph.view.currentRoot;
    if (root == null) {
      root = this.graph.getDataModel().getRoot();
    }
    return root;
  }
  /**
   * Returns true if CSS transforms should be used for scaling content.
   * This returns true if foreignObject is supported and we're not in Safari
   * as it has clipping bugs for transformed CSS content with foreignObjects.
   */
  useCssTransforms() {
    return !Client.NO_FO && !Client.IS_SF;
  }
  /**
   * Adds a graph fragment to the given div.
   *
   * @param dx Horizontal translation for the diagram.
   * @param dy Vertical translation for the diagram.
   * @param scale Scale for the diagram.
   * @param pageNumber Number of the page to be rendered.
   * @param div Div that contains the output.
   * @param clip Contains the clipping rectangle as an {@link Rectangle}.
   */
  addGraphFragment(dx, dy, scale, pageNumber, div, clip) {
    const view = this.graph.getView();
    const previousContainer = this.graph.container;
    this.graph.container = div;
    const canvas = view.getCanvas();
    const backgroundPane = view.getBackgroundPane();
    const drawPane = view.getDrawPane();
    const overlayPane = view.getOverlayPane();
    const realScale = scale;
    if (this.graph.dialect === DIALECT.SVG) {
      view.createSvg();
      if (this.useCssTransforms()) {
        const g = view.getDrawPane().parentNode;
        g.getAttribute("transform");
        g.setAttribute("transformOrigin", "0 0");
        g.setAttribute("transform", `scale(${scale},${scale})translate(${dx},${dy})`);
        scale = 1;
        dx = 0;
        dy = 0;
      }
    } else {
      view.createHtml();
    }
    const eventsEnabled = view.isEventsEnabled();
    view.setEventsEnabled(false);
    const graphEnabled = this.graph.isEnabled();
    this.graph.setEnabled(false);
    const translate2 = view.getTranslate();
    view.translate = new Point(dx, dy);
    const { redraw } = this.graph.cellRenderer;
    const { states } = view;
    const s = view.scale;
    if (this.clipping) {
      const tempClip = new Rectangle((clip.x + translate2.x) * s, (clip.y + translate2.y) * s, clip.width * s / realScale, clip.height * s / realScale);
      this.graph.cellRenderer.redraw = (state, force, rendering) => {
        if (state != null) {
          const orig = states.get(state.cell);
          if (orig != null) {
            const bbox = view.getBoundingBox(orig, false);
            if (bbox != null && bbox.width > 0 && bbox.height > 0 && !intersects$1(tempClip, bbox)) {
              return;
            }
          }
        }
        redraw.apply(this.graph.cellRenderer, [state, force, rendering]);
      };
    }
    let temp = null;
    try {
      const cells = [this.getRoot()];
      temp = new TemporaryCellStates(view, scale, cells, null, (state) => {
        return this.getLinkForCellState(state);
      });
    } catch (e) {
      GlobalConfig.logger.error("PrintPreview unable to generate the preview", e);
    } finally {
      let tmp = div.firstChild;
      while (tmp != null) {
        const next = tmp.nextSibling;
        const name = tmp.nodeName.toLowerCase();
        if (name === "svg") {
          tmp.style.overflow = "hidden";
          tmp.style.position = "relative";
          tmp.style.top = `${this.marginTop}px`;
          tmp.setAttribute("width", String(clip.width));
          tmp.setAttribute("height", String(clip.height));
          tmp.style.width = "";
          tmp.style.height = "";
        } else if (tmp.style.cursor !== "default" && name !== "div") {
          tmp.parentNode.removeChild(tmp);
        }
        tmp = next;
      }
      if (this.printBackgroundImage) {
        const svgs = div.getElementsByTagName("svg");
        if (svgs.length > 0) {
          svgs[0].style.position = "absolute";
        }
      }
      view.overlayPane.parentNode.removeChild(view.overlayPane);
      this.graph.setEnabled(graphEnabled);
      this.graph.container = previousContainer;
      this.graph.cellRenderer.redraw = redraw;
      view.canvas = canvas;
      view.backgroundPane = backgroundPane;
      view.drawPane = drawPane;
      view.overlayPane = overlayPane;
      view.translate = translate2;
      if (temp) {
        temp.destroy();
      }
      view.setEventsEnabled(eventsEnabled);
    }
  }
  /**
   * Returns the link for the given cell state. This returns null.
   */
  getLinkForCellState(state) {
    return this.graph.getLinkForCell(state.cell);
  }
  /**
   * Inserts the background image into the given div.
   */
  insertBackgroundImage(div, dx, dy) {
    const bg = this.graph.backgroundImage;
    if (bg != null) {
      const img = document.createElement("img");
      img.style.position = "absolute";
      img.style.marginLeft = `${Math.round(dx * this.scale)}px`;
      img.style.marginTop = `${Math.round(dy * this.scale)}px`;
      img.setAttribute("width", String(Math.round(this.scale * bg.width)));
      img.setAttribute("height", String(Math.round(this.scale * bg.height)));
      img.src = bg.src;
      div.insertBefore(img, div.firstChild);
    }
  }
  /**
   * Returns the pages to be added before the print output. This returns `null`.
   */
  getCoverPages(_width, _height) {
    return null;
  }
  /**
   * Returns the pages to be added after the print output. This returns `null`.
   */
  getAppendices(_width, _height) {
    return null;
  }
  /**
   * Opens the print preview and shows the print dialog.
   *
   * @param css Optional CSS string to be used in the head section.
   */
  print(css) {
    const wnd = this.open(css);
    if (wnd != null) {
      wnd.print();
    }
  }
  /**
   * Closes the print preview window.
   */
  close() {
    if (this.wnd != null) {
      this.wnd.close();
      this.wnd = null;
    }
  }
}
class SwimlaneManager extends EventSource {
  constructor(graph, horizontal = true, addEnabled = true, resizeEnabled = true) {
    super();
    this.enabled = true;
    this.horizontal = true;
    this.addEnabled = true;
    this.resizeEnabled = true;
    this.horizontal = horizontal;
    this.addEnabled = addEnabled;
    this.resizeEnabled = resizeEnabled;
    this.addHandler = (sender, evt) => {
      if (this.isEnabled() && this.isAddEnabled()) {
        this.cellsAdded(evt.getProperty("cells"));
      }
    };
    this.resizeHandler = (sender, evt) => {
      if (this.isEnabled() && this.isResizeEnabled()) {
        this.cellsResized(evt.getProperty("cells"));
      }
    };
    this.setGraph(graph);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates {@link enabled}.
   *
   * @param enabled Boolean that specifies the new enabled state.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * Returns {@link horizontal}.
   */
  isHorizontal() {
    return this.horizontal;
  }
  /**
   * Sets {@link horizontal}.
   */
  setHorizontal(value) {
    this.horizontal = value;
  }
  /**
   * Returns {@link addEnabled}.
   */
  isAddEnabled() {
    return this.addEnabled;
  }
  /**
   * Sets {@link addEnabled}.
   */
  setAddEnabled(value) {
    this.addEnabled = value;
  }
  /**
   * Returns {@link resizeEnabled}.
   */
  isResizeEnabled() {
    return this.resizeEnabled;
  }
  /**
   * Sets {@link resizeEnabled}.
   */
  setResizeEnabled(value) {
    this.resizeEnabled = value;
  }
  /**
   * Returns the graph that this manager operates on.
   */
  getGraph() {
    return this.graph;
  }
  /**
   * Sets the graph that the manager operates on.
   */
  setGraph(graph) {
    if (this.graph) {
      this.graph.removeListener(this.addHandler);
      this.graph.removeListener(this.resizeHandler);
    }
    this.graph = graph;
    if (this.graph) {
      this.graph.addListener(InternalEvent.ADD_CELLS, this.addHandler);
      this.graph.addListener(InternalEvent.CELLS_RESIZED, this.resizeHandler);
    }
  }
  /**
   * Returns true if the given swimlane should be ignored.
   */
  isSwimlaneIgnored(swimlane) {
    return !this.getGraph().isSwimlane(swimlane);
  }
  /**
   * Returns true if the given cell is horizontal. If the given cell is not a
   * swimlane, then the global orientation is returned.
   */
  isCellHorizontal(cell) {
    if (this.graph.isSwimlane(cell)) {
      const style = this.graph.getCellStyle(cell);
      return style.horizontal ?? true;
    }
    return !this.isHorizontal();
  }
  /**
   * Called if any cells have been added.
   *
   * @param cell Array of {@link Cell} that have been added.
   */
  cellsAdded(cells) {
    if (cells.length > 0) {
      this.graph.batchUpdate(() => {
        for (const cell of cells) {
          if (!this.isSwimlaneIgnored(cell)) {
            this.swimlaneAdded(cell);
          }
        }
      });
    }
  }
  /**
   * Updates the size of the given swimlane to match that of any existing
   * siblings swimlanes.
   *
   * @param swimlane {@link mxCell} that represents the new swimlane.
   */
  swimlaneAdded(swimlane) {
    const parent = swimlane.getParent();
    const childCount = parent.getChildCount();
    let geo = null;
    for (let i = 0; i < childCount; i += 1) {
      const child = parent.getChildAt(i);
      if (child !== swimlane && !this.isSwimlaneIgnored(child)) {
        geo = child.getGeometry();
        if (geo) {
          break;
        }
      }
    }
    if (geo) {
      const parentHorizontal = parent ? this.isCellHorizontal(parent) : this.horizontal;
      this.resizeSwimlane(swimlane, geo.width, geo.height, parentHorizontal);
    }
  }
  /**
   * Called if any cells have been resizes. Calls {@link swimlaneResized} for all
   * swimlanes where {@link isSwimlaneIgnored} returns false.
   *
   * @param cells Array of {@link Cell} whose size was changed.
   */
  cellsResized(cells) {
    if (cells.length > 0) {
      this.graph.batchUpdate(() => {
        for (const cell of cells) {
          if (!this.isSwimlaneIgnored(cell)) {
            const geo = cell.getGeometry();
            if (geo) {
              const size = new Rectangle(0, 0, geo.width, geo.height);
              let top = cell;
              let current = top;
              while (current) {
                top = current;
                current = current.getParent();
                const tmp = this.graph.isSwimlane(current) ? this.graph.getStartSize(current) : new Rectangle();
                size.width += tmp.width;
                size.height += tmp.height;
              }
              const parentHorizontal = current ? this.isCellHorizontal(current) : this.horizontal;
              this.resizeSwimlane(top, size.width, size.height, parentHorizontal);
            }
          }
        }
      });
    }
  }
  /**
   * Called from {@link cellsResized} for all swimlanes that are not ignored to update
   * the size of the siblings and the size of the parent swimlanes, recursively,
   * if {@link bubbling} is true.
   *
   * @param swimlane {@link mxCell} whose size has changed.
   */
  resizeSwimlane(swimlane, w, h, parentHorizontal) {
    const model = this.graph.getDataModel();
    model.batchUpdate(() => {
      const horizontal = this.isCellHorizontal(swimlane);
      if (!this.isSwimlaneIgnored(swimlane)) {
        let geo = swimlane.getGeometry();
        if (geo) {
          if (parentHorizontal && geo.height !== h || !parentHorizontal && geo.width !== w) {
            geo = geo.clone();
            if (parentHorizontal) {
              geo.height = h;
            } else {
              geo.width = w;
            }
            model.setGeometry(swimlane, geo);
          }
        }
      }
      const tmp = this.graph.isSwimlane(swimlane) ? this.graph.getStartSize(swimlane) : new Rectangle();
      w -= tmp.width;
      h -= tmp.height;
      const childCount = swimlane.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        const child = swimlane.getChildAt(i);
        this.resizeSwimlane(child, w, h, horizontal);
      }
    });
  }
  /**
   * Removes all handlers from the {@link graph} and deletes the reference to it.
   */
  destroy() {
    this.setGraph(null);
  }
}
class CellAttributeChange {
  constructor(cell, attribute, value) {
    this.cell = cell;
    this.attribute = attribute;
    this.value = value;
    this.previous = value;
  }
  /**
   * Changes the attribute of the cell's user object by
   * using {@link Cell#setAttribute}.
   */
  execute() {
    const tmp = this.cell.getAttribute(this.attribute);
    if (isNullish(this.previous)) {
      this.cell.value.removeAttribute(this.attribute);
    } else {
      this.cell.setAttribute(this.attribute, this.previous);
    }
    this.previous = tmp;
  }
}
class KeyHandler {
  /**
   * Constructs an event handler that executes functions bound to specific keystrokes.
   *
   * @param graph Reference to the associated {@link Graph}.
   * @param target  Optional reference to the event target.
   *                If `null`, the document element is used as the event target, that is, the object where the key event listener is installed.
   */
  constructor(graph, target = null) {
    this.keydownHandler = null;
    this.graph = null;
    this.target = null;
    this.normalKeys = {};
    this.shiftKeys = {};
    this.controlKeys = {};
    this.controlShiftKeys = {};
    this.enabled = true;
    if (graph != null) {
      this.graph = graph;
      this.target = target || document.documentElement;
      this.keydownHandler = (evt) => {
        this.keyDown(evt);
      };
      InternalEvent.addListener(this.target, "keydown", this.keydownHandler);
    }
  }
  /**
   * Returns true if events are handled. This implementation returns
   * <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling by updating <enabled>.
   *
   * @param enabled Boolean that specifies the new enabled state.
   */
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  /**
   * Binds the specified keycode to the given function. This binding is used
   * if the control key is not pressed.
   *
   * @param code Integer that specifies the keycode.
   * @param funct JavaScript function that takes the key event as an argument.
   */
  bindKey(code, funct) {
    this.normalKeys[code] = funct;
  }
  /**
   * Binds the specified keycode to the given function. This binding is used
   * if the shift key is pressed.
   *
   * @param code Integer that specifies the keycode.
   * @param funct JavaScript function that takes the key event as an argument.
   */
  bindShiftKey(code, funct) {
    this.shiftKeys[code] = funct;
  }
  /**
   * Binds the specified keycode to the given function. This binding is used
   * if the control key is pressed.
   *
   * @param code Integer that specifies the keycode.
   * @param funct JavaScript function that takes the key event as an argument.
   */
  bindControlKey(code, funct) {
    this.controlKeys[code] = funct;
  }
  /**
   * Binds the specified keycode to the given function. This binding is used
   * if the control and shift key are pressed.
   *
   * @param code Integer that specifies the keycode.
   * @param funct JavaScript function that takes the key event as an argument.
   */
  bindControlShiftKey(code, funct) {
    this.controlShiftKeys[code] = funct;
  }
  /**
   * Returns true if the control key is pressed. This uses {@link Event#isControlDown}.
   *
   * @param evt Key event whose control key pressed state should be returned.
   */
  isControlDown(evt) {
    return isControlDown(evt);
  }
  /**
   * Returns the function associated with the given key event or null if no
   * function is associated with the given event.
   *
   * @param evt Key event whose associated function should be returned.
   */
  getFunction(evt) {
    if (evt != null && !isAltDown(evt)) {
      if (this.isControlDown(evt)) {
        if (isShiftDown(evt)) {
          return this.controlShiftKeys[evt.keyCode];
        }
        return this.controlKeys[evt.keyCode];
      }
      if (isShiftDown(evt)) {
        return this.shiftKeys[evt.keyCode];
      }
      return this.normalKeys[evt.keyCode];
    }
    return null;
  }
  /**
   * Returns `true` if the event should be processed by this handler.
   * That is, if the event source is either the target, one of its direct children a descendant of the {@link Graph.container},
   * or the {@link CellEditorHandler} plugin of the {@link graph}.
   *
   * @param evt Key event that represents the keystroke.
   */
  isGraphEvent(evt) {
    var _a;
    const source = getSource(evt);
    const cellEditorHandler = (_a = this.graph) == null ? void 0 : _a.getPlugin("CellEditorHandler");
    if (source === this.target || source.parentNode === this.target || cellEditorHandler && cellEditorHandler.isEventSource(evt)) {
      return true;
    }
    return this.graph ? isAncestorNode(this.graph.container, source) : false;
  }
  /**
   * Handles the event by invoking the function bound to the respective keystroke
   * if {@link isEnabledForEvent} returns `true` for the given event and if
   * {@link isEventIgnored} returns `false`, except for escape for which
   * {@link isEventIgnored} is not invoked.
   *
   * @param evt Key event that represents the keystroke.
   */
  keyDown(evt) {
    if (this.isEnabledForEvent(evt)) {
      if (evt.keyCode === 27) {
        this.escape(evt);
      } else if (!this.isEventIgnored(evt)) {
        const boundFunction = this.getFunction(evt);
        if (boundFunction != null) {
          boundFunction(evt);
          InternalEvent.consume(evt);
        }
      }
    }
  }
  /**
   * Returns true if the given event should be handled. {@link isEventIgnored} is
   * called later if the event is not an escape keystroke, in which case
   * {@link escape} is called.
   *
   * This implementation returns `true` if  {@link Graph.isEnabled}
   * returns `true` for both, this handler and {@link graph}, if the event is not
   * consumed and if  {@link isGraphEvent} returns `true`.
   *
   * @param evt Key event that represents the keystroke.
   */
  isEnabledForEvent(evt) {
    var _a;
    return ((_a = this.graph) == null ? void 0 : _a.isEnabled()) && !isConsumed(evt) && this.isGraphEvent(evt) && this.isEnabled();
  }
  /**
   * Returns true if the given keystroke should be ignored. This returns {@link Graph.isEditing}.
   *
   * @param evt Key event that represents the keystroke.
   */
  isEventIgnored(evt) {
    var _a;
    return ((_a = this.graph) == null ? void 0 : _a.isEditing()) ?? false;
  }
  /**
   * Hook to process ESCAPE keystrokes. This implementation invokes
   * {@link Graph.stopEditing} to cancel the current editing, connecting
   * and/or other ongoing modifications.
   *
   * @param evt Key event that represents the keystroke. Possible keycode in this case is 27 (ESCAPE).
   */
  escape(evt) {
    var _a;
    if ((_a = this.graph) == null ? void 0 : _a.isEscapeEnabled()) {
      this.graph.escape(evt);
    }
  }
  /**
   * Destroys the handler and all its references into the DOM. This does
   * normally not need to be called, it is called automatically when the
   * window unloads (in IE).
   */
  onDestroy() {
    if (this.target != null && this.keydownHandler != null) {
      InternalEvent.removeListener(this.target, "keydown", this.keydownHandler);
      this.keydownHandler = null;
    }
    this.target = null;
  }
}
class EditorKeyHandler {
  constructor(editor = null) {
    this.editor = null;
    this.handler = null;
    if (editor != null) {
      this.editor = editor;
      const handler = this.handler = new KeyHandler(editor.graph);
      const old = this.handler.escape;
      this.handler.escape = (evt) => {
        old.apply(handler, [evt]);
        editor.hideProperties();
        editor.fireEvent(new EventObject(InternalEvent.ESCAPE, { event: evt }));
      };
    }
  }
  /**
   * Binds the specified keycode to the given action in {@link editor}.  The optional control flag specifies if the control key must be pressed to trigger the action.
   *
   * @param code      Integer that specifies the keycode.
   * @param action    Name of the action to execute in {@link editor}.
   * @param control   Optional boolean that specifies if control must be pressed.  Default is false.
   */
  bindAction(code, action, control) {
    const keyHandler = () => {
      this.editor.execute(action);
    };
    if (control) {
      this.handler.bindControlKey(code, keyHandler);
    } else {
      this.handler.bindKey(code, keyHandler);
    }
  }
  /**
   * Destroys the {@link handler} associated with this object.  This does normally not need to be called, the {@link handler} is destroyed automatically when the window unloads (in IE) by {@link Editor}.
   */
  destroy() {
    this.handler.onDestroy();
    this.handler = null;
  }
}
class EditorPopupMenu {
  constructor(config = null) {
    this.imageBasePath = null;
    this.config = config;
  }
  /**
   * This function is called from {@link Editor} to add items to the
   * given menu based on {@link config}. The config is a sequence of
   * the following nodes and attributes.
   *
   * @ChildNodes:
   *
   * add - Adds a new menu item. See below for attributes.
   * separator - Adds a separator. No attributes.
   * condition - Adds a custom condition. Name attribute.
   *
   * The add-node may have a child node that defines a function to be invoked
   * before the action is executed (or instead of an action to be executed).
   *
   * @Attributes:
   *
   * as - Resource key for the label (needs entry in property file).
   * action - Name of the action to execute in enclosing editor.
   * icon - Optional icon (relative/absolute URL).
   * iconCls - Optional CSS class for the icon.
   * if - Optional name of condition that must be true (see below).
   * enabled-if - Optional name of condition that specifies if the menu item
   * should be enabled.
   * name - Name of custom condition. Only for condition nodes.
   *
   * @Conditions:
   *
   * nocell - No cell under the mouse.
   * ncells - More than one cell selected.
   * notRoot - Drilling position is other than home.
   * cell - Cell under the mouse.
   * notEmpty - Exactly one cell with children under mouse.
   * expandable - Exactly one expandable cell under mouse.
   * collapsable - Exactly one collapsable cell under mouse.
   * validRoot - Exactly one cell which is a possible root under mouse.
   * swimlane - Exactly one cell which is a swimlane under mouse.
   *
   * @Example:
   *
   * To add a new item for a given action to the popupmenu:
   *
   * ```
   * <EditorPopupMenu as="popupHandler">
   *   <add as="delete" action="delete" icon="images/delete.gif" if="cell"/>
   * </EditorPopupMenu>
   * ```
   *
   * To add a new item for a custom function:
   *
   * ```
   * <EditorPopupMenu as="popupHandler">
   *   <add as="action1"><![CDATA[
   *		function (editor, cell, evt)
   *		{
   *			editor.execute('action1', cell, 'myArg');
   *		}
   *   ]]></add>
   * </EditorPopupMenu>
   * ```
   *
   * The above example invokes action1 with an additional third argument via
   * the editor instance. The third argument is passed to the function that
   * defines action1. If the add-node has no action-attribute, then only the
   * function defined in the text content is executed, otherwise first the
   * function and then the action defined in the action-attribute is
   * executed. The function in the text content has 3 arguments, namely the
   * {@link Editor} instance, the {@link Cell} instance under the mouse, and the
   * native mouse event.
   *
   * Custom Conditions:
   *
   * To add a new condition for popupmenu items:
   *
   * ```
   * <condition name="condition1"><![CDATA[
   *   function (editor, cell, evt)
   *   {
   *     return cell != null;
   *   }
   * ]]></condition>
   * ```
   *
   * The new condition can then be used in any item as follows:
   *
   * ```
   * <add as="action1" action="action1" icon="action1.gif" if="condition1"/>
   * ```
   *
   * The order in which the items and conditions appear is not significant as
   * all conditions are evaluated before any items are created.
   *
   * @param editor - Enclosing {@link Editor} instance.
   * @param menu - {@link MaxPopupMenu} that is used for adding items and separators.
   * @param cell - Optional {@link Cell} which is under the mouse pointer.
   * @param evt - Optional mouse event which triggered the menu.
   */
  createMenu(editor, menu, cell = null, evt = null) {
    if (!isNullish(this.config)) {
      const conditions = this.createConditions(editor, cell, evt);
      const item = this.config.firstChild;
      this.addItems(editor, menu, cell, evt, conditions, item, null);
    }
  }
  /**
   * Recursively adds the given items and all of its children into the given menu.
   *
   * @param editor Enclosing  {@link Editor} instance.
   * @param menu {@link MaxPopupMenu} that is used for adding items and separators.
   * @param cell Optional {@link Cell} which is under the mouse pointer.
   * @param evt Optional mouse event which triggered the menu.
   * @param conditions Array of names boolean conditions.
   * @param item XML node that represents the current menu item.
   * @param parent DOM node that represents the parent menu item.
   */
  addItems(editor, menu, cell = null, evt = null, conditions, item, parent = null) {
    let addSeparator = false;
    while (item) {
      if (item.nodeName === "add") {
        const condition = item.getAttribute("if");
        if (isNullish(condition) || conditions[condition]) {
          let as = item.getAttribute("as");
          as = translate(as) || as;
          const funct = doEval(getTextContent(item));
          const action = item.getAttribute("action");
          let icon = item.getAttribute("icon");
          const iconCls = item.getAttribute("iconCls");
          const enabledCond = item.getAttribute("enabled-if");
          const enabled = isNullish(enabledCond) || conditions[enabledCond];
          if (addSeparator) {
            menu.addSeparator(parent);
            addSeparator = false;
          }
          if (!isNullish(icon) && this.imageBasePath) {
            icon = this.imageBasePath + icon;
          }
          const row = this.addAction(menu, editor, as, icon, funct, action, cell, parent, iconCls, enabled);
          this.addItems(
            editor,
            menu,
            cell,
            evt,
            conditions,
            // @ts-ignore
            item.firstChild,
            row
          );
        }
      } else if (item.nodeName === "separator") {
        addSeparator = true;
      }
      item = item.nextSibling;
    }
  }
  /**
   * Helper method to bind an action to a new menu item.
   *
   * @param menu {@link MaxPopupMenu} that is used for adding items and separators.
   * @param editor Enclosing {@link Editor} instance.
   * @param lab String that represents the label of the menu item.
   * @param icon Optional URL that represents the icon of the menu item.
   * @param action Optional name of the action to execute in the given editor.
   * @param funct Optional function to execute before the optional action. The
   * function takes an <Editor>, the <Cell> under the mouse and the
   * mouse event that triggered the call.
   * @param cell Optional <Cell> to use as an argument for the action.
   * @param parent DOM node that represents the parent menu item.
   * @param iconCls Optional CSS class for the menu icon.
   * @param enabled Optional boolean that specifies if the menu item is enabled.
   * Default is true.
   */
  addAction(menu, editor, lab, icon = null, funct = null, action = null, cell = null, parent = null, iconCls = null, enabled = true) {
    const clickHandler = (evt) => {
      if (typeof funct === "function") {
        funct.call(editor, editor, cell, evt);
      }
      if (!isNullish(action)) {
        editor.execute(action, cell, evt);
      }
    };
    return menu.addItem(lab, icon || null, clickHandler, parent, iconCls, enabled);
  }
  /**
   * Evaluates the default conditions for the given context.
   *
   * @param editor
   * @param cell
   * @param evt
   */
  createConditions(editor, cell = null, evt = null) {
    const model = editor.graph.getDataModel();
    const childCount = cell ? cell.getChildCount() : 0;
    const conditions = {};
    conditions.nocell = cell == null;
    conditions.ncells = editor.graph.getSelectionCount() > 1;
    conditions.notRoot = model.getRoot() !== editor.graph.getDefaultParent().getParent();
    conditions.cell = cell != null;
    const isCell = cell != null && editor.graph.getSelectionCount() === 1;
    conditions.nonEmpty = isCell && childCount > 0;
    conditions.expandable = isCell && editor.graph.isCellFoldable(cell, false);
    conditions.collapsable = isCell && editor.graph.isCellFoldable(cell, true);
    conditions.validRoot = isCell && editor.graph.isValidRoot(cell);
    conditions.emptyValidRoot = conditions.validRoot && childCount === 0;
    conditions.swimlane = isCell && editor.graph.isSwimlane(cell);
    const condNodes = this.config.getElementsByTagName("condition");
    for (const condNode of Array.from(condNodes)) {
      const funct = doEval(getTextContent(condNode));
      const name = condNode.getAttribute("name");
      if (!isNullish(name) && typeof funct === "function") {
        conditions[name] = funct(editor, cell, evt);
      }
    }
    return conditions;
  }
}
class MaxToolbar extends EventSource {
  constructor(container) {
    super();
    this.menu = null;
    this.currentImg = null;
    this.selectedMode = null;
    this.defaultMode = null;
    this.defaultFunction = null;
    this.enabled = true;
    this.noReset = false;
    this.updateDefaultMode = true;
    this.container = container;
  }
  /**
   * Adds the given function as an image with the specified title and icon
   * and returns the new image node.
   *
   * @param title Optional string that is used as the tooltip.
   * @param icon Optional URL of the image to be used. If no URL is given, then a
   * button is created.
   * @param funct Function to execute on a mouse click.
   * @param pressedIcon Optional URL of the pressed image. Default is a gray
   * background.
   * @param style Optional style classname. Default is mxToolbarItem.
   * @param factoryMethod Optional factory method for popup menu, eg.
   * (menu, evt, cell)=> { menu.addItem('Hello, World!'); }
   */
  addItem(title = null, icon = null, funct = null, pressedIcon = null, style = null, factoryMethod = null) {
    const img = document.createElement(icon != null ? "img" : "button");
    const initialClassName = style || (factoryMethod ? "mxToolbarMode" : "mxToolbarItem");
    img.className = initialClassName;
    if (icon) {
      img.setAttribute("src", icon);
    }
    if (title != null) {
      if (icon != null) {
        img.setAttribute("title", title);
      } else {
        write(img, title);
      }
    }
    this.container.appendChild(img);
    if (funct != null) {
      InternalEvent.addListener(img, "click", funct);
      if (Client.IS_TOUCH) {
        InternalEvent.addListener(img, "touchend", funct);
      }
    }
    const mouseHandler = (evt) => {
      if (pressedIcon != null) {
        img.setAttribute("src", icon);
      } else {
        img.style.backgroundColor = "";
      }
    };
    InternalEvent.addGestureListeners(img, (evt) => {
      if (pressedIcon != null) {
        img.setAttribute("src", pressedIcon);
      } else {
        img.style.backgroundColor = "gray";
      }
      if (factoryMethod) {
        if (this.menu == null) {
          this.menu = new MaxPopupMenu();
        }
        const last = this.currentImg;
        if (this.menu.isMenuShowing()) {
          this.menu.hideMenu();
        }
        if (last != img) {
          this.currentImg = img;
          this.menu.factoryMethod = factoryMethod;
          const point = new Point(img.offsetLeft, img.offsetTop + img.offsetHeight);
          this.menu.popup(point.x, point.y, null, evt);
          if (this.menu.isMenuShowing()) {
            img.className = `${initialClassName}Selected`;
            const hideMenu = this.menu.hideMenu;
            this.menu.hideMenu = () => {
              hideMenu.apply(this);
              img.className = initialClassName;
              this.currentImg = null;
            };
          }
        }
      }
    }, null, mouseHandler);
    InternalEvent.addListener(img, "mouseout", mouseHandler);
    return img;
  }
  /**
   * Adds and returns a new SELECT element using the given style. The element
   * is placed inside a DIV with the mxToolbarComboContainer style classname.
   *
   * @param style - Optional style classname. Default is mxToolbarCombo.
   */
  addCombo(style) {
    const div = document.createElement("div");
    div.style.display = "inline";
    div.className = "mxToolbarComboContainer";
    const select = document.createElement("select");
    select.className = style || "mxToolbarCombo";
    div.appendChild(select);
    this.container.appendChild(div);
    return select;
  }
  /**
   * Adds and returns a new SELECT element using the given title as the
   * default element. The selection is reset to this element after each
   * change.
   *
   * @param title - String that specifies the title of the default element.
   * @param style - Optional style classname. Default is mxToolbarCombo.
   */
  addActionCombo(title, style) {
    const select = document.createElement("select");
    select.className = style || "mxToolbarCombo";
    this.addOption(select, title, null);
    InternalEvent.addListener(select, "change", (evt) => {
      const value = select.options[select.selectedIndex];
      select.selectedIndex = 0;
      if (value.funct != null) {
        value.funct(evt);
      }
    });
    this.container.appendChild(select);
    return select;
  }
  /**
   * Adds and returns a new OPTION element inside the given SELECT element.
   * If the given value is a function then it is stored in the option's funct
   * field.
   *
   * @param combo - SELECT element that will contain the new entry.
   * @param title - String that specifies the title of the option.
   * @param value - Specifies the value associated with this option.
   */
  addOption(combo, title, value = null) {
    const option = document.createElement("option");
    writeln(option, title);
    if (typeof value === "function") {
      option.funct = value;
    } else {
      option.setAttribute("value", value);
    }
    combo.appendChild(option);
    return option;
  }
  /**
   * Adds a new selectable item to the toolbar. Only one switch mode item may
   * be selected at a time. The currently selected item is the default item
   * after a reset of the toolbar.
   */
  addSwitchMode(title, icon, funct, pressedIcon = null, style = "mxToolbarMode") {
    const img = document.createElement("img");
    img.initialClassName = style;
    img.className = img.initialClassName;
    img.setAttribute("src", icon);
    img.altIcon = pressedIcon;
    if (title != null) {
      img.setAttribute("title", title);
    }
    InternalEvent.addListener(img, "click", (evt) => {
      const selectedModeImg = this.selectedMode;
      let tmp = selectedModeImg.altIcon;
      if (tmp != null) {
        selectedModeImg.altIcon = selectedModeImg.getAttribute("src");
        selectedModeImg.setAttribute("src", tmp);
      } else {
        selectedModeImg.className = selectedModeImg.initialClassName;
      }
      if (this.updateDefaultMode) {
        this.defaultMode = img;
      }
      this.selectedMode = img;
      tmp = img.altIcon;
      if (tmp != null) {
        img.altIcon = img.getAttribute("src");
        img.setAttribute("src", tmp);
      } else {
        img.className = `${img.initialClassName}Selected`;
      }
      this.fireEvent(new EventObject(InternalEvent.SELECT));
      funct();
    });
    this.container.appendChild(img);
    if (this.defaultMode == null) {
      this.defaultMode = img;
      this.selectMode(img);
      funct();
    }
    return img;
  }
  /**
   * Adds a new item to the toolbar. The selection is typically reset after
   * the item has been consumed, for example by adding a new vertex to the
   * graph. The reset is not carried out if the item is double clicked.
   *
   * The function argument uses the following signature: funct(evt, cell) where
   * evt is the native mouse event and cell is the cell under the mouse.
   */
  addMode(title = null, icon = null, funct, pressedIcon, style = null, toggle = false) {
    toggle = toggle != null ? toggle : true;
    const img = document.createElement(icon != null ? "img" : "button");
    img.initialClassName = style || "mxToolbarMode";
    img.className = img.initialClassName;
    if (icon) {
      img.setAttribute("src", icon);
    }
    img.altIcon = pressedIcon;
    if (title != null) {
      img.setAttribute("title", title);
    }
    if (this.enabled && toggle) {
      InternalEvent.addListener(img, "click", (evt) => {
        this.selectMode(img, funct);
        this.noReset = false;
      });
      InternalEvent.addListener(img, "dblclick", (evt) => {
        this.selectMode(img, funct);
        this.noReset = true;
      });
      if (this.defaultMode == null) {
        this.defaultMode = img;
        this.defaultFunction = funct;
        this.selectMode(img, funct);
      }
    }
    this.container.appendChild(img);
    return img;
  }
  /**
   * Resets the state of the previously selected mode and displays the given
   * DOM node as selected. This function fires a select event with the given
   * function as a parameter.
   */
  selectMode(domNode, funct = null) {
    if (this.selectedMode != domNode) {
      if (this.selectedMode != null) {
        const tmp2 = this.selectedMode.altIcon;
        if (tmp2 != null) {
          this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
          this.selectedMode.setAttribute("src", tmp2);
        } else {
          this.selectedMode.className = this.selectedMode.initialClassName;
        }
      }
      this.selectedMode = domNode;
      const tmp = this.selectedMode.altIcon;
      if (tmp != null) {
        this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
        this.selectedMode.setAttribute("src", tmp);
      } else {
        this.selectedMode.className = `${this.selectedMode.initialClassName}Selected`;
      }
      this.fireEvent(new EventObject(InternalEvent.SELECT, { function: funct }));
    }
  }
  /**
   * Selects the default mode and resets the state of the previously selected
   * mode.
   */
  resetMode(forced = false) {
    if ((forced || !this.noReset) && this.selectedMode != this.defaultMode) {
      this.selectMode(this.defaultMode, this.defaultFunction);
    }
  }
  /**
   * Adds the specifies image as a separator.
   *
   * @param icon - URL of the separator icon.
   */
  addSeparator(icon) {
    return this.addItem(null, icon, null);
  }
  /**
   * Adds a break to the container.
   */
  addBreak() {
    br(this.container);
  }
  /**
   * Adds a horizontal line to the container.
   */
  addLine() {
    const hr = document.createElement("hr");
    hr.style.marginRight = "6px";
    hr.setAttribute("size", "1");
    this.container.appendChild(hr);
  }
  /**
   * Removes the toolbar and all its associated resources.
   */
  destroy() {
    InternalEvent.release(this.container);
    this.container = null;
    this.defaultMode = null;
    this.defaultFunction = null;
    this.selectedMode = null;
    if (this.menu != null) {
      this.menu.destroy();
    }
  }
}
class DragSource {
  constructor(element, dropHandler) {
    this.dragOffset = null;
    this.dragElement = null;
    this.previewElement = null;
    this.previewOffset = null;
    this.enabled = true;
    this.currentGraph = null;
    this.currentDropTarget = null;
    this.currentPoint = null;
    this.currentGuide = null;
    this.currentHighlight = null;
    this.autoscroll = true;
    this.guidesEnabled = true;
    this.gridEnabled = true;
    this.highlightDropTargets = true;
    this.dragElementZIndex = 100;
    this.dragElementOpacity = 70;
    this.checkEventSource = true;
    this.mouseMoveHandler = null;
    this.mouseUpHandler = null;
    this.eventSource = null;
    this.element = element;
    this.dropHandler = dropHandler;
    InternalEvent.addGestureListeners(element, (evt) => {
      this.mouseDown(evt);
    });
    InternalEvent.addListener(element, "dragstart", (evt) => {
      InternalEvent.consume(evt);
    });
    this.eventConsumer = (sender, evt) => {
      const evtName = evt.getProperty("eventName");
      const me = evt.getProperty("event");
      if (evtName !== InternalEvent.MOUSE_DOWN) {
        me.consume();
      }
    };
  }
  /**
   * Returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Sets {@link enabled}.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * Returns {@link guidesEnabled}.
   */
  isGuidesEnabled() {
    return this.guidesEnabled;
  }
  /**
   * Sets {@link guidesEnabled}.
   */
  setGuidesEnabled(value) {
    this.guidesEnabled = value;
  }
  /**
   * Returns {@link gridEnabled}.
   */
  isGridEnabled() {
    return this.gridEnabled;
  }
  /**
   * Sets {@link gridEnabled}.
   */
  setGridEnabled(value) {
    this.gridEnabled = value;
  }
  /**
   * Returns the graph for the given mouse event. This implementation returns
   * null.
   */
  getGraphForEvent(evt) {
    return null;
  }
  /**
   * Returns the drop target for the given graph and coordinates. This
   * implementation uses {@link mxGraph.getCellAt}.
   */
  getDropTarget(graph, x, y, evt) {
    return graph.getCellAt(x, y);
  }
  /**
   * Creates and returns a clone of the {@link dragElementPrototype} or the {@link element}
   * if the former is not defined.
   */
  createDragElement(evt) {
    return this.element.cloneNode(true);
  }
  /**
   * Creates and returns an element which can be used as a preview in the given
   * graph.
   */
  createPreviewElement(graph) {
    return null;
  }
  /**
   * Returns true if this drag source is active.
   */
  isActive() {
    return !!this.mouseMoveHandler;
  }
  /**
   * Stops and removes everything and restores the state of the object.
   */
  reset() {
    if (this.currentGraph) {
      this.dragExit(this.currentGraph);
      this.currentGraph = null;
    }
    this.removeDragElement();
    this.removeListeners();
    this.stopDrag();
  }
  /**
   * Returns the drop target for the given graph and coordinates. This
   * implementation uses {@link mxGraph.getCellAt}.
   *
   * To ignore popup menu events for a drag source, this function can be
   * overridden as follows.
   *
   * @example
   * ```javascript
   * var mouseDown = dragSource.mouseDown;
   *
   * dragSource.mouseDown(evt)
   * {
   *   if (!mxEvent.isPopupTrigger(evt))
   *   {
   *     mouseDown.apply(this, arguments);
   *   }
   * };
   * ```
   */
  mouseDown(evt) {
    if (this.enabled && !isConsumed(evt) && this.mouseMoveHandler == null) {
      this.startDrag(evt);
      this.mouseMoveHandler = this.mouseMove.bind(this);
      this.mouseUpHandler = this.mouseUp.bind(this);
      InternalEvent.addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
      if (Client.IS_TOUCH && !isMouseEvent(evt)) {
        this.eventSource = getSource(evt);
        if (this.eventSource) {
          InternalEvent.addGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
        }
      }
    }
  }
  /**
   * Creates the {@link dragElement} using {@link createDragElement}.
   */
  startDrag(evt) {
    this.dragElement = this.createDragElement(evt);
    this.dragElement.style.position = "absolute";
    this.dragElement.style.zIndex = String(this.dragElementZIndex);
    setOpacity(this.dragElement, this.dragElementOpacity);
    if (this.checkEventSource && Client.IS_SVG) {
      this.dragElement.style.pointerEvents = "none";
    }
  }
  /**
   * Invokes {@link removeDragElement}.
   */
  stopDrag() {
    this.removeDragElement();
  }
  /**
   * Removes and destroys the {@link dragElement}.
   */
  removeDragElement() {
    if (this.dragElement) {
      if (this.dragElement.parentNode) {
        this.dragElement.parentNode.removeChild(this.dragElement);
      }
      this.dragElement = null;
    }
  }
  /**
   * Returns the topmost element under the given event.
   */
  getElementForEvent(evt) {
    return isTouchEvent(evt) || isPenEvent(evt) ? document.elementFromPoint(getClientX(evt), getClientY(evt)) : getSource(evt);
  }
  /**
   * Returns true if the given graph contains the given event.
   */
  graphContainsEvent(graph, evt) {
    const x = getClientX(evt);
    const y = getClientY(evt);
    const offset = getOffset(graph.container);
    const origin = getScrollOrigin();
    let elt = this.getElementForEvent(evt);
    if (this.checkEventSource) {
      while (elt && elt !== graph.container) {
        elt = elt.parentNode;
      }
    }
    return !!elt && x >= offset.x - origin.x && y >= offset.y - origin.y && x <= offset.x - origin.x + graph.container.offsetWidth && y <= offset.y - origin.y + graph.container.offsetHeight;
  }
  /**
   * Gets the graph for the given event using {@link getGraphForEvent}, updates the
   * {@link currentGraph}, calling {@link dragEnter} and {@link dragExit} on the new and old graph,
   * respectively, and invokes {@link dragOver} if {@link currentGraph} is not null.
   */
  mouseMove(evt) {
    let graph = this.getGraphForEvent(evt);
    if (graph && !this.graphContainsEvent(graph, evt)) {
      graph = null;
    }
    if (graph !== this.currentGraph) {
      if (this.currentGraph) {
        this.dragExit(this.currentGraph, evt);
      }
      this.currentGraph = graph;
      if (this.currentGraph) {
        this.dragEnter(this.currentGraph, evt);
      }
    }
    if (this.currentGraph) {
      this.dragOver(this.currentGraph, evt);
    }
    if (this.dragElement && (!this.previewElement || this.previewElement.style.visibility !== "visible")) {
      let x = getClientX(evt);
      let y = getClientY(evt);
      if (this.dragElement.parentNode == null) {
        document.body.appendChild(this.dragElement);
      }
      this.dragElement.style.visibility = "visible";
      if (this.dragOffset) {
        x += this.dragOffset.x;
        y += this.dragOffset.y;
      }
      const offset = getDocumentScrollOrigin(document);
      this.dragElement.style.left = `${x + offset.x}px`;
      this.dragElement.style.top = `${y + offset.y}px`;
    } else if (this.dragElement) {
      this.dragElement.style.visibility = "hidden";
    }
    InternalEvent.consume(evt);
  }
  /**
   * Processes the mouse up event and invokes {@link drop}, {@link dragExit} and {@link stopDrag}
   * as required.
   */
  mouseUp(evt) {
    if (this.currentGraph) {
      if (this.currentPoint && (!this.previewElement || this.previewElement.style.visibility !== "hidden")) {
        const { scale } = this.currentGraph.view;
        const tr = this.currentGraph.view.translate;
        const x = this.currentPoint.x / scale - tr.x;
        const y = this.currentPoint.y / scale - tr.y;
        this.drop(this.currentGraph, evt, this.currentDropTarget, x, y);
      }
      this.dragExit(this.currentGraph);
      this.currentGraph = null;
    }
    this.stopDrag();
    this.removeListeners();
    InternalEvent.consume(evt);
  }
  /**
   * Actives the given graph as a drop target.
   */
  // removeListeners(): void;
  removeListeners() {
    if (this.eventSource) {
      InternalEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
      this.eventSource = null;
    }
    InternalEvent.removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
    this.mouseMoveHandler = null;
    this.mouseUpHandler = null;
  }
  /**
   * Actives the given graph as a drop target.
   */
  dragEnter(graph, evt) {
    graph.isMouseDown = true;
    graph.isMouseTrigger = isMouseEvent(evt);
    this.previewElement = this.createPreviewElement(graph);
    if (this.previewElement && this.checkEventSource && Client.IS_SVG) {
      this.previewElement.style.pointerEvents = "none";
    }
    if (this.isGuidesEnabled() && this.previewElement) {
      const selectionHandler = graph.getPlugin("SelectionHandler");
      this.currentGuide = new Guide(graph, selectionHandler == null ? void 0 : selectionHandler.getGuideStates());
    }
    if (this.highlightDropTargets) {
      this.currentHighlight = new CellHighlight(graph, DROP_TARGET_COLOR);
    }
    graph.addListener(InternalEvent.FIRE_MOUSE_EVENT, this.eventConsumer);
  }
  /**
   * Deactivates the given graph as a drop target.
   */
  dragExit(graph, evt) {
    this.currentDropTarget = null;
    this.currentPoint = null;
    graph.isMouseDown = false;
    graph.removeListener(this.eventConsumer);
    if (this.previewElement) {
      if (this.previewElement.parentNode) {
        this.previewElement.parentNode.removeChild(this.previewElement);
      }
      this.previewElement = null;
    }
    if (this.currentGuide) {
      this.currentGuide.destroy();
      this.currentGuide = null;
    }
    if (this.currentHighlight) {
      this.currentHighlight.destroy();
      this.currentHighlight = null;
    }
  }
  /**
   * Implements autoscroll, updates the {@link currentPoint}, highlights any drop
   * targets and updates the preview.
   */
  dragOver(graph, evt) {
    const offset = getOffset(graph.container);
    const origin = getScrollOrigin(graph.container);
    let x = getClientX(evt) - offset.x + origin.x - graph.getPanDx();
    let y = getClientY(evt) - offset.y + origin.y - graph.getPanDy();
    if (graph.isAutoScroll() && (!this.autoscroll || this.autoscroll)) {
      graph.scrollPointToVisible(x, y, graph.isAutoExtend());
    }
    if (this.currentHighlight && graph.isDropEnabled()) {
      this.currentDropTarget = this.getDropTarget(graph, x, y, evt);
      if (this.currentDropTarget) {
        const state = graph.getView().getState(this.currentDropTarget);
        this.currentHighlight.highlight(state);
      }
    }
    if (this.previewElement) {
      if (!this.previewElement.parentNode) {
        graph.container.appendChild(this.previewElement);
        this.previewElement.style.zIndex = "3";
        this.previewElement.style.position = "absolute";
      }
      const gridEnabled = this.isGridEnabled() && graph.isGridEnabledEvent(evt);
      let hideGuide = true;
      if (this.currentGuide && this.currentGuide.isEnabledForEvent(evt)) {
        const w = parseInt(this.previewElement.style.width);
        const h = parseInt(this.previewElement.style.height);
        const bounds = new Rectangle(0, 0, w, h);
        let delta = new Point(x, y);
        delta = this.currentGuide.move(bounds, delta, gridEnabled, true);
        hideGuide = false;
        x = delta.x;
        y = delta.y;
      } else if (gridEnabled) {
        const { scale } = graph.view;
        const tr = graph.view.translate;
        const off = graph.getGridSize() / 2;
        x = (graph.snap(x / scale - tr.x - off) + tr.x) * scale;
        y = (graph.snap(y / scale - tr.y - off) + tr.y) * scale;
      }
      if (this.currentGuide && hideGuide) {
        this.currentGuide.hide();
      }
      if (this.previewOffset) {
        x += this.previewOffset.x;
        y += this.previewOffset.y;
      }
      this.previewElement.style.left = `${Math.round(x)}px`;
      this.previewElement.style.top = `${Math.round(y)}px`;
      this.previewElement.style.visibility = "visible";
    }
    this.currentPoint = new Point(x, y);
  }
  /**
   * Returns the drop target for the given graph and coordinates. This
   * implementation uses {@link mxGraph.getCellAt}.
   */
  drop(graph, evt, dropTarget = null, x, y) {
    this.dropHandler(graph, evt, dropTarget, x, y);
    if (graph.container.style.visibility !== "hidden") {
      graph.container.focus();
    }
  }
}
const makeDraggable = (element, graphF, funct, dragElement = null, dx = null, dy = null, autoscroll = null, scalePreview = false, highlightDropTargets = true, getDropTarget = null) => {
  const dragSource = new DragSource(element, funct);
  dragSource.dragOffset = new Point(dx != null ? dx : 0, dy != null ? dy : TOOLTIP_VERTICAL_OFFSET);
  if (autoscroll != null) {
    dragSource.autoscroll = autoscroll;
  }
  dragSource.setGuidesEnabled(false);
  if (highlightDropTargets != null) {
    dragSource.highlightDropTargets = highlightDropTargets;
  }
  if (getDropTarget != null) {
    dragSource.getDropTarget = getDropTarget;
  }
  dragSource.getGraphForEvent = (evt) => {
    return typeof graphF === "function" ? graphF(evt) : graphF;
  };
  if (dragElement != null) {
    dragSource.createDragElement = () => {
      return dragElement.cloneNode(true);
    };
    if (scalePreview) {
      dragSource.createPreviewElement = (graph) => {
        const elt = dragElement.cloneNode(true);
        const w = parseInt(elt.style.width);
        const h = parseInt(elt.style.height);
        elt.style.width = `${Math.round(w * graph.view.scale)}px`;
        elt.style.height = `${Math.round(h * graph.view.scale)}px`;
        return elt;
      };
    }
  }
  return dragSource;
};
const gestureUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  makeDraggable
}, Symbol.toStringTag, { value: "Module" }));
class EditorToolbar {
  constructor(container = null, editor = null) {
    this.toolbar = null;
    this.resetHandler = null;
    this.spacing = 4;
    this.connectOnDrop = false;
    this.editor = editor;
    if (container != null && editor != null) {
      this.init(container);
    }
  }
  /**
   * Constructs the {@link toolbar} for the given container and installs a listener that updates the {@link Editor.insertFunction} on {@link editor} if an item is selected in the toolbar.  This assumes that {@link editor} is not null.
   */
  init(container) {
    if (container != null) {
      this.toolbar = new MaxToolbar(container);
      this.toolbar.addListener(InternalEvent.SELECT, (sender, evt) => {
        const funct = evt.getProperty("function");
        if (funct != null) {
          this.editor.insertFunction = () => {
            funct.apply(this, [container]);
            this.toolbar.resetMode();
          };
        } else {
          this.editor.insertFunction = null;
        }
      });
      this.resetHandler = () => {
        if (this.toolbar != null) {
          this.toolbar.resetMode(true);
        }
      };
      this.editor.graph.addListener(InternalEvent.DOUBLE_CLICK, this.resetHandler);
      this.editor.addListener(InternalEvent.ESCAPE, this.resetHandler);
    }
  }
  /**
   * Adds a new item that executes the given action in {@link editor}. The title,
   * icon and pressedIcon are used to display the toolbar item.
   *
   * @param title - String that represents the title (tooltip) for the item.
   * @param icon - URL of the icon to be used for displaying the item.
   * @param action - Name of the action to execute when the item is clicked.
   * @param pressed - Optional URL of the icon for the pressed state.
   */
  addItem(title, icon, action, pressed) {
    const clickHandler = () => {
      if (action != null && action.length > 0) {
        this.editor.execute(action);
      }
    };
    return this.toolbar.addItem(title, icon, clickHandler, pressed);
  }
  /**
   * Adds a vertical separator using the optional icon.
   *
   * @param icon - Optional URL of the icon that represents the vertical separator. Default is {@link Client.imageBasePath} + /separator.gif.
   */
  addSeparator(icon) {
    icon = icon || `${Client.imageBasePath}/separator.gif`;
    this.toolbar.addSeparator(icon);
  }
  /**
   * Helper method to invoke {@link MaxToolbar.addCombo} on toolbar and return the resulting DOM node.
   */
  addCombo() {
    return this.toolbar.addCombo();
  }
  /**
   * Helper method to invoke <MaxToolbar.addActionCombo> on <toolbar> using
   * the given title and return the resulting DOM node.
   *
   * @param title String that represents the title of the combo.
   */
  addActionCombo(title) {
    return this.toolbar.addActionCombo(title);
  }
  /**
   * Binds the given action to a option with the specified label in the given combo.  Combo is an object returned from an earlier call to {@link addCombo} or {@link addActionCombo}.
   *
   * @param combo - DOM node that represents the combo box.
   * @param title - String that represents the title of the combo.
   * @param action - Name of the action to execute in {@link editor}.
   */
  addActionOption(combo, title, action) {
    const clickHandler = () => {
      this.editor.execute(action);
    };
    this.addOption(combo, title, clickHandler);
  }
  /**
   * Helper method to invoke {@link MaxToolbar.addOption} on {@link toolbar} and return the resulting DOM node that represents the option.
   *
   * @param combo - DOM node that represents the combo box.
   * @param title - String that represents the title of the combo.
   * @param value - Object that represents the value of the option.
   */
  addOption(combo, title, value) {
    return this.toolbar.addOption(combo, title, value);
  }
  /**
   * Creates an item for selecting the given mode in the {@link editor}'s graph.
   * Supported modenames are select, connect and pan.
   *
   * @param title - String that represents the title of the item.
   * @param icon - URL of the icon that represents the item.
   * @param mode - String that represents the mode name to be used in {@link Editor.setMode}.
   * @param pressed - Optional URL of the icon that represents the pressed state.
   * @param funct - Optional JavaScript function that takes the {@link Editor} as the first and only argument that is executed after the mode has been selected.
   */
  addMode(title, icon, mode, pressed = null, funct = null) {
    const clickHandler = () => {
      this.editor.setMode(mode);
      if (funct != null) {
        funct(this.editor);
      }
    };
    return this.toolbar.addSwitchMode(title, icon, clickHandler, pressed);
  }
  /**
   * Creates an item for inserting a clone of the specified prototype cell into
   * the <editor>'s graph. The ptype may either be a cell or a function that
   * returns a cell.
   *
   * @param title String that represents the title of the item.
   * @param icon URL of the icon that represents the item.
   * @param ptype Function or object that represents the prototype cell. If ptype
   * is a function then it is invoked with no arguments to create new
   * instances.
   * @param pressed Optional URL of the icon that represents the pressed state.
   * @param insert Optional JavaScript function that handles an insert of the new
   * cell. This function takes the <Editor>, new cell to be inserted, mouse
   * event and optional <Cell> under the mouse pointer as arguments.
   * @param toggle Optional boolean that specifies if the item can be toggled.
   * Default is true.
   */
  addPrototype(title, icon, ptype, pressed, insert, toggle = true) {
    const factory = () => {
      if (typeof ptype === "function") {
        return ptype();
      }
      if (ptype != null) {
        return this.editor.graph.cloneCell(ptype);
      }
      return null;
    };
    const clickHandler = (evt, cell) => {
      if (typeof insert === "function") {
        insert(this.editor, factory(), evt, cell);
      } else {
        this.drop(factory(), evt, cell);
      }
      this.toolbar.resetMode();
      InternalEvent.consume(evt);
    };
    const img = this.toolbar.addMode(title, icon, clickHandler, pressed, null, toggle);
    const dropHandler = (graph, evt, cell) => {
      clickHandler(evt, cell);
    };
    this.installDropHandler(img, dropHandler);
    return img;
  }
  /**
   * Handles a drop from a toolbar item to the graph. The given vertex
   * represents the new cell to be inserted. This invokes {@link insert} or
   * {@link connect} depending on the given target cell.
   *
   * @param vertex - {@link Cell} to be inserted.
   * @param evt - Mouse event that represents the drop.
   * @param target - Optional {@link Cell} that represents the drop target.
   */
  drop(vertex, evt, target = null) {
    const { graph } = this.editor;
    graph.getDataModel();
    if (target == null || target.isEdge() || !this.connectOnDrop || !target.isConnectable()) {
      while (target != null && !graph.isValidDropTarget(target, [vertex], evt)) {
        target = target.getParent();
      }
      this.insert(vertex, evt, target);
    } else {
      this.connect(vertex, evt, target);
    }
  }
  /**
   * Handles a drop by inserting the given vertex into the given parent cell
   * or the default parent if no parent is specified.
   *
   * @param vertex - {@link Cell} to be inserted.
   * @param evt - Mouse event that represents the drop.
   * @param target - Optional {@link Cell} that represents the parent.
   */
  insert(vertex, evt, target = null) {
    const { graph } = this.editor;
    if (graph.canImportCell(vertex)) {
      const x = getClientX(evt);
      const y = getClientY(evt);
      const pt = convertPoint(graph.container, x, y);
      if (target && graph.isSplitEnabled() && graph.isSplitTarget(target, [vertex], evt)) {
        return graph.splitEdge(target, [vertex], null, pt.x, pt.y);
      }
      return this.editor.addVertex(target, vertex, pt.x, pt.y);
    }
    return null;
  }
  /**
   * Handles a drop by connecting the given vertex to the given source cell.
   *
   * @param vertex - {@link Cell} to be inserted.
   * @param evt - Mouse event that represents the drop.
   * @param source - Optional {@link Cell} that represents the source terminal.
   */
  connect(vertex, evt, source = null) {
    const { graph } = this.editor;
    const model = graph.getDataModel();
    if (source != null && vertex.isConnectable() && graph.isEdgeValid(null, source, vertex)) {
      let edge = null;
      model.beginUpdate();
      try {
        const geo = source.getGeometry();
        const g = vertex.getGeometry().clone();
        g.x = geo.x + (geo.width - g.width) / 2;
        g.y = geo.y + (geo.height - g.height) / 2;
        const step = this.spacing * graph.gridSize;
        const dist = source.getDirectedEdgeCount(true) * 20;
        if (this.editor.horizontalFlow) {
          g.x += (g.width + geo.width) / 2 + step + dist;
        } else {
          g.y += (g.height + geo.height) / 2 + step + dist;
        }
        vertex.setGeometry(g);
        const parent = source.getParent();
        graph.addCell(vertex, parent);
        graph.constrainChild(vertex);
        edge = this.editor.createEdge(source, vertex);
        if (edge.getGeometry() == null) {
          const edgeGeometry = new Geometry();
          edgeGeometry.relative = true;
          model.setGeometry(edge, edgeGeometry);
        }
        graph.addEdge(edge, parent, source, vertex);
      } finally {
        model.endUpdate();
      }
      graph.setSelectionCells([vertex, edge]);
      graph.scrollCellToVisible(vertex);
    }
  }
  /**
   * Makes the given img draggable using the given function for handling a drop event.
   *
   * @param img - DOM node that represents the image.
   * @param dropHandler - Function that handles a drop of the image.
   */
  installDropHandler(img, dropHandler) {
    const sprite = document.createElement("img");
    sprite.setAttribute("src", img.getAttribute("src"));
  }
  /**
   * Destroys the {@link toolbar} associated with this object and removes all installed listeners.
   * This does normally not need to be called, the {@link toolbar} is destroyed automatically when the window unloads (in IE) by {@link Editor}.
   */
  destroy() {
    if (this.resetHandler != null) {
      this.editor.graph.removeListener(this.resetHandler);
      this.editor.removeListener(this.resetHandler);
      this.resetHandler = null;
    }
    if (this.toolbar != null) {
      this.toolbar.destroy();
      this.toolbar = null;
    }
  }
}
class UndoManager extends EventSource {
  constructor(size = 100) {
    super();
    this.size = 100;
    this.history = [];
    this.indexOfNextAdd = 0;
    this.size = size;
    this.clear();
  }
  /**
   * Returns true if the history is empty.
   */
  isEmpty() {
    return this.history.length == 0;
  }
  /**
   * Clears the command history.
   */
  clear() {
    this.history = [];
    this.indexOfNextAdd = 0;
    this.fireEvent(new EventObject(InternalEvent.CLEAR));
  }
  /**
   * Returns true if an undo is possible.
   */
  canUndo() {
    return this.indexOfNextAdd > 0;
  }
  /**
   * Undoes the last change.
   */
  undo() {
    while (this.indexOfNextAdd > 0) {
      const edit = this.history[--this.indexOfNextAdd];
      edit.undo();
      if (edit.isSignificant()) {
        this.fireEvent(new EventObject(InternalEvent.UNDO, { edit }));
        break;
      }
    }
  }
  /**
   * Returns true if a redo is possible.
   */
  canRedo() {
    return this.indexOfNextAdd < this.history.length;
  }
  /**
   * Redoes the last change.
   */
  redo() {
    const n = this.history.length;
    while (this.indexOfNextAdd < n) {
      const edit = this.history[this.indexOfNextAdd++];
      edit.redo();
      if (edit.isSignificant()) {
        this.fireEvent(new EventObject(InternalEvent.REDO, { edit }));
        break;
      }
    }
  }
  /**
   * Method to be called to add new undoable edits to the <history>.
   */
  undoableEditHappened(undoableEdit) {
    this.trim();
    if (this.size > 0 && this.size == this.history.length) {
      this.history.shift();
    }
    this.history.push(undoableEdit);
    this.indexOfNextAdd = this.history.length;
    this.fireEvent(new EventObject(InternalEvent.ADD, { edit: undoableEdit }));
  }
  /**
   * Removes all pending steps after <indexOfNextAdd> from the history,
   * invoking die on each edit. This is called from <undoableEditHappened>.
   */
  trim() {
    if (this.history.length > this.indexOfNextAdd) {
      const edits = this.history.splice(this.indexOfNextAdd, this.history.length - this.indexOfNextAdd);
      for (let i = 0; i < edits.length; i += 1) {
        edits[i].die();
      }
    }
  }
}
class GraphLayout {
  constructor(graph) {
    this.useBoundingBox = true;
    this.parent = null;
    this.graph = graph;
  }
  /**
   * Notified when a cell is being moved in a parent that has automatic
   * layout to update the cell state (eg. index) so that the outcome of the
   * layout will position the vertex as close to the point (x, y) as
   * possible.
   *
   * Empty implementation.
   *
   * @param cell {@link Cell} which has been moved.
   * @param x X-coordinate of the new cell location.
   * @param y Y-coordinate of the new cell location.
   */
  moveCell(cell, x, y) {
    return;
  }
  /**
   * Notified when a cell is being resized in a parent that has automatic
   * layout to update the other cells in the layout.
   *
   * Empty implementation.
   *
   * @param cell {@link Cell} which has been moved.
   * @param bounds {@link Rectangle} that represents the new cell bounds.
   * @param prev
   */
  resizeCell(cell, bounds, prev) {
    return;
  }
  /**
   * Executes the layout algorithm for the children of the given parent.
   *
   * @param parent {@link Cell} whose children should be layed out.
   */
  execute(parent) {
    return;
  }
  /**
   * Returns the graph that this layout operates on.
   */
  getGraph() {
    return this.graph;
  }
  /**
   * Returns the constraint for the given key and cell. The optional edge and
   * source arguments are used to return inbound and outgoing routing-
   * constraints for the given edge and vertex. This implementation always
   * returns the value for the given key in the style of the given cell.
   *
   * @param key Key of the constraint to be returned.
   * @param cell {@link Cell} whose constraint should be returned.
   * @param edge Optional {@link Cell} that represents the connection whose constraint
   * should be returned. Default is null.
   * @param source Optional boolean that specifies if the connection is incoming
   * or outgoing. Default is null.
   */
  getConstraint(key, cell, edge, source) {
    return this.graph.getCurrentCellStyle(cell)[key];
  }
  /**
   * Traverses the (directed) graph invoking the given function for each
   * visited vertex and edge. The function is invoked with the current vertex
   * and the incoming edge as a parameter. This implementation makes sure
   * each vertex is only visited once. The function may return false if the
   * traversal should stop at the given vertex.
   *
   * Example:
   *
   * ```javascript
   * GlobalConfig.logger.show();
   * const cell = graph.getSelectionCell();
   * graph.traverse(cell, false, function(vertex, edge)
   * {
   *   GlobalConfig.logger.debug(graph.getLabel(vertex));
   * });
   * ```
   *
   * @param vertex {@link Cell} that represents the vertex where the traversal starts.
   * @param directed Optional boolean indicating if edges should only be traversed
   * from source to target. Default is true.
   * @param func Visitor function that takes the current vertex and the incoming
   * edge as arguments. The traversal stops if the function returns false.
   * @param edge Optional {@link Cell} that represents the incoming edge. This is
   * null for the first step of the traversal.
   * @param visited Optional {@link Dictionary} of cell paths for the visited cells.
   */
  traverse({ vertex, directed, func, edge, visited }) {
    if (func != null && vertex != null) {
      directed = directed != null ? directed : true;
      visited = visited || new Dictionary();
      if (!visited.get(vertex)) {
        visited.put(vertex, true);
        const result = func(vertex, edge);
        if (result == null || result) {
          const edgeCount = vertex.getEdgeCount();
          if (edgeCount > 0) {
            for (let i = 0; i < edgeCount; i += 1) {
              const e = vertex.getEdgeAt(i);
              const isSource = e.getTerminal(true) === vertex;
              if (!directed || isSource) {
                const next = this.graph.view.getVisibleTerminal(e, !isSource);
                this.traverse({
                  vertex: next,
                  directed,
                  func,
                  edge: e,
                  visited
                });
              }
            }
          }
        }
      }
    }
  }
  /**
   * Returns true if the given parent is an ancestor of the given child.
   *
   * @param parent {@link Cell} that specifies the parent.
   * @param child {@link Cell} that specifies the child.
   * @param traverseAncestors boolean whether to
   */
  isAncestor(parent, child, traverseAncestors) {
    if (!traverseAncestors) {
      return child.getParent() === parent;
    }
    if (child === parent) {
      return false;
    }
    while (child != null && child !== parent) {
      child = child.getParent();
    }
    return child === parent;
  }
  /**
   * Returns a boolean indicating if the given {@link Cell} is movable or
   * bendable by the algorithm. This implementation returns true if the given
   * cell is movable in the graph.
   *
   * @param cell {@link Cell} whose movable state should be returned.
   */
  isVertexMovable(cell) {
    return this.graph.isCellMovable(cell);
  }
  /**
   * Returns a boolean indicating if the given {@link Cell} should be ignored by
   * the algorithm. This implementation returns false for all vertices.
   *
   * @param vertex {@link Cell} whose ignored state should be returned.
   */
  isVertexIgnored(vertex) {
    return !vertex.isVertex() || !vertex.isVisible();
  }
  /**
   * Returns a boolean indicating if the given {@link Cell} should be ignored by
   * the algorithm. This implementation returns false for all vertices.
   *
   * @param edge {@link Cell} whose ignored state should be returned.
   */
  isEdgeIgnored(edge) {
    return !edge.isEdge() || !edge.isVisible() || edge.getTerminal(true) == null || edge.getTerminal(false) == null;
  }
  /**
   * Disables or enables the edge style of the given edge.
   */
  setEdgeStyleEnabled(edge, value) {
    this.graph.setCellStyles("noEdgeStyle", value ? "0" : "1", [edge]);
  }
  /**
   * Disables or enables orthogonal end segments of the given edge.
   */
  setOrthogonalEdge(edge, value) {
    this.graph.setCellStyles("orthogonal", value ? "1" : "0", [edge]);
  }
  /**
   * Determines the offset of the given parent to the parent
   * of the layout
   */
  getParentOffset(parent) {
    const result = new Point();
    if (parent != null && parent !== this.parent) {
      this.graph.getDataModel();
      if (this.parent && this.parent.isAncestor(parent)) {
        let parentGeo = parent.getGeometry();
        while (parent !== this.parent) {
          result.x += parentGeo.x;
          result.y += parentGeo.y;
          parent = parent.getParent();
          parentGeo = parent.getGeometry();
        }
      }
    }
    return result;
  }
  /**
   * Replaces the array of Point in the geometry of the given edge
   * with the given array of Point.
   */
  setEdgePoints(edge, points) {
    if (edge != null) {
      const { model } = this.graph;
      let geometry = edge.getGeometry();
      if (geometry == null) {
        geometry = new Geometry();
        geometry.setRelative(true);
      } else {
        geometry = geometry.clone();
      }
      if (this.parent != null && points != null) {
        const parent = edge.getParent();
        const parentOffset = this.getParentOffset(parent);
        for (let i = 0; i < points.length; i += 1) {
          points[i].x = points[i].x - parentOffset.x;
          points[i].y = points[i].y - parentOffset.y;
        }
      }
      geometry.points = points;
      model.setGeometry(edge, geometry);
    }
  }
  /**
   * Sets the new position of the given cell taking into account the size of
   * the bounding box if {@link useBoundingBox} is true. The change is only carried
   * out if the new location is not equal to the existing location, otherwise
   * the geometry is not replaced with an updated instance. The new or old
   * bounds are returned (including overlapping labels).
   *
   * @param cell {@link Cell} whose geometry is to be set.
   * @param x Integer that defines the x-coordinate of the new location.
   * @param y Integer that defines the y-coordinate of the new location.
   */
  setVertexLocation(cell, x, y) {
    const model = this.graph.getDataModel();
    let geometry = cell.getGeometry();
    let result = null;
    if (geometry != null) {
      result = new Rectangle(x, y, geometry.width, geometry.height);
      if (this.useBoundingBox) {
        const state = this.graph.getView().getState(cell);
        if (state != null && state.text != null && state.text.boundingBox != null) {
          const { scale } = this.graph.getView();
          const box = state.text.boundingBox;
          if (state.text.boundingBox.x < state.x) {
            x += (state.x - box.x) / scale;
            result.width = box.width;
          }
          if (state.text.boundingBox.y < state.y) {
            y += (state.y - box.y) / scale;
            result.height = box.height;
          }
        }
      }
      if (this.parent != null) {
        const parent = cell.getParent();
        if (parent != null && parent !== this.parent) {
          const parentOffset = this.getParentOffset(parent);
          x -= parentOffset.x;
          y -= parentOffset.y;
        }
      }
      if (geometry.x !== x || geometry.y !== y) {
        geometry = geometry.clone();
        geometry.x = x;
        geometry.y = y;
        model.setGeometry(cell, geometry);
      }
    }
    return result;
  }
  /**
   * Returns an {@link Rectangle} that defines the bounds of the given cell or
   * the bounding box if {@link useBoundingBox} is true.
   */
  getVertexBounds(cell) {
    let geo = cell.getGeometry();
    if (this.useBoundingBox) {
      const state = this.graph.getView().getState(cell);
      if (state != null && state.text != null && state.text.boundingBox != null) {
        const { scale } = this.graph.getView();
        const tmp = state.text.boundingBox;
        const dx0 = Math.max(state.x - tmp.x, 0) / scale;
        const dy0 = Math.max(state.y - tmp.y, 0) / scale;
        const dx1 = Math.max(tmp.x + tmp.width - (state.x + state.width), 0) / scale;
        const dy1 = Math.max(tmp.y + tmp.height - (state.y + state.height), 0) / scale;
        geo = new Rectangle(geo.x - dx0, geo.y - dy0, geo.width + dx0 + dx1, geo.height + dy0 + dy1);
      }
    }
    if (this.parent != null) {
      const parent = cell.getParent();
      geo = geo.clone();
      if (parent != null && parent !== this.parent) {
        const parentOffset = this.getParentOffset(parent);
        geo.x += parentOffset.x;
        geo.y += parentOffset.y;
      }
    }
    return new Rectangle(geo.x, geo.y, geo.width, geo.height);
  }
  /**
   * Shortcut to {@link Graph#updateGroupBounds} with moveGroup set to true.
   */
  arrangeGroups(cells, border, topBorder, rightBorder, bottomBorder, leftBorder) {
    return this.graph.updateGroupBounds(cells, border, true, topBorder, rightBorder, bottomBorder, leftBorder);
  }
}
class WeightedCellSorter {
  constructor(cell, weightedValue = 0) {
    this.weightedValue = 0;
    this.nudge = false;
    this.visited = false;
    this.rankIndex = null;
    this.cell = cell;
    this.weightedValue = weightedValue;
  }
  /**
   * Compares two WeightedCellSorters.
   */
  static compare(a, b) {
    if (a != null && b != null) {
      if (b.weightedValue > a.weightedValue) {
        return -1;
      }
      if (b.weightedValue < a.weightedValue) {
        return 1;
      }
      if (b.nudge) {
        return -1;
      }
      return 1;
    }
    return 0;
  }
}
function findTreeRoots(graph, parent, isolate = false, invert = false) {
  const roots = [];
  if (parent != null) {
    let best = null;
    let maxDiff = 0;
    for (const cell of parent.getChildren()) {
      if (cell.isVertex() && cell.isVisible()) {
        const conns = graph.getConnections(cell, isolate ? parent : null);
        let fanOut = 0;
        let fanIn = 0;
        for (let j = 0; j < conns.length; j++) {
          const src = graph.view.getVisibleTerminal(conns[j], true);
          if (src == cell) {
            fanOut++;
          } else {
            fanIn++;
          }
        }
        if (invert && fanOut == 0 && fanIn > 0 || !invert && fanIn == 0 && fanOut > 0) {
          roots.push(cell);
        }
        const diff = invert ? fanIn - fanOut : fanOut - fanIn;
        if (diff > maxDiff) {
          maxDiff = diff;
          best = cell;
        }
      }
    }
    if (roots.length == 0 && best != null) {
      roots.push(best);
    }
  }
  return roots;
}
class CompactTreeLayout extends GraphLayout {
  constructor(graph, horizontal = true, invert = false) {
    super(graph);
    this.parentX = null;
    this.parentY = null;
    this.visited = {};
    this.horizontal = true;
    this.invert = false;
    this.resizeParent = true;
    this.maintainParentLocation = false;
    this.groupPadding = 10;
    this.groupPaddingTop = 0;
    this.groupPaddingRight = 0;
    this.groupPaddingBottom = 0;
    this.groupPaddingLeft = 0;
    this.parentsChanged = null;
    this.moveTree = false;
    this.levelDistance = 10;
    this.nodeDistance = 20;
    this.resetEdges = true;
    this.prefHozEdgeSep = 5;
    this.prefVertEdgeOff = 4;
    this.minEdgeJetty = 8;
    this.channelBuffer = 4;
    this.edgeRouting = true;
    this.sortEdges = false;
    this.alignRanks = false;
    this.maxRankHeight = [];
    this.root = null;
    this.node = null;
    this.horizontal = horizontal;
    this.invert = invert;
  }
  /**
   * Returns a boolean indicating if the given {@link mxCell} should be ignored as a
   * vertex. This returns true if the cell has no connections.
   *
   * @param vertex {@link mxCell} whose ignored state should be returned.
   */
  isVertexIgnored(vertex) {
    return super.isVertexIgnored(vertex) || vertex.getConnections().length === 0;
  }
  /**
   * Returns {@link horizontal}.
   */
  isHorizontal() {
    return this.horizontal;
  }
  /**
   * Implements {@link GraphLayout.execute}.
   *
   * If the parent has any connected edges, then it is used as the root of
   * the tree. Else, {@link mxGraph.findTreeRoots} will be used to find a suitable
   * root node within the set of children of the given parent.
   *
   * @param parent  {@link mxCell} whose children should be laid out.
   * @param root    Optional {@link mxCell} that will be used as the root of the tree. Overrides {@link root} if specified.
   */
  execute(parent, root) {
    this.parent = parent;
    const model = this.graph.getDataModel();
    if (root == null) {
      if (this.graph.getEdges(parent, parent.getParent(), this.invert, !this.invert, false).length > 0) {
        this.root = parent;
      } else {
        const roots = findTreeRoots(this.graph, parent, true, this.invert);
        if (roots.length > 0) {
          for (let i = 0; i < roots.length; i += 1) {
            if (!this.isVertexIgnored(roots[i]) && this.graph.getEdges(roots[i], null, this.invert, !this.invert, false).length > 0) {
              this.root = roots[i];
              break;
            }
          }
        }
      }
    } else {
      this.root = root;
    }
    if (this.root != null) {
      if (this.resizeParent) {
        this.parentsChanged = {};
      } else {
        this.parentsChanged = null;
      }
      this.parentX = null;
      this.parentY = null;
      if (parent !== this.root && parent.isVertex() != null && this.maintainParentLocation) {
        const geo = parent.getGeometry();
        if (geo != null) {
          this.parentX = geo.x;
          this.parentY = geo.y;
        }
      }
      model.beginUpdate();
      try {
        this.visited = {};
        this.node = this.dfs(this.root, parent);
        if (this.alignRanks) {
          this.maxRankHeight = [];
          this.findRankHeights(this.node, 0);
          this.setCellHeights(this.node, 0);
        }
        if (this.node != null) {
          this.layout(this.node);
          let x0 = this.graph.gridSize;
          let y0 = x0;
          if (!this.moveTree) {
            const g = this.getVertexBounds(this.root);
            if (g != null) {
              x0 = g.x;
              y0 = g.y;
            }
          }
          let bounds = null;
          if (this.isHorizontal()) {
            bounds = this.horizontalLayout(this.node, x0, y0);
          } else {
            bounds = this.verticalLayout(this.node, null, x0, y0);
          }
          if (bounds != null) {
            let dx = 0;
            let dy = 0;
            if (bounds.x < 0) {
              dx = Math.abs(x0 - bounds.x);
            }
            if (bounds.y < 0) {
              dy = Math.abs(y0 - bounds.y);
            }
            if (dx !== 0 || dy !== 0) {
              this.moveNode(this.node, dx, dy);
            }
            if (this.resizeParent) {
              this.adjustParents();
            }
            if (this.edgeRouting) {
              this.localEdgeProcessing(this.node);
            }
          }
          if (this.parentX != null && this.parentY != null) {
            let geo = parent.getGeometry();
            if (geo != null) {
              geo = geo.clone();
              geo.x = this.parentX;
              geo.y = this.parentY;
              model.setGeometry(parent, geo);
            }
          }
        }
      } finally {
        model.endUpdate();
      }
    }
  }
  /**
   * Moves the specified node and all of its children by the given amount.
   */
  moveNode(node, dx, dy) {
    node.x += dx;
    node.y += dy;
    this.apply(node);
    let { child } = node;
    while (child != null) {
      this.moveNode(child, dx, dy);
      child = child.next;
    }
  }
  /**
   * Called if {@link sortEdges} is true to sort the array of outgoing edges in place.
   */
  sortOutgoingEdges(source, edges) {
    const lookup = new Dictionary();
    edges.sort((e1, e2) => {
      const end1 = e1.getTerminal(e1.getTerminal(false) == source);
      let p1 = lookup.get(end1);
      if (p1 == null) {
        p1 = CellPath.create(end1).split(CellPath.PATH_SEPARATOR);
        lookup.put(end1, p1);
      }
      const end2 = e2.getTerminal(e2.getTerminal(false) === source);
      let p2 = lookup.get(end2);
      if (p2 == null) {
        p2 = CellPath.create(end2).split(CellPath.PATH_SEPARATOR);
        lookup.put(end2, p2);
      }
      return CellPath.compare(p1, p2);
    });
  }
  /**
   * Stores the maximum height (relative to the layout
   * direction) of cells in each rank
   */
  findRankHeights(node, rank) {
    const maxRankHeight = this.maxRankHeight;
    if (maxRankHeight[rank] == null || maxRankHeight[rank] < node.height) {
      maxRankHeight[rank] = node.height;
    }
    let { child } = node;
    while (child != null) {
      this.findRankHeights(child, rank + 1);
      child = child.next;
    }
  }
  /**
   * Set the cells heights (relative to the layout
   * direction) when the tops of each rank are to be aligned
   */
  setCellHeights(node, rank) {
    const maxRankHeight = this.maxRankHeight;
    if (maxRankHeight[rank] != null && maxRankHeight[rank] > node.height) {
      node.height = maxRankHeight[rank];
    }
    let { child } = node;
    while (child != null) {
      this.setCellHeights(child, rank + 1);
      child = child.next;
    }
  }
  /**
   * Does a depth first search starting at the specified cell.
   * Makes sure the specified parent is never left by the
   * algorithm.
   */
  dfs(cell, parent) {
    const id = CellPath.create(cell);
    let node = null;
    if (cell != null && this.visited[id] == null && !this.isVertexIgnored(cell)) {
      this.visited[id] = cell;
      node = this.createNode(cell);
      this.graph.getDataModel();
      let prev = null;
      const out = this.graph.getEdges(cell, parent, this.invert, !this.invert, false, true);
      const view = this.graph.getView();
      if (this.sortEdges) {
        this.sortOutgoingEdges(cell, out);
      }
      for (let i = 0; i < out.length; i += 1) {
        const edge = out[i];
        if (!this.isEdgeIgnored(edge)) {
          if (this.resetEdges) {
            this.setEdgePoints(edge, null);
          }
          if (this.edgeRouting) {
            this.setEdgeStyleEnabled(edge, false);
            this.setEdgePoints(edge, null);
          }
          const state = view.getState(edge);
          const target = state != null ? state.getVisibleTerminal(this.invert) : view.getVisibleTerminal(edge, this.invert);
          const tmp = this.dfs(target, parent);
          if (tmp != null && target.getGeometry() != null) {
            if (prev == null) {
              node.child = tmp;
            } else {
              prev.next = tmp;
            }
            prev = tmp;
          }
        }
      }
    }
    return node;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  layout(node) {
    let { child } = node;
    while (child != null) {
      this.layout(child);
      child = child.next;
    }
    if (node.child != null) {
      this.attachParent(node, this.join(node));
    } else {
      this.layoutLeaf(node);
    }
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  horizontalLayout(node, x0, y0, bounds = null) {
    node.x += x0 + node.offsetX;
    node.y += y0 + node.offsetY;
    bounds = this.apply(node, bounds);
    const { child } = node;
    if (child != null) {
      bounds = this.horizontalLayout(child, node.x, node.y, bounds);
      let siblingOffset = node.y + child.offsetY;
      let s = child.next;
      while (s != null) {
        bounds = this.horizontalLayout(s, node.x + child.offsetX, siblingOffset, bounds);
        siblingOffset += s.offsetY;
        s = s.next;
      }
    }
    return bounds;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  verticalLayout(node, parent, x0, y0, bounds = null) {
    node.x = node.x + x0 + node.offsetY;
    node.y = node.y + y0 + node.offsetX;
    bounds = this.apply(node, bounds);
    const { child } = node;
    if (child != null) {
      bounds = this.verticalLayout(child, node, node.x, node.y, bounds);
      let siblingOffset = node.x + child.offsetY;
      let s = child.next;
      while (s != null) {
        bounds = this.verticalLayout(s, node, siblingOffset, node.y + child.offsetX, bounds);
        siblingOffset += s.offsetY;
        s = s.next;
      }
    }
    return bounds;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  attachParent(node, height) {
    const x = this.nodeDistance + this.levelDistance;
    const y2 = (height - node.width) / 2 - this.nodeDistance;
    const y1 = y2 + node.width + 2 * this.nodeDistance - height;
    node.child.offsetX = x + node.height;
    node.child.offsetY = y1;
    node.contour.upperHead = this.createLine(node.height, 0, this.createLine(x, y1, node.contour.upperHead));
    node.contour.lowerHead = this.createLine(node.height, 0, this.createLine(x, y2, node.contour.lowerHead));
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  // layoutLeaf(node: any): void;
  layoutLeaf(node) {
    const dist = 2 * this.nodeDistance;
    node.contour.upperTail = this.createLine(node.height + dist, 0);
    node.contour.upperHead = node.contour.upperTail;
    node.contour.lowerTail = this.createLine(0, -node.width - dist);
    node.contour.lowerHead = this.createLine(node.height + dist, 0, node.contour.lowerTail);
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  join(node) {
    const dist = 2 * this.nodeDistance;
    let { child } = node;
    node.contour = child.contour;
    let h = child.width + dist;
    let sum = h;
    child = child.next;
    while (child != null) {
      const d = this.merge(node.contour, child.contour);
      child.offsetY = d + h;
      child.offsetX = 0;
      h = child.width + dist;
      sum += d + h;
      child = child.next;
    }
    return sum;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  merge(p1, p2) {
    let x = 0;
    let y = 0;
    let total = 0;
    let upper = p1.lowerHead;
    let lower = p2.upperHead;
    while (lower != null && upper != null) {
      const d = this.offset(x, y, lower.dx, lower.dy, upper.dx, upper.dy);
      y += d;
      total += d;
      if (x + lower.dx <= upper.dx) {
        x += lower.dx;
        y += lower.dy;
        lower = lower.next;
      } else {
        x -= upper.dx;
        y -= upper.dy;
        upper = upper.next;
      }
    }
    if (lower != null) {
      const b = this.bridge(p1.upperTail, 0, 0, lower, x, y);
      p1.upperTail = b.next != null ? p2.upperTail : b;
      p1.lowerTail = p2.lowerTail;
    } else {
      const b = this.bridge(p2.lowerTail, x, y, upper, 0, 0);
      if (b.next == null) {
        p1.lowerTail = b;
      }
    }
    p1.lowerHead = p2.lowerHead;
    return total;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  // offset(p1: number, p2: number, a1: number, a2: number, b1: number, b2: number): number;
  offset(p1, p2, a1, a2, b1, b2) {
    let d = 0;
    if (b1 <= p1 || p1 + a1 <= 0) {
      return 0;
    }
    const t = b1 * a2 - a1 * b2;
    if (t > 0) {
      if (p1 < 0) {
        const s = p1 * a2;
        d = s / a1 - p2;
      } else if (p1 > 0) {
        const s = p1 * b2;
        d = s / b1 - p2;
      } else {
        d = -p2;
      }
    } else if (b1 < p1 + a1) {
      const s = (b1 - p1) * a2;
      d = b2 - (p2 + s / a1);
    } else if (b1 > p1 + a1) {
      const s = (a1 + p1) * b2;
      d = s / b1 - (p2 + a2);
    } else {
      d = b2 - (p2 + a2);
    }
    if (d > 0) {
      return d;
    }
    return 0;
  }
  bridge(line1, x1, y1, line2, x2, y2) {
    const dx = x2 + line2.dx - x1;
    let dy = 0;
    let s = 0;
    if (line2.dx === 0) {
      dy = line2.dy;
    } else {
      s = dx * line2.dy;
      dy = s / line2.dx;
    }
    const r = this.createLine(dx, dy, line2.next);
    line1.next = this.createLine(0, y2 + line2.dy - dy - y1, r);
    return r;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  createNode(cell) {
    const node = {};
    node.cell = cell;
    node.x = 0;
    node.y = 0;
    node.width = 0;
    node.height = 0;
    const geo = this.getVertexBounds(cell);
    if (geo != null) {
      if (this.isHorizontal()) {
        node.width = geo.height;
        node.height = geo.width;
      } else {
        node.width = geo.width;
        node.height = geo.height;
      }
    }
    node.offsetX = 0;
    node.offsetY = 0;
    node.contour = {};
    return node;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  apply(node, bounds = null) {
    this.graph.getDataModel();
    const cell = node.cell;
    let g = cell.getGeometry();
    if (cell != null && g != null) {
      if (this.isVertexMovable(cell)) {
        g = this.setVertexLocation(cell, node.x, node.y);
        if (this.resizeParent) {
          const parent = cell.getParent();
          const id = CellPath.create(parent);
          const parentsChanged = this.parentsChanged;
          if (parentsChanged[id] == null) {
            parentsChanged[id] = parent;
          }
        }
      }
      if (bounds == null) {
        bounds = new Rectangle(g.x, g.y, g.width, g.height);
      } else {
        bounds = new Rectangle(Math.min(bounds.x, g.x), Math.min(bounds.y, g.y), Math.max(bounds.x + bounds.width, g.x + g.width), Math.max(bounds.y + bounds.height, g.y + g.height));
      }
    }
    return bounds;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  createLine(dx, dy, next = null) {
    const line = {
      dx,
      dy,
      next
    };
    return line;
  }
  /**
   * Adjust parent cells whose child geometries have changed. The default
   * implementation adjusts the group to just fit around the children with
   * a padding.
   */
  adjustParents() {
    const tmp = [];
    for (const id in this.parentsChanged) {
      tmp.push(this.parentsChanged[id]);
    }
    this.arrangeGroups(sortCells(tmp, true), this.groupPadding, this.groupPaddingTop, this.groupPaddingRight, this.groupPaddingBottom, this.groupPaddingLeft);
  }
  /**
   * Moves the specified node and all of its children by the given amount.
   */
  localEdgeProcessing(node) {
    this.processNodeOutgoing(node);
    let { child } = node;
    while (child != null) {
      this.localEdgeProcessing(child);
      child = child.next;
    }
  }
  /**
   * Separates the x position of edges as they connect to vertices
   */
  processNodeOutgoing(node) {
    let { child } = node;
    const parentCell = node.cell;
    let childCount = 0;
    const sortedCells = [];
    while (child != null) {
      childCount++;
      let sortingCriterion;
      if (this.horizontal) {
        sortingCriterion = child.y;
      } else {
        sortingCriterion = child.x;
      }
      sortedCells.push(new WeightedCellSorter(child, sortingCriterion));
      child = child.next;
    }
    sortedCells.sort(WeightedCellSorter.compare);
    let availableWidth = node.width;
    const requiredWidth = (childCount + 1) * this.prefHozEdgeSep;
    if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {
      availableWidth -= 2 * this.prefHozEdgeSep;
    }
    const edgeSpacing = availableWidth / childCount;
    let currentXOffset = edgeSpacing / 2;
    if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {
      currentXOffset += this.prefHozEdgeSep;
    }
    let currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;
    const parentBounds = this.getVertexBounds(parentCell);
    child = node.child;
    for (let j = 0; j < sortedCells.length; j++) {
      const childCell = sortedCells[j].cell.cell;
      const childBounds = this.getVertexBounds(childCell);
      const edges = this.graph.getEdgesBetween(parentCell, childCell, false);
      const newPoints = [];
      let x = 0;
      let y = 0;
      for (let i = 0; i < edges.length; i += 1) {
        if (this.horizontal) {
          x = parentBounds.x + parentBounds.width;
          y = parentBounds.y + currentXOffset;
          newPoints.push(new Point(x, y));
          x = parentBounds.x + parentBounds.width + currentYOffset;
          newPoints.push(new Point(x, y));
          y = childBounds.y + childBounds.height / 2;
          newPoints.push(new Point(x, y));
          this.setEdgePoints(edges[i], newPoints);
        } else {
          x = parentBounds.x + currentXOffset;
          y = parentBounds.y + parentBounds.height;
          newPoints.push(new Point(x, y));
          y = parentBounds.y + parentBounds.height + currentYOffset;
          newPoints.push(new Point(x, y));
          x = childBounds.x + childBounds.width / 2;
          newPoints.push(new Point(x, y));
          this.setEdgePoints(edges[i], newPoints);
        }
      }
      if (j < childCount / 2) {
        currentYOffset += this.prefVertEdgeOff;
      } else if (j > childCount / 2) {
        currentYOffset -= this.prefVertEdgeOff;
      }
      currentXOffset += edgeSpacing;
    }
  }
}
class StackLayout extends GraphLayout {
  constructor(graph, horizontal = null, spacing = null, x0 = null, y0 = null, border = null) {
    super(graph);
    this.border = 0;
    this.marginTop = 0;
    this.marginLeft = 0;
    this.marginRight = 0;
    this.marginBottom = 0;
    this.keepFirstLocation = false;
    this.fill = false;
    this.resizeParent = false;
    this.resizeParentMax = false;
    this.resizeLast = false;
    this.wrap = null;
    this.borderCollapse = true;
    this.allowGaps = false;
    this.gridSize = 0;
    this.horizontal = horizontal != null ? horizontal : true;
    this.spacing = spacing != null ? spacing : 0;
    this.x0 = x0 != null ? x0 : 0;
    this.y0 = y0 != null ? y0 : 0;
    this.border = border != null ? border : 0;
  }
  /**
   * Returns horizontal.
   */
  isHorizontal() {
    return this.horizontal;
  }
  /**
   * Implements mxGraphLayout.moveCell.
   */
  moveCell(cell, x, y) {
    const model = this.graph.getDataModel();
    const parent = cell.getParent();
    const horizontal = this.isHorizontal();
    if (cell != null && parent != null) {
      let i = 0;
      let last = 0;
      const childCount = parent.getChildCount();
      let value = horizontal ? x : y;
      const pstate = this.graph.getView().getState(parent);
      if (pstate != null) {
        value -= horizontal ? pstate.x : pstate.y;
      }
      value /= this.graph.view.scale;
      for (i = 0; i < childCount; i += 1) {
        const child = parent.getChildAt(i);
        if (child !== cell) {
          const bounds = child.getGeometry();
          if (bounds != null) {
            const tmp = horizontal ? bounds.x + bounds.width / 2 : bounds.y + bounds.height / 2;
            if (last <= value && tmp > value) {
              break;
            }
            last = tmp;
          }
        }
      }
      let idx = parent.getIndex(cell);
      idx = Math.max(0, i - (i > idx ? 1 : 0));
      model.add(parent, cell, idx);
    }
  }
  /**
   * Returns the size for the parent container or the size of the graph container if the parent is a layer or the root of the model.
   */
  getParentSize(parent) {
    const model = this.graph.getDataModel();
    let pgeo = parent.getGeometry();
    if (this.graph.container != null && (pgeo == null && model.isLayer(parent) || parent === this.graph.getView().currentRoot)) {
      const width = this.graph.container.offsetWidth - 1;
      const height = this.graph.container.offsetHeight - 1;
      pgeo = new Geometry(0, 0, width, height);
    }
    return pgeo;
  }
  /**
   * Returns the cells to be layouted.
   */
  getLayoutCells(parent) {
    this.graph.getDataModel();
    const childCount = parent.getChildCount();
    const cells = [];
    for (let i = 0; i < childCount; i += 1) {
      const child = parent.getChildAt(i);
      if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {
        cells.push(child);
      }
    }
    if (this.allowGaps) {
      cells.sort((c1, c2) => {
        const geo1 = c1.getGeometry();
        const geo2 = c2.getGeometry();
        return this.horizontal ? geo1.x === geo2.x ? 0 : geo1.x > geo2.x && geo2.x > 0 ? 1 : -1 : geo1.y === geo2.y ? 0 : geo1.y > geo2.y && geo2.y > 0 ? 1 : -1;
      });
    }
    return cells;
  }
  /**
   * Snaps the given value to the grid size.
   */
  snap(value) {
    if (this.gridSize != null && this.gridSize > 0) {
      value = Math.max(value, this.gridSize);
      if (value / this.gridSize > 1) {
        const mod2 = value % this.gridSize;
        value += mod2 > this.gridSize / 2 ? this.gridSize - mod2 : -mod2;
      }
    }
    return value;
  }
  /**
   * Implements mxGraphLayout.execute.
   */
  execute(parent) {
    if (parent != null) {
      const pgeo = this.getParentSize(parent);
      const horizontal = this.isHorizontal();
      const model = this.graph.getDataModel();
      let fillValue = null;
      if (pgeo != null) {
        fillValue = horizontal ? pgeo.height - this.marginTop - this.marginBottom : pgeo.width - this.marginLeft - this.marginRight;
        fillValue -= 2 * this.border;
      }
      let x0 = this.x0 + this.border + this.marginLeft;
      let y0 = this.y0 + this.border + this.marginTop;
      if (this.graph.isSwimlane(parent)) {
        const style = this.graph.getCellStyle(parent);
        let start = style.startSize ?? DEFAULT_STARTSIZE;
        const horz = style.horizontal ?? true;
        if (pgeo != null) {
          if (horz) {
            start = Math.min(start, pgeo.height);
          } else {
            start = Math.min(start, pgeo.width);
          }
        }
        if (horizontal === horz && fillValue != null) {
          fillValue -= start;
        }
        if (horz) {
          y0 += start;
        } else {
          x0 += start;
        }
      }
      model.beginUpdate();
      try {
        let tmp = 0;
        let last = null;
        let lastValue = 0;
        let lastChild = null;
        const cells = this.getLayoutCells(parent);
        for (let i = 0; i < cells.length; i += 1) {
          const child = cells[i];
          let geo = child.getGeometry();
          if (geo != null) {
            geo = geo.clone();
            if (this.wrap != null && last != null) {
              if (horizontal && last.x + last.width + geo.width + 2 * this.spacing > this.wrap || !horizontal && last.y + last.height + geo.height + 2 * this.spacing > this.wrap) {
                last = null;
                if (horizontal) {
                  y0 += tmp + this.spacing;
                } else {
                  x0 += tmp + this.spacing;
                }
                tmp = 0;
              }
            }
            tmp = Math.max(tmp, horizontal ? geo.height : geo.width);
            let sw = 0;
            if (!this.borderCollapse) {
              const childStyle = this.graph.getCellStyle(child);
              sw = childStyle.strokeWidth ?? 1;
            }
            if (last != null) {
              const temp = lastValue + this.spacing + Math.floor(sw / 2);
              if (horizontal) {
                geo.x = this.snap((this.allowGaps ? Math.max(temp, geo.x) : temp) - this.marginLeft) + this.marginLeft;
              } else {
                geo.y = this.snap((this.allowGaps ? Math.max(temp, geo.y) : temp) - this.marginTop) + this.marginTop;
              }
            } else if (!this.keepFirstLocation) {
              if (horizontal) {
                geo.x = this.allowGaps && geo.x > x0 ? Math.max(this.snap(geo.x - this.marginLeft) + this.marginLeft, x0) : x0;
              } else {
                geo.y = this.allowGaps && geo.y > y0 ? Math.max(this.snap(geo.y - this.marginTop) + this.marginTop, y0) : y0;
              }
            }
            if (horizontal) {
              geo.y = y0;
            } else {
              geo.x = x0;
            }
            if (this.fill && fillValue != null) {
              if (horizontal) {
                geo.height = fillValue;
              } else {
                geo.width = fillValue;
              }
            }
            if (horizontal) {
              geo.width = this.snap(geo.width);
            } else {
              geo.height = this.snap(geo.height);
            }
            this.setChildGeometry(child, geo);
            lastChild = child;
            last = geo;
            if (horizontal) {
              lastValue = last.x + last.width + Math.floor(sw / 2);
            } else {
              lastValue = last.y + last.height + Math.floor(sw / 2);
            }
          }
        }
        if (this.resizeParent && pgeo != null && last != null && !parent.isCollapsed()) {
          this.updateParentGeometry(parent, pgeo, last);
        } else if (this.resizeLast && pgeo != null && last != null && lastChild != null) {
          if (horizontal) {
            last.width = pgeo.width - last.x - this.spacing - this.marginRight - this.marginLeft;
          } else {
            last.height = pgeo.height - last.y - this.spacing - this.marginBottom;
          }
          this.setChildGeometry(lastChild, last);
        }
      } finally {
        model.endUpdate();
      }
    }
  }
  /**
   * Sets the specific geometry to the given child cell.
   *
   * @param child The given child of <Cell>.
   * @param geo The specific geometry of {@link Geometry}.
   */
  setChildGeometry(child, geo) {
    const geo2 = child.getGeometry();
    if (geo2 == null || geo.x !== geo2.x || geo.y !== geo2.y || geo.width !== geo2.width || geo.height !== geo2.height) {
      this.graph.getDataModel().setGeometry(child, geo);
    }
  }
  /**
   * Updates the geometry of the given parent cell.
   *
   * @param parent The given parent of <Cell>.
   * @param pgeo The new {@link Geometry} for parent.
   * @param last The last {@link Geometry}.
   */
  updateParentGeometry(parent, pgeo, last) {
    const horizontal = this.isHorizontal();
    const model = this.graph.getDataModel();
    const pgeo2 = pgeo.clone();
    if (horizontal) {
      const tmp = last.x + last.width + this.marginRight + this.border;
      if (this.resizeParentMax) {
        pgeo2.width = Math.max(pgeo2.width, tmp);
      } else {
        pgeo2.width = tmp;
      }
    } else {
      const tmp = last.y + last.height + this.marginBottom + this.border;
      if (this.resizeParentMax) {
        pgeo2.height = Math.max(pgeo2.height, tmp);
      } else {
        pgeo2.height = tmp;
      }
    }
    if (pgeo.x !== pgeo2.x || pgeo.y !== pgeo2.y || pgeo.width !== pgeo2.width || pgeo.height !== pgeo2.height) {
      model.setGeometry(parent, pgeo2);
    }
  }
}
class CellCodec extends ObjectCodec {
  constructor() {
    super(new Cell(), ["children", "edges", "overlays", "mxTransient"], ["parent", "source", "target"]);
    this.setName("Cell");
  }
  /**
   * Returns `true` since this is a cell codec.
   */
  isCellCodec() {
    return true;
  }
  /**
   * Overridden to disable conversion of value to number.
   */
  isNumericAttribute(dec, attr, obj) {
    return attr.nodeName !== "value" && super.isNumericAttribute(dec, attr, obj);
  }
  /**
   * Excludes user objects that are XML nodes.
   */
  isExcluded(obj, attr, value, isWrite) {
    return super.isExcluded(obj, attr, value, isWrite) || isWrite && attr === "value" && isElement(value);
  }
  /**
   * Encodes a {@link Cell} and wraps the XML up inside the XML of the user object (inversion).
   */
  afterEncode(enc, obj, node) {
    if (isElement(obj.value)) {
      const tmp = node;
      node = importNode(enc.document, obj.value, true);
      node.appendChild(tmp);
      const id = tmp.getAttribute("id");
      node.setAttribute("id", String(id));
      tmp.removeAttribute("id");
    }
    return node;
  }
  /**
   * Decodes an {@link Cell} and uses the enclosing XML node as the user object for the cell (inversion).
   */
  beforeDecode(dec, node, obj) {
    let inner = node.cloneNode(true);
    const classname = this.getName();
    if (node.nodeName !== classname) {
      const tmp = node.getElementsByTagName(classname)[0];
      if (tmp != null && tmp.parentNode === node) {
        removeWhitespace(tmp, true);
        removeWhitespace(tmp, false);
        tmp.parentNode.removeChild(tmp);
        inner = tmp;
      } else {
        inner = null;
      }
      obj.value = node.cloneNode(true);
      const id = obj.value.getAttribute("id");
      if (id != null) {
        obj.setId(id);
        obj.value.removeAttribute("id");
      }
    } else {
      obj.setId(node.getAttribute("id"));
    }
    if (inner != null) {
      for (let i = 0; i < this.idrefs.length; i += 1) {
        const attr = this.idrefs[i];
        const ref = inner.getAttribute(attr);
        if (ref != null) {
          inner.removeAttribute(attr);
          let object = dec.objects[ref] || dec.lookup(ref);
          if (object == null) {
            const element = dec.getElementById(ref);
            if (element != null) {
              const decoder = CodecRegistry.codecs[element.nodeName] || this;
              object = decoder.decode(dec, element);
            }
          }
          obj[attr] = object;
        }
      }
    }
    return inner;
  }
}
class ModelCodec extends ObjectCodec {
  constructor() {
    super(new GraphDataModel());
    this.setName("GraphDataModel");
  }
  /**
   * Encodes the given {@link GraphDataModel} by writing a (flat) XML sequence of cell nodes as produced by the {@link CellCodec}.
   * The sequence is wrapped-up in a node with the name `root`.
   */
  encodeObject(enc, obj, node) {
    const rootNode = enc.document.createElement("root");
    enc.encodeCell(obj.getRoot(), rootNode);
    node.appendChild(rootNode);
  }
  /**
   * Overrides decode child to handle special child nodes.
   */
  decodeChild(dec, child, obj) {
    if (child.nodeName === "root") {
      this.decodeRoot(dec, child, obj);
    } else {
      this.decodeChild.apply(this, [dec, child, obj]);
    }
  }
  /**
   * Reads the cells into the graph model. All cells are children of the root element in the node.
   */
  decodeRoot(dec, root, model) {
    let rootCell = null;
    let tmp = root.firstChild;
    while (tmp != null) {
      const cell = dec.decodeCell(tmp);
      if (cell != null && cell.getParent() == null) {
        rootCell = cell;
      }
      tmp = tmp.nextSibling;
    }
    if (rootCell != null) {
      model.setRoot(rootCell);
    }
  }
}
const fieldMapping = /* @__PURE__ */ new Map([["autosize", "autoSize"]]);
function convertStyleFromString(input) {
  const style = {};
  input.startsWith(";") && (style.ignoreDefaultStyle = true);
  const elements = input.split(";").filter(([k]) => k);
  for (const element of elements) {
    if (!element.includes("=")) {
      !style.baseStyleNames && (style.baseStyleNames = []);
      style.baseStyleNames.push(element);
    } else {
      const [key, value] = element.split("=");
      style[fieldMapping.get(key) ?? key] = convertToNumericIfNeeded(value);
    }
  }
  return style;
}
function convertToNumericIfNeeded(value) {
  if (!isNumeric(value)) {
    return value;
  }
  let numericValue = parseFloat(value);
  if (Number.isNaN(numericValue) || !Number.isFinite(numericValue)) {
    numericValue = 0;
  }
  return numericValue;
}
class mxCellCodec extends CellCodec {
  getName() {
    return "mxCell";
  }
  decodeAttribute(dec, attr, obj) {
    const attributeNodeName = attr.nodeName;
    if (obj && attributeNodeName == "style") {
      obj["style"] = convertStyleFromString(attr.value);
    } else {
      super.decodeAttribute(dec, attr, obj);
    }
  }
}
class mxGeometryCodec extends ObjectCodec {
  getName() {
    return "mxGeometry";
  }
  constructor() {
    super(new Geometry());
  }
  afterDecode(dec, node, obj) {
    const originalPoints = obj.points;
    if (originalPoints) {
      const points = [];
      for (const pointInput of originalPoints) {
        const rawPoint = pointInput;
        points.push(new Point(rawPoint.x, rawPoint.y));
      }
      obj.points = points;
    }
    return obj;
  }
}
let isBaseCodecsRegistered = false;
const registerBaseCodecs = (force = false) => {
  if (!isBaseCodecsRegistered || force) {
    CodecRegistry.register(new ObjectCodec({}));
    CodecRegistry.register(new ObjectCodec([]));
    isBaseCodecsRegistered = true;
  }
};
const createObjectCodec = (template, name) => {
  const objectCodec = new ObjectCodec(template);
  objectCodec.setName(name);
  return objectCodec;
};
let isModelCodecsRegistered = false;
const registerModelCodecs = (force = false) => {
  if (!isModelCodecsRegistered || force) {
    CodecRegistry.register(new CellCodec());
    CodecRegistry.register(new ModelCodec());
    CodecRegistry.register(createObjectCodec(new Geometry(), "Geometry"));
    CodecRegistry.register(createObjectCodec(new Point(), "Point"));
    registerBaseCodecs(force);
    CodecRegistry.addAlias("mxGraphModel", "GraphDataModel");
    CodecRegistry.addAlias("mxPoint", "Point");
    CodecRegistry.register(new mxCellCodec(), false);
    CodecRegistry.register(new mxGeometryCodec(), false);
    isModelCodecsRegistered = true;
  }
};
class ModelXmlSerializer {
  constructor(dataModel) {
    this.dataModel = dataModel;
    this.registerCodecs();
  }
  import(input) {
    const doc = typeof input === "string" ? parseXml(input) : input.ownerDocument;
    new Codec(doc).decode(doc.documentElement, this.dataModel);
  }
  export(options) {
    const encodedNode = new Codec().encode(this.dataModel);
    return (options == null ? void 0 : options.pretty) ?? true ? getPrettyXml(encodedNode) : getXml(encodedNode);
  }
  /**
   * Hook for replacing codecs registered by default (model codecs).
   */
  registerCodecs() {
    registerModelCodecs();
  }
}
let activeWindow = null;
class MaxWindow extends EventSource {
  constructor(title, content, x, y, width = null, height = null, minimizable = true, movable = true, replaceNode = null, style) {
    super();
    this.closeImage = `${Client.imageBasePath}/close.gif`;
    this.minimizeImage = `${Client.imageBasePath}/minimize.gif`;
    this.normalizeImage = `${Client.imageBasePath}/normalize.gif`;
    this.maximizeImage = `${Client.imageBasePath}/maximize.gif`;
    this.resizeImage = `${Client.imageBasePath}/resize.gif`;
    this.visible = false;
    this.minimumSize = new Rectangle(0, 0, 50, 40);
    this.destroyOnClose = true;
    if (content != null) {
      this.content = content;
      this.init(x, y, width, height, style);
      this.installMaximizeHandler();
      this.installMinimizeHandler();
      this.installCloseHandler();
      this.setMinimizable(minimizable);
      this.setTitle(title);
      if (movable) {
        this.installMoveHandler();
      }
      if (replaceNode != null && replaceNode.parentNode != null) {
        replaceNode.parentNode.replaceChild(this.div, replaceNode);
      } else {
        document.body.appendChild(this.div);
      }
    }
  }
  /**
   * Initializes the DOM tree that represents the window.
   */
  init(x, y, width = null, height = null, style = "mxWindow") {
    this.div = document.createElement("div");
    this.div.className = style;
    this.div.style.left = `${x}px`;
    this.div.style.top = `${y}px`;
    this.table = document.createElement("table");
    this.table.className = style;
    if (Client.IS_POINTER) {
      this.div.style.touchAction = "none";
    }
    if (width != null) {
      this.div.style.width = `${width}px`;
      this.table.style.width = `${width}px`;
    }
    if (height != null) {
      this.div.style.height = `${height}px`;
      this.table.style.height = `${height}px`;
    }
    const tbody = document.createElement("tbody");
    let tr = document.createElement("tr");
    this.title = document.createElement("td");
    this.title.className = `${style}Title`;
    this.buttons = document.createElement("div");
    this.buttons.style.position = "absolute";
    this.buttons.style.display = "inline-block";
    this.buttons.style.right = "4px";
    this.buttons.style.top = "5px";
    this.title.appendChild(this.buttons);
    tr.appendChild(this.title);
    tbody.appendChild(tr);
    tr = document.createElement("tr");
    this.td = document.createElement("td");
    this.td.className = `${style}Pane`;
    this.contentWrapper = document.createElement("div");
    this.contentWrapper.className = `${style}Pane`;
    this.contentWrapper.style.width = "100%";
    this.contentWrapper.appendChild(this.content);
    if (this.content.nodeName.toUpperCase() !== "DIV") {
      this.contentWrapper.style.height = "100%";
    }
    this.td.appendChild(this.contentWrapper);
    tr.appendChild(this.td);
    tbody.appendChild(tr);
    this.table.appendChild(tbody);
    this.div.appendChild(this.table);
    const activator = (evt) => {
      this.activate();
    };
    InternalEvent.addGestureListeners(this.title, activator);
    InternalEvent.addGestureListeners(this.table, activator);
    this.hide();
  }
  /**
   * Sets the window title to the given string. HTML markup inside the title
   * will be escaped.
   */
  setTitle(title) {
    let child = this.title.firstChild;
    while (child != null) {
      const next = child.nextSibling;
      if (child.nodeType === NODETYPE.TEXT) {
        child.parentNode.removeChild(child);
      }
      child = next;
    }
    write(this.title, title || "");
    this.title.appendChild(this.buttons);
  }
  /**
   * Sets if the window contents should be scrollable.
   */
  setScrollable(scrollable) {
    if (navigator.userAgent == null || navigator.userAgent.indexOf("Presto/2.5") < 0) {
      if (scrollable) {
        this.contentWrapper.style.overflow = "auto";
      } else {
        this.contentWrapper.style.overflow = "hidden";
      }
    }
  }
  /**
   * Puts the window on top of all other windows.
   */
  activate() {
    if (activeWindow !== this) {
      const style = getCurrentStyle(this.getElement());
      const index = style != null ? parseInt(style.zIndex) : 3;
      if (activeWindow) {
        const elt = activeWindow.getElement();
        if (elt == null ? void 0 : elt.style) {
          elt.style.zIndex = String(index);
        }
      }
      const previousWindow = activeWindow;
      this.getElement().style.zIndex = String(index + 1);
      activeWindow = this;
      this.fireEvent(new EventObject(InternalEvent.ACTIVATE, { previousWindow }));
    }
  }
  /**
   * Returuns the outermost DOM node that makes up the window.
   */
  getElement() {
    return this.div;
  }
  /**
   * Makes sure the window is inside the client area of the window.
   */
  fit() {
    fit(this.div);
  }
  /**
   * Returns true if the window is resizable.
   */
  isResizable() {
    if (this.resize != null) {
      return this.resize.style.display !== "none";
    }
    return false;
  }
  /**
   * Sets if the window should be resizable. To avoid interference with some
   * built-in features of IE10 and later, the use of the following code is
   * recommended if there are resizable <MaxWindow>s in the page:
   *
   * ```javascript
   * if (Client.IS_POINTER)
   * {
   *   document.body.style.msTouchAction = 'none';
   * }
   * ```
   */
  setResizable(resizable) {
    if (resizable) {
      if (this.resize == null) {
        this.resize = document.createElement("img");
        this.resize.style.position = "absolute";
        this.resize.style.bottom = "2px";
        this.resize.style.right = "2px";
        this.resize.setAttribute("src", this.resizeImage);
        this.resize.style.cursor = "nw-resize";
        let startX = null;
        let startY = null;
        let width = null;
        let height = null;
        const start = (evt) => {
          this.activate();
          startX = getClientX(evt);
          startY = getClientY(evt);
          width = this.div.offsetWidth;
          height = this.div.offsetHeight;
          InternalEvent.addGestureListeners(document, null, dragHandler, dropHandler);
          this.fireEvent(new EventObject(InternalEvent.RESIZE_START, { event: evt }));
          InternalEvent.consume(evt);
        };
        const dragHandler = (evt) => {
          if (startX != null && startY != null) {
            const dx = getClientX(evt) - startX;
            const dy = getClientY(evt) - startY;
            if (width != null && height != null) {
              this.setSize(width + dx, height + dy);
            }
            this.fireEvent(new EventObject(InternalEvent.RESIZE, { event: evt }));
            InternalEvent.consume(evt);
          }
        };
        const dropHandler = (evt) => {
          if (startX != null && startY != null) {
            startX = null;
            startY = null;
            InternalEvent.removeGestureListeners(document, null, dragHandler, dropHandler);
            this.fireEvent(new EventObject(InternalEvent.RESIZE_END, { event: evt }));
            InternalEvent.consume(evt);
          }
        };
        InternalEvent.addGestureListeners(this.resize, start, dragHandler, dropHandler);
        this.div.appendChild(this.resize);
      } else {
        this.resize.style.display = "inline";
      }
    } else if (this.resize != null) {
      this.resize.style.display = "none";
    }
  }
  /**
   * Sets the size of the window.
   */
  setSize(width, height) {
    width = Math.max(this.minimumSize.width, width);
    height = Math.max(this.minimumSize.height, height);
    this.div.style.width = `${width}px`;
    this.div.style.height = `${height}px`;
    this.table.style.width = `${width}px`;
    this.table.style.height = `${height}px`;
    this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;
  }
  /**
   * Sets if the window is minimizable.
   */
  setMinimizable(minimizable) {
    this.minimize.style.display = minimizable ? "" : "none";
  }
  /**
   * Returns an {@link Rectangle} that specifies the size for the minimized window.
   * A width or height of 0 means keep the existing width or height. This
   * implementation returns the height of the window title and keeps the width.
   */
  getMinimumSize() {
    return new Rectangle(0, 0, 0, this.title.offsetHeight);
  }
  /**
   * Installs the event listeners required for minimizing the window.
   */
  installMinimizeHandler() {
    this.minimize = document.createElement("img");
    this.minimize.setAttribute("src", this.minimizeImage);
    this.minimize.setAttribute("title", "Minimize");
    this.minimize.style.cursor = "pointer";
    this.minimize.style.marginLeft = "2px";
    this.minimize.style.display = "none";
    this.buttons.appendChild(this.minimize);
    let minimized = false;
    let maxDisplay = null;
    let height = null;
    const funct = (evt) => {
      this.activate();
      if (!minimized) {
        minimized = true;
        this.minimize.setAttribute("src", this.normalizeImage);
        this.minimize.setAttribute("title", "Normalize");
        this.contentWrapper.style.display = "none";
        maxDisplay = this.maximize.style.display;
        this.maximize.style.display = "none";
        height = this.table.style.height;
        const minSize = this.getMinimumSize();
        if (minSize.height > 0) {
          this.div.style.height = `${minSize.height}px`;
          this.table.style.height = `${minSize.height}px`;
        }
        if (minSize.width > 0) {
          this.div.style.width = `${minSize.width}px`;
          this.table.style.width = `${minSize.width}px`;
        }
        if (this.resize != null) {
          this.resize.style.visibility = "hidden";
        }
        this.fireEvent(new EventObject(InternalEvent.MINIMIZE, { event: evt }));
      } else {
        minimized = false;
        this.minimize.setAttribute("src", this.minimizeImage);
        this.minimize.setAttribute("title", "Minimize");
        this.contentWrapper.style.display = "";
        if (maxDisplay != null && height != null) {
          this.maximize.style.display = maxDisplay;
          this.div.style.height = height;
          this.table.style.height = height;
        }
        if (this.resize != null) {
          this.resize.style.visibility = "";
        }
        this.fireEvent(new EventObject(InternalEvent.NORMALIZE, { event: evt }));
      }
      InternalEvent.consume(evt);
    };
    InternalEvent.addGestureListeners(this.minimize, funct);
  }
  /**
   * Sets if the window is maximizable.
   */
  setMaximizable(maximizable) {
    this.maximize.style.display = maximizable ? "" : "none";
  }
  /**
   * Installs the event listeners required for maximizing the window.
   */
  installMaximizeHandler() {
    this.maximize = document.createElement("img");
    this.maximize.setAttribute("src", this.maximizeImage);
    this.maximize.setAttribute("title", "Maximize");
    this.maximize.style.cursor = "default";
    this.maximize.style.marginLeft = "2px";
    this.maximize.style.cursor = "pointer";
    this.maximize.style.display = "none";
    this.buttons.appendChild(this.maximize);
    let maximized = false;
    let x = null;
    let y = null;
    let height = null;
    let width = null;
    let minDisplay = null;
    const funct = (evt) => {
      this.activate();
      if (this.maximize.style.display !== "none") {
        if (!maximized) {
          maximized = true;
          this.maximize.setAttribute("src", this.normalizeImage);
          this.maximize.setAttribute("title", "Normalize");
          this.contentWrapper.style.display = "";
          minDisplay = this.minimize.style.display;
          this.minimize.style.display = "none";
          x = parseInt(this.div.style.left);
          y = parseInt(this.div.style.top);
          height = this.table.style.height;
          width = this.table.style.width;
          this.div.style.left = "0px";
          this.div.style.top = "0px";
          const docHeight = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight || 0);
          this.div.style.width = `${document.body.clientWidth - 2}px`;
          this.div.style.height = `${docHeight - 2}px`;
          this.table.style.width = `${document.body.clientWidth - 2}px`;
          this.table.style.height = `${docHeight - 2}px`;
          if (this.resize != null) {
            this.resize.style.visibility = "hidden";
          }
          const style = getCurrentStyle(this.contentWrapper);
          if (style.overflow === "auto" || this.resize != null) {
            this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;
          }
          this.fireEvent(new EventObject(InternalEvent.MAXIMIZE, { event: evt }));
        } else {
          maximized = false;
          this.maximize.setAttribute("src", this.maximizeImage);
          this.maximize.setAttribute("title", "Maximize");
          this.contentWrapper.style.display = "";
          if (minDisplay != null) {
            this.minimize.style.display = minDisplay;
          }
          this.div.style.left = `${x}px`;
          this.div.style.top = `${y}px`;
          if (width != null && height != null) {
            this.div.style.height = height;
            this.div.style.width = width;
          }
          const style = getCurrentStyle(this.contentWrapper);
          if (style.overflow === "auto" || this.resize != null) {
            this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;
          }
          if (width != null && height != null) {
            this.table.style.height = height;
            this.table.style.width = width;
          }
          if (this.resize != null) {
            this.resize.style.visibility = "";
          }
          this.fireEvent(new EventObject(InternalEvent.NORMALIZE, { event: evt }));
        }
        InternalEvent.consume(evt);
      }
    };
    InternalEvent.addGestureListeners(this.maximize, funct);
    InternalEvent.addListener(this.title, "dblclick", funct);
  }
  /**
   * Installs the event listeners required for moving the window.
   */
  installMoveHandler() {
    this.title.style.cursor = "move";
    InternalEvent.addGestureListeners(this.title, (evt) => {
      const startX = getClientX(evt);
      const startY = getClientY(evt);
      const x = this.getX();
      const y = this.getY();
      const dragHandler = (evt2) => {
        const dx = getClientX(evt2) - startX;
        const dy = getClientY(evt2) - startY;
        this.setLocation(x + dx, y + dy);
        this.fireEvent(new EventObject(InternalEvent.MOVE, { event: evt2 }));
        InternalEvent.consume(evt2);
      };
      const dropHandler = (evt2) => {
        InternalEvent.removeGestureListeners(document, null, dragHandler, dropHandler);
        this.fireEvent(new EventObject(InternalEvent.MOVE_END, { event: evt2 }));
        InternalEvent.consume(evt2);
      };
      InternalEvent.addGestureListeners(document, null, dragHandler, dropHandler);
      this.fireEvent(new EventObject(InternalEvent.MOVE_START, { event: evt }));
      InternalEvent.consume(evt);
    });
    if (Client.IS_POINTER) {
      this.title.style.touchAction = "none";
    }
  }
  /**
   * Sets the upper, left corner of the window.
   */
  setLocation(x, y) {
    this.div.style.left = `${x}px`;
    this.div.style.top = `${y}px`;
  }
  /**
   * Returns the current position on the x-axis.
   */
  getX() {
    return parseInt(this.div.style.left);
  }
  /**
   * Returns the current position on the y-axis.
   */
  getY() {
    return parseInt(this.div.style.top);
  }
  /**
   * Adds the <closeImage> as a new image node in <closeImg> and installs the
   * <close> event.
   */
  installCloseHandler() {
    this.closeImg = document.createElement("img");
    this.closeImg.setAttribute("src", this.closeImage);
    this.closeImg.setAttribute("title", "Close");
    this.closeImg.style.marginLeft = "2px";
    this.closeImg.style.cursor = "pointer";
    this.closeImg.style.display = "none";
    this.buttons.appendChild(this.closeImg);
    InternalEvent.addGestureListeners(this.closeImg, (evt) => {
      this.fireEvent(new EventObject(InternalEvent.CLOSE, { event: evt }));
      if (this.destroyOnClose) {
        this.destroy();
      } else {
        this.setVisible(false);
      }
      InternalEvent.consume(evt);
    });
  }
  /**
   * Sets the image associated with the window.
   *
   *
   * @param image - URL of the image to be used.
   */
  setImage(image) {
    this.image = document.createElement("img");
    this.image.setAttribute("src", image);
    this.image.setAttribute("align", "left");
    this.image.style.marginRight = "4px";
    this.image.style.marginLeft = "0px";
    this.image.style.marginTop = "-2px";
    this.title.insertBefore(this.image, this.title.firstChild);
  }
  /**
   * Sets the image associated with the window.
   *
   *
   * @param closable - Boolean specifying if the window should be closable.
   */
  setClosable(closable) {
    this.closeImg.style.display = closable ? "" : "none";
  }
  /**
   * Returns true if the window is visible.
   */
  isVisible() {
    if (this.div != null) {
      return this.div.style.display !== "none";
    }
    return false;
  }
  /**
   * Shows or hides the window depending on the given flag.
   *
   *
   * @param visible - Boolean indicating if the window should be made visible.
   */
  setVisible(visible) {
    if (this.div != null && this.isVisible() !== visible) {
      if (visible) {
        this.show();
      } else {
        this.hide();
      }
    }
  }
  /**
   * Shows the window.
   */
  show() {
    this.div.style.display = "";
    this.activate();
    const style = getCurrentStyle(this.contentWrapper);
    if ((style.overflow == "auto" || this.resize != null) && this.contentWrapper.style.display != "none") {
      this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;
    }
    this.fireEvent(new EventObject(InternalEvent.SHOW));
  }
  /**
   * Hides the window.
   */
  hide() {
    this.div.style.display = "none";
    this.fireEvent(new EventObject(InternalEvent.HIDE));
  }
  /**
   * Destroys the window and removes all associated resources. Fires a
   * <destroy> event prior to destroying the window.
   */
  destroy() {
    this.fireEvent(new EventObject(InternalEvent.DESTROY));
    if (this.div != null) {
      InternalEvent.release(this.div);
      this.div.parentNode.removeChild(this.div);
      this.div = null;
    }
    this.title = null;
    this.content = null;
    this.contentWrapper = null;
  }
}
class MaxForm {
  constructor(className) {
    this.table = document.createElement("table");
    this.table.className = className;
    this.body = document.createElement("tbody");
    this.table.appendChild(this.body);
  }
  /**
   * Returns the table that contains this form.
   */
  getTable() {
    return this.table;
  }
  /**
   * Helper method to add an OK and Cancel button using the respective
   * functions.
   */
  addButtons(okFunct, cancelFunct) {
    const tr = document.createElement("tr");
    let td = document.createElement("td");
    tr.appendChild(td);
    td = document.createElement("td");
    let button2 = document.createElement("button");
    write(button2, translate("ok") || "OK");
    td.appendChild(button2);
    InternalEvent.addListener(button2, "click", () => {
      okFunct();
    });
    button2 = document.createElement("button");
    write(button2, translate("cancel") || "Cancel");
    td.appendChild(button2);
    InternalEvent.addListener(button2, "click", () => {
      cancelFunct();
    });
    tr.appendChild(td);
    this.body.appendChild(tr);
  }
  /**
   * Adds an input for the given name, type and value and returns it.
   */
  addText(name, value, type = "text") {
    const input = document.createElement("input");
    input.setAttribute("type", type);
    input.value = value;
    return this.addField(name, input);
  }
  /**
   * Adds a checkbox for the given name and value and returns the textfield.
   */
  addCheckbox(name, value) {
    const input = document.createElement("input");
    input.setAttribute("type", "checkbox");
    this.addField(name, input);
    if (value) {
      input.checked = true;
    }
    return input;
  }
  /**
   * Adds a textarea for the given name and value and returns the textarea.
   */
  addTextarea(name, value, rows) {
    const input = document.createElement("textarea");
    if (Client.IS_NS) {
      rows--;
    }
    input.setAttribute("rows", String(rows || 2));
    input.value = value;
    return this.addField(name, input);
  }
  /**
   * Adds a combo for the given name and returns the combo.
   */
  addCombo(name, isMultiSelect, size) {
    const select = document.createElement("select");
    if (size != null) {
      select.setAttribute("size", String(size));
    }
    if (isMultiSelect) {
      select.setAttribute("multiple", "true");
    }
    return this.addField(name, select);
  }
  /**
   * Adds an option for the given label to the specified combo.
   */
  addOption(combo, label, value, isSelected) {
    const option = document.createElement("option");
    writeln(option, label);
    option.setAttribute("value", value);
    if (isSelected) {
      option.setAttribute("selected", String(isSelected));
    }
    combo.appendChild(option);
  }
  /**
   * Adds a new row with the name and the input field in two columns and
   * returns the given input.
   */
  addField(name, input) {
    const tr = document.createElement("tr");
    let td = document.createElement("td");
    write(td, name);
    tr.appendChild(td);
    td = document.createElement("td");
    td.appendChild(input);
    tr.appendChild(td);
    this.body.appendChild(tr);
    return input;
  }
}
class Clipboard {
  /**
   * Sets the cells in the clipboard. Fires a {@link InternalEvent.CHANGE} event.
   */
  static setCells(cells) {
    Clipboard.cells = cells;
  }
  /**
   * Returns the cells in the clipboard.
   */
  static getCells() {
    return Clipboard.cells;
  }
  /**
   * Returns `true` if the clipboard currently has no data stored.
   */
  static isEmpty() {
    return !Clipboard.getCells();
  }
  /**
   * Cuts the given array of {@link Cell} from the specified graph.
   * If {@link cells} is `null` then the selection cells of the graph will be used.
   *
   * @param graph - {@link graph} that contains the cells to be cut.
   * @param cells - Optional array of {@link Cell} to be cut.
   * @returns Returns the cells that have been cut from the graph.
   */
  static cut(graph, cells = []) {
    cells = Clipboard.copy(graph, cells);
    Clipboard.insertCount = 0;
    Clipboard.removeCells(graph, cells);
    return cells;
  }
  /**
   * Hook to remove the given cells from the given graph after a cut operation.
   *
   * @param graph - {@link graph} that contains the cells to be cut.
   * @param cells - Array of {@link Cell} to be cut.
   */
  static removeCells(graph, cells) {
    graph.removeCells(cells);
  }
  /**
   * Copies the given array of {@link Cell} from the specified graph to {@link cells}.
   * Returns the original array of cells that has been cloned.
   * Descendants of cells in the array are ignored.
   *
   * @param graph - {@link graph} that contains the cells to be copied.
   * @param cells - Optional array of {@link Cell} to be copied.
   */
  static copy(graph, cells) {
    cells = cells || graph.getSelectionCells();
    const result = getTopmostCells(graph.getExportableCells(cells));
    Clipboard.insertCount = 1;
    Clipboard.setCells(graph.cloneCells(result));
    return result;
  }
  /**
   * Pastes the {@link Cell}s into the specified graph associating them to the default parent.
   * The cells are added to the graph using {@link graph.importCells} and returned.
   *
   * @param graph - {@link Graph} to paste the {@link Cell}s into.
   */
  static paste(graph) {
    let cells = null;
    if (!Clipboard.isEmpty() && Clipboard.getCells()) {
      cells = graph.getImportableCells(Clipboard.getCells());
      const delta = Clipboard.insertCount * Clipboard.STEPSIZE;
      const parent = graph.getDefaultParent();
      cells = graph.importCells(cells, delta, delta, parent);
      Clipboard.insertCount++;
      graph.setSelectionCells(cells);
    }
    return cells;
  }
}
Clipboard.STEPSIZE = 10;
Clipboard.insertCount = 1;
const popup = (content, isInternalWindow = false) => {
  if (isInternalWindow) {
    const div = document.createElement("div");
    div.style.overflow = "scroll";
    div.style.width = "636px";
    div.style.height = "460px";
    const pre = document.createElement("pre");
    pre.innerHTML = htmlEntities(content, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
    div.appendChild(pre);
    const w = document.body.clientWidth;
    const h = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight);
    const wnd = new MaxWindow("Popup Window", div, w / 2 - 320, h / 2 - 240, 640, 480, false, true);
    wnd.setClosable(true);
    wnd.setVisible(true);
  } else {
    if (Client.IS_NS) {
      const wnd = window.open();
      if (!wnd) {
        throw new Error("Permission not granted to open popup window");
      }
      wnd.document.writeln(`<pre>${htmlEntities(content)}</pre>`);
      wnd.document.close();
    } else {
      const wnd = window.open();
      if (!wnd) {
        throw new Error("Permission not granted to open popup window");
      }
      const pre = wnd.document.createElement("pre");
      pre.innerHTML = htmlEntities(content, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
      wnd.document.body.appendChild(pre);
    }
  }
};
const error = (message, width, close, icon = null) => {
  const div = document.createElement("div");
  div.style.padding = "20px";
  const img = document.createElement("img");
  img.setAttribute("src", icon || GuiConfig.errorImage);
  img.setAttribute("valign", "bottom");
  img.style.verticalAlign = "middle";
  div.appendChild(img);
  div.appendChild(document.createTextNode(""));
  div.appendChild(document.createTextNode(""));
  div.appendChild(document.createTextNode(""));
  write(div, message);
  const w = document.body.clientWidth;
  const h = document.body.clientHeight || document.documentElement.clientHeight;
  const warn = new MaxWindow(translate(GuiConfig.errorResource) || GuiConfig.errorResource, div, (w - width) / 2, h / 4, width, null, false, true);
  if (close) {
    br(div);
    const tmp = document.createElement("p");
    const button2 = document.createElement("button");
    button2.setAttribute("style", "float:right");
    InternalEvent.addListener(button2, "click", (evt) => {
      warn.destroy();
    });
    write(button2, translate(GuiConfig.closeResource) || GuiConfig.closeResource);
    tmp.appendChild(button2);
    div.appendChild(tmp);
    br(div);
    warn.setClosable(true);
  }
  warn.setVisible(true);
  return warn;
};
const GuiConfig = {
  /*
   * Specifies the resource key for the title of the error window. If the
   * resource for this key does not exist then the value is used as
   * the title. Default is 'error'.
   */
  errorResource: "error",
  /**
   * Specifies the resource key for the label of the close button. If the
   * resource for this key does not exist then the value is used as
   * the label. Default is 'close'.
   */
  closeResource: "close",
  /**
   * Defines the image used for error dialogs.
   */
  errorImage: `${Client.imageBasePath}/error.gif`
};
const guiUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GuiConfig,
  error,
  popup
}, Symbol.toStringTag, { value: "Module" }));
const copyTextToClipboard = (text) => {
  navigator.clipboard.writeText(text).then(function() {
    GlobalConfig.logger.info("Async: Copying to clipboard was successful!");
  }, function(err) {
    GlobalConfig.logger.error("Async: Could not copy text: ", err);
  });
};
class MaxLog {
  /**
   * Initializes the DOM node for the console.
   * This requires `document.body` to point to a non-null value.
   * This is called from within setVisible if the log has not yet been initialized.
   */
  static init() {
    if (MaxLog.window == null && document.body != null) {
      const title = `${MaxLog.consoleName} - mxGraph ${VERSION}`;
      const table = document.createElement("table");
      table.setAttribute("width", "100%");
      table.setAttribute("height", "100%");
      const tbody = document.createElement("tbody");
      let tr = document.createElement("tr");
      const td = document.createElement("td");
      td.style.verticalAlign = "top";
      MaxLog.textarea = document.createElement("textarea");
      MaxLog.textarea.setAttribute("wrap", "off");
      MaxLog.textarea.setAttribute("readOnly", "true");
      MaxLog.textarea.style.height = "100%";
      MaxLog.textarea.style.resize = "none";
      MaxLog.textarea.value = MaxLog.buffer;
      if (Client.IS_NS && document.compatMode !== "BackCompat") {
        MaxLog.textarea.style.width = "99%";
      } else {
        MaxLog.textarea.style.width = "100%";
      }
      td.appendChild(MaxLog.textarea);
      tr.appendChild(td);
      tbody.appendChild(tr);
      tr = document.createElement("tr");
      MaxLog.td = document.createElement("td");
      MaxLog.td.style.verticalAlign = "top";
      MaxLog.td.setAttribute("height", "30px");
      tr.appendChild(MaxLog.td);
      tbody.appendChild(tr);
      table.appendChild(tbody);
      MaxLog.addButton("Info", function(evt) {
        MaxLog.info();
      });
      MaxLog.addButton("DOM", function(evt) {
        const content = getInnerHtml(document.body);
        MaxLog.debug(content);
      });
      MaxLog.addButton("Trace", function(evt) {
        MaxLog.TRACE = !MaxLog.TRACE;
        if (MaxLog.TRACE) {
          MaxLog.debug("Tracing enabled");
        } else {
          MaxLog.debug("Tracing disabled");
        }
      });
      MaxLog.addButton("Copy", function(evt) {
        try {
          copyTextToClipboard(MaxLog.textarea.value);
        } catch (err) {
          alert(err);
        }
      });
      MaxLog.addButton("Show", function(evt) {
        try {
          popup(MaxLog.textarea.value);
        } catch (err) {
          alert(err);
        }
      });
      MaxLog.addButton("Clear", function(evt) {
        MaxLog.textarea.value = "";
      });
      let h = 0;
      let w = 0;
      if (typeof window.innerWidth === "number") {
        h = window.innerHeight;
        w = window.innerWidth;
      } else {
        h = document.documentElement.clientHeight || document.body.clientHeight;
        w = document.body.clientWidth;
      }
      MaxLog.window = new MaxWindow(title, table, Math.max(0, w - 320), Math.max(0, h - 210), 300, 160);
      MaxLog.window.setMaximizable(true);
      MaxLog.window.setScrollable(false);
      MaxLog.window.setResizable(true);
      MaxLog.window.setClosable(true);
      MaxLog.window.destroyOnClose = false;
      if (Client.IS_NS && !Client.IS_GC && !Client.IS_SF && document.compatMode !== "BackCompat") {
        const elt = MaxLog.window.getElement();
        const resizeHandler = (sender, evt) => {
          MaxLog.textarea.style.height = `${Math.max(0, elt.offsetHeight - 70)}px`;
        };
        MaxLog.window.addListener(InternalEvent.RESIZE_END, resizeHandler);
        MaxLog.window.addListener(InternalEvent.MAXIMIZE, resizeHandler);
        MaxLog.window.addListener(InternalEvent.NORMALIZE, resizeHandler);
        MaxLog.textarea.style.height = "92px";
      }
    }
  }
  /**
   * Writes the current navigator information to the console.
   */
  static info() {
    MaxLog.writeln(toString(navigator));
  }
  /**
   * Adds a button to the console using the given label and function.
   */
  static addButton(lab, funct) {
    const button2 = document.createElement("button");
    write(button2, lab);
    InternalEvent.addListener(button2, "click", funct);
    MaxLog.td.appendChild(button2);
  }
  /**
   * Returns `true` if the console is visible.
   */
  static isVisible() {
    if (MaxLog.window != null) {
      return MaxLog.window.isVisible();
    }
    return false;
  }
  /**
   * Shows the console.
   */
  static show() {
    MaxLog.setVisible(true);
  }
  /**
   * Shows or hides the console.
   */
  static setVisible(visible) {
    if (MaxLog.window == null) {
      MaxLog.init();
    }
    if (MaxLog.window != null) {
      MaxLog.window.setVisible(visible);
    }
  }
  /**
   * Writes the specified string to the console if {@link TRACE} is `true` and returns the current time in milliseconds.
   */
  static enter(string) {
    if (MaxLog.TRACE) {
      MaxLog.writeln(`Entering ${string}`);
      return (/* @__PURE__ */ new Date()).getTime();
    }
  }
  /**
   * Writes the specified string to the console if {@link TRACE} is `true` and computes the difference between the current
   * time and t0 in milliseconds.
   *
   * @see {@link enter} for an example.
   */
  static leave(string, t0) {
    if (MaxLog.TRACE) {
      const dt = getElapseMillisecondsMessage(t0);
      MaxLog.writeln(`Leaving ${string}${dt}`);
    }
  }
  /**
   * Adds all arguments to the console if {@link DEBUG} is enabled.
   */
  static debug(...args) {
    if (MaxLog.DEBUG) {
      MaxLog.writeln(...args);
    }
  }
  /**
   * Adds all arguments to the console if {@link TRACE} is enabled.
   */
  static trace(...args) {
    if (MaxLog.TRACE) {
      MaxLog.writeln(...args);
    }
  }
  /**
   * Adds all arguments to the console if {@link WARN} is enabled.
   */
  static warn(...args) {
    if (MaxLog.WARN) {
      MaxLog.writeln(...args);
    }
  }
  /**
   * Adds the specified strings to the console.
   */
  static write(...args) {
    let string = "";
    for (let i = 0; i < args.length; i += 1) {
      string += args[i];
      if (i < args.length - 1) {
        string += " ";
      }
    }
    if (MaxLog.textarea != null) {
      MaxLog.textarea.value = MaxLog.textarea.value + string;
      if (navigator.userAgent != null && navigator.userAgent.indexOf("Presto/2.5") >= 0) {
        MaxLog.textarea.style.visibility = "hidden";
        MaxLog.textarea.style.visibility = "visible";
      }
      MaxLog.textarea.scrollTop = MaxLog.textarea.scrollHeight;
    } else {
      MaxLog.buffer += string;
    }
  }
  /**
   * Adds the specified strings to the console, appending a linefeed at the end of each string.
   */
  static writeln(...args) {
    let string = "";
    for (let i = 0; i < args.length; i += 1) {
      string += args[i];
      if (i < args.length - 1) {
        string += " ";
      }
    }
    MaxLog.write(`${string}
`);
  }
}
MaxLog.textarea = null;
MaxLog.consoleName = "Console";
MaxLog.TRACE = false;
MaxLog.DEBUG = true;
MaxLog.WARN = true;
MaxLog.buffer = "";
const getScaleForPageCount = (pageCount, graph, pageFormat, border = 0) => {
  if (pageCount < 1) {
    return 1;
  }
  pageFormat = pageFormat != null ? pageFormat : new Rectangle(...PAGE_FORMAT_A4_PORTRAIT);
  const availablePageWidth = pageFormat.width - border * 2;
  const availablePageHeight = pageFormat.height - border * 2;
  const graphBounds = graph.getGraphBounds().clone();
  const sc = graph.getView().getScale();
  graphBounds.width /= sc;
  graphBounds.height /= sc;
  const graphWidth = graphBounds.width;
  const graphHeight = graphBounds.height;
  let scale = 1;
  const pageFormatAspectRatio = availablePageWidth / availablePageHeight;
  const graphAspectRatio = graphWidth / graphHeight;
  const pagesAspectRatio = graphAspectRatio / pageFormatAspectRatio;
  const pageRoot = Math.sqrt(pageCount);
  const pagesAspectRatioSqrt = Math.sqrt(pagesAspectRatio);
  let numRowPages = pageRoot * pagesAspectRatioSqrt;
  let numColumnPages = pageRoot / pagesAspectRatioSqrt;
  if (numRowPages < 1 && numColumnPages > pageCount) {
    const scaleChange = numColumnPages / pageCount;
    numColumnPages = pageCount;
    numRowPages /= scaleChange;
  }
  if (numColumnPages < 1 && numRowPages > pageCount) {
    const scaleChange = numRowPages / pageCount;
    numRowPages = pageCount;
    numColumnPages /= scaleChange;
  }
  let currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);
  let numLoops = 0;
  while (currentTotalPages > pageCount) {
    let roundRowDownProportion = Math.floor(numRowPages) / numRowPages;
    let roundColumnDownProportion = Math.floor(numColumnPages) / numColumnPages;
    if (roundRowDownProportion == 1) {
      roundRowDownProportion = Math.floor(numRowPages - 1) / numRowPages;
    }
    if (roundColumnDownProportion == 1) {
      roundColumnDownProportion = Math.floor(numColumnPages - 1) / numColumnPages;
    }
    let scaleChange = 1;
    if (roundRowDownProportion > roundColumnDownProportion) {
      scaleChange = roundRowDownProportion;
    } else {
      scaleChange = roundColumnDownProportion;
    }
    numRowPages *= scaleChange;
    numColumnPages *= scaleChange;
    currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);
    numLoops++;
    if (numLoops > 10) {
      break;
    }
  }
  const posterWidth = availablePageWidth * numRowPages;
  scale = posterWidth / graphWidth;
  return scale * 0.99999;
};
const show = (graph, doc = null, x0 = 0, y0 = 0, w = null, h = null) => {
  x0 = x0 != null ? x0 : 0;
  y0 = y0 != null ? y0 : 0;
  if (doc == null) {
    const wnd = window.open();
    doc = wnd.document;
  } else {
    doc.open();
  }
  const bounds = graph.getGraphBounds();
  const dx = Math.ceil(x0 - bounds.x);
  const dy = Math.ceil(y0 - bounds.y);
  if (w == null) {
    w = Math.ceil(bounds.width + x0) + Math.ceil(Math.ceil(bounds.x) - bounds.x);
  }
  if (h == null) {
    h = Math.ceil(bounds.height + y0) + Math.ceil(Math.ceil(bounds.y) - bounds.y);
  }
  doc.writeln("<html><head>");
  const base = document.getElementsByTagName("base");
  for (let i = 0; i < base.length; i += 1) {
    doc.writeln(getOuterHtml(base[i]));
  }
  const links = document.getElementsByTagName("link");
  for (let i = 0; i < links.length; i += 1) {
    doc.writeln(getOuterHtml(links[i]));
  }
  const styles = document.getElementsByTagName("style");
  for (let i = 0; i < styles.length; i += 1) {
    doc.writeln(getOuterHtml(styles[i]));
  }
  doc.writeln('</head><body style="margin:0px;"></body></html>');
  doc.close();
  const outer = doc.createElement("div");
  outer.style.position = "absolute";
  outer.style.overflow = "hidden";
  outer.style.width = `${w}px`;
  outer.style.height = `${h}px`;
  const div = doc.createElement("div");
  div.style.position = "absolute";
  div.style.left = `${dx}px`;
  div.style.top = `${dy}px`;
  if (graph.container && graph.view.drawPane) {
    let node = graph.container.firstChild;
    let svg = null;
    while (node != null) {
      const clone2 = node.cloneNode(true);
      if (node == graph.view.drawPane.ownerSVGElement) {
        outer.appendChild(clone2);
        svg = clone2;
      } else {
        div.appendChild(clone2);
      }
      node = node.nextSibling;
    }
    doc.body.appendChild(outer);
    if (div.firstChild != null) {
      doc.body.appendChild(div);
    }
    if (svg != null) {
      svg.style.minWidth = "";
      svg.style.minHeight = "";
      if (svg.firstChild)
        svg.firstChild.setAttribute("transform", `translate(${dx},${dy})`);
    }
    removeCursors(doc.body);
  }
  return doc;
};
const printScreen = (graph) => {
  const wnd = window.open();
  if (!wnd)
    return;
  graph.getGraphBounds();
  show(graph, wnd.document);
  const print = () => {
    wnd.focus();
    wnd.print();
    wnd.close();
  };
  if (Client.IS_GC) {
    wnd.setTimeout(print, 500);
  } else {
    print();
  }
};
const printUtils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getScaleForPageCount,
  printScreen,
  show
}, Symbol.toStringTag, { value: "Module" }));
class Editor extends EventSource {
  /**
   * Constructs a new editor. This function invokes the {@link onInit} callback upon completion.
   *
   * ```javascript
   * const config = load('config/diagram-editor.xml').getDocumentElement();
   * const editor = new Editor(config);
   * ```
   *
   * @param config The configuration element that contains the editor configuration.
   */
  constructor(config) {
    var _a;
    super();
    this.onInit = null;
    this.lastSnapshot = null;
    this.ignoredChanges = null;
    this.rubberband = null;
    this.isActive = null;
    this.destroyed = false;
    this.askZoomResource = isI18nEnabled() ? "askZoom" : "";
    this.lastSavedResource = isI18nEnabled() ? "lastSaved" : "";
    this.currentFileResource = isI18nEnabled() ? "currentFile" : "";
    this.propertiesResource = isI18nEnabled() ? "properties" : "";
    this.tasksResource = isI18nEnabled() ? "tasks" : "";
    this.helpResource = isI18nEnabled() ? "help" : "";
    this.outlineResource = isI18nEnabled() ? "outline" : "";
    this.outline = null;
    this.graphRenderHint = null;
    this.toolbar = null;
    this.status = null;
    this.popupHandler = null;
    this.undoManager = null;
    this.keyHandler = null;
    this.actions = {};
    this.dblClickAction = "edit";
    this.swimlaneRequired = false;
    this.disableContextMenu = true;
    this.insertFunction = null;
    this.forcedInserting = false;
    this.templates = null;
    this.defaultEdge = null;
    this.defaultEdgeStyle = null;
    this.defaultGroup = null;
    this.groupBorderSize = null;
    this.filename = null;
    this.linefeed = "&#xa;";
    this.postParameterName = "xml";
    this.escapePostData = true;
    this.urlPost = null;
    this.urlImage = null;
    this.horizontalFlow = false;
    this.layoutDiagram = false;
    this.swimlaneSpacing = 0;
    this.maintainSwimlanes = false;
    this.layoutSwimlanes = false;
    this.cycleAttributeValues = [];
    this.cycleAttributeIndex = 0;
    this.cycleAttributeName = "fillColor";
    this.tasks = null;
    this.tasksWindowImage = null;
    this.tasksTop = 20;
    this.help = null;
    this.helpWindowImage = null;
    this.urlHelp = null;
    this.helpWidth = 300;
    this.helpHeight = 260;
    this.propertiesWidth = 240;
    this.propertiesHeight = null;
    this.movePropertiesDialog = false;
    this.validating = false;
    this.modified = false;
    this.actions = {};
    this.addActions();
    if (document.body) {
      this.cycleAttributeValues = [];
      this.popupHandler = new EditorPopupMenu();
      this.undoManager = new UndoManager();
      this.graph = this.createGraph();
      this.toolbar = this.createToolbar();
      this.keyHandler = new EditorKeyHandler(this);
      this.configure(config);
      this.graph.swimlaneIndicatorColorAttribute = this.cycleAttributeName;
      (_a = this.onInit) == null ? void 0 : _a.call(this);
    }
  }
  /**
   * Returns {@link modified}.
   */
  isModified() {
    return this.modified;
  }
  /**
   * Sets {@link modified} to the specified boolean value.
   * @param value
   */
  setModified(value) {
    this.modified = value;
  }
  /**
   * Adds the built-in actions to the editor instance.
   * save - Saves the graph using <urlPost>.
   * print - Shows the graph in a new print preview window.
   * show - Shows the graph in a new window.
   * exportImage - Shows the graph as a bitmap image using <getUrlImage>.
   * refresh - Refreshes the graph's display.
   * cut - Copies the current selection into the clipboard
   * and removes it from the graph.
   * copy - Copies the current selection into the clipboard.
   * paste - Pastes the clipboard into the graph.
   * delete - Removes the current selection from the graph.
   * group - Puts the current selection into a new group.
   * ungroup - Removes the selected groups and selects the children.
   * undo - Undoes the last change on the graph model.
   * redo - Redoes the last change on the graph model.
   * zoom - Sets the zoom via a dialog.
   * zoomIn - Zooms into the graph.
   * zoomOut - Zooms out of the graph
   * actualSize - Resets the scale and translation on the graph.
   * fit - Changes the scale so that the graph fits into the window.
   * showProperties - Shows the properties dialog.
   * selectAll - Selects all cells.
   * selectNone - Clears the selection.
   * selectVertices - Selects all vertices.
   * selectEdges = Selects all edges.
   * edit - Starts editing the current selection cell.
   * enterGroup - Drills down into the current selection cell.
   * exitGroup - Moves up in the drilling hierachy
   * home - Moves to the topmost parent in the drilling hierarchy
   * selectPrevious - Selects the previous cell.
   * selectNext - Selects the next cell.
   * selectParent - Selects the parent of the selection cell.
   * selectChild - Selects the first child of the selection cell.
   * collapse - Collapses the currently selected cells.
   * expand - Expands the currently selected cells.
   * bold - Toggle bold text style.
   * italic - Toggle italic text style.
   * underline - Toggle underline text style.
   * alignCellsLeft - Aligns the selection cells at the left.
   * alignCellsCenter - Aligns the selection cells in the center.
   * alignCellsRight - Aligns the selection cells at the right.
   * alignCellsTop - Aligns the selection cells at the top.
   * alignCellsMiddle - Aligns the selection cells in the middle.
   * alignCellsBottom - Aligns the selection cells at the bottom.
   * alignFontLeft - Sets the horizontal text alignment to left.
   * alignFontCenter - Sets the horizontal text alignment to center.
   * alignFontRight - Sets the horizontal text alignment to right.
   * alignFontTop - Sets the vertical text alignment to top.
   * alignFontMiddle - Sets the vertical text alignment to middle.
   * alignFontBottom - Sets the vertical text alignment to bottom.
   * toggleTasks - Shows or hides the tasks window.
   * toggleHelp - Shows or hides the help window.
   * toggleOutline - Shows or hides the outline window.
   * toggleConsole - Shows or hides the console window.
   */
  addActions() {
    this.addAction("save", (editor) => {
      editor.save();
    });
    this.addAction("print", (editor) => {
      const preview = new PrintPreview(editor.graph, 1);
      preview.open();
    });
    this.addAction("show", (editor) => {
      show(editor.graph, null, 10, 10);
    });
    this.addAction("exportImage", (editor) => {
      const url = editor.getUrlImage();
      if (url == null || Client.IS_LOCAL) {
        editor.execute("show");
      } else {
        const node = getViewXml(editor.graph, 1);
        const xml = getXml(node, "\n");
        submit(url, `${editor.postParameterName}=${encodeURIComponent(xml)}`, document, "_blank");
      }
    });
    this.addAction("refresh", (editor) => {
      editor.graph.refresh();
    });
    this.addAction("cut", (editor) => {
      if (editor.graph.isEnabled()) {
        Clipboard.cut(editor.graph);
      }
    });
    this.addAction("copy", (editor) => {
      if (editor.graph.isEnabled()) {
        Clipboard.copy(editor.graph);
      }
    });
    this.addAction("paste", (editor) => {
      if (editor.graph.isEnabled()) {
        Clipboard.paste(editor.graph);
      }
    });
    this.addAction("delete", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.removeCells();
      }
    });
    this.addAction("group", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.setSelectionCell(editor.groupCells());
      }
    });
    this.addAction("ungroup", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.setSelectionCells(editor.graph.ungroupCells());
      }
    });
    this.addAction("removeFromParent", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.removeCellsFromParent();
      }
    });
    this.addAction("undo", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.undo();
      }
    });
    this.addAction("redo", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.redo();
      }
    });
    this.addAction("zoomIn", (editor) => {
      editor.graph.zoomIn();
    });
    this.addAction("zoomOut", (editor) => {
      editor.graph.zoomOut();
    });
    this.addAction("actualSize", (editor) => {
      editor.graph.zoomActual();
    });
    this.addAction("fit", (editor) => {
      editor.graph.fit();
    });
    this.addAction("showProperties", (editor, cell) => {
      editor.showProperties(cell);
    });
    this.addAction("selectAll", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.selectAll();
      }
    });
    this.addAction("selectNone", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.clearSelection();
      }
    });
    this.addAction("selectVertices", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.selectVertices();
      }
    });
    this.addAction("selectEdges", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.selectEdges();
      }
    });
    this.addAction("edit", (editor, cell) => {
      if (editor.graph.isEnabled() && editor.graph.isCellEditable(cell)) {
        editor.graph.startEditingAtCell(cell);
      }
    });
    this.addAction("toBack", (editor, cell) => {
      if (editor.graph.isEnabled()) {
        editor.graph.orderCells(true);
      }
    });
    this.addAction("toFront", (editor, cell) => {
      if (editor.graph.isEnabled()) {
        editor.graph.orderCells(false);
      }
    });
    this.addAction("enterGroup", (editor, cell) => {
      editor.graph.enterGroup(cell);
    });
    this.addAction("exitGroup", (editor) => {
      editor.graph.exitGroup();
    });
    this.addAction("home", (editor) => {
      editor.graph.home();
    });
    this.addAction("selectPrevious", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.selectPreviousCell();
      }
    });
    this.addAction("selectNext", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.selectNextCell();
      }
    });
    this.addAction("selectParent", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.selectParentCell();
      }
    });
    this.addAction("selectChild", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.selectChildCell();
      }
    });
    this.addAction("collapse", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.foldCells(true);
      }
    });
    this.addAction("collapseAll", (editor) => {
      if (editor.graph.isEnabled()) {
        const cells = editor.graph.getChildVertices();
        editor.graph.foldCells(true, false, cells);
      }
    });
    this.addAction("expand", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.foldCells(false);
      }
    });
    this.addAction("expandAll", (editor) => {
      if (editor.graph.isEnabled()) {
        const cells = editor.graph.getChildVertices();
        editor.graph.foldCells(false, false, cells);
      }
    });
    this.addAction("bold", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.toggleCellStyleFlags("fontStyle", FONT.BOLD);
      }
    });
    this.addAction("italic", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.toggleCellStyleFlags("fontStyle", FONT.ITALIC);
      }
    });
    this.addAction("underline", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.toggleCellStyleFlags("fontStyle", FONT.UNDERLINE);
      }
    });
    this.addAction("alignCellsLeft", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.alignCells(ALIGN.LEFT);
      }
    });
    this.addAction("alignCellsCenter", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.alignCells(ALIGN.CENTER);
      }
    });
    this.addAction("alignCellsRight", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.alignCells(ALIGN.RIGHT);
      }
    });
    this.addAction("alignCellsTop", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.alignCells(ALIGN.TOP);
      }
    });
    this.addAction("alignCellsMiddle", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.alignCells(ALIGN.MIDDLE);
      }
    });
    this.addAction("alignCellsBottom", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.alignCells(ALIGN.BOTTOM);
      }
    });
    this.addAction("alignFontLeft", (editor) => {
      editor.graph.setCellStyles("align", ALIGN.LEFT);
    });
    this.addAction("alignFontCenter", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.setCellStyles("align", ALIGN.CENTER);
      }
    });
    this.addAction("alignFontRight", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.setCellStyles("align", ALIGN.RIGHT);
      }
    });
    this.addAction("alignFontTop", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.setCellStyles("verticalAlign", ALIGN.TOP);
      }
    });
    this.addAction("alignFontMiddle", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.setCellStyles("verticalAlign", ALIGN.MIDDLE);
      }
    });
    this.addAction("alignFontBottom", (editor) => {
      if (editor.graph.isEnabled()) {
        editor.graph.setCellStyles("verticalAlign", ALIGN.BOTTOM);
      }
    });
    this.addAction("zoom", (editor) => {
      const current = editor.graph.getView().scale * 100;
      const preInput = prompt(translate(editor.askZoomResource) || editor.askZoomResource, String(current));
      if (preInput) {
        const scale = parseFloat(preInput) / 100;
        if (!isNaN(scale)) {
          editor.graph.getView().setScale(scale);
        }
      }
    });
    this.addAction("toggleTasks", (editor) => {
      if (!isNullish(editor.tasks)) {
        editor.tasks.setVisible(!editor.tasks.isVisible());
      } else {
        editor.showTasks();
      }
    });
    this.addAction("toggleHelp", (editor) => {
      if (!isNullish(editor.help)) {
        editor.help.setVisible(!editor.help.isVisible());
      } else {
        editor.showHelp();
      }
    });
    this.addAction("toggleOutline", (editor) => {
      if (isNullish(editor.outline)) {
        editor.showOutline();
      } else {
        editor.outline.setVisible(!editor.outline.isVisible());
      }
    });
    this.addAction("toggleConsole", (editor) => {
      MaxLog.setVisible(!MaxLog.isVisible());
    });
  }
  /**
   * Configures the editor using the specified node. To load the
   * configuration from a given URL the following code can be used to obtain
   * the XML node.
   *
   * @example
   * ```javascript
   * var node = mxUtils.load(url).getDocumentElement();
   * ```
   * @param node XML node that contains the configuration.
   */
  configure(node) {
    if (node) {
      const dec = new Codec(node.ownerDocument);
      dec.decode(node, this);
      this.resetHistory();
    }
  }
  /**
   * Resets the cookie that is used to remember if the editor has already been used.
   */
  resetFirstTime() {
    document.cookie = "mxgraph=seen; expires=Fri, 27 Jul 2001 02:47:11 UTC; path=/";
  }
  /**
   * Resets the command history, modified state and counters.
   */
  resetHistory() {
    this.lastSnapshot = (/* @__PURE__ */ new Date()).getTime();
    this.undoManager.clear();
    this.ignoredChanges = 0;
    this.setModified(false);
  }
  /**
   * Binds the specified actionname to the specified function.
   *
   * @example
   * ```javascript
   * editor.addAction('test', function(editor: Editor, cell: Cell)
   * {
   * 		mxUtils.alert("test "+cell);
   * });
   * ```
   * @param actionname String that specifies the name of the action to be added.
   * @param funct Function that implements the new action. The first argument
   * of the function is the editor it is used with,
   * the second argument is the cell it operates upon.
   */
  addAction(actionname, funct) {
    this.actions[actionname] = funct;
  }
  /**
   * Executes the function with the given name in {@link actions} passing the
   * editor instance and given cell as the first and second argument. All
   * additional arguments are passed to the action as well. This method
   * contains a try-catch block and displays an error message if an action
   * causes an exception. The exception is re-thrown after the error
   * message was displayed.
   *
   * @example
   * ```javascript
   * editor.execute("showProperties", cell);
   * ```
   * @param actionname
   * @param cell
   * @param evt
   */
  execute(actionname, cell = null, evt = null) {
    const action = this.actions[actionname];
    if (action) {
      try {
        const args = [this, cell, evt];
        action.apply(this, args);
      } catch (e) {
        error(`Cannot execute ${actionname}: ${e.message}`, 280, true);
        throw e;
      }
    } else {
      error(`Cannot find action ${actionname}`, 280, true);
    }
  }
  /**
   * Adds the specified template under the given name in {@link templates}.
   * @param name
   * @param template
   */
  addTemplate(name, template) {
    this.templates[name] = template;
  }
  /**
   * Returns the template for the given name.
   * @param name
   */
  getTemplate(name) {
    return this.templates[name];
  }
  /**
   * Creates the {@link graph} for the editor. The graph is created with no
   * container and is initialized from {@link setGraphContainer}.
   * @returns graph instance
   */
  createGraph() {
    const graph = new Graph(void 0);
    graph.setTooltips(true);
    graph.setPanning(true);
    this.installDblClickHandler(graph);
    this.installUndoHandler(graph);
    this.installDrillHandler(graph);
    this.installChangeHandler(graph);
    this.installInsertHandler(graph);
    const popupMenuHandler = graph.getPlugin("PopupMenuHandler");
    if (popupMenuHandler) {
      popupMenuHandler.factoryMethod = (menu, cell, evt) => {
        return this.createPopupMenu(menu, cell, evt);
      };
    }
    const connectionHandler = graph.getPlugin("ConnectionHandler");
    if (connectionHandler) {
      connectionHandler.factoryMethod = (source, target) => {
        return this.createEdge(source, target);
      };
    }
    this.createSwimlaneManager(graph);
    this.createLayoutManager(graph);
    return graph;
  }
  /**
   * Sets the graph's container using [@link mxGraph.init}.
   * @param graph
   * @returns SwimlaneManager instance
   */
  createSwimlaneManager(graph) {
    const swimlaneMgr = new SwimlaneManager(graph, false);
    swimlaneMgr.isHorizontal = () => {
      return this.horizontalFlow;
    };
    swimlaneMgr.isEnabled = () => {
      return this.maintainSwimlanes;
    };
    return swimlaneMgr;
  }
  /**
   * Creates a layout manager for the swimlane and diagram layouts, that
   * is, the locally defined inter and intraswimlane layouts.
   * @param graph
   * @returns LayoutManager instance
   */
  createLayoutManager(graph) {
    const layoutMgr = new LayoutManager(graph);
    layoutMgr.getLayout = (cell) => {
      var _a;
      let layout = null;
      this.graph.getDataModel();
      if (cell.getParent()) {
        if (this.layoutSwimlanes && graph.isSwimlane(cell)) {
          if (this.swimlaneLayout == null) {
            this.swimlaneLayout = this.createSwimlaneLayout();
          }
          layout = this.swimlaneLayout;
        } else if (this.layoutDiagram && (graph.isValidRoot(cell) || !((_a = cell == null ? void 0 : cell.getParent()) == null ? void 0 : _a.getParent()))) {
          if (this.diagramLayout == null) {
            this.diagramLayout = this.createDiagramLayout();
          }
          layout = this.diagramLayout;
        }
      }
      return layout;
    };
    return layoutMgr;
  }
  /**
   * Sets the graph's container using {@link graph.init}.
   * @param container
   */
  setGraphContainer(container) {
    if (!this.graph.container && container) {
      this.graph.init(container);
      this.rubberband = new RubberBandHandler(this.graph);
      if (this.disableContextMenu) {
        InternalEvent.disableContextMenu(container);
      }
    }
  }
  /**
   * Overrides {@link graph.dblClick} to invoke {@link dblClickAction}
   * on a cell and reset the selection tool in the toolbar.
   * @param graph
   */
  installDblClickHandler(graph) {
    graph.addListener(InternalEvent.DOUBLE_CLICK, (sender, evt) => {
      const cell = evt.getProperty("cell");
      if (cell != null && graph.isEnabled() && this.dblClickAction != null) {
        this.execute(this.dblClickAction, cell);
        evt.consume();
      }
    });
  }
  /**
   * Adds the {@link undoManager} to the graph model and the view.
   * @param graph
   */
  installUndoHandler(graph) {
    const listener = (sender, evt) => {
      const edit = evt.getProperty("edit");
      this.undoManager.undoableEditHappened(edit);
    };
    graph.getDataModel().addListener(InternalEvent.UNDO, listener);
    graph.getView().addListener(InternalEvent.UNDO, listener);
    const undoHandler = (sender, evt) => {
      const { changes } = evt.getProperty("edit");
      graph.setSelectionCells(graph.getSelectionCellsForChanges(changes));
    };
    this.undoManager.addListener(InternalEvent.UNDO, undoHandler);
    this.undoManager.addListener(InternalEvent.REDO, undoHandler);
  }
  /**
   * Installs listeners for dispatching the {@link root} event.
   * @param graph
   */
  installDrillHandler(graph) {
    const listener = (sender) => {
      this.fireEvent(new EventObject(InternalEvent.ROOT));
    };
    graph.getView().addListener(InternalEvent.DOWN, listener);
    graph.getView().addListener(InternalEvent.UP, listener);
  }
  /**
   * Installs the listeners required to automatically validate
   * the graph. On each change of the root, this implementation
   * fires a {@link root} event.
   * @param graph
   */
  installChangeHandler(graph) {
    const listener = (sender, evt) => {
      this.setModified(true);
      if (this.validating) {
        graph.validateGraph();
      }
      const { changes } = evt.getProperty("edit");
      for (const change of changes) {
        if (change instanceof RootChange || change instanceof ValueChange && change.cell === this.graph.model.root || change instanceof CellAttributeChange && change.cell === this.graph.model.root) {
          this.fireEvent(new EventObject(InternalEvent.ROOT));
          break;
        }
      }
    };
    graph.getDataModel().addListener(InternalEvent.CHANGE, listener);
  }
  /**
   * Installs the handler for invoking {@link insertFunction} if one is defined.
   * @param graph
   */
  installInsertHandler(graph) {
    const insertHandler = {
      mouseDown: (_sender, me) => {
        if (this.insertFunction && !me.isPopupTrigger() && (this.forcedInserting || me.getState() == null)) {
          this.graph.clearSelection();
          this.insertFunction(me.getEvent(), me.getCell());
          this.isActive = true;
          me.consume();
        }
      },
      mouseMove: (_sender, me) => {
        if (this.isActive) {
          me.consume();
        }
      },
      mouseUp: (_sender, me) => {
        if (this.isActive) {
          this.isActive = false;
          me.consume();
        }
      }
    };
    graph.addMouseListener(insertHandler);
  }
  /**
   * Creates the layout instance used to layout the swimlanes in the diagram.
   * @returns StackLayout instance
   */
  createDiagramLayout() {
    const gs = this.graph.gridSize;
    const layout = new StackLayout(this.graph, !this.horizontalFlow, this.swimlaneSpacing, 2 * gs, 2 * gs);
    layout.isVertexIgnored = (cell) => {
      return !layout.graph.isSwimlane(cell);
    };
    return layout;
  }
  /**
   * Creates the layout instance used to layout the children of each swimlane.
   * @returns CompactTreeLayout instance
   */
  createSwimlaneLayout() {
    return new CompactTreeLayout(this.graph, this.horizontalFlow);
  }
  /**
   * Creates the {@link toolbar} with no container.
   * @returns EditorToolbar instance
   */
  createToolbar() {
    return new EditorToolbar(null, this);
  }
  /**
   * Initializes the toolbar for the given container.
   * @param container
   */
  setToolbarContainer(container) {
    var _a;
    (_a = this.toolbar) == null ? void 0 : _a.init(container);
  }
  /**
   * Creates the {@link status} using the specified container.
   * This implementation adds listeners in the editor to display the last saved time and the current filename in the status bar.
   * @param container DOM node that will contain the statusbar.
   */
  setStatusContainer(container) {
    if (!this.status && container) {
      this.status = container;
      this.addListener(InternalEvent.SAVE, () => {
        const timestamp = (/* @__PURE__ */ new Date()).toLocaleString();
        this.setStatus(`${translate(this.lastSavedResource) || this.lastSavedResource}: ${timestamp}`);
      });
      this.addListener(InternalEvent.OPEN, () => {
        this.setStatus(`${translate(this.currentFileResource) || this.currentFileResource}: ${this.filename}`);
      });
    }
  }
  /**
   * Display the specified message in the status bar.
   * @param message String the specified the message to be displayed.
   */
  setStatus(message) {
    if (this.status && !isNullish(message)) {
      this.status.innerHTML = message;
    }
  }
  /**
   * Creates a listener to update the inner HTML of the
   * specified DOM node with the value of {@link getTitle}.
   * @param container DOM node that will contain the title.
   */
  setTitleContainer(container) {
    this.addListener(InternalEvent.ROOT, (sender) => {
      container.innerHTML = this.getTitle();
    });
  }
  /**
   * Executes a vertical or horizontal compact tree layout using the specified cell as an argument.
   * The cell may either be a group or the root of a tree.
   *
   * @param cell {@link Cell} to use in the compact tree layout.
   * @param horizontal Optional boolean to specify the tree's
   * orientation. Default is true.
   */
  treeLayout(cell, horizontal) {
    if (cell) {
      const layout = new CompactTreeLayout(this.graph, horizontal);
      layout.execute(cell);
    }
  }
  /**
   * Returns the string value for the current root of the diagram.
   */
  getTitle() {
    var _a;
    let title = "";
    const { graph } = this;
    let cell = graph.getCurrentRoot();
    while ((_a = cell == null ? void 0 : cell.getParent()) == null ? void 0 : _a.getParent()) {
      if (graph.isValidRoot(cell)) {
        title = ` > ${graph.convertValueToString(cell)}${title}`;
      }
      cell = cell.getParent();
    }
    const prefix = this.getRootTitle();
    return prefix + title;
  }
  /**
   * Returns the string value of the root cell in {@link graph.model}.
   */
  getRootTitle() {
    const root = this.graph.getDataModel().getRoot();
    return this.graph.convertValueToString(root);
  }
  /**
   * Undo the last change in {@link graph}.
   */
  undo() {
    this.undoManager.undo();
  }
  /**
   * Redo the last change in {@link graph}.
   */
  redo() {
    this.undoManager.redo();
  }
  /**
   * Invokes {@link createGroup} to create a new group cell and the invokes
   * {@link graph.groupCells}, using the grid size of the graph as the spacing
   * in the group's content area.
   */
  groupCells() {
    const border = this.groupBorderSize ?? this.graph.gridSize;
    return this.graph.groupCells(this.createGroup(), border);
  }
  /**
   * Creates and returns a clone of {@link defaultGroup} to be used as a new group cell in {@link group}.
   * @returns Cell
   */
  createGroup() {
    return cloneCell(this.defaultGroup);
  }
  /**
   * Opens the specified file synchronously and parses it using {@link readGraphModel}.
   * It updates {@link filename} and fires an <open>-event after the file has been opened.
   *
   * Exceptions should be handled as follows:
   *
   * ```javascript
   * try {
   *   editor.open(filename);
   * } catch (e) {
   *   GlobalConfig.logger.error(`Cannot open ${filename}: ${e.message}`);
   * }
   * ```
   *
   * @param filename URL of the file to be opened.
   */
  open(filename) {
    if (!isNullish(filename)) {
      const xml = load(filename).getXml();
      this.readGraphModel(xml.documentElement);
      this.filename = filename;
      this.fireEvent(new EventObject(InternalEvent.OPEN, { filename }));
    }
  }
  /**
   * Reads the specified XML node into the existing graph model and resets the command history and modified state.
   * @param node the XML node to be read into the graph model.
   */
  readGraphModel(node) {
    new ModelXmlSerializer(this.graph.getDataModel()).import(node);
    this.resetHistory();
  }
  /**
   * Posts the string returned by {@link writeGraphModel} to the given URL or the URL returned by {@link getUrlPost}.
   *
   * The actual posting is carried out by {@link postDiagram}.
   * If the URL is null then the resulting XML will be displayed using {@link popup}.
   *
   * Exceptions should be handled as follows:
   *
   * ```javascript
   * try {
   *   editor.open(filename);
   * } catch (e) {
   *   GlobalConfig.logger.error(`Cannot save: ${e.message}`);
   * }
   * ```
   *
   * @param url
   * @param linefeed
   */
  save(url = null, linefeed = this.linefeed) {
    url = url || this.getUrlPost();
    if (url) {
      const data = this.writeGraphModel(linefeed);
      this.postDiagram(url, data);
      this.setModified(false);
    }
    this.fireEvent(new EventObject(InternalEvent.SAVE, { url }));
  }
  /**
   * Hook for subclassers to override the posting of a diagram
   * represented by the given node to the given URL. This fires
   * an asynchronous {@link post} event if the diagram has been posted.
   *
   * ### Example:
   *
   * To replace the diagram with the diagram in the response, use the
   * following code.
   *
   * @example
   * ```javascript
   * editor.addListener(mxEvent.POST, function(sender, evt)
   * {
   *   // Process response (replace diagram)
   *   var req = evt.getProperty('request');
   *   var root = req.getDocumentElement();
   *   editor.graph.readGraphModel(root)
   * });
   * ```
   * @param url
   * @param data
   */
  postDiagram(url, data) {
    if (this.escapePostData) {
      data = encodeURIComponent(data);
    }
    post(url, `${this.postParameterName}=${data}`, (req) => {
      this.fireEvent(new EventObject(InternalEvent.POST, { request: req, url, data }));
    });
  }
  /**
   * Hook to create the string representation of the diagram.
   *
   * The default implementation uses {@link ModelXmlSerializer} to encode the graph model.
   *
   * @param linefeed Optional character to be used as the linefeed. Default is {@link linefeed}.
   */
  writeGraphModel(linefeed) {
    return new ModelXmlSerializer(this.graph.getDataModel()).export({ pretty: false });
  }
  /**
   * Returns the URL to post the diagram to. This is used
   * in {@link save}. The default implementation returns {@link urlPost},
   * adding <code>?draft=true</code>.
   */
  getUrlPost() {
    return this.urlPost;
  }
  /**
   * Returns the URL to create the image width. This is typically
   * the URL of a backend which accepts an XML representation
   * of a graph view to create an image. The function is used
   * in the image action to create an image. This implementation
   * returns {@link urlImage}.
   */
  getUrlImage() {
    return this.urlImage;
  }
  /**
   * Swaps the styles for the given names in the graph's
   * stylesheet and refreshes the graph.
   * @param first
   * @param second
   */
  swapStyles(first, second) {
    const style = this.graph.getStylesheet().styles[second];
    this.graph.getView().getStylesheet().putCellStyle(second, this.graph.getStylesheet().styles[first]);
    this.graph.getStylesheet().putCellStyle(first, style);
    this.graph.refresh();
  }
  /**
   * Creates and shows the properties dialog for the given
   * cell. The content area of the dialog is created using
   * {@link createProperties}.
   * @param cell
   */
  showProperties(cell = null) {
    cell = cell || this.graph.getSelectionCell();
    if (!cell) {
      cell = this.graph.getCurrentRoot();
      if (!cell) {
        cell = this.graph.getDataModel().getRoot();
      }
    }
    if (cell) {
      this.graph.stopEditing(true);
      const offset = getOffset(this.graph.container);
      let x = offset.x + 10;
      let { y } = offset;
      if (this.properties && !this.movePropertiesDialog) {
        x = this.properties.getX();
        y = this.properties.getY();
      } else {
        const bounds = this.graph.getCellBounds(cell);
        if (bounds) {
          x += bounds.x + Math.min(200, bounds.width);
          y += bounds.y;
        }
      }
      this.hideProperties();
      const node = this.createProperties(cell);
      if (node) {
        this.properties = new MaxWindow(translate(this.propertiesResource) || this.propertiesResource, node, x, y, this.propertiesWidth, this.propertiesHeight, false);
        this.properties.setVisible(true);
      }
    }
  }
  /**
   * Returns true if the properties dialog is currently visible.
   */
  isPropertiesVisible() {
    return this.properties != null;
  }
  /**
   * Creates and returns the DOM node that represents the contents
   * of the properties dialog for the given cell. This implementation
   * works for user objects that are XML nodes and display all the
   * node attributes in a form.
   */
  createProperties(cell) {
    const model = this.graph.getDataModel();
    const value = cell.getValue();
    if (isNode(value)) {
      const form = new MaxForm("properties");
      const id = form.addText("ID", cell.getId());
      id.setAttribute("readonly", "true");
      let geo = null;
      let yField = null;
      let xField = null;
      let widthField = null;
      let heightField = null;
      if (cell.isVertex()) {
        geo = cell.getGeometry();
        if (geo != null) {
          yField = form.addText("top", geo.y);
          xField = form.addText("left", geo.x);
          widthField = form.addText("width", geo.width);
          heightField = form.addText("height", geo.height);
        }
      }
      const tmp = cell.getStyle();
      const style = form.addText("Style", tmp || "");
      const attrs = value.attributes;
      const texts = [];
      for (let i = 0; i < attrs.length; i += 1) {
        const val = attrs[i].value;
        texts.push(form.addTextarea(attrs[i].nodeName, val, attrs[i].nodeName === "label" ? 4 : 2));
      }
      const okFunction = () => {
        this.hideProperties();
        model.beginUpdate();
        try {
          if (geo && xField && yField && widthField && heightField) {
            geo = geo.clone();
            geo.x = parseFloat(xField.value);
            geo.y = parseFloat(yField.value);
            geo.width = parseFloat(widthField.value);
            geo.height = parseFloat(heightField.value);
            model.setGeometry(cell, geo);
          }
          if (style.value.length > 0) {
            model.setStyle(cell, style.value);
          } else {
            model.setStyle(cell, {});
          }
          for (let i = 0; i < attrs.length; i += 1) {
            const edit = new CellAttributeChange(cell, attrs[i].nodeName, texts[i].value);
            model.execute(edit);
          }
          if (this.graph.isAutoSizeCell(cell)) {
            this.graph.updateCellSize(cell);
          }
        } finally {
          model.endUpdate();
        }
      };
      const cancelFunction = () => {
        this.hideProperties();
      };
      form.addButtons(okFunction, cancelFunction);
      return form.table;
    }
    return null;
  }
  /**
   * Hides the properties dialog.
   */
  hideProperties() {
    if (this.properties != null) {
      this.properties.destroy();
      this.properties = null;
    }
  }
  /**
   * Shows the tasks window. The tasks window is created using {@link createTasks}. The
   * default width of the window is 200 pixels, the y-coordinate of the location
   * can be specified in {@link tasksTop} and the x-coordinate is right aligned with a
   * 20 pixel offset from the right border. To change the location of the tasks
   * window, the following code can be used:
   *
   * @example
   * ```javascript
   * var oldShowTasks = Editor.prototype.showTasks;
   * Editor.prototype.showTasks = function()
   * {
   *   oldShowTasks.apply(this, arguments); // "supercall"
   *
   *   if (this.tasks != null)
   *   {
   *     this.tasks.setLocation(10, 10);
   *   }
   * };
   * ```
   */
  showTasks() {
    if (this.tasks == null) {
      const div = document.createElement("div");
      div.style.padding = "4px";
      div.style.paddingLeft = "20px";
      const w = document.body.clientWidth;
      const wnd = new MaxWindow(translate(this.tasksResource) || this.tasksResource, div, w - 220, this.tasksTop, 200);
      wnd.setClosable(true);
      wnd.destroyOnClose = false;
      const funct = (sender) => {
        InternalEvent.release(div);
        div.innerHTML = "";
        this.createTasks(div);
      };
      this.graph.getDataModel().addListener(InternalEvent.CHANGE, funct);
      this.graph.getSelectionModel().addListener(InternalEvent.CHANGE, funct);
      this.graph.addListener(InternalEvent.ROOT, funct);
      if (this.tasksWindowImage != null) {
        wnd.setImage(this.tasksWindowImage);
      }
      this.tasks = wnd;
      this.createTasks(div);
    }
    this.tasks.setVisible(true);
  }
  /**
   * Updates the contents of the tasks window using {@link createTasks}.
   * @param div
   */
  refreshTasks(div) {
    if (this.tasks != null) {
      const div2 = this.tasks.content;
      InternalEvent.release(div2);
      div2.innerHTML = "";
      this.createTasks(div2);
    }
  }
  /**
   * Updates the contents of the given DOM node to
   * display the tasks associated with the current
   * editor state. This is invoked whenever there
   * is a possible change of state in the editor.
   * Default implementation is empty.
   * @param div
   */
  createTasks(div) {
  }
  /**
   * Shows the help window. If the help window does not exist
   * then it is created using an iframe pointing to the resource
   * for the `urlHelp` key or {@link urlHelp} if the resource
   * is undefined.
   * @param tasks
   */
  showHelp(tasks = null) {
    if (this.help == null) {
      const frame = document.createElement("iframe");
      frame.setAttribute("src", translate("urlHelp") || this.urlHelp);
      frame.setAttribute("height", "100%");
      frame.setAttribute("width", "100%");
      frame.setAttribute("frameBorder", "0");
      frame.style.backgroundColor = "white";
      const w = document.body.clientWidth;
      const h = document.body.clientHeight || document.documentElement.clientHeight;
      const wnd = new MaxWindow(translate(this.helpResource) || this.helpResource, frame, (w - this.helpWidth) / 2, (h - this.helpHeight) / 3, this.helpWidth, this.helpHeight);
      wnd.setMaximizable(true);
      wnd.setClosable(true);
      wnd.destroyOnClose = false;
      wnd.setResizable(true);
      if (this.helpWindowImage != null) {
        wnd.setImage(this.helpWindowImage);
      }
      if (Client.IS_NS) {
        const handler = (sender) => {
          const h2 = wnd.div.offsetHeight;
          frame.setAttribute("height", `${h2 - 26}px`);
        };
        wnd.addListener(InternalEvent.RESIZE_END, handler);
        wnd.addListener(InternalEvent.MAXIMIZE, handler);
        wnd.addListener(InternalEvent.NORMALIZE, handler);
        wnd.addListener(InternalEvent.SHOW, handler);
      }
      this.help = wnd;
    }
    this.help.setVisible(true);
  }
  /**
   * Shows the outline window. If the window does not exist, then it is
   * created using an {@link outline}.
   */
  showOutline() {
    const create = this.outline == null;
    if (create) {
      const div = document.createElement("div");
      div.style.overflow = "hidden";
      div.style.position = "relative";
      div.style.width = "100%";
      div.style.height = "100%";
      div.style.background = "white";
      div.style.cursor = "move";
      const wnd = new MaxWindow(translate(this.outlineResource) || this.outlineResource, div, 600, 480, 200, 200, false);
      const outline = new Outline(this.graph, div);
      wnd.setClosable(true);
      wnd.setResizable(true);
      wnd.destroyOnClose = false;
      wnd.addListener(InternalEvent.RESIZE_END, () => {
        outline.update();
      });
      this.outline = wnd;
      this.outline.Outline = outline;
    }
    this.outline.setVisible(true);
    this.outline.outline.update(true);
  }
  /**
   * Puts the graph into the specified mode. The following mode names are supported:
   * - select - Selects using the left mouse button, new connections are disabled.
   * - connect - Selects using the left mouse button or creates new connections if mouse over cell hotspot. See {@link ConnectionHandler}.
   * - pan - Pans using the left mouse button, new connections are disabled.
   */
  setMode(modename) {
    const panningHandler = this.graph.getPlugin("PanningHandler");
    if (modename === "select") {
      panningHandler && (panningHandler.useLeftButtonForPanning = false);
      this.graph.setConnectable(false);
    } else if (modename === "connect") {
      panningHandler && (panningHandler.useLeftButtonForPanning = false);
      this.graph.setConnectable(true);
    } else if (modename === "pan") {
      panningHandler && (panningHandler.useLeftButtonForPanning = true);
      this.graph.setConnectable(false);
    }
  }
  /**
   * Uses {@link popupHandler} to create the menu in the graph's
   * panning handler. The redirection is setup in {@link setToolbarContainer}.
   * @param menu
   * @param cell
   * @param evt
   */
  createPopupMenu(menu, cell, evt) {
    this.popupHandler.createMenu(this, menu, cell, evt);
  }
  /**
   * Uses {@link defaultEdge} as the prototype for creating new edges
   * in the connection handler of the graph. The style of the
   * edge will be overridden with the value returned by {@link getEdgeStyle}.
   * @param source
   * @param target
   */
  createEdge(source, target) {
    let e;
    if (this.defaultEdge != null) {
      e = cloneCell(this.defaultEdge);
    } else {
      e = new Cell("");
      e.setEdge(true);
      const geo = new Geometry();
      geo.relative = true;
      e.setGeometry(geo);
    }
    const style = this.getEdgeStyle();
    if (style != null) {
      e.setStyle(style);
    }
    return e;
  }
  /**
   * Returns a string identifying the style of new edges.
   * The function is used in {@link createEdge} when new edges
   * are created in the graph.
   */
  getEdgeStyle() {
    return this.defaultEdgeStyle;
  }
  /**
   * Returns the next attribute in {@link cycleAttributeValues}
   * or null, if not attribute should be used in the specified cell.
   * @param cell
   */
  consumeCycleAttribute(cell) {
    return this.cycleAttributeValues && this.cycleAttributeValues.length > 0 && this.graph.isSwimlane(cell) ? this.cycleAttributeValues[this.cycleAttributeIndex++ % this.cycleAttributeValues.length] : null;
  }
  /**
   * Uses the returned value from {@link consumeCycleAttribute}
   * as the value for the {@link cycleAttributeName} key in the given cell's style.
   * @param cell
   */
  cycleAttribute(cell) {
    if (!isNullish(this.cycleAttributeName)) {
      const value = this.consumeCycleAttribute(cell);
      if (!isNullish(value)) {
        cell.setStyle(`${cell.getStyle()};${this.cycleAttributeName}=${value}`);
      }
    }
  }
  /**
   * Adds the given vertex as a child of parent at the specified
   * x and y coordinate and fires an {@link addVertex} event.
   * @param parent
   * @param vertex
   * @param x
   * @param y
   */
  addVertex(parent, vertex, x, y) {
    const model = this.graph.getDataModel();
    while (parent && !this.graph.isValidDropTarget(parent)) {
      parent = parent.getParent();
    }
    parent ?? (parent = this.graph.getSwimlaneAt(x, y));
    const { scale } = this.graph.getView();
    let geo = vertex.getGeometry();
    const pgeo = parent == null ? void 0 : parent.getGeometry();
    if (this.graph.isSwimlane(vertex) && !this.graph.swimlaneNesting) {
      parent = null;
    } else if (!parent && this.swimlaneRequired) {
      return null;
    } else if (parent && pgeo) {
      const state = this.graph.getView().getState(parent);
      if (state) {
        x -= state.origin.x * scale;
        y -= state.origin.y * scale;
        if (this.graph.isConstrainedMoving) {
          const { width } = geo;
          const { height } = geo;
          let tmp = state.x + state.width;
          if (x + width > tmp) {
            x -= x + width - tmp;
          }
          tmp = state.y + state.height;
          if (y + height > tmp) {
            y -= y + height - tmp;
          }
        }
      } else {
        x -= pgeo.x * scale;
        y -= pgeo.y * scale;
      }
    }
    geo = geo.clone();
    geo.x = this.graph.snap(x / scale - this.graph.getView().translate.x - this.graph.gridSize / 2);
    geo.y = this.graph.snap(y / scale - this.graph.getView().translate.y - this.graph.gridSize / 2);
    vertex.setGeometry(geo);
    if (parent) {
      parent = this.graph.getDefaultParent();
    }
    this.cycleAttribute(vertex);
    this.fireEvent(new EventObject(InternalEvent.BEFORE_ADD_VERTEX, { vertex, parent }));
    model.beginUpdate();
    try {
      vertex = this.graph.addCell(vertex, parent);
      if (vertex) {
        this.graph.constrainChild(vertex);
        this.fireEvent(new EventObject(InternalEvent.ADD_VERTEX, { vertex }));
      }
    } finally {
      model.endUpdate();
    }
    if (vertex != null) {
      this.graph.setSelectionCell(vertex);
      this.graph.scrollCellToVisible(vertex);
      this.fireEvent(new EventObject(InternalEvent.AFTER_ADD_VERTEX, { vertex }));
    }
    return vertex;
  }
  /**
   * Removes the editor and all its associated resources. This does not
   * normally need to be called, it is called automatically when the window
   * unloads.
   */
  destroy() {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.destroyed) {
      this.destroyed = true;
      (_a = this.tasks) == null ? void 0 : _a.destroy();
      (_b = this.outline) == null ? void 0 : _b.destroy();
      (_c = this.properties) == null ? void 0 : _c.destroy();
      (_d = this.keyHandler) == null ? void 0 : _d.destroy();
      (_e = this.rubberband) == null ? void 0 : _e.onDestroy();
      (_f = this.toolbar) == null ? void 0 : _f.destroy();
      (_g = this.graph) == null ? void 0 : _g.destroy();
      this.status = null;
      this.templates = null;
    }
  }
}
class CellTracker extends CellMarker {
  constructor(graph, color, funct = null) {
    super(graph, color);
    this.destroyed = false;
    this.graph.addMouseListener(this);
    if (funct) {
      this.getCell = funct;
    }
  }
  /**
   * Ignores the event. The event is not consumed.
   */
  mouseDown(sender, me) {
    return;
  }
  /**
   * Handles the event by highlighting the cell under the mouse pointer if it is over the hotspot region of the cell.
   */
  mouseMove(sender, me) {
    if (this.isEnabled()) {
      this.process(me);
    }
  }
  /**
   * Handles the event by resetting the highlight.
   */
  mouseUp(sender, me) {
    return;
  }
  /**
   * Destroys the object and all its resources and DOM nodes. This doesn't normally need to be called.
   * It is called automatically when the window unloads.
   */
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.graph.removeMouseListener(this);
      super.destroy();
    }
  }
}
class VertexHandle {
  constructor(state, cursor = "default", image = null, shape = null) {
    this.dependencies = ["snap", "cells"];
    this.cursor = "default";
    this.image = null;
    this.ignoreGrid = false;
    this.active = true;
    this.graph = state.view.graph;
    this.state = state;
    this.cursor = cursor;
    this.image = image;
    this.shape = shape;
    this.init();
  }
  /**
   * Hook for subclassers to return the current position of the handle.
   */
  getPosition(bounds) {
    return new Point();
  }
  /**
   * Hooks for subclassers to update the style in the <state>.
   */
  setPosition(bounds, pt, me) {
    return;
  }
  /**
   * Hook for subclassers to execute the handle.
   */
  execute(me) {
    return;
  }
  /**
   * Sets the cell style with the given name to the corresponding value in <state>.
   */
  copyStyle(key) {
    this.graph.setCellStyles(key, this.state.style[key], [this.state.cell]);
  }
  /**
   * Processes the given {@link MouseEvent} and invokes <setPosition>.
   */
  processEvent(me) {
    const { scale } = this.graph.view;
    const tr = this.graph.view.translate;
    let pt = new Point(me.getGraphX() / scale - tr.x, me.getGraphY() / scale - tr.y);
    if (this.shape != null && this.shape.bounds != null) {
      pt.x -= this.shape.bounds.width / scale / 4;
      pt.y -= this.shape.bounds.height / scale / 4;
    }
    const alpha1 = -toRadians(this.getRotation());
    const alpha2 = -toRadians(this.getTotalRotation()) - alpha1;
    pt = this.flipPoint(this.rotatePoint(this.snapPoint(this.rotatePoint(pt, alpha1), this.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())), alpha2));
    this.setPosition(this.state.getPaintBounds(), pt, me);
    this.redraw();
  }
  /**
   * Should be called after <setPosition> in <processEvent>.
   * This repaints the state using {@link CellRenderer}.
   */
  positionChanged() {
    if (this.state.text != null) {
      this.state.text.apply(this.state);
    }
    if (this.state.shape != null) {
      this.state.shape.apply(this.state);
    }
    this.graph.cellRenderer.redraw(this.state, true);
  }
  /**
   * Returns the rotation defined in the style of the cell.
   */
  getRotation() {
    if (this.state.shape != null) {
      return this.state.shape.getRotation();
    }
    return 0;
  }
  /**
   * Returns the rotation from the style and the rotation from the direction of
   * the cell.
   */
  getTotalRotation() {
    if (this.state.shape != null) {
      return this.state.shape.getShapeRotation();
    }
    return 0;
  }
  /**
   * Creates and initializes the shapes required for this handle.
   */
  init() {
    const html = this.isHtmlRequired();
    if (this.image) {
      this.shape = new ImageShape(new Rectangle(0, 0, this.image.width, this.image.height), this.image.src);
      this.shape.preserveImageAspect = false;
    } else if (!this.shape) {
      this.shape = this.createShape(html);
    }
    this.initShape(html);
  }
  /**
   * Creates and returns the shape for this handle.
   */
  createShape(_html) {
    const handleSize = HandleConfig.size;
    const bounds = new Rectangle(0, 0, handleSize, handleSize);
    return new RectangleShape(bounds, HandleConfig.fillColor, HandleConfig.strokeColor);
  }
  /**
   * Initializes <shape> and sets its cursor.
   */
  initShape(html) {
    const shape = this.shape;
    if (html && shape.isHtmlAllowed()) {
      shape.dialect = DIALECT.STRICTHTML;
      shape.init(this.graph.container);
    } else {
      shape.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
      if (this.cursor) {
        shape.init(this.graph.getView().getOverlayPane());
      }
    }
    InternalEvent.redirectMouseEvents(shape.node, this.graph, this.state);
    shape.node.style.cursor = this.cursor;
  }
  /**
   * Renders the shape for this handle.
   */
  redraw() {
    if (this.shape && this.state.shape) {
      let pt = this.getPosition(this.state.getPaintBounds());
      if (pt) {
        const alpha = toRadians(this.getTotalRotation());
        pt = this.rotatePoint(this.flipPoint(pt), alpha);
        const { scale } = this.graph.view;
        const tr = this.graph.view.translate;
        const shapeBounds = this.shape.bounds;
        shapeBounds.x = Math.floor((pt.x + tr.x) * scale - shapeBounds.width / 2);
        shapeBounds.y = Math.floor((pt.y + tr.y) * scale - shapeBounds.height / 2);
        this.shape.redraw();
      }
    }
  }
  /**
   * Returns true if this handle should be rendered in HTML. This returns true if
   * the text node is in the graph container.
   */
  isHtmlRequired() {
    return !!this.state.text && this.state.text.node.parentNode === this.graph.container;
  }
  /**
   * Rotates the point by the given angle.
   */
  rotatePoint(pt, alpha) {
    const bounds = this.state.getCellBounds();
    const cx = new Point(bounds.getCenterX(), bounds.getCenterY());
    const cos = Math.cos(alpha);
    const sin = Math.sin(alpha);
    return getRotatedPoint(pt, cos, sin, cx);
  }
  /**
   * Flips the given point vertically and/or horizontally.
   */
  flipPoint(pt) {
    if (this.state.shape) {
      const bounds = this.state.getCellBounds();
      if (this.state.shape.flipH) {
        pt.x = 2 * bounds.x + bounds.width - pt.x;
      }
      if (this.state.shape.flipV) {
        pt.y = 2 * bounds.y + bounds.height - pt.y;
      }
    }
    return pt;
  }
  /**
   * Snaps the given point to the grid if ignore is false. This modifies
   * the given point in-place and also returns it.
   */
  snapPoint(pt, ignore) {
    if (!ignore) {
      pt.x = this.graph.snap(pt.x);
      pt.y = this.graph.snap(pt.y);
    }
    return pt;
  }
  /**
   * Shows or hides this handle.
   */
  setVisible(visible) {
    if (this.shape && this.shape.node) {
      this.shape.node.style.display = visible ? "" : "none";
    }
  }
  /**
   * Resets the state of this handle by setting its visibility to true.
   */
  reset() {
    this.setVisible(true);
    this.state.style = this.graph.getCellStyle(this.state.cell);
    this.positionChanged();
  }
  /**
   * Destroys this handle.
   */
  destroy() {
    if (this.shape) {
      this.shape.destroy();
      this.shape = null;
    }
  }
}
class CircleLayout extends GraphLayout {
  /**
   * Constructs a new circular layout for the specified radius.
   *
   * @param graph {@link Graph} that contains the cells.
   * @param radius Optional radius as an int. Default is 100.
   */
  constructor(graph, radius = 100) {
    super(graph);
    this.moveCircle = false;
    this.x0 = 0;
    this.y0 = 0;
    this.resetEdges = true;
    this.disableEdgeStyle = true;
    this.radius = radius;
  }
  /**
   * Implements {@link GraphLayout#execute}.
   */
  execute(parent) {
    this.graph.batchUpdate(() => {
      let max = 0;
      let top = null;
      let left = null;
      const vertices = [];
      const childCount = parent.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        const cell = parent.getChildAt(i);
        if (!this.isVertexIgnored(cell)) {
          vertices.push(cell);
          const bounds = this.getVertexBounds(cell);
          if (top == null) {
            top = bounds.y;
          } else {
            top = Math.min(top, bounds.y);
          }
          if (left == null) {
            left = bounds.x;
          } else {
            left = Math.min(left, bounds.x);
          }
          max = Math.max(max, Math.max(bounds.width, bounds.height));
        } else if (!this.isEdgeIgnored(cell)) {
          if (this.resetEdges) {
            this.graph.resetEdge(cell);
          }
          if (this.disableEdgeStyle) {
            this.setEdgeStyleEnabled(cell, false);
          }
        }
      }
      const r = this.getRadius(vertices.length, max);
      if (this.moveCircle) {
        left = this.x0;
        top = this.y0;
      }
      this.circle(vertices, r, left, top);
    });
  }
  /**
   * Returns the radius to be used for the given vertex count. Max is the maximum
   * width or height of all vertices in the layout.
   */
  getRadius(count, max) {
    return Math.max(count * max / Math.PI, this.radius);
  }
  /**
   * Executes the circular layout for the specified array
   * of vertices and the given radius. This is called from
   * <execute>.
   */
  circle(vertices, r, left, top) {
    const vertexCount = vertices.length;
    const phi = 2 * Math.PI / vertexCount;
    vertices.forEach((vertex, i) => {
      if (this.isVertexMovable(vertex)) {
        this.setVertexLocation(vertex, Math.round(left + r + r * Math.sin(i * phi)), Math.round(top + r + r * Math.cos(i * phi)));
      }
    });
  }
}
class CompositeLayout extends GraphLayout {
  /**
   * Constructs a new layout using the given layouts. The graph instance is
   * required for creating the transaction that contains all layouts.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   * @param layouts Array of {@link GraphLayout}s.
   * @param master Optional layout that handles moves. If no layout is given, then the first layout of the above array is used to handle moves.
   */
  constructor(graph, layouts, master) {
    super(graph);
    this.layouts = layouts;
    this.master = master;
  }
  /**
   * Calls `move` on {@link master} or the first layout in {@link layouts}.
   */
  moveCell(cell, x, y) {
    if (this.master != null) {
      this.master.moveCell.apply(this.master, [cell, x, y]);
    } else {
      this.layouts[0].moveCell.apply(this.layouts[0], [cell, x, y]);
    }
  }
  /**
   * Implements {@link GraphLayout#execute} by executing all {@link layouts} in a single transaction.
   */
  execute(parent) {
    this.graph.batchUpdate(() => {
      for (let i = 0; i < this.layouts.length; i += 1) {
        this.layouts[i].execute.apply(this.layouts[i], [parent]);
      }
    });
  }
}
class EdgeLabelLayout extends GraphLayout {
  constructor(graph, radius) {
    super(graph);
  }
  /**
   * Implements {@link GraphLayout.execute}
   */
  execute(parent) {
    const { view } = this.graph;
    this.graph.getDataModel();
    const edges = [];
    const vertices = [];
    const childCount = parent.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      const cell = parent.getChildAt(i);
      const state = view.getState(cell);
      if (state != null) {
        if (!this.isVertexIgnored(cell)) {
          vertices.push(state);
        } else if (!this.isEdgeIgnored(cell)) {
          edges.push(state);
        }
      }
    }
    this.placeLabels(vertices, edges);
  }
  /**
   * Places the labels of the given edges.
   *
   * @param v   vertexes
   * @param e   edges
   */
  placeLabels(v, e) {
    this.graph.batchUpdate(() => {
      for (let i = 0; i < e.length; i += 1) {
        const edge = e[i];
        if (edge != null && edge.text != null && edge.text.boundingBox != null) {
          for (let j = 0; j < v.length; j += 1) {
            const vertex = v[j];
            if (vertex != null) {
              this.avoid(edge, vertex);
            }
          }
        }
      }
    });
  }
  /**
   * Places the labels of the given edges.
   */
  avoid(edge, vertex) {
    const model = this.graph.getDataModel();
    const labRect = edge.text.boundingBox;
    if (intersects$1(labRect, vertex)) {
      const dy1 = -labRect.y - labRect.height + vertex.y;
      const dy2 = -labRect.y + vertex.y + vertex.height;
      let dy = Math.abs(dy1) < Math.abs(dy2) ? dy1 : dy2;
      const dx1 = -labRect.x - labRect.width + vertex.x;
      const dx2 = -labRect.x + vertex.x + vertex.width;
      let dx = Math.abs(dx1) < Math.abs(dx2) ? dx1 : dx2;
      if (Math.abs(dx) < Math.abs(dy)) {
        dy = 0;
      } else {
        dx = 0;
      }
      let g = edge.cell.getGeometry();
      if (g != null) {
        g = g.clone();
        if (g.offset != null) {
          g.offset.x += dx;
          g.offset.y += dy;
        } else {
          g.offset = new Point(dx, dy);
        }
        model.setGeometry(edge.cell, g);
      }
    }
  }
}
class MxFastOrganicLayout extends GraphLayout {
  constructor(graph) {
    super(graph);
    this.useInputOrigin = true;
    this.resetEdges = true;
    this.disableEdgeStyle = true;
    this.forceConstant = 50;
    this.forceConstantSquared = 0;
    this.minDistanceLimit = 2;
    this.maxDistanceLimit = 500;
    this.minDistanceLimitSquared = 4;
    this.initialTemp = 200;
    this.temperature = 0;
    this.maxIterations = 0;
    this.iteration = 0;
    this.vertexArray = [];
    this.dispX = [];
    this.dispY = [];
    this.cellLocation = [];
    this.radius = [];
    this.radiusSquared = [];
    this.isMoveable = [];
    this.neighbours = {};
    this.indices = {};
    this.allowedToRun = true;
  }
  /**
   * Returns a boolean indicating if the given <Cell> should be ignored as a
   * vertex. This returns true if the cell has no connections.
   *
   * @param vertex <Cell> whose ignored state should be returned.
   */
  isVertexIgnored(vertex) {
    return super.isVertexIgnored(vertex) || this.graph.getConnections(vertex).length === 0;
  }
  /**
   * Implements {@link GraphLayout#execute}. This operates on all children of the
   * given parent where <isVertexIgnored> returns false.
   */
  execute(parent) {
    this.vertexArray = [];
    let cells = this.graph.getChildVertices(parent);
    for (let i = 0; i < cells.length; i += 1) {
      if (!this.isVertexIgnored(cells[i])) {
        this.vertexArray.push(cells[i]);
      }
    }
    const initialBounds = this.useInputOrigin ? this.graph.getBoundingBoxFromGeometry(this.vertexArray) : null;
    const n = this.vertexArray.length;
    this.indices = {};
    this.dispX = [];
    this.dispY = [];
    this.cellLocation = [];
    this.isMoveable = [];
    this.neighbours = {};
    this.radius = [];
    this.radiusSquared = [];
    if (this.forceConstant < 1e-3) {
      this.forceConstant = 1e-3;
    }
    this.forceConstantSquared = this.forceConstant * this.forceConstant;
    for (let i = 0; i < this.vertexArray.length; i += 1) {
      const vertex = this.vertexArray[i];
      this.cellLocation[i] = [];
      const id = ObjectIdentity.get(vertex);
      this.indices[id] = i;
      const bounds = this.getVertexBounds(vertex);
      const { width } = bounds;
      const { height } = bounds;
      const { x } = bounds;
      const { y } = bounds;
      this.cellLocation[i][0] = x + width / 2;
      this.cellLocation[i][1] = y + height / 2;
      this.radius[i] = Math.min(width, height);
      this.radiusSquared[i] = this.radius[i] * this.radius[i];
    }
    this.graph.batchUpdate(() => {
      for (let i = 0; i < n; i += 1) {
        this.dispX[i] = 0;
        this.dispY[i] = 0;
        this.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);
        const edges = this.graph.getConnections(this.vertexArray[i], parent);
        cells = this.graph.getOpposites(edges, this.vertexArray[i]);
        this.neighbours[i] = [];
        for (let j = 0; j < cells.length; j += 1) {
          if (this.resetEdges) {
            this.graph.resetEdge(edges[j]);
          }
          if (this.disableEdgeStyle) {
            this.setEdgeStyleEnabled(edges[j], false);
          }
          const id = ObjectIdentity.get(cells[j]);
          const index = this.indices[id];
          if (index != null) {
            this.neighbours[i][j] = index;
          } else {
            this.neighbours[i][j] = i;
          }
        }
      }
      this.temperature = this.initialTemp;
      if (this.maxIterations === 0) {
        this.maxIterations = 20 * Math.sqrt(n);
      }
      for (this.iteration = 0; this.iteration < this.maxIterations; this.iteration += 1) {
        if (!this.allowedToRun) {
          return;
        }
        this.calcRepulsion();
        this.calcAttraction();
        this.calcPositions();
        this.reduceTemperature();
      }
      let minx = null;
      let miny = null;
      for (let i = 0; i < this.vertexArray.length; i += 1) {
        const vertex = this.vertexArray[i];
        if (this.isVertexMovable(vertex)) {
          const bounds = this.getVertexBounds(vertex);
          if (bounds != null) {
            this.cellLocation[i][0] -= bounds.width / 2;
            this.cellLocation[i][1] -= bounds.height / 2;
            const x = this.graph.snap(Math.round(this.cellLocation[i][0]));
            const y = this.graph.snap(Math.round(this.cellLocation[i][1]));
            this.setVertexLocation(vertex, x, y);
            if (minx == null) {
              minx = x;
            } else {
              minx = Math.min(minx, x);
            }
            if (miny == null) {
              miny = y;
            } else {
              miny = Math.min(miny, y);
            }
          }
        }
      }
      let dx = -(minx || 0) + 1;
      let dy = -(miny || 0) + 1;
      if (initialBounds != null) {
        dx += initialBounds.x;
        dy += initialBounds.y;
      }
      this.graph.moveCells(this.vertexArray, dx, dy);
    });
  }
  /**
   * Takes the displacements calculated for each cell and applies them to the
   * local cache of cell positions. Limits the displacement to the current
   * temperature.
   */
  calcPositions() {
    for (let index = 0; index < this.vertexArray.length; index += 1) {
      if (this.isMoveable[index]) {
        let deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] + this.dispY[index] * this.dispY[index]);
        if (deltaLength < 1e-3) {
          deltaLength = 1e-3;
        }
        const newXDisp = this.dispX[index] / deltaLength * Math.min(deltaLength, this.temperature);
        const newYDisp = this.dispY[index] / deltaLength * Math.min(deltaLength, this.temperature);
        this.dispX[index] = 0;
        this.dispY[index] = 0;
        this.cellLocation[index][0] += newXDisp;
        this.cellLocation[index][1] += newYDisp;
      }
    }
  }
  /**
   * Calculates the attractive forces between all laid out nodes linked by
   * edges
   */
  calcAttraction() {
    for (let i = 0; i < this.vertexArray.length; i += 1) {
      for (let k = 0; k < this.neighbours[i].length; k += 1) {
        const j = this.neighbours[i][k];
        if (i !== j && this.isMoveable[i] && this.isMoveable[j]) {
          const xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];
          const yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];
          let deltaLengthSquared = xDelta * xDelta + yDelta * yDelta - this.radiusSquared[i] - this.radiusSquared[j];
          if (deltaLengthSquared < this.minDistanceLimitSquared) {
            deltaLengthSquared = this.minDistanceLimitSquared;
          }
          const deltaLength = Math.sqrt(deltaLengthSquared);
          const force = deltaLengthSquared / this.forceConstant;
          const displacementX = xDelta / deltaLength * force;
          const displacementY = yDelta / deltaLength * force;
          this.dispX[i] -= displacementX;
          this.dispY[i] -= displacementY;
          this.dispX[j] += displacementX;
          this.dispY[j] += displacementY;
        }
      }
    }
  }
  /**
   * Calculates the repulsive forces between all laid out nodes
   */
  calcRepulsion() {
    const vertexCount = this.vertexArray.length;
    for (let i = 0; i < vertexCount; i += 1) {
      for (let j = i; j < vertexCount; j += 1) {
        if (!this.allowedToRun) {
          return;
        }
        if (j !== i && this.isMoveable[i] && this.isMoveable[j]) {
          let xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];
          let yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];
          if (xDelta === 0) {
            xDelta = 0.01 + Math.random();
          }
          if (yDelta === 0) {
            yDelta = 0.01 + Math.random();
          }
          const deltaLength = Math.sqrt(xDelta * xDelta + yDelta * yDelta);
          let deltaLengthWithRadius = deltaLength - this.radius[i] - this.radius[j];
          if (deltaLengthWithRadius > this.maxDistanceLimit) {
            continue;
          }
          if (deltaLengthWithRadius < this.minDistanceLimit) {
            deltaLengthWithRadius = this.minDistanceLimit;
          }
          const force = this.forceConstantSquared / deltaLengthWithRadius;
          const displacementX = xDelta / deltaLength * force;
          const displacementY = yDelta / deltaLength * force;
          this.dispX[i] += displacementX;
          this.dispY[i] += displacementY;
          this.dispX[j] -= displacementX;
          this.dispY[j] -= displacementY;
        }
      }
    }
  }
  /**
   * Reduces the temperature of the layout from an initial setting in a linear
   * fashion to zero.
   */
  reduceTemperature() {
    this.temperature = this.initialTemp * (1 - this.iteration / this.maxIterations);
  }
}
class ParallelEdgeLayout extends GraphLayout {
  constructor(graph) {
    super(graph);
    this.spacing = 20;
    this.checkOverlap = false;
  }
  /**
   * Implements {@link GraphLayout#execute}.
   */
  execute(parent, cells = null) {
    const lookup = this.findParallels(parent, cells);
    this.graph.batchUpdate(() => {
      for (const i in lookup) {
        const parallels = lookup[i];
        if (parallels.length > 1) {
          this.layout(parallels);
        }
      }
    });
  }
  /**
   * Finds the parallel edges in the given parent.
   */
  findParallels(parent, cells = null) {
    const lookup = [];
    const addCell = (cell) => {
      if (!this.isEdgeIgnored(cell)) {
        const id = this.getEdgeId(cell);
        if (id != null) {
          if (lookup[id] == null) {
            lookup[id] = [];
          }
          lookup[id].push(cell);
        }
      }
    };
    if (cells != null) {
      for (let i = 0; i < cells.length; i += 1) {
        addCell(cells[i]);
      }
    } else {
      this.graph.getDataModel();
      const childCount = parent.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        addCell(parent.getChildAt(i));
      }
    }
    return lookup;
  }
  /**
   * Returns a unique ID for the given edge. The id is independent of the
   * edge direction and is built using the visible terminal of the given
   * edge.
   */
  getEdgeId(edge) {
    const view = this.graph.getView();
    let src = view.getVisibleTerminal(edge, true);
    let trg = view.getVisibleTerminal(edge, false);
    let pts = "";
    if (src != null && trg != null) {
      src = ObjectIdentity.get(src);
      trg = ObjectIdentity.get(trg);
      if (this.checkOverlap) {
        const state = this.graph.view.getState(edge);
        if (state != null && state.absolutePoints != null) {
          const tmp = [];
          for (let i = 0; i < state.absolutePoints.length; i += 1) {
            const pt = state.absolutePoints[i];
            if (pt != null) {
              tmp.push(pt.x, pt.y);
            }
          }
          pts = tmp.join(",");
        }
      }
      return (src > trg ? `${trg}-${src}` : `${src}-${trg}`) + pts;
    }
    return null;
  }
  /**
   * Lays out the parallel edges in the given array.
   */
  layout(parallels) {
    const edge = parallels[0];
    const view = this.graph.getView();
    this.graph.getDataModel();
    const src = view.getVisibleTerminal(edge, true).getGeometry();
    const trg = view.getVisibleTerminal(edge, false).getGeometry();
    let x0;
    let y0;
    if (src === trg) {
      x0 = src.x + src.width + this.spacing;
      y0 = src.y + src.height / 2;
      for (let i = 0; i < parallels.length; i += 1) {
        this.route(parallels[i], x0, y0);
        x0 += this.spacing;
      }
    } else if (src != null && trg != null) {
      const scx = src.x + src.width / 2;
      const scy = src.y + src.height / 2;
      const tcx = trg.x + trg.width / 2;
      const tcy = trg.y + trg.height / 2;
      const dx = tcx - scx;
      const dy = tcy - scy;
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len > 0) {
        x0 = scx + dx / 2;
        y0 = scy + dy / 2;
        const nx = dy * this.spacing / len;
        const ny = dx * this.spacing / len;
        x0 += nx * (parallels.length - 1) / 2;
        y0 -= ny * (parallels.length - 1) / 2;
        for (let i = 0; i < parallels.length; i += 1) {
          this.route(parallels[i], x0, y0);
          x0 -= nx;
          y0 += ny;
        }
      }
    }
  }
  /**
   * Routes the given edge via the given point.
   */
  route(edge, x, y) {
    if (this.graph.isCellMovable(edge)) {
      this.setEdgePoints(edge, [new Point(x, y)]);
    }
  }
}
class PartitionLayout extends GraphLayout {
  constructor(graph, horizontal = true, spacing = 0, border = 0) {
    super(graph);
    this.resizeVertices = true;
    this.horizontal = horizontal != null ? horizontal : true;
    this.spacing = spacing || 0;
    this.border = border || 0;
  }
  /**
   * Returns <horizontal>.
   */
  isHorizontal() {
    return this.horizontal;
  }
  /**
   * Implements {@link GraphLayout.moveCell}.
   *
   * @param {mxCell} cell
   * @param {number} x
   * @param {number} y
   * @memberof mxPartitionLayout
   */
  moveCell(cell, x, y) {
    const model = this.graph.getDataModel();
    const parent = cell.getParent();
    if (cell != null && parent != null) {
      let i = 0;
      let last = 0;
      const childCount = parent.getChildCount();
      for (i = 0; i < childCount; i += 1) {
        const child = parent.getChildAt(i);
        const bounds = this.getVertexBounds(child);
        if (bounds != null) {
          const tmp = bounds.x + bounds.width / 2;
          if (last < x && tmp > x) {
            break;
          }
          last = tmp;
        }
      }
      let idx = parent.getIndex(cell);
      idx = Math.max(0, i - (i > idx ? 1 : 0));
      model.add(parent, cell, idx);
    }
  }
  /**
   * Implements {@link GraphLayout#execute}. All children where <isVertexIgnored>
   * returns false and <isVertexMovable> returns true are modified.
   */
  execute(parent) {
    const horizontal = this.isHorizontal();
    const model = this.graph.getDataModel();
    let pgeo = parent.getGeometry();
    if (this.graph.container != null && (pgeo == null && model.isLayer(parent) || parent === this.graph.getView().currentRoot)) {
      const width = this.graph.container.offsetWidth - 1;
      const height = this.graph.container.offsetHeight - 1;
      pgeo = new Rectangle(0, 0, width, height);
    }
    if (pgeo != null) {
      const children = [];
      const childCount = parent.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        const child = parent.getChildAt(i);
        if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {
          children.push(child);
        }
      }
      const n = children.length;
      if (n > 0) {
        let x0 = this.border;
        let y0 = this.border;
        let other = horizontal ? pgeo.height : pgeo.width;
        other -= 2 * this.border;
        const size = this.graph.isSwimlane(parent) ? this.graph.getStartSize(parent) : new Rectangle();
        other -= horizontal ? size.height : size.width;
        x0 += size.width;
        y0 += size.height;
        const tmp = this.border + (n - 1) * this.spacing;
        const value = horizontal ? (pgeo.width - x0 - tmp) / n : (pgeo.height - y0 - tmp) / n;
        if (value > 0) {
          model.beginUpdate();
          try {
            for (let i = 0; i < n; i += 1) {
              const child = children[i];
              let geo = child.getGeometry();
              if (geo != null) {
                geo = geo.clone();
                geo.x = x0;
                geo.y = y0;
                if (horizontal) {
                  if (this.resizeVertices) {
                    geo.width = value;
                    geo.height = other;
                  }
                  x0 += value + this.spacing;
                } else {
                  if (this.resizeVertices) {
                    geo.height = value;
                    geo.width = other;
                  }
                  y0 += value + this.spacing;
                }
                model.setGeometry(child, geo);
              }
            }
          } finally {
            model.endUpdate();
          }
        }
      }
    }
  }
}
class RadialTreeLayout extends CompactTreeLayout {
  constructor(graph) {
    super(graph, false);
    this.centerX = null;
    this.centerY = null;
    this.angleOffset = 0.5;
    this.rootx = 0;
    this.rooty = 0;
    this.levelDistance = 120;
    this.nodeDistance = 10;
    this.autoRadius = false;
    this.sortEdges = false;
    this.rowMinX = {};
    this.rowMaxX = {};
    this.rowMinCenX = {};
    this.rowMaxCenX = {};
    this.rowRadi = {};
    this.row = [];
  }
  /**
   * Returns a boolean indicating if the given {@link mxCell} should be ignored as a vertex.
   *
   * @param vertex {@link mxCell} whose ignored state should be returned.
   * @return true if the cell has no connections.
   */
  isVertexIgnored(vertex) {
    return super.isVertexIgnored(vertex) || this.graph.getConnections(vertex).length === 0;
  }
  /**
   * Implements {@link GraphLayout#execute}.
   *
   * If the parent has any connected edges, then it is used as the root of
   * the tree. Else, {@link Graph#findTreeRoots} will be used to find a suitable
   * root node within the set of children of the given parent.
   *
   * @param parent    {@link mxCell} whose children should be laid out.
   * @param root      Optional {@link mxCell} that will be used as the root of the tree.
   */
  execute(parent, root = null) {
    this.parent = parent;
    this.useBoundingBox = false;
    this.edgeRouting = false;
    super.execute(parent, root || void 0);
    let bounds = null;
    const rootBounds = this.getVertexBounds(this.root);
    this.centerX = rootBounds.x + rootBounds.width / 2;
    this.centerY = rootBounds.y + rootBounds.height / 2;
    for (const vertex in this.visited) {
      const vertexBounds = this.getVertexBounds(this.visited[vertex]);
      bounds = bounds != null ? bounds : vertexBounds.clone();
      bounds.add(vertexBounds);
    }
    this.calcRowDims([this.node], 0);
    let maxLeftGrad = 0;
    let maxRightGrad = 0;
    for (let i = 0; i < this.row.length; i += 1) {
      const leftGrad = (this.centerX - this.rowMinX[i] - this.nodeDistance) / this.rowRadi[i];
      const rightGrad = (this.rowMaxX[i] - this.centerX - this.nodeDistance) / this.rowRadi[i];
      maxLeftGrad = Math.max(maxLeftGrad, leftGrad);
      maxRightGrad = Math.max(maxRightGrad, rightGrad);
    }
    for (let i = 0; i < this.row.length; i += 1) {
      const xLeftLimit = this.centerX - this.nodeDistance - maxLeftGrad * this.rowRadi[i];
      const xRightLimit = this.centerX + this.nodeDistance + maxRightGrad * this.rowRadi[i];
      const fullWidth = xRightLimit - xLeftLimit;
      for (let j = 0; j < this.row[i].length; j++) {
        const row = this.row[i];
        const node = row[j];
        const vertexBounds = this.getVertexBounds(node.cell);
        const xProportion = (vertexBounds.x + vertexBounds.width / 2 - xLeftLimit) / fullWidth;
        const theta = 2 * Math.PI * xProportion;
        node.theta = theta;
      }
    }
    for (let i = this.row.length - 2; i >= 0; i--) {
      const row = this.row[i];
      for (let j = 0; j < row.length; j++) {
        const node = row[j];
        let { child } = node;
        let counter = 0;
        let totalTheta = 0;
        while (child != null) {
          totalTheta += child.theta;
          counter++;
          child = child.next;
        }
        if (counter > 0) {
          const averTheta = totalTheta / counter;
          if (averTheta > node.theta && j < row.length - 1) {
            const nextTheta = row[j + 1].theta;
            node.theta = Math.min(averTheta, nextTheta - Math.PI / 10);
          } else if (averTheta < node.theta && j > 0) {
            const lastTheta = row[j - 1].theta;
            node.theta = Math.max(averTheta, lastTheta + Math.PI / 10);
          }
        }
      }
    }
    for (let i = 0; i < this.row.length; i += 1) {
      for (let j = 0; j < this.row[i].length; j++) {
        const row = this.row[i];
        const node = row[j];
        const vertexBounds = this.getVertexBounds(node.cell);
        this.setVertexLocation(node.cell, this.centerX - vertexBounds.width / 2 + this.rowRadi[i] * Math.cos(node.theta), this.centerY - vertexBounds.height / 2 + this.rowRadi[i] * Math.sin(node.theta));
      }
    }
  }
  /**
   * Recursive function to calculate the dimensions of each row
   *
   * @param row      Array of internal nodes, the children of which are to be processed.
   * @param rowNum   Integer indicating which row is being processed.
   */
  calcRowDims(row, rowNum) {
    if (row == null || row.length === 0) {
      return;
    }
    this.rowMinX[rowNum] = this.centerX;
    this.rowMaxX[rowNum] = this.centerX;
    this.rowMinCenX[rowNum] = this.centerX;
    this.rowMaxCenX[rowNum] = this.centerX;
    this.row[rowNum] = [];
    let rowHasChildren = false;
    for (let i = 0; i < row.length; i += 1) {
      let child = row[i] != null ? row[i].child : null;
      while (child != null) {
        const { cell } = child;
        const vertexBounds = this.getVertexBounds(cell);
        this.rowMinX[rowNum] = Math.min(vertexBounds.x, this.rowMinX[rowNum]);
        this.rowMaxX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width, this.rowMaxX[rowNum]);
        this.rowMinCenX[rowNum] = Math.min(vertexBounds.x + vertexBounds.width / 2, this.rowMinCenX[rowNum]);
        this.rowMaxCenX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width / 2, this.rowMaxCenX[rowNum]);
        this.rowRadi[rowNum] = vertexBounds.y - this.getVertexBounds(this.root).y;
        if (child.child != null) {
          rowHasChildren = true;
        }
        this.row[rowNum].push(child);
        child = child.next;
      }
    }
    if (rowHasChildren) {
      this.calcRowDims(this.row[rowNum], rowNum + 1);
    }
  }
}
const HierarchicalEdgeStyle = {
  ORTHOGONAL: 1,
  POLYLINE: 2,
  STRAIGHT: 3,
  CURVE: 4
};
class GraphAbstractHierarchyCell extends Cell {
  constructor() {
    super();
    this.swimlaneIndex = null;
    this.maxRank = -1;
    this.minRank = -1;
    this.width = 0;
    this.height = 0;
    this.nextLayerConnectedCells = null;
    this.previousLayerConnectedCells = null;
    this.x = [];
    this.y = [];
    this.temp = [];
  }
  /**
   * Returns whether or not this cell is an edge
   */
  isEdge() {
    return false;
  }
  /**
   * Returns whether or not this cell is a node
   */
  isVertex() {
    return false;
  }
  /**
   * Set the value of x for the specified layer
   */
  setX(layer, value) {
    if (this.isVertex()) {
      this.x[0] = value;
    } else if (this.isEdge()) {
      this.x[layer - this.minRank - 1] = value;
    }
  }
  /**
   * Gets the value of x on the specified layer
   */
  getX(layer) {
    if (this.isVertex()) {
      return this.x[0];
    }
    if (this.isEdge()) {
      return this.x[layer - this.minRank - 1];
    }
    return 0;
  }
  /**
   * Set the value of y for the specified layer
   */
  setY(layer, value) {
    if (this.isVertex()) {
      this.y[0] = value;
    } else if (this.isEdge()) {
      this.y[layer - this.minRank - 1] = value;
    }
  }
}
class GraphHierarchyNode extends GraphAbstractHierarchyCell {
  /**
   * Constructs an internal node to represent the specified real graph cell
   *
   * @param cell the real graph cell this node represents
   */
  constructor(cell) {
    super();
    this.ids = [];
    this.hashCode = false;
    this.cell = cell;
    this.id = ObjectIdentity.get(cell);
    this.connectsAsTarget = [];
    this.connectsAsSource = [];
  }
  /**
   * Returns the integer value of the layer that this node resides in
   */
  getRankValue(layer) {
    return this.maxRank;
  }
  /**
   * Returns the cells this cell connects to on the next layer up
   */
  getNextLayerConnectedCells(layer) {
    if (this.nextLayerConnectedCells == null) {
      this.nextLayerConnectedCells = {};
      this.nextLayerConnectedCells[0] = [];
      for (let i = 0; i < this.connectsAsTarget.length; i += 1) {
        const edge = this.connectsAsTarget[i];
        if (edge.maxRank === -1 || edge.maxRank === layer + 1) {
          this.nextLayerConnectedCells[0].push(edge.source);
        } else {
          this.nextLayerConnectedCells[0].push(edge);
        }
      }
    }
    return this.nextLayerConnectedCells[0];
  }
  /**
   * Returns the cells this cell connects to on the next layer down
   */
  getPreviousLayerConnectedCells(layer) {
    if (this.previousLayerConnectedCells == null) {
      this.previousLayerConnectedCells = [];
      this.previousLayerConnectedCells[0] = [];
      for (let i = 0; i < this.connectsAsSource.length; i += 1) {
        const edge = this.connectsAsSource[i];
        if (edge.minRank === -1 || edge.minRank === layer - 1) {
          this.previousLayerConnectedCells[0].push(edge.target);
        } else {
          this.previousLayerConnectedCells[0].push(edge);
        }
      }
    }
    return this.previousLayerConnectedCells[0];
  }
  /**
   * Returns true.
   */
  isVertex() {
    return true;
  }
  /**
   * Gets the value of temp for the specified layer
   */
  getGeneralPurposeVariable(layer) {
    return this.temp[0];
  }
  /**
   * Set the value of temp for the specified layer
   */
  setGeneralPurposeVariable(layer, value) {
    this.temp[0] = value;
  }
  isAncestor(otherNode) {
    if (otherNode != null && this.hashCode != null && otherNode.hashCode != null && this.hashCode.length < otherNode.hashCode.length) {
      if (this.hashCode === otherNode.hashCode) {
        return true;
      }
      if (this.hashCode == null || this.hashCode == null) {
        return false;
      }
      for (let i = 0; i < this.hashCode.length; i += 1) {
        if (this.hashCode[i] !== otherNode.hashCode[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Gets the core vertex associated with this wrapper
   */
  getCoreCell() {
    return this.cell;
  }
}
class GraphHierarchyEdge extends GraphAbstractHierarchyCell {
  /**
   * Constructs a hierarchy edge
   *
   * @param edges a list of real graph edges this abstraction represents
   */
  constructor(edges) {
    super();
    this.source = null;
    this.target = null;
    this.isReversed = false;
    this.edges = edges;
    this.ids = [];
    for (let i = 0; i < edges.length; i += 1) {
      this.ids.push(ObjectIdentity.get(edges[i]));
    }
  }
  /**
   * Inverts the direction of this internal edge(s)
   */
  invert() {
    const temp = this.source;
    this.source = this.target;
    this.target = temp;
    this.isReversed = !this.isReversed;
  }
  /**
   * Returns the cells this cell connects to on the next layer up
   */
  getNextLayerConnectedCells(layer) {
    if (this.nextLayerConnectedCells == null) {
      this.nextLayerConnectedCells = [];
      for (let i = 0; i < this.temp.length; i += 1) {
        this.nextLayerConnectedCells[i] = [];
        if (i === this.temp.length - 1) {
          this.nextLayerConnectedCells[i].push(this.source);
        } else {
          this.nextLayerConnectedCells[i].push(this);
        }
      }
    }
    return this.nextLayerConnectedCells[layer - this.minRank - 1];
  }
  /**
   * Returns the cells this cell connects to on the next layer down
   */
  getPreviousLayerConnectedCells(layer) {
    if (this.previousLayerConnectedCells == null) {
      this.previousLayerConnectedCells = [];
      for (let i = 0; i < this.temp.length; i += 1) {
        this.previousLayerConnectedCells[i] = [];
        if (i === 0) {
          this.previousLayerConnectedCells[i].push(this.target);
        } else {
          this.previousLayerConnectedCells[i].push(this);
        }
      }
    }
    return this.previousLayerConnectedCells[layer - this.minRank - 1];
  }
  /**
   * Returns true.
   */
  isEdge() {
    return true;
  }
  /**
   * Gets the value of temp for the specified layer
   */
  getGeneralPurposeVariable(layer) {
    return this.temp[layer - this.minRank - 1];
  }
  /**
   * Set the value of temp for the specified layer
   */
  setGeneralPurposeVariable(layer, value) {
    this.temp[layer - this.minRank - 1] = value;
  }
  /**
   * Gets the first core edge associated with this wrapper
   */
  getCoreCell() {
    if (this.edges.length > 0) {
      return this.edges[0];
    }
    return null;
  }
}
class GraphHierarchyModel {
  /**
   *
   * Creates an internal ordered graph model using the vertices passed in. If
   * there are any, leftward edge need to be inverted in the internal model
   *
   * @param layout
   * @param vertices the vertices for this hierarchy
   * @param roots
   * @param parent
   * @param tightenToSource whether or not to tighten vertices towards the sources
   */
  constructor(layout, vertices, roots, parent, tightenToSource) {
    this.ranks = null;
    this.roots = null;
    this.parent = null;
    this.dfsCount = 0;
    this.SOURCESCANSTARTRANK = 1e8;
    this.tightenToSource = false;
    const graph = layout.getGraph();
    this.tightenToSource = tightenToSource;
    this.roots = roots;
    this.parent = parent;
    this.vertexMapper = new Dictionary();
    this.edgeMapper = new Dictionary();
    this.maxRank = 0;
    const internalVertices = {};
    if (vertices == null) {
      vertices = graph.getChildVertices(parent);
    }
    this.maxRank = this.SOURCESCANSTARTRANK;
    this.createInternalCells(layout, vertices, internalVertices);
    for (let i = 0; i < vertices.length; i += 1) {
      const edges = internalVertices[i].connectsAsSource;
      for (let j = 0; j < edges.length; j++) {
        const internalEdge = edges[j];
        const realEdges = internalEdge.edges;
        if (realEdges != null && realEdges.length > 0) {
          const realEdge = realEdges[0];
          let targetCell = layout.getVisibleTerminal(realEdge, false);
          let internalTargetCell = this.vertexMapper.get(targetCell);
          if (internalVertices[i] === internalTargetCell) {
            targetCell = layout.getVisibleTerminal(realEdge, true);
            internalTargetCell = this.vertexMapper.get(targetCell);
          }
          if (internalTargetCell != null && internalVertices[i] !== internalTargetCell) {
            internalEdge.target = internalTargetCell;
            if (internalTargetCell.connectsAsTarget.length === 0) {
              internalTargetCell.connectsAsTarget = [];
            }
            if (internalTargetCell.connectsAsTarget.indexOf(internalEdge) < 0) {
              internalTargetCell.connectsAsTarget.push(internalEdge);
            }
          }
        }
      }
      internalVertices[i].temp[0] = 1;
    }
  }
  /**
   * Creates all edges in the internal model
   *
   * @param layout Reference to the <HierarchicalLayout> algorithm.
   * @param vertices Array of {@link Cells} that represent the vertices whom are to
   * have an internal representation created.
   * @param internalVertices The array of {@link GraphHierarchyNodes} to have their
   * information filled in using the real vertices.
   */
  createInternalCells(layout, vertices, internalVertices) {
    const graph = layout.getGraph();
    for (let i = 0; i < vertices.length; i += 1) {
      internalVertices[i] = new GraphHierarchyNode(vertices[i]);
      this.vertexMapper.put(vertices[i], internalVertices[i]);
      const conns = layout.getEdges(vertices[i]);
      internalVertices[i].connectsAsSource = [];
      for (let j = 0; j < conns.length; j++) {
        const cell = layout.getVisibleTerminal(conns[j], false);
        if (cell !== vertices[i] && cell.isVertex() && !layout.isVertexIgnored(cell)) {
          const undirectedEdges = layout.getEdgesBetween(vertices[i], cell, false);
          const directedEdges = layout.getEdgesBetween(vertices[i], cell, true);
          if (undirectedEdges != null && undirectedEdges.length > 0 && this.edgeMapper.get(undirectedEdges[0]) == null && directedEdges.length * 2 >= undirectedEdges.length) {
            const internalEdge = new GraphHierarchyEdge(undirectedEdges);
            for (let k = 0; k < undirectedEdges.length; k++) {
              const edge = undirectedEdges[k];
              this.edgeMapper.put(edge, internalEdge);
              graph.resetEdge(edge);
              if (layout.disableEdgeStyle) {
                layout.setEdgeStyleEnabled(edge, false);
                layout.setOrthogonalEdge(edge, true);
              }
            }
            internalEdge.source = internalVertices[i];
            if (internalVertices[i].connectsAsSource.indexOf(internalEdge) < 0) {
              internalVertices[i].connectsAsSource.push(internalEdge);
            }
          }
        }
      }
      internalVertices[i].temp[0] = 0;
    }
  }
  /**
   * Basic determination of minimum layer ranking by working from from sources
   * or sinks and working through each node in the relevant edge direction.
   * Starting at the sinks is basically a longest path layering algorithm.
   */
  initialRank() {
    const startNodes = [];
    if (this.roots != null) {
      for (let i = 0; i < this.roots.length; i += 1) {
        const internalNode = this.vertexMapper.get(this.roots[i]);
        if (internalNode != null) {
          startNodes.push(internalNode);
        }
      }
    }
    const internalNodes = this.vertexMapper.getValues();
    for (let i = 0; i < internalNodes.length; i += 1) {
      internalNodes[i].temp[0] = -1;
    }
    const startNodesCopy = startNodes.slice();
    while (startNodes.length > 0) {
      const internalNode = startNodes[0];
      const layerDeterminingEdges = internalNode.connectsAsTarget;
      const edgesToBeMarked = internalNode.connectsAsSource;
      let allEdgesScanned = true;
      let minimumLayer = this.SOURCESCANSTARTRANK;
      for (let i = 0; i < layerDeterminingEdges.length; i += 1) {
        const internalEdge = layerDeterminingEdges[i];
        if (internalEdge.temp[0] === 5270620) {
          const otherNode = internalEdge.source;
          minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);
        } else {
          allEdgesScanned = false;
          break;
        }
      }
      if (allEdgesScanned) {
        internalNode.temp[0] = minimumLayer;
        this.maxRank = Math.min(this.maxRank, minimumLayer);
        if (edgesToBeMarked != null) {
          for (let i = 0; i < edgesToBeMarked.length; i += 1) {
            const internalEdge = edgesToBeMarked[i];
            internalEdge.temp[0] = 5270620;
            const otherNode = internalEdge.target;
            if (otherNode.temp[0] === -1) {
              startNodes.push(otherNode);
              otherNode.temp[0] = -2;
            }
          }
        }
        startNodes.shift();
      } else {
        const removedCell = startNodes.shift();
        startNodes.push(internalNode);
        if (removedCell === internalNode && startNodes.length === 1) {
          break;
        }
      }
    }
    for (let i = 0; i < internalNodes.length; i += 1) {
      internalNodes[i].temp[0] -= this.maxRank;
    }
    for (let i = 0; i < startNodesCopy.length; i += 1) {
      const internalNode = startNodesCopy[i];
      let currentMaxLayer = 0;
      const layerDeterminingEdges = internalNode.connectsAsSource;
      for (let j = 0; j < layerDeterminingEdges.length; j++) {
        const internalEdge = layerDeterminingEdges[j];
        const otherNode = internalEdge.target;
        internalNode.temp[0] = Math.max(currentMaxLayer, otherNode.temp[0] + 1);
        currentMaxLayer = internalNode.temp[0];
      }
    }
    this.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;
  }
  /**
   * Fixes the layer assignments to the values stored in the nodes. Also needs
   * to create dummy nodes for edges that cross layers.
   */
  fixRanks() {
    const rankList = {};
    this.ranks = [];
    for (let i = 0; i < this.maxRank + 1; i += 1) {
      rankList[i] = [];
      this.ranks.push(rankList[i]);
    }
    let rootsArray = null;
    if (this.roots != null) {
      const oldRootsArray = this.roots;
      rootsArray = [];
      for (let i = 0; i < oldRootsArray.length; i += 1) {
        const cell = oldRootsArray[i];
        const internalNode = this.vertexMapper.get(cell);
        rootsArray[i] = internalNode;
      }
    }
    this.visit((parent, node, edge, layer, seen) => {
      if (seen == 0 && node.maxRank < 0 && node.minRank < 0) {
        rankList[node.temp[0]].push(node);
        node.maxRank = node.temp[0];
        node.minRank = node.temp[0];
        node.temp[0] = rankList[node.maxRank].length - 1;
      }
      if (parent != null && edge != null) {
        const parentToCellRankDifference = parent.maxRank - node.maxRank;
        if (parentToCellRankDifference > 1) {
          edge.maxRank = parent.maxRank;
          edge.minRank = node.maxRank;
          edge.temp = [];
          edge.x = [];
          edge.y = [];
          for (let i = edge.minRank + 1; i < edge.maxRank; i += 1) {
            rankList[i].push(edge);
            edge.setGeneralPurposeVariable(i, rankList[i].length - 1);
          }
        }
      }
    }, rootsArray, false, null);
  }
  /**
   * A depth first search through the internal heirarchy model.
   *
   * @param visitor The visitor function pattern to be called for each node.
   * @param trackAncestors Whether or not the search is to keep track all nodes
   * directly above this one in the search path.
   */
  visit(visitor, dfsRoots, trackAncestors, seenNodes = null) {
    if (dfsRoots != null) {
      for (let i = 0; i < dfsRoots.length; i += 1) {
        const internalNode = dfsRoots[i];
        if (internalNode != null) {
          if (seenNodes == null) {
            seenNodes = {};
          }
          if (trackAncestors) {
            internalNode.hashCode = [];
            internalNode.hashCode[0] = this.dfsCount;
            internalNode.hashCode[1] = i;
            this.extendedDfs(null, internalNode, null, visitor, seenNodes, internalNode.hashCode, i, 0);
          } else {
            this.dfs(null, internalNode, null, visitor, seenNodes, 0);
          }
        }
      }
      this.dfsCount++;
    }
  }
  /**
   * Performs a depth first search on the internal hierarchy model
   *
   * @param parent the parent internal node of the current internal node
   * @param root the current internal node
   * @param connectingEdge the internal edge connecting the internal node and the parent
   * internal node, if any
   * @param visitor the visitor pattern to be called for each node
   * @param seen a set of all nodes seen by this dfs a set of all of the
   * ancestor node of the current node
   * @param layer the layer on the dfs tree ( not the same as the model ranks )
   */
  dfs(parent, root, connectingEdge, visitor, seen, layer) {
    if (root != null) {
      const rootId = root.id;
      if (seen[rootId] == null) {
        seen[rootId] = root;
        visitor(parent, root, connectingEdge, layer, 0);
        const outgoingEdges = root.connectsAsSource.slice();
        for (let i = 0; i < outgoingEdges.length; i += 1) {
          const internalEdge = outgoingEdges[i];
          const targetNode = internalEdge.target;
          this.dfs(root, targetNode, internalEdge, visitor, seen, layer + 1);
        }
      } else {
        visitor(parent, root, connectingEdge, layer, 1);
      }
    }
  }
  /**
   * Performs a depth first search on the internal hierarchy model. This dfs
   * extends the default version by keeping track of cells ancestors, but it
   * should be only used when necessary because of it can be computationally
   * intensive for deep searches.
   *
   * @param parent the parent internal node of the current internal node
   * @param root the current internal node
   * @param connectingEdge the internal edge connecting the internal node and the parent
   * internal node, if any
   * @param visitor the visitor pattern to be called for each node
   * @param seen a set of all nodes seen by this dfs
   * @param ancestors the parent hash code
   * @param childHash the new hash code for this node
   * @param layer the layer on the dfs tree ( not the same as the model ranks )
   */
  extendedDfs(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer) {
    if (root != null) {
      if (parent != null) {
        if (root.hashCode == null || root.hashCode[0] != parent.hashCode[0]) {
          const hashCodeLength = parent.hashCode.length + 1;
          root.hashCode = parent.hashCode.slice();
          root.hashCode[hashCodeLength - 1] = childHash;
        }
      }
      const rootId = root.id;
      if (seen[rootId] == null) {
        seen[rootId] = root;
        visitor(parent, root, connectingEdge, layer, 0);
        const outgoingEdges = root.connectsAsSource.slice();
        for (let i = 0; i < outgoingEdges.length; i += 1) {
          const internalEdge = outgoingEdges[i];
          const targetNode = internalEdge.target;
          this.extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i, layer + 1);
        }
      } else {
        visitor(parent, root, connectingEdge, layer, 1);
      }
    }
  }
}
class HierarchicalLayoutStage {
}
class MinimumCycleRemover extends HierarchicalLayoutStage {
  /**
   * Creates a cycle remover for the given internal model.
   */
  constructor(layout) {
    super();
    this.layout = layout;
  }
  /**
   * Takes the graph detail and configuration information within the facade
   * and creates the resulting laid out graph within that facade for further
   * use.
   */
  execute(parent) {
    const model = this.layout.getDataModel();
    const seenNodes = {};
    const unseenNodesArray = model.vertexMapper.getValues();
    const unseenNodes = {};
    for (let i = 0; i < unseenNodesArray.length; i += 1) {
      unseenNodes[unseenNodesArray[i].id] = unseenNodesArray[i];
    }
    let rootsArray = null;
    if (model.roots != null) {
      const modelRoots = model.roots;
      rootsArray = [];
      for (let i = 0; i < modelRoots.length; i += 1) {
        rootsArray[i] = model.vertexMapper.get(modelRoots[i]);
      }
    }
    model.visit((parent2, node, connectingEdge, layer, seen) => {
      if (node.isAncestor(parent2)) {
        connectingEdge.invert();
        remove(connectingEdge, parent2.connectsAsSource);
        parent2.connectsAsTarget.push(connectingEdge);
        remove(connectingEdge, node.connectsAsTarget);
        node.connectsAsSource.push(connectingEdge);
      }
      seenNodes[node.id] = node;
      delete unseenNodes[node.id];
    }, rootsArray, true, null);
    const seenNodesCopy = clone(seenNodes, null, true);
    model.visit((parent2, node, connectingEdge, layer, seen) => {
      if (node.isAncestor(parent2)) {
        connectingEdge.invert();
        remove(connectingEdge, parent2.connectsAsSource);
        node.connectsAsSource.push(connectingEdge);
        parent2.connectsAsTarget.push(connectingEdge);
        remove(connectingEdge, node.connectsAsTarget);
      }
      seenNodes[node.id] = node;
      delete unseenNodes[node.id];
    }, Object.values(unseenNodes), true, seenNodesCopy);
  }
}
class MedianCellSorter {
  constructor() {
    this.medianValue = 0;
    this.cell = false;
  }
  /**
   * Compares two MedianCellSorters.
   */
  compare(a, b) {
    if (a != null && b != null) {
      if (b.medianValue > a.medianValue) {
        return -1;
      }
      if (b.medianValue < a.medianValue) {
        return 1;
      }
      return 0;
    }
    return 0;
  }
}
class MedianHybridCrossingReduction extends HierarchicalLayoutStage {
  constructor(layout) {
    super();
    this.maxIterations = 24;
    this.nestedBestRanks = null;
    this.currentBestCrossings = 0;
    this.iterationsWithoutImprovement = 0;
    this.maxNoImprovementIterations = 2;
    this.layout = layout;
  }
  /**
   * Performs a vertex ordering within ranks as described by Gansner et al
   * 1993
   */
  execute(parent) {
    const model = this.layout.getDataModel();
    let ranks = model.ranks;
    this.nestedBestRanks = [];
    for (let i = 0; i < ranks.length; i += 1) {
      this.nestedBestRanks[i] = ranks[i].slice();
    }
    let iterationsWithoutImprovement = 0;
    let currentBestCrossings = this.calculateCrossings(model);
    for (let i = 0; i < this.maxIterations && iterationsWithoutImprovement < this.maxNoImprovementIterations; i++) {
      this.weightedMedian(i, model);
      this.transpose(i, model);
      const candidateCrossings = this.calculateCrossings(model);
      if (candidateCrossings < currentBestCrossings) {
        currentBestCrossings = candidateCrossings;
        iterationsWithoutImprovement = 0;
        for (let j = 0; j < this.nestedBestRanks.length; j += 1) {
          const rank = ranks[j];
          for (let k = 0; k < rank.length; k += 1) {
            const cell = rank[k];
            this.nestedBestRanks[j][cell.getGeneralPurposeVariable(j)] = cell;
          }
        }
      } else {
        iterationsWithoutImprovement += 1;
        for (let j = 0; j < this.nestedBestRanks.length; j += 1) {
          const rank = ranks[j];
          for (let k = 0; k < rank.length; k += 1) {
            const cell = rank[k];
            cell.setGeneralPurposeVariable(j, k);
          }
        }
      }
      if (currentBestCrossings === 0) {
        break;
      }
    }
    ranks = [];
    const rankList = [];
    for (let i = 0; i < model.maxRank + 1; i += 1) {
      rankList[i] = [];
      ranks[i] = rankList[i];
    }
    for (let i = 0; i < this.nestedBestRanks.length; i += 1) {
      for (let j = 0; j < this.nestedBestRanks[i].length; j += 1) {
        rankList[i].push(this.nestedBestRanks[i][j]);
      }
    }
    model.ranks = ranks;
  }
  /**
   * Calculates the total number of edge crossing in the current graph.
   * Returns the current number of edge crossings in the hierarchy graph
   * model in the current candidate layout
   *
   * @param model the internal model describing the hierarchy
   */
  calculateCrossings(model) {
    const ranks = model.ranks;
    const numRanks = ranks.length;
    let totalCrossings = 0;
    for (let i = 1; i < numRanks; i += 1) {
      totalCrossings += this.calculateRankCrossing(i, model);
    }
    return totalCrossings;
  }
  /**
   * Calculates the number of edges crossings between the specified rank and
   * the rank below it. Returns the number of edges crossings with the rank
   * beneath
   *
   * @param i  the topmost rank of the pair ( higher rank value )
   * @param model the internal model describing the hierarchy
   */
  calculateRankCrossing(i, model) {
    let totalCrossings = 0;
    const ranks = model.ranks;
    const rank = ranks[i];
    const previousRank = ranks[i - 1];
    const tmpIndices = [];
    for (let j = 0; j < rank.length; j += 1) {
      const node = rank[j];
      const rankPosition = node.getGeneralPurposeVariable(i);
      const connectedCells = node.getPreviousLayerConnectedCells(i);
      const nodeIndices = [];
      for (let k = 0; k < connectedCells.length; k += 1) {
        const connectedNode = connectedCells[k];
        const otherCellRankPosition = connectedNode.getGeneralPurposeVariable(i - 1);
        nodeIndices.push(otherCellRankPosition);
      }
      nodeIndices.sort((x, y) => {
        return x - y;
      });
      tmpIndices[rankPosition] = nodeIndices;
    }
    let indices = [];
    for (let j = 0; j < tmpIndices.length; j++) {
      indices = indices.concat(tmpIndices[j]);
    }
    let firstIndex = 1;
    while (firstIndex < previousRank.length) {
      firstIndex <<= 1;
    }
    const treeSize = 2 * firstIndex - 1;
    firstIndex -= 1;
    const tree = [];
    for (let j = 0; j < treeSize; ++j) {
      tree[j] = 0;
    }
    for (let j = 0; j < indices.length; j += 1) {
      const index = indices[j];
      let treeIndex = index + firstIndex;
      ++tree[treeIndex];
      while (treeIndex > 0) {
        if (treeIndex % 2) {
          totalCrossings += tree[treeIndex + 1];
        }
        treeIndex = treeIndex - 1 >> 1;
        ++tree[treeIndex];
      }
    }
    return totalCrossings;
  }
  /**
   * Takes each possible adjacent cell pair on each rank and checks if
   * swapping them around reduces the number of crossing
   *
   * @param mainLoopIteration the iteration number of the main loop
   * @param model the internal model describing the hierarchy
   */
  transpose(mainLoopIteration, model) {
    let improved = true;
    let count = 0;
    const maxCount = 10;
    while (improved && count++ < maxCount) {
      const nudge = mainLoopIteration % 2 === 1 && count % 2 === 1;
      improved = false;
      const ranks = model.ranks;
      for (let i = 0; i < ranks.length; i += 1) {
        const rank = ranks[i];
        const orderedCells = [];
        for (let j = 0; j < rank.length; j++) {
          const cell = rank[j];
          let tempRank = cell.getGeneralPurposeVariable(i);
          if (tempRank < 0) {
            tempRank = j;
          }
          orderedCells[tempRank] = cell;
        }
        let leftCellAboveConnections = null;
        let leftCellBelowConnections = null;
        let rightCellAboveConnections = null;
        let rightCellBelowConnections = null;
        let leftAbovePositions = null;
        let leftBelowPositions = null;
        let rightAbovePositions = null;
        let rightBelowPositions = null;
        let leftCell = null;
        let rightCell = null;
        for (let j = 0; j < rank.length - 1; j++) {
          if (j === 0) {
            leftCell = orderedCells[j];
            leftCellAboveConnections = leftCell.getNextLayerConnectedCells(i);
            leftCellBelowConnections = leftCell.getPreviousLayerConnectedCells(i);
            leftAbovePositions = [];
            leftBelowPositions = [];
            for (let k = 0; k < leftCellAboveConnections.length; k++) {
              leftAbovePositions[k] = leftCellAboveConnections[k].getGeneralPurposeVariable(i + 1);
            }
            for (let k = 0; k < leftCellBelowConnections.length; k++) {
              leftBelowPositions[k] = leftCellBelowConnections[k].getGeneralPurposeVariable(i - 1);
            }
          } else {
            leftCellAboveConnections = rightCellAboveConnections;
            leftCellBelowConnections = rightCellBelowConnections;
            leftAbovePositions = rightAbovePositions;
            leftBelowPositions = rightBelowPositions;
            leftCell = rightCell;
          }
          rightCell = orderedCells[j + 1];
          rightCellAboveConnections = rightCell.getNextLayerConnectedCells(i);
          rightCellBelowConnections = rightCell.getPreviousLayerConnectedCells(i);
          rightAbovePositions = [];
          rightBelowPositions = [];
          for (let k = 0; k < rightCellAboveConnections.length; k++) {
            rightAbovePositions[k] = rightCellAboveConnections[k].getGeneralPurposeVariable(i + 1);
          }
          for (let k = 0; k < rightCellBelowConnections.length; k++) {
            rightBelowPositions[k] = rightCellBelowConnections[k].getGeneralPurposeVariable(i - 1);
          }
          let totalCurrentCrossings = 0;
          let totalSwitchedCrossings = 0;
          for (let k = 0; k < leftAbovePositions.length; k += 1) {
            for (let ik = 0; ik < rightAbovePositions.length; ik += 1) {
              if (leftAbovePositions[k] > rightAbovePositions[ik]) {
                totalCurrentCrossings += 1;
              }
              if (leftAbovePositions[k] < rightAbovePositions[ik]) {
                totalSwitchedCrossings += 1;
              }
            }
          }
          for (let k = 0; k < leftBelowPositions.length; k += 1) {
            for (let ik = 0; ik < rightBelowPositions.length; ik += 1) {
              if (leftBelowPositions[k] > rightBelowPositions[ik]) {
                totalCurrentCrossings += 1;
              }
              if (leftBelowPositions[k] < rightBelowPositions[ik]) {
                totalSwitchedCrossings += 1;
              }
            }
          }
          if (totalSwitchedCrossings < totalCurrentCrossings || totalSwitchedCrossings === totalCurrentCrossings && nudge) {
            const temp = leftCell.getGeneralPurposeVariable(i);
            leftCell.setGeneralPurposeVariable(i, rightCell.getGeneralPurposeVariable(i));
            rightCell.setGeneralPurposeVariable(i, temp);
            rightCellAboveConnections = leftCellAboveConnections;
            rightCellBelowConnections = leftCellBelowConnections;
            rightAbovePositions = leftAbovePositions;
            rightBelowPositions = leftBelowPositions;
            rightCell = leftCell;
            if (!nudge) {
              improved = true;
            }
          }
        }
      }
    }
  }
  /**
   * Sweeps up or down the layout attempting to minimise the median placement
   * of connected cells on adjacent ranks
   *
   * @param iteration the iteration number of the main loop
   * @param model the internal model describing the hierarchy
   */
  weightedMedian(iteration, model) {
    const downwardSweep = iteration % 2 === 0;
    if (downwardSweep) {
      for (let j = model.maxRank - 1; j >= 0; j -= 1) {
        this.medianRank(j, downwardSweep);
      }
    } else {
      for (let j = 1; j < model.maxRank; j += 1) {
        this.medianRank(j, downwardSweep);
      }
    }
  }
  /**
   * Attempts to minimise the median placement of connected cells on this rank
   * and one of the adjacent ranks
   *
   * @param rankValue the layer number of this rank
   * @param downwardSweep whether or not this is a downward sweep through the graph
   */
  medianRank(rankValue, downwardSweep) {
    const nestedBestRanks = this.nestedBestRanks;
    const numCellsForRank = nestedBestRanks[rankValue].length;
    const medianValues = [];
    const reservedPositions = {};
    for (let i = 0; i < numCellsForRank; i += 1) {
      const cell = nestedBestRanks[rankValue][i];
      const sorterEntry = new MedianCellSorter();
      sorterEntry.cell = cell;
      const nextLevelConnectedCells = downwardSweep ? cell.getNextLayerConnectedCells(rankValue) : cell.getPreviousLayerConnectedCells(rankValue);
      const nextRankValue = downwardSweep ? rankValue + 1 : rankValue - 1;
      if (nextLevelConnectedCells != null && nextLevelConnectedCells.length !== 0) {
        sorterEntry.medianValue = this.medianValue(nextLevelConnectedCells, nextRankValue);
        medianValues.push(sorterEntry);
      } else {
        reservedPositions[cell.getGeneralPurposeVariable(rankValue)] = true;
      }
    }
    medianValues.sort(new MedianCellSorter().compare);
    for (let i = 0; i < numCellsForRank; i += 1) {
      if (reservedPositions[i] == null) {
        const cell = medianValues.shift().cell;
        cell.setGeneralPurposeVariable(rankValue, i);
      }
    }
  }
  /**
   * Calculates the median rank order positioning for the specified cell using
   * the connected cells on the specified rank. Returns the median rank
   * ordering value of the connected cells
   *
   * @param connectedCells the cells on the specified rank connected to the
   * specified cell
   * @param rankValue the rank that the connected cell lie upon
   */
  medianValue(connectedCells, rankValue) {
    const medianValues = [];
    let arrayCount = 0;
    for (let i = 0; i < connectedCells.length; i += 1) {
      const cell = connectedCells[i];
      medianValues[arrayCount++] = cell.getGeneralPurposeVariable(rankValue);
    }
    medianValues.sort((a, b) => {
      return a - b;
    });
    if (arrayCount % 2 === 1) {
      return medianValues[Math.floor(arrayCount / 2)];
    }
    if (arrayCount === 2) {
      return (medianValues[0] + medianValues[1]) / 2;
    }
    const medianPoint = arrayCount / 2;
    const leftMedian = medianValues[medianPoint - 1] - medianValues[0];
    const rightMedian = medianValues[arrayCount - 1] - medianValues[medianPoint];
    return (medianValues[medianPoint - 1] * rightMedian + medianValues[medianPoint] * leftMedian) / (leftMedian + rightMedian);
  }
}
class CoordinateAssignment extends HierarchicalLayoutStage {
  /**
   * Creates a coordinate assignment.
   *
   * @param layout
   * @param intraCellSpacing the minimum buffer between cells on the same rank interRankCellSpacing
   * @param interRankCellSpacing the minimum distance between cells on adjacent ranks
   * @param orientation the position of the root node(s) relative to the graph
   * @param initialX the leftmost coordinate node placement starts at
   * @param parallelEdgeSpacing
   */
  constructor(layout, intraCellSpacing = 30, interRankCellSpacing = 100, orientation, initialX, parallelEdgeSpacing = 10) {
    super();
    this.intraCellSpacing = 30;
    this.interRankCellSpacing = 100;
    this.parallelEdgeSpacing = 10;
    this.maxIterations = 8;
    this.prefHozEdgeSep = 5;
    this.prefVertEdgeOff = 2;
    this.minEdgeJetty = 12;
    this.channelBuffer = 4;
    this.jettyPositions = null;
    this.orientation = DIRECTION.NORTH;
    this.limitX = null;
    this.currentXDelta = null;
    this.widestRank = null;
    this.rankTopY = null;
    this.rankBottomY = null;
    this.widestRankValue = null;
    this.rankWidths = null;
    this.rankY = null;
    this.fineTuning = true;
    this.nextLayerConnectedCache = null;
    this.previousLayerConnectedCache = null;
    this.groupPadding = 10;
    this.layout = layout;
    this.intraCellSpacing = intraCellSpacing;
    this.interRankCellSpacing = interRankCellSpacing;
    this.orientation = orientation;
    this.initialX = initialX;
    this.parallelEdgeSpacing = parallelEdgeSpacing;
  }
  /**
   * Utility method to display current positions
   */
  printStatus() {
    const model = this.layout.getDataModel();
    const ranks = model.ranks;
    const logger = GlobalConfig.logger;
    logger.show();
    logger.info("======Coord assignment debug=======");
    for (let j = 0; j < ranks.length; j++) {
      const rank = ranks[j];
      const cellsInfo = rank.map((cell) => String(cell.getGeneralPurposeVariable(j))).join("  ");
      logger.info(`Rank ${j} : ${cellsInfo}`);
    }
    logger.info("====================================");
  }
  /**
   * A basic horizontal coordinate assignment algorithm
   */
  execute(parent) {
    this.jettyPositions = Object();
    const model = this.layout.getDataModel();
    this.currentXDelta = 0;
    this.initialCoords(this.layout.getGraph(), model);
    if (this.fineTuning) {
      this.minNode(model);
    }
    let bestXDelta = 1e8;
    if (this.fineTuning) {
      for (let i = 0; i < this.maxIterations; i += 1) {
        if (i !== 0) {
          this.medianPos(i, model);
          this.minNode(model);
        }
        const ranks = model.ranks;
        if (this.currentXDelta < bestXDelta) {
          for (let j = 0; j < ranks.length; j++) {
            const rank = ranks[j];
            for (let k = 0; k < rank.length; k++) {
              const cell = rank[k];
              cell.setX(j, cell.getGeneralPurposeVariable(j));
            }
          }
          bestXDelta = this.currentXDelta;
        } else {
          for (let j = 0; j < ranks.length; j++) {
            const rank = ranks[j];
            for (let k = 0; k < rank.length; k++) {
              const cell = rank[k];
              cell.setGeneralPurposeVariable(j, cell.getX(j));
            }
          }
        }
        this.minPath(this.layout.getGraph(), model);
        this.currentXDelta = 0;
      }
    }
    this.setCellLocations(this.layout.getGraph(), model);
  }
  /**
   * Performs one median positioning sweep in both directions
   */
  minNode(model) {
    const nodeList = [];
    const map = new Dictionary();
    const rank = [];
    for (let i = 0; i <= model.maxRank; i += 1) {
      rank[i] = model.ranks[i];
      for (let j = 0; j < rank[i].length; j += 1) {
        const node = rank[i][j];
        const nodeWrapper = new WeightedCellSorter(node, i);
        nodeWrapper.rankIndex = j;
        nodeWrapper.visited = true;
        nodeList.push(nodeWrapper);
        map.put(node, nodeWrapper);
      }
    }
    const maxTries = nodeList.length * 10;
    let count = 0;
    const tolerance = 1;
    while (nodeList.length > 0 && count <= maxTries) {
      const cellWrapper = nodeList.shift();
      const cell = cellWrapper.cell;
      const rankValue = cellWrapper.weightedValue;
      const rankIndex = parseInt(String(cellWrapper.rankIndex));
      const nextLayerConnectedCells = cell.getNextLayerConnectedCells(rankValue);
      const previousLayerConnectedCells = cell.getPreviousLayerConnectedCells(rankValue);
      const numNextLayerConnected = nextLayerConnectedCells.length;
      const numPreviousLayerConnected = previousLayerConnectedCells.length;
      const medianNextLevel = this.medianXValue(nextLayerConnectedCells, rankValue + 1);
      const medianPreviousLevel = this.medianXValue(previousLayerConnectedCells, rankValue - 1);
      const numConnectedNeighbours = numNextLayerConnected + numPreviousLayerConnected;
      const currentPosition = cell.getGeneralPurposeVariable(rankValue);
      let cellMedian = currentPosition;
      if (numConnectedNeighbours > 0) {
        cellMedian = (medianNextLevel * numNextLayerConnected + medianPreviousLevel * numPreviousLayerConnected) / numConnectedNeighbours;
      }
      let positionChanged = false;
      if (cellMedian < currentPosition - tolerance) {
        if (rankIndex === 0) {
          cell.setGeneralPurposeVariable(rankValue, cellMedian);
          positionChanged = true;
        } else {
          const leftCell = rank[rankValue][rankIndex - 1];
          let leftLimit = leftCell.getGeneralPurposeVariable(rankValue);
          leftLimit = leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell.width / 2;
          if (leftLimit < cellMedian) {
            cell.setGeneralPurposeVariable(rankValue, cellMedian);
            positionChanged = true;
          } else if (leftLimit < cell.getGeneralPurposeVariable(rankValue) - tolerance) {
            cell.setGeneralPurposeVariable(rankValue, leftLimit);
            positionChanged = true;
          }
        }
      } else if (cellMedian > currentPosition + tolerance) {
        const rankSize = rank[rankValue].length;
        if (rankIndex === rankSize - 1) {
          cell.setGeneralPurposeVariable(rankValue, cellMedian);
          positionChanged = true;
        } else {
          const rightCell = rank[rankValue][rankIndex + 1];
          let rightLimit = rightCell.getGeneralPurposeVariable(rankValue);
          rightLimit = rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell.width / 2;
          if (rightLimit > cellMedian) {
            cell.setGeneralPurposeVariable(rankValue, cellMedian);
            positionChanged = true;
          } else if (rightLimit > cell.getGeneralPurposeVariable(rankValue) + tolerance) {
            cell.setGeneralPurposeVariable(rankValue, rightLimit);
            positionChanged = true;
          }
        }
      }
      if (positionChanged) {
        for (let i = 0; i < nextLayerConnectedCells.length; i += 1) {
          const connectedCell = nextLayerConnectedCells[i];
          const connectedCellWrapper = map.get(connectedCell);
          if (connectedCellWrapper != null) {
            if (connectedCellWrapper.visited == false) {
              connectedCellWrapper.visited = true;
              nodeList.push(connectedCellWrapper);
            }
          }
        }
        for (let i = 0; i < previousLayerConnectedCells.length; i += 1) {
          const connectedCell = previousLayerConnectedCells[i];
          const connectedCellWrapper = map.get(connectedCell);
          if (connectedCellWrapper != null) {
            if (connectedCellWrapper.visited == false) {
              connectedCellWrapper.visited = true;
              nodeList.push(connectedCellWrapper);
            }
          }
        }
      }
      cellWrapper.visited = false;
      count += 1;
    }
  }
  /**
   * Performs one median positioning sweep in one direction
   *
   * @param i the iteration of the whole process
   * @param model an internal model of the hierarchical layout
   */
  medianPos(i, model) {
    const downwardSweep = i % 2 === 0;
    if (downwardSweep) {
      for (let j = model.maxRank; j > 0; j--) {
        this.rankMedianPosition(j - 1, model, j);
      }
    } else {
      for (let j = 0; j < model.maxRank - 1; j++) {
        this.rankMedianPosition(j + 1, model, j);
      }
    }
  }
  /**
   * Performs median minimisation over one rank.
   *
   * @param rankValue the layer number of this rank
   * @param model an internal model of the hierarchical layout
   * @param nextRankValue the layer number whose connected cels are to be laid out
   * relative to
   */
  rankMedianPosition(rankValue, model, nextRankValue) {
    const ranks = model.ranks;
    const rank = ranks[rankValue];
    const weightedValues = [];
    const cellMap = {};
    for (let i = 0; i < rank.length; i += 1) {
      const currentCell = rank[i];
      weightedValues[i] = new WeightedCellSorter(currentCell);
      weightedValues[i].rankIndex = i;
      cellMap[currentCell.id] = weightedValues[i];
      let nextLayerConnectedCells = null;
      if (nextRankValue < rankValue) {
        nextLayerConnectedCells = currentCell.getPreviousLayerConnectedCells(rankValue);
      } else {
        nextLayerConnectedCells = currentCell.getNextLayerConnectedCells(rankValue);
      }
      weightedValues[i].weightedValue = this.calculatedWeightedValue(currentCell, nextLayerConnectedCells);
    }
    weightedValues.sort(WeightedCellSorter.compare);
    for (let i = 0; i < weightedValues.length; i += 1) {
      let numConnectionsNextLevel = 0;
      const cell = weightedValues[i].cell;
      let nextLayerConnectedCells = null;
      let medianNextLevel = 0;
      if (nextRankValue < rankValue) {
        nextLayerConnectedCells = cell.getPreviousLayerConnectedCells(rankValue).slice();
      } else {
        nextLayerConnectedCells = cell.getNextLayerConnectedCells(rankValue).slice();
      }
      if (nextLayerConnectedCells != null) {
        numConnectionsNextLevel = nextLayerConnectedCells.length;
        if (numConnectionsNextLevel > 0) {
          medianNextLevel = this.medianXValue(nextLayerConnectedCells, nextRankValue);
        } else {
          medianNextLevel = cell.getGeneralPurposeVariable(rankValue);
        }
      }
      let leftBuffer = 0;
      let leftLimit = -1e8;
      for (let j = weightedValues[i].rankIndex - 1; j >= 0; ) {
        const weightedValue = cellMap[rank[j].id];
        if (weightedValue != null) {
          const leftCell = weightedValue.cell;
          if (weightedValue.visited) {
            leftLimit = leftCell.getGeneralPurposeVariable(rankValue) + leftCell.width / 2 + this.intraCellSpacing + leftBuffer + cell.width / 2;
            j = -1;
          } else {
            leftBuffer += leftCell.width + this.intraCellSpacing;
            j--;
          }
        }
      }
      let rightBuffer = 0;
      let rightLimit = 1e8;
      for (let j = weightedValues[i].rankIndex + 1; j < weightedValues.length; ) {
        const weightedValue = cellMap[rank[j].id];
        if (weightedValue != null) {
          const rightCell = weightedValue.cell;
          if (weightedValue.visited) {
            rightLimit = rightCell.getGeneralPurposeVariable(rankValue) - rightCell.width / 2 - this.intraCellSpacing - rightBuffer - cell.width / 2;
            j = weightedValues.length;
          } else {
            rightBuffer += rightCell.width + this.intraCellSpacing;
            j++;
          }
        }
      }
      if (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit) {
        cell.setGeneralPurposeVariable(rankValue, medianNextLevel);
      } else if (medianNextLevel < leftLimit) {
        cell.setGeneralPurposeVariable(rankValue, leftLimit);
        this.currentXDelta = this.currentXDelta + leftLimit - medianNextLevel;
      } else if (medianNextLevel > rightLimit) {
        cell.setGeneralPurposeVariable(rankValue, rightLimit);
        this.currentXDelta = this.currentXDelta + medianNextLevel - rightLimit;
      }
      weightedValues[i].visited = true;
    }
  }
  /**
   * Calculates the priority the specified cell has based on the type of its
   * cell and the cells it is connected to on the next layer
   *
   * @param currentCell the cell whose weight is to be calculated
   * @param collection the cells the specified cell is connected to
   */
  calculatedWeightedValue(currentCell, collection) {
    let totalWeight = 0;
    for (let i = 0; i < collection.length; i += 1) {
      const cell = collection[i];
      if (currentCell.isVertex() && cell.isVertex()) {
        totalWeight += 1;
      } else if (currentCell.isEdge() && cell.isEdge()) {
        totalWeight += 8;
      } else {
        totalWeight += 2;
      }
    }
    return totalWeight;
  }
  /**
   * Calculates the median position of the connected cell on the specified
   * rank
   *
   * @param connectedCells the cells the candidate connects to on this level
   * @param rankValue the layer number of this rank
   */
  medianXValue(connectedCells, rankValue) {
    if (connectedCells.length === 0) {
      return 0;
    }
    const medianValues = [];
    for (let i = 0; i < connectedCells.length; i += 1) {
      medianValues[i] = connectedCells[i].getGeneralPurposeVariable(rankValue);
    }
    medianValues.sort((a, b) => a - b);
    if (connectedCells.length % 2 === 1) {
      return medianValues[Math.floor(connectedCells.length / 2)];
    }
    const medianPoint = connectedCells.length / 2;
    const leftMedian = medianValues[medianPoint - 1];
    const rightMedian = medianValues[medianPoint];
    return (leftMedian + rightMedian) / 2;
  }
  /**
   * Sets up the layout in an initial positioning. The ranks are all centered
   * as much as possible along the middle vertex in each rank. The other cells
   * are then placed as close as possible on either side.
   *
   * @param facade the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  initialCoords(facade, model) {
    this.calculateWidestRank(facade, model);
    for (let i = this.widestRank; i >= 0; i--) {
      if (i < model.maxRank) {
        this.rankCoordinates(i, facade, model);
      }
    }
    for (let i = this.widestRank + 1; i <= model.maxRank; i += 1) {
      if (i > 0) {
        this.rankCoordinates(i, facade, model);
      }
    }
  }
  /**
   * Sets up the layout in an initial positioning. All the first cells in each
   * rank are moved to the left and the rest of the rank inserted as close
   * together as their size and buffering permits. This method works on just
   * the specified rank.
   *
   * @param rankValue the current rank being processed
   * @param graph the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  rankCoordinates(rankValue, graph, model) {
    const ranks = model.ranks;
    const rank = ranks[rankValue];
    let maxY = 0;
    let localX = this.initialX + (this.widestRankValue - this.rankWidths[rankValue]) / 2;
    let boundsWarning = false;
    for (let i = 0; i < rank.length; i += 1) {
      const node = rank[i];
      if (node.isVertex()) {
        const bounds = this.layout.getVertexBounds(node.cell);
        if (bounds != null) {
          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
            node.width = bounds.width;
            node.height = bounds.height;
          } else {
            node.width = bounds.height;
            node.height = bounds.width;
          }
        } else {
          boundsWarning = true;
        }
        maxY = Math.max(maxY, node.height);
      } else if (node.isEdge()) {
        let numEdges = 1;
        if (node.edges != null) {
          numEdges = node.edges.length;
        } else {
          GlobalConfig.logger.warn("edge.edges is null");
        }
        node.width = (numEdges - 1) * this.parallelEdgeSpacing;
      }
      localX += node.width / 2;
      node.setX(rankValue, localX);
      node.setGeneralPurposeVariable(rankValue, localX);
      localX += node.width / 2;
      localX += this.intraCellSpacing;
    }
    if (boundsWarning) {
      GlobalConfig.logger.warn("At least one cell has no bounds");
    }
  }
  /**
   * Calculates the width rank in the hierarchy. Also set the y value of each
   * rank whilst performing the calculation
   *
   * @param graph the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  calculateWidestRank(graph, model) {
    let y = -this.interRankCellSpacing;
    let lastRankMaxCellHeight = 0;
    this.rankWidths = [];
    this.rankY = [];
    for (let rankValue = model.maxRank; rankValue >= 0; rankValue -= 1) {
      let maxCellHeight = 0;
      const ranks = model.ranks;
      const rank = ranks[rankValue];
      let localX = this.initialX;
      let boundsWarning = false;
      for (let i = 0; i < rank.length; i += 1) {
        const node = rank[i];
        if (node.isVertex()) {
          const bounds = this.layout.getVertexBounds(node.cell);
          if (bounds != null) {
            if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
              node.width = bounds.width;
              node.height = bounds.height;
            } else {
              node.width = bounds.height;
              node.height = bounds.width;
            }
          } else {
            boundsWarning = true;
          }
          maxCellHeight = Math.max(maxCellHeight, node.height);
        } else if (node.isEdge()) {
          let numEdges = 1;
          if (node.edges != null) {
            numEdges = node.edges.length;
          } else {
            GlobalConfig.logger.warn("edge.edges is null");
          }
          node.width = (numEdges - 1) * this.parallelEdgeSpacing;
        }
        localX += node.width / 2;
        node.setX(rankValue, localX);
        node.setGeneralPurposeVariable(rankValue, localX);
        localX += node.width / 2;
        localX += this.intraCellSpacing;
        if (localX > this.widestRankValue) {
          this.widestRankValue = localX;
          this.widestRank = rankValue;
        }
        this.rankWidths[rankValue] = localX;
      }
      if (boundsWarning) {
        GlobalConfig.logger.warn("At least one cell has no bounds");
      }
      this.rankY[rankValue] = y;
      const distanceToNextRank = maxCellHeight / 2 + lastRankMaxCellHeight / 2 + this.interRankCellSpacing;
      lastRankMaxCellHeight = maxCellHeight;
      if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.WEST) {
        y += distanceToNextRank;
      } else {
        y -= distanceToNextRank;
      }
      for (let i = 0; i < rank.length; i += 1) {
        const cell = rank[i];
        cell.setY(rankValue, y);
      }
    }
  }
  /**
   * Straightens out chains of virtual nodes where possibleacade to those stored after this layout
   * processing step has completed.
   *
   * @param graph the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  minPath(graph, model) {
    const edges = model.edgeMapper.getValues();
    for (let j = 0; j < edges.length; j++) {
      const cell = edges[j];
      if (cell.maxRank - cell.minRank - 1 < 1) {
        continue;
      }
      let referenceX = cell.getGeneralPurposeVariable(cell.minRank + 1);
      let edgeStraight = true;
      let refSegCount = 0;
      for (let i = cell.minRank + 2; i < cell.maxRank; i += 1) {
        const x = cell.getGeneralPurposeVariable(i);
        if (referenceX !== x) {
          edgeStraight = false;
          referenceX = x;
        } else {
          refSegCount += 1;
        }
      }
      if (!edgeStraight) {
        let upSegCount = 0;
        let downSegCount = 0;
        const upXPositions = [];
        const downXPositions = [];
        let i = 0;
        let currentX = cell.getGeneralPurposeVariable(cell.minRank + 1);
        for (i = cell.minRank + 1; i < cell.maxRank - 1; i += 1) {
          const nextX = cell.getX(i + 1);
          if (currentX === nextX) {
            upXPositions[i - cell.minRank - 1] = currentX;
            upSegCount += 1;
          } else if (this.repositionValid(model, cell, i + 1, currentX)) {
            upXPositions[i - cell.minRank - 1] = currentX;
            upSegCount += 1;
          } else {
            upXPositions[i - cell.minRank - 1] = nextX;
            currentX = nextX;
          }
        }
        currentX = cell.getX(i);
        for (let i2 = cell.maxRank - 1; i2 > cell.minRank + 1; i2--) {
          const nextX = cell.getX(i2 - 1);
          if (currentX === nextX) {
            downXPositions[i2 - cell.minRank - 2] = currentX;
            downSegCount += 1;
          } else if (this.repositionValid(model, cell, i2 - 1, currentX)) {
            downXPositions[i2 - cell.minRank - 2] = currentX;
            downSegCount += 1;
          } else {
            downXPositions[i2 - cell.minRank - 2] = cell.getX(i2 - 1);
            currentX = nextX;
          }
        }
        if (downSegCount > refSegCount || upSegCount > refSegCount) {
          if (downSegCount >= upSegCount) {
            for (let i2 = cell.maxRank - 2; i2 > cell.minRank; i2--) {
              cell.setX(i2, downXPositions[i2 - cell.minRank - 1]);
            }
          } else if (upSegCount > downSegCount) {
            for (let i2 = cell.minRank + 2; i2 < cell.maxRank; i2 += 1) {
              cell.setX(i2, upXPositions[i2 - cell.minRank - 2]);
            }
          } else ;
        }
      }
    }
  }
  /**
   * Determines whether or not a node may be moved to the specified x
   * position on the specified rank
   *
   * @param model the layout model
   * @param cell the cell being analysed
   * @param rank the layer of the cell
   * @param position the x position being sought
   */
  repositionValid(model, cell, rank, position) {
    const ranks = model.ranks;
    const rankArray = ranks[rank];
    let rankIndex = -1;
    for (let i = 0; i < rankArray.length; i += 1) {
      if (cell === rankArray[i]) {
        rankIndex = i;
        break;
      }
    }
    if (rankIndex < 0) {
      return false;
    }
    const currentX = cell.getGeneralPurposeVariable(rank);
    if (position < currentX) {
      if (rankIndex === 0) {
        return true;
      }
      const leftCell = rankArray[rankIndex - 1];
      let leftLimit = leftCell.getGeneralPurposeVariable(rank);
      leftLimit = leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell.width / 2;
      return leftLimit <= position;
    }
    if (position > currentX) {
      if (rankIndex === rankArray.length - 1) {
        return true;
      }
      const rightCell = rankArray[rankIndex + 1];
      let rightLimit = rightCell.getGeneralPurposeVariable(rank);
      rightLimit = rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell.width / 2;
      return rightLimit >= position;
    }
    return true;
  }
  /**
   * Sets the cell locations in the facade to those stored after this layout
   * processing step has completed.
   *
   * @param graph the input graph
   * @param model the layout model
   */
  setCellLocations(graph, model) {
    this.rankTopY = [];
    this.rankBottomY = [];
    const ranks = model.ranks;
    for (let i = 0; i < ranks.length; i += 1) {
      this.rankTopY[i] = Number.MAX_VALUE;
      this.rankBottomY[i] = -Number.MAX_VALUE;
    }
    const vertices = model.vertexMapper.getValues();
    for (let i = 0; i < vertices.length; i += 1) {
      this.setVertexLocation(vertices[i]);
    }
    if (this.layout.edgeStyle === HierarchicalEdgeStyle.ORTHOGONAL || this.layout.edgeStyle === HierarchicalEdgeStyle.POLYLINE || this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {
      this.localEdgeProcessing(model);
    }
    const edges = model.edgeMapper.getValues();
    for (let i = 0; i < edges.length; i += 1) {
      this.setEdgePosition(edges[i]);
    }
  }
  /**
   * Separates the x position of edges as they connect to vertices
   *
   * @param model the layout model
   */
  localEdgeProcessing(model) {
    const ranks = model.ranks;
    for (let rankIndex = 0; rankIndex < ranks.length; rankIndex += 1) {
      const rank = ranks[rankIndex];
      for (let cellIndex = 0; cellIndex < rank.length; cellIndex += 1) {
        const cell = rank[cellIndex];
        if (cell.isVertex()) {
          let currentCells = cell.getPreviousLayerConnectedCells(rankIndex);
          let currentRank = rankIndex - 1;
          for (let k = 0; k < 2; k += 1) {
            if (currentRank > -1 && currentRank < ranks.length && currentCells != null && currentCells.length > 0) {
              const sortedCells = [];
              for (let j = 0; j < currentCells.length; j++) {
                const sorter = new WeightedCellSorter(currentCells[j], currentCells[j].getX(currentRank));
                sortedCells.push(sorter);
              }
              sortedCells.sort(WeightedCellSorter.compare);
              let leftLimit = cell.x[0] - cell.width / 2;
              let rightLimit = leftLimit + cell.width;
              let connectedEdgeCount = 0;
              const connectedEdges = [];
              for (let j = 0; j < sortedCells.length; j++) {
                const innerCell = sortedCells[j].cell;
                let connections;
                if (innerCell.isVertex()) {
                  if (k === 0) {
                    connections = cell.connectsAsSource;
                  } else {
                    connections = cell.connectsAsTarget;
                  }
                  for (let connIndex = 0; connIndex < connections.length; connIndex += 1) {
                    if (connections[connIndex].source === innerCell || connections[connIndex].target === innerCell) {
                      connectedEdgeCount += connections[connIndex].edges.length;
                      connectedEdges.push(connections[connIndex]);
                    }
                  }
                } else {
                  connectedEdgeCount += innerCell.edges.length;
                  connectedEdges.push(innerCell);
                }
              }
              const requiredWidth = (connectedEdgeCount + 1) * this.prefHozEdgeSep;
              if (cell.width > requiredWidth + 2 * this.prefHozEdgeSep) {
                leftLimit += this.prefHozEdgeSep;
                rightLimit -= this.prefHozEdgeSep;
              }
              const availableWidth = rightLimit - leftLimit;
              const edgeSpacing = availableWidth / connectedEdgeCount;
              let currentX = leftLimit + edgeSpacing / 2;
              let currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;
              for (let j = 0; j < connectedEdges.length; j++) {
                const numActualEdges = connectedEdges[j].edges.length;
                const jettyPositions = this.jettyPositions;
                let pos = jettyPositions[connectedEdges[j].ids[0]];
                if (pos == null) {
                  pos = [];
                  jettyPositions[connectedEdges[j].ids[0]] = pos;
                }
                if (j < connectedEdgeCount / 2) {
                  currentYOffset += this.prefVertEdgeOff;
                } else if (j > connectedEdgeCount / 2) {
                  currentYOffset -= this.prefVertEdgeOff;
                }
                for (let m = 0; m < numActualEdges; m += 1) {
                  pos[m * 4 + k * 2] = currentX;
                  currentX += edgeSpacing;
                  pos[m * 4 + k * 2 + 1] = currentYOffset;
                }
              }
            }
            currentCells = cell.getNextLayerConnectedCells(rankIndex);
            currentRank = rankIndex + 1;
          }
        }
      }
    }
  }
  /**
   * Fixes the control points
   */
  setEdgePosition(cell) {
    let offsetX = 0;
    if (cell.temp[0] !== 101207) {
      let { maxRank } = cell;
      let { minRank } = cell;
      if (maxRank === minRank) {
        maxRank = cell.source.maxRank;
        minRank = cell.target.minRank;
      }
      let parallelEdgeCount = 0;
      const jettyPositions = this.jettyPositions;
      const jettys = jettyPositions[cell.ids[0]];
      const source = cell.isReversed ? cell.target.cell : cell.source.cell;
      const { graph } = this.layout;
      const layoutReversed = this.orientation === DIRECTION.EAST || this.orientation === DIRECTION.SOUTH;
      for (let i = 0; i < cell.edges.length; i += 1) {
        const realEdge = cell.edges[i];
        const realSource = this.layout.getVisibleTerminal(realEdge, true);
        const newPoints = [];
        let reversed = cell.isReversed;
        if (realSource !== source) {
          reversed = !reversed;
        }
        if (jettys != null) {
          const arrayOffset = reversed ? 2 : 0;
          const rankBottomY = this.rankBottomY;
          const rankTopY = this.rankTopY;
          let y = reversed ? layoutReversed ? rankBottomY[minRank] : rankTopY[minRank] : layoutReversed ? rankTopY[maxRank] : rankBottomY[maxRank];
          let jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];
          if (reversed !== layoutReversed) {
            jetty = -jetty;
          }
          y += jetty;
          let x = jettys[parallelEdgeCount * 4 + arrayOffset];
          const modelSource = realEdge.getTerminal(true);
          if (this.layout.isPort(modelSource) && modelSource.getParent() === realSource) {
            const state = graph.view.getState(modelSource);
            if (state != null) {
              x = state.x;
            } else {
              x = realSource.geometry.x + cell.source.width * modelSource.geometry.x;
            }
          }
          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
            newPoints.push(new Point(x, y));
            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {
              newPoints.push(new Point(x, y + jetty));
            }
          } else {
            newPoints.push(new Point(y, x));
            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {
              newPoints.push(new Point(y + jetty, x));
            }
          }
        }
        let loopStart = cell.x.length - 1;
        let loopLimit = -1;
        let loopDelta = -1;
        let currentRank = cell.maxRank - 1;
        if (reversed) {
          loopStart = 0;
          loopLimit = cell.x.length;
          loopDelta = 1;
          currentRank = cell.minRank + 1;
        }
        for (let j = loopStart; cell.maxRank !== cell.minRank && j !== loopLimit; j += loopDelta) {
          const positionX = cell.x[j] + offsetX;
          const rankTopY = this.rankTopY;
          const rankBottomY = this.rankBottomY;
          let topChannelY = (rankTopY[currentRank] + rankBottomY[currentRank + 1]) / 2;
          let bottomChannelY = (rankTopY[currentRank - 1] + rankBottomY[currentRank]) / 2;
          if (reversed) {
            const tmp = topChannelY;
            topChannelY = bottomChannelY;
            bottomChannelY = tmp;
          }
          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
            newPoints.push(new Point(positionX, topChannelY));
            newPoints.push(new Point(positionX, bottomChannelY));
          } else {
            newPoints.push(new Point(topChannelY, positionX));
            newPoints.push(new Point(bottomChannelY, positionX));
          }
          this.limitX = Math.max(this.limitX, positionX);
          currentRank += loopDelta;
        }
        if (jettys != null) {
          const arrayOffset = reversed ? 2 : 0;
          const rankTopY = this.rankTopY;
          const rankBottomY = this.rankBottomY;
          const rankY = reversed ? layoutReversed ? rankTopY[maxRank] : rankBottomY[maxRank] : layoutReversed ? rankBottomY[minRank] : rankTopY[minRank];
          let jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];
          if (reversed !== layoutReversed) {
            jetty = -jetty;
          }
          const y = rankY - jetty;
          let x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];
          const modelTarget = realEdge.getTerminal(false);
          const realTarget = this.layout.getVisibleTerminal(realEdge, false);
          if (this.layout.isPort(modelTarget) && modelTarget.getParent() === realTarget) {
            const state = graph.view.getState(modelTarget);
            if (state != null) {
              x = state.x;
            } else {
              x = realTarget.geometry.x + cell.target.width * modelTarget.geometry.x;
            }
          }
          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {
              newPoints.push(new Point(x, y - jetty));
            }
            newPoints.push(new Point(x, y));
          } else {
            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {
              newPoints.push(new Point(y - jetty, x));
            }
            newPoints.push(new Point(y, x));
          }
        }
        if (cell.isReversed) {
          this.processReversedEdge(cell, realEdge);
        }
        this.layout.setEdgePoints(realEdge, newPoints);
        if (offsetX === 0) {
          offsetX = this.parallelEdgeSpacing;
        } else if (offsetX > 0) {
          offsetX = -offsetX;
        } else {
          offsetX = -offsetX + this.parallelEdgeSpacing;
        }
        parallelEdgeCount++;
      }
      cell.temp[0] = 101207;
    }
  }
  /**
   * Fixes the position of the specified vertex.
   *
   * @param cell the vertex to position
   */
  setVertexLocation(cell) {
    const realCell = cell.cell;
    const positionX = cell.x[0] - cell.width / 2;
    const positionY = cell.y[0] - cell.height / 2;
    const rankTopY = this.rankTopY;
    const rankBottomY = this.rankBottomY;
    rankTopY[cell.minRank] = Math.min(rankTopY[cell.minRank], positionY);
    rankBottomY[cell.minRank] = Math.max(rankBottomY[cell.minRank], positionY + cell.height);
    if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
      this.layout.setVertexLocation(realCell, positionX, positionY);
    } else {
      this.layout.setVertexLocation(realCell, positionY, positionX);
    }
    this.limitX = Math.max(this.limitX, positionX + cell.width);
  }
  /**
   * Hook to add additional processing
   *
   * @param edge the hierarchical model edge
   * @param realEdge the real edge in the graph
   */
  processReversedEdge(edge, realEdge) {
  }
}
class HierarchicalLayout extends GraphLayout {
  /**
   * Constructs a new hierarchical layout algorithm.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   * @param orientation Optional constant that defines the orientation of this layout. Default is {@link DIRECTION.NORTH}.
   * @param deterministic Optional boolean that specifies if this layout should be deterministic. Default is true.
   */
  constructor(graph, orientation = DIRECTION.NORTH, deterministic = true) {
    super(graph);
    this.parentX = null;
    this.parentY = null;
    this.roots = null;
    this.resizeParent = false;
    this.maintainParentLocation = false;
    this.moveParent = false;
    this.parentBorder = 0;
    this.intraCellSpacing = 30;
    this.interRankCellSpacing = 100;
    this.interHierarchySpacing = 60;
    this.parallelEdgeSpacing = 10;
    this.orientation = DIRECTION.NORTH;
    this.fineTuning = true;
    this.tightenToSource = true;
    this.disableEdgeStyle = true;
    this.traverseAncestors = true;
    this.model = null;
    this.edgesCache = new Dictionary();
    this.edgeSourceTermCache = new Dictionary();
    this.edgesTargetTermCache = new Dictionary();
    this.edgeStyle = HierarchicalEdgeStyle.POLYLINE;
    this.orientation = orientation;
    this.deterministic = deterministic;
  }
  /**
   * Returns the internal <GraphHierarchyModel> for this layout algorithm.
   */
  getDataModel() {
    return this.model;
  }
  /**
   * Executes the layout for the children of the specified parent.
   *
   * @param parent Parent <Cell> that contains the children to be laid out.
   * @param roots Optional starting roots of the layout.
   */
  execute(parent, roots = null) {
    this.parent = parent;
    this.edgesCache = new Dictionary();
    this.edgeSourceTermCache = new Dictionary();
    this.edgesTargetTermCache = new Dictionary();
    if (roots != null && !(roots instanceof Array)) {
      roots = [roots];
    }
    if (roots == null && parent == null) {
      return;
    }
    this.parentX = null;
    this.parentY = null;
    if (parent !== this.graph.getDataModel().root && parent.isVertex() != null && this.maintainParentLocation) {
      const geo = parent.getGeometry();
      if (geo != null) {
        this.parentX = geo.x;
        this.parentY = geo.y;
      }
    }
    if (roots != null) {
      const rootsCopy = [];
      for (let i = 0; i < roots.length; i += 1) {
        const ancestor = parent != null ? parent.isAncestor(roots[i]) : true;
        if (ancestor && roots[i].isVertex()) {
          rootsCopy.push(roots[i]);
        }
      }
      this.roots = rootsCopy;
    }
    const { model } = this.graph;
    model.batchUpdate(() => {
      this.run(parent);
      if (this.resizeParent && !parent.isCollapsed()) {
        this.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);
      }
      if (this.parentX != null && this.parentY != null) {
        let geo = parent.getGeometry();
        if (geo != null) {
          geo = geo.clone();
          geo.x = this.parentX;
          geo.y = this.parentY;
          model.setGeometry(parent, geo);
        }
      }
    });
  }
  /**
   * Returns all visible children in the given parent which do not have
   * incoming edges. If the result is empty then the children with the
   * maximum difference between incoming and outgoing edges are returned.
   * This takes into account edges that are being promoted to the given
   * root due to invisible children or collapsed cells.
   *
   * @param parent <Cell> whose children should be checked.
   * @param vertices array of vertices to limit search to
   */
  findRoots(parent, vertices) {
    const roots = [];
    if (parent != null && vertices != null) {
      const { model } = this.graph;
      let best = null;
      let maxDiff = -1e5;
      for (const i in vertices) {
        const cell = vertices[i];
        if (cell.isVertex() && cell.isVisible()) {
          const conns = this.getEdges(cell);
          let fanOut = 0;
          let fanIn = 0;
          for (let k = 0; k < conns.length; k++) {
            const src = this.getVisibleTerminal(conns[k], true);
            if (src === cell) {
              fanOut++;
            } else {
              fanIn++;
            }
          }
          if (fanIn === 0 && fanOut > 0) {
            roots.push(cell);
          }
          const diff = fanOut - fanIn;
          if (diff > maxDiff) {
            maxDiff = diff;
            best = cell;
          }
        }
      }
      if (roots.length === 0 && best != null) {
        roots.push(best);
      }
    }
    return roots;
  }
  /**
   * Returns the connected edges for the given cell.
   *
   * @param cell <Cell> whose edges should be returned.
   */
  getEdges(cell) {
    const cachedEdges = this.edgesCache.get(cell);
    if (cachedEdges != null) {
      return cachedEdges;
    }
    const { model } = this.graph;
    let edges = [];
    const isCollapsed = cell.isCollapsed();
    const childCount = cell.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      const child = cell.getChildAt(i);
      if (this.isPort(child)) {
        edges = edges.concat(child.getEdges(true, true));
      } else if (isCollapsed || !child.isVisible()) {
        edges = edges.concat(child.getEdges(true, true));
      }
    }
    edges = edges.concat(cell.getEdges(true, true));
    const result = [];
    for (let i = 0; i < edges.length; i += 1) {
      const source = this.getVisibleTerminal(edges[i], true);
      const target = this.getVisibleTerminal(edges[i], false);
      if (source === target || source !== target && (target === cell && (this.parent == null || this.isAncestor(this.parent, source, this.traverseAncestors)) || source === cell && (this.parent == null || this.isAncestor(this.parent, target, this.traverseAncestors)))) {
        result.push(edges[i]);
      }
    }
    this.edgesCache.put(cell, result);
    return result;
  }
  /**
   * Helper function to return visible terminal for edge allowing for ports
   *
   * @param edge <Cell> whose edges should be returned.
   * @param source Boolean that specifies whether the source or target terminal is to be returned
   */
  getVisibleTerminal(edge, source) {
    let terminalCache;
    if (source) {
      terminalCache = this.edgeSourceTermCache;
    } else {
      terminalCache = this.edgesTargetTermCache;
    }
    const term = terminalCache.get(edge);
    if (term != null) {
      return term;
    }
    const state = this.graph.view.getState(edge);
    let terminal = state != null ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);
    if (terminal == null) {
      terminal = state != null ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);
    }
    if (terminal != null) {
      if (this.isPort(terminal)) {
        terminal = terminal.getParent();
      }
      terminalCache.put(edge, terminal);
    }
    return terminal;
  }
  /**
   * The API method used to exercise the layout upon the graph description
   * and produce a separate description of the vertex position and edge
   * routing changes made. It runs each stage of the layout that has been
   * created.
   */
  run(parent) {
    const hierarchyVertices = [];
    const allVertexSet = {};
    if (this.roots == null && parent != null) {
      const filledVertexSet = Object();
      this.filterDescendants(parent, filledVertexSet);
      this.roots = [];
      let filledVertexSetEmpty = true;
      for (const key in filledVertexSet) {
        if (filledVertexSet[key] != null) {
          filledVertexSetEmpty = false;
          break;
        }
      }
      while (!filledVertexSetEmpty) {
        const candidateRoots = this.findRoots(parent, filledVertexSet);
        for (let i = 0; i < candidateRoots.length; i += 1) {
          const vertexSet = Object();
          hierarchyVertices.push(vertexSet);
          this.traverse({
            vertex: candidateRoots[i],
            directed: true,
            edge: null,
            allVertices: allVertexSet,
            currentComp: vertexSet,
            hierarchyVertices,
            filledVertexSet,
            func: null,
            visited: null
          });
        }
        for (let i = 0; i < candidateRoots.length; i += 1) {
          this.roots.push(candidateRoots[i]);
        }
        filledVertexSetEmpty = true;
        for (const key in filledVertexSet) {
          if (filledVertexSet[key] != null) {
            filledVertexSetEmpty = false;
            break;
          }
        }
      }
    } else {
      const roots = this.roots;
      for (let i = 0; i < roots.length; i += 1) {
        const vertexSet = Object();
        hierarchyVertices.push(vertexSet);
        this.traverse({
          vertex: roots[i],
          directed: true,
          edge: null,
          allVertices: allVertexSet,
          currentComp: vertexSet,
          hierarchyVertices,
          filledVertexSet: null,
          func: null,
          visited: null
        });
      }
    }
    let initialX = 0;
    for (let i = 0; i < hierarchyVertices.length; i += 1) {
      const vertexSet = hierarchyVertices[i];
      const tmp = [];
      for (const key in vertexSet) {
        tmp.push(vertexSet[key]);
      }
      this.model = new GraphHierarchyModel(this, tmp, this.roots, parent, this.tightenToSource);
      this.cycleStage(parent);
      this.layeringStage();
      this.crossingStage(parent);
      initialX = this.placementStage(initialX, parent);
    }
  }
  /**
   * Creates an array of descendant cells
   */
  filterDescendants(cell, result) {
    const { model } = this.graph;
    if (cell.isVertex() && cell !== this.parent && cell.isVisible()) {
      result[ObjectIdentity.get(cell)] = cell;
    }
    if (this.traverseAncestors || cell === this.parent && cell.isVisible()) {
      const childCount = cell.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        const child = cell.getChildAt(i);
        if (!this.isPort(child)) {
          this.filterDescendants(child, result);
        }
      }
    }
  }
  /**
   * Returns true if the given cell is a "port", that is, when connecting to
   * it, its parent is the connecting vertex in terms of graph traversal
   *
   * @param cell <Cell> that represents the port.
   */
  isPort(cell) {
    if (cell != null && cell.geometry != null) {
      return cell.geometry.relative;
    }
    return false;
  }
  /**
   * Returns the edges between the given source and target. This takes into
   * account collapsed and invisible cells and ports.
   *
   * source -
   * target -
   * directed -
   */
  getEdgesBetween(source, target, directed) {
    directed = directed != null ? directed : false;
    const edges = this.getEdges(source);
    const result = [];
    for (let i = 0; i < edges.length; i += 1) {
      const src = this.getVisibleTerminal(edges[i], true);
      const trg = this.getVisibleTerminal(edges[i], false);
      if (src === source && trg === target || !directed && src === target && trg === source) {
        result.push(edges[i]);
      }
    }
    return result;
  }
  /**
   * Traverses the (directed) graph invoking the given function for each
   * visited vertex and edge. The function is invoked with the current vertex
   * and the incoming edge as a parameter. This implementation makes sure
   * each vertex is only visited once. The function may return false if the
   * traversal should stop at the given vertex.
   *
   * @param vertex <Cell> that represents the vertex where the traversal starts.
   * @param directed boolean indicating if edges should only be traversed
   * from source to target. Default is true.
   * @param edge Optional <Cell> that represents the incoming edge. This is
   * null for the first step of the traversal.
   * @param allVertices Array of cell paths for the visited cells.
   */
  traverse({ vertex, directed, allVertices, currentComp, hierarchyVertices, filledVertexSet }) {
    if (vertex != null && allVertices != null) {
      const vertexID = ObjectIdentity.get(vertex);
      if (allVertices[vertexID] == null && (filledVertexSet == null ? true : filledVertexSet[vertexID] != null)) {
        if (currentComp[vertexID] == null) {
          currentComp[vertexID] = vertex;
        }
        if (allVertices[vertexID] == null) {
          allVertices[vertexID] = vertex;
        }
        if (filledVertexSet !== null) {
          delete filledVertexSet[vertexID];
        }
        const edges = this.getEdges(vertex);
        const edgeIsSource = [];
        for (let i = 0; i < edges.length; i += 1) {
          edgeIsSource[i] = this.getVisibleTerminal(edges[i], true) == vertex;
        }
        for (let i = 0; i < edges.length; i += 1) {
          if (!directed || edgeIsSource[i]) {
            const next = this.getVisibleTerminal(edges[i], !edgeIsSource[i]);
            let netCount = 1;
            for (let j = 0; j < edges.length; j++) {
              if (j !== i) {
                const isSource2 = edgeIsSource[j];
                const otherTerm = this.getVisibleTerminal(edges[j], !isSource2);
                if (otherTerm === next) {
                  if (isSource2) {
                    netCount++;
                  } else {
                    netCount--;
                  }
                }
              }
            }
            if (netCount >= 0) {
              currentComp = this.traverse({
                vertex: next,
                directed,
                edge: edges[i],
                allVertices,
                currentComp,
                hierarchyVertices,
                filledVertexSet,
                func: null,
                visited: null
              });
            }
          }
        }
      } else if (currentComp[vertexID] == null) {
        for (let i = 0; i < hierarchyVertices.length; i += 1) {
          const comp = hierarchyVertices[i];
          if (comp[vertexID] != null) {
            for (const key in comp) {
              currentComp[key] = comp[key];
            }
            hierarchyVertices.splice(i, 1);
            return currentComp;
          }
        }
      }
    }
    return currentComp;
  }
  /**
   * Executes the cycle stage using mxMinimumCycleRemover.
   */
  cycleStage(parent) {
    const cycleStage = new MinimumCycleRemover(this);
    cycleStage.execute(parent);
  }
  /**
   * Implements first stage of a Sugiyama layout.
   */
  layeringStage() {
    const model = this.model;
    model.initialRank();
    model.fixRanks();
  }
  /**
   * Executes the crossing stage using mxMedianHybridCrossingReduction.
   */
  crossingStage(parent) {
    const crossingStage = new MedianHybridCrossingReduction(this);
    crossingStage.execute(parent);
  }
  /**
   * Executes the placement stage using mxCoordinateAssignment.
   */
  placementStage(initialX, parent) {
    const placementStage = new CoordinateAssignment(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, initialX, this.parallelEdgeSpacing);
    placementStage.fineTuning = this.fineTuning;
    placementStage.execute(parent);
    return placementStage.limitX + this.interHierarchySpacing;
  }
}
class SwimlaneModel {
  /**
   * Creates an internal ordered graph model using the vertices passed in. If
   * there are any, leftward edge need to be inverted in the internal model.
   *
   * @param layout
   * @param vertices the vertices for this hierarchy
   * @param roots
   * @param parent
   * @param tightenToSource whether or not to tighten vertices towards the sources
   */
  constructor(layout, vertices, roots, parent, tightenToSource) {
    this.ranks = [];
    this.dfsCount = 0;
    this.SOURCESCANSTARTRANK = 1e8;
    this.tightenToSource = false;
    this.ranksPerGroup = null;
    const graph = layout.getGraph();
    this.tightenToSource = tightenToSource;
    this.roots = roots;
    this.parent = parent;
    this.vertexMapper = new Dictionary();
    this.edgeMapper = new Dictionary();
    this.maxRank = 0;
    const internalVertices = [];
    if (vertices == null) {
      vertices = graph.getChildVertices(parent);
    }
    this.maxRank = this.SOURCESCANSTARTRANK;
    this.createInternalCells(layout, vertices, internalVertices);
    for (let i = 0; i < vertices.length; i += 1) {
      const edges = internalVertices[i].connectsAsSource;
      for (let j = 0; j < edges.length; j++) {
        const internalEdge = edges[j];
        const realEdges = internalEdge.edges;
        if (realEdges != null && realEdges.length > 0) {
          const realEdge = realEdges[0];
          let targetCell = layout.getVisibleTerminal(realEdge, false);
          let internalTargetCell = this.vertexMapper.get(targetCell);
          if (internalVertices[i] == internalTargetCell) {
            targetCell = layout.getVisibleTerminal(realEdge, true);
            internalTargetCell = this.vertexMapper.get(targetCell);
          }
          if (internalTargetCell != null && internalVertices[i] !== internalTargetCell) {
            internalEdge.target = internalTargetCell;
            if (internalTargetCell.connectsAsTarget.length == 0) {
              internalTargetCell.connectsAsTarget = [];
            }
            if (internalTargetCell.connectsAsTarget.indexOf(internalEdge) < 0) {
              internalTargetCell.connectsAsTarget.push(internalEdge);
            }
          }
        }
      }
      internalVertices[i].temp[0] = 1;
    }
  }
  /**
   * Creates all edges in the internal model
   *
   * @param layout Reference to the <HierarchicalLayout> algorithm.
   * @param vertices Array of {@link Cells} that represent the vertices whom are to
   * have an internal representation created.
   * @param internalVertices The array of {@link GraphHierarchyNodes} to have their
   * information filled in using the real vertices.
   */
  createInternalCells(layout, vertices, internalVertices) {
    const graph = layout.getGraph();
    const swimlanes = layout.swimlanes;
    for (let i = 0; i < vertices.length; i += 1) {
      internalVertices[i] = new GraphHierarchyNode(vertices[i]);
      this.vertexMapper.put(vertices[i], internalVertices[i]);
      internalVertices[i].swimlaneIndex = -1;
      for (let ii = 0; ii < swimlanes.length; ii += 1) {
        if (vertices[i].getParent() === swimlanes[ii]) {
          internalVertices[i].swimlaneIndex = ii;
          break;
        }
      }
      const conns = layout.getEdges(vertices[i]);
      internalVertices[i].connectsAsSource = [];
      for (let j = 0; j < conns.length; j += 1) {
        const cell = layout.getVisibleTerminal(conns[j], false);
        if (cell !== vertices[i] && cell.isVertex() && !layout.isVertexIgnored(cell)) {
          const undirectedEdges = layout.getEdgesBetween(vertices[i], cell, false);
          const directedEdges = layout.getEdgesBetween(vertices[i], cell, true);
          if (undirectedEdges != null && undirectedEdges.length > 0 && this.edgeMapper.get(undirectedEdges[0]) == null && directedEdges.length * 2 >= undirectedEdges.length) {
            const internalEdge = new GraphHierarchyEdge(undirectedEdges);
            for (let k = 0; k < undirectedEdges.length; k += 1) {
              const edge = undirectedEdges[k];
              this.edgeMapper.put(edge, internalEdge);
              graph.resetEdge(edge);
              if (layout.disableEdgeStyle) {
                layout.setEdgeStyleEnabled(edge, false);
                layout.setOrthogonalEdge(edge, true);
              }
            }
            internalEdge.source = internalVertices[i];
            if (internalVertices[i].connectsAsSource.indexOf(internalEdge) < 0) {
              internalVertices[i].connectsAsSource.push(internalEdge);
            }
          }
        }
      }
      internalVertices[i].temp[0] = 0;
    }
  }
  /**
   * Basic determination of minimum layer ranking by working from from sources
   * or sinks and working through each node in the relevant edge direction.
   * Starting at the sinks is basically a longest path layering algorithm.
   */
  initialRank() {
    this.ranksPerGroup = [];
    const startNodes = [];
    const seen = {};
    if (this.roots != null) {
      for (let i = 0; i < this.roots.length; i += 1) {
        const internalNode = this.vertexMapper.get(this.roots[i]);
        this.maxChainDfs(null, internalNode, null, seen, 0);
        if (internalNode != null) {
          startNodes.push(internalNode);
        }
      }
    }
    const lowerRank = {};
    const upperRank = {};
    for (let i = this.ranksPerGroup.length - 1; i >= 0; i--) {
      if (i === this.ranksPerGroup.length - 1) {
        lowerRank[i] = 0;
      } else {
        lowerRank[i] = upperRank[i + 1] + 1;
      }
      upperRank[i] = lowerRank[i] + this.ranksPerGroup[i];
    }
    this.maxRank = upperRank[0];
    const internalNodes = this.vertexMapper.getValues();
    for (let i = 0; i < internalNodes.length; i += 1) {
      internalNodes[i].temp[0] = -1;
    }
    while (startNodes.length > 0) {
      const internalNode = startNodes[0];
      const layerDeterminingEdges = internalNode.connectsAsTarget;
      const edgesToBeMarked = internalNode.connectsAsSource;
      let allEdgesScanned = true;
      let minimumLayer = upperRank[0];
      for (let i = 0; i < layerDeterminingEdges.length; i += 1) {
        const internalEdge = layerDeterminingEdges[i];
        if (internalEdge.temp[0] === 5270620) {
          const otherNode = internalEdge.source;
          minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);
        } else {
          allEdgesScanned = false;
          break;
        }
      }
      if (allEdgesScanned) {
        if (minimumLayer > upperRank[internalNode.swimlaneIndex]) {
          minimumLayer = upperRank[internalNode.swimlaneIndex];
        }
        internalNode.temp[0] = minimumLayer;
        if (edgesToBeMarked != null) {
          for (let i = 0; i < edgesToBeMarked.length; i += 1) {
            const internalEdge = edgesToBeMarked[i];
            internalEdge.temp[0] = 5270620;
            const otherNode = internalEdge.target;
            if (otherNode.temp[0] === -1) {
              startNodes.push(otherNode);
              otherNode.temp[0] = -2;
            }
          }
        }
        startNodes.shift();
      } else {
        const removedCell = startNodes.shift();
        startNodes.push(internalNode);
        if (removedCell === internalNode && startNodes.length === 1) {
          break;
        }
      }
    }
  }
  /**
   * Performs a depth first search on the internal hierarchy model. This dfs
   * extends the default version by keeping track of chains within groups.
   * Any cycles should be removed prior to running, but previously seen cells
   * are ignored.
   *
   * @param parent the parent internal node of the current internal node
   * @param root the current internal node
   * @param connectingEdge the internal edge connecting the internal node and the parent
   * internal node, if any
   * @param seen a set of all nodes seen by this dfs
   * @param chainCount the number of edges in the chain of vertices going through
   * the current swimlane
   */
  maxChainDfs(parent, root, connectingEdge, seen, chainCount) {
    if (root != null) {
      const rootId = CellPath.create(root.cell);
      if (seen[rootId] == null) {
        seen[rootId] = root;
        const slIndex = root.swimlaneIndex;
        const ranksPerGroup = this.ranksPerGroup;
        if (ranksPerGroup[slIndex] == null || ranksPerGroup[slIndex] < chainCount) {
          ranksPerGroup[slIndex] = chainCount;
        }
        const outgoingEdges = root.connectsAsSource.slice();
        for (let i = 0; i < outgoingEdges.length; i += 1) {
          const internalEdge = outgoingEdges[i];
          const targetNode = internalEdge.target;
          if (root.swimlaneIndex < targetNode.swimlaneIndex) {
            this.maxChainDfs(root, targetNode, internalEdge, clone(seen, null, true), 0);
          } else if (root.swimlaneIndex === targetNode.swimlaneIndex) {
            this.maxChainDfs(root, targetNode, internalEdge, clone(seen, null, true), chainCount + 1);
          }
        }
      }
    }
  }
  /**
   * Fixes the layer assignments to the values stored in the nodes. Also needs
   * to create dummy nodes for edges that cross layers.
   */
  fixRanks() {
    const rankList = [];
    this.ranks = [];
    for (let i = 0; i < this.maxRank + 1; i += 1) {
      rankList[i] = [];
      this.ranks[i] = rankList[i];
    }
    let rootsArray = null;
    if (this.roots != null) {
      const oldRootsArray = this.roots;
      rootsArray = [];
      for (let i = 0; i < oldRootsArray.length; i += 1) {
        const cell = oldRootsArray[i];
        const internalNode = this.vertexMapper.get(cell);
        rootsArray[i] = internalNode;
      }
    }
    this.visit((parent, node, edge, layer, seen) => {
      if (seen === 0 && node.maxRank < 0 && node.minRank < 0) {
        rankList[node.temp[0]].push(node);
        node.maxRank = node.temp[0];
        node.minRank = node.temp[0];
        node.temp[0] = rankList[node.maxRank].length - 1;
      }
      if (parent != null && edge != null) {
        const parentToCellRankDifference = parent.maxRank - node.maxRank;
        if (parentToCellRankDifference > 1) {
          edge.maxRank = parent.maxRank;
          edge.minRank = node.maxRank;
          edge.temp = [];
          edge.x = [];
          edge.y = [];
          for (let i = edge.minRank + 1; i < edge.maxRank; i += 1) {
            rankList[i].push(edge);
            edge.setGeneralPurposeVariable(i, rankList[i].length - 1);
          }
        }
      }
    }, rootsArray, false, null);
  }
  /**
   * A depth first search through the internal heirarchy model.
   *
   * @param visitor The visitor function pattern to be called for each node.
   * @param trackAncestors Whether or not the search is to keep track all nodes
   * directly above this one in the search path.
   */
  visit(visitor, dfsRoots, trackAncestors, seenNodes) {
    if (dfsRoots != null) {
      for (let i = 0; i < dfsRoots.length; i += 1) {
        const internalNode = dfsRoots[i];
        if (internalNode != null) {
          if (seenNodes == null) {
            seenNodes = {};
          }
          if (trackAncestors) {
            internalNode.hashCode = [];
            internalNode.hashCode[0] = this.dfsCount;
            internalNode.hashCode[1] = i;
            this.extendedDfs(null, internalNode, null, visitor, seenNodes, internalNode.hashCode, i, 0);
          } else {
            this.dfs(null, internalNode, null, visitor, seenNodes, 0);
          }
        }
      }
      this.dfsCount += 1;
    }
  }
  /**
   * Performs a depth first search on the internal hierarchy model
   *
   * @param parent the parent internal node of the current internal node
   * @param root the current internal node
   * @param connectingEdge the internal edge connecting the internal node and the parent
   * internal node, if any
   * @param visitor the visitor pattern to be called for each node
   * @param seen a set of all nodes seen by this dfs a set of all of the
   * ancestor node of the current node
   * @param layer the layer on the dfs tree ( not the same as the model ranks )
   */
  dfs(parent, root, connectingEdge, visitor, seen, layer) {
    if (root != null) {
      const rootId = root.id;
      if (seen[rootId] == null) {
        seen[rootId] = root;
        visitor(parent, root, connectingEdge, layer, 0);
        const outgoingEdges = root.connectsAsSource.slice();
        for (let i = 0; i < outgoingEdges.length; i += 1) {
          const internalEdge = outgoingEdges[i];
          const targetNode = internalEdge.target;
          this.dfs(root, targetNode, internalEdge, visitor, seen, layer + 1);
        }
      } else {
        visitor(parent, root, connectingEdge, layer, 1);
      }
    }
  }
  /**
   * Performs a depth first search on the internal hierarchy model. This dfs
   * extends the default version by keeping track of cells ancestors, but it
   * should be only used when necessary because of it can be computationally
   * intensive for deep searches.
   *
   * @param parent the parent internal node of the current internal node
   * @param root the current internal node
   * @param connectingEdge the internal edge connecting the internal node and the parent
   * internal node, if any
   * @param visitor the visitor pattern to be called for each node
   * @param seen a set of all nodes seen by this dfs
   * @param ancestors the parent hash code
   * @param childHash the new hash code for this node
   * @param layer the layer on the dfs tree ( not the same as the model ranks )
   */
  extendedDfs(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer) {
    if (root != null) {
      if (parent != null) {
        if (root.hashCode == null || root.hashCode[0] !== parent.hashCode[0]) {
          const hashCodeLength = parent.hashCode.length + 1;
          root.hashCode = parent.hashCode.slice();
          root.hashCode[hashCodeLength - 1] = childHash;
        }
      }
      const rootId = root.id;
      if (seen[rootId] == null) {
        seen[rootId] = root;
        visitor(parent, root, connectingEdge, layer, 0);
        const outgoingEdges = root.connectsAsSource.slice();
        const incomingEdges = root.connectsAsTarget.slice();
        for (let i = 0; i < outgoingEdges.length; i += 1) {
          const internalEdge = outgoingEdges[i];
          const targetNode = internalEdge.target;
          if (root.swimlaneIndex <= targetNode.swimlaneIndex) {
            this.extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i, layer + 1);
          }
        }
        for (let i = 0; i < incomingEdges.length; i += 1) {
          const internalEdge = incomingEdges[i];
          const targetNode = internalEdge.source;
          if (root.swimlaneIndex < targetNode.swimlaneIndex) {
            this.extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i, layer + 1);
          }
        }
      } else {
        visitor(parent, root, connectingEdge, layer, 1);
      }
    }
  }
}
class SwimlaneOrdering extends HierarchicalLayoutStage {
  /**
   * Creates a cycle remover for the given internal model.
   */
  constructor(layout) {
    super();
    this.layout = layout;
  }
  /**
   * Takes the graph detail and configuration information within the facade
   * and creates the resulting laid out graph within that facade for further
   * use.
   */
  execute(parent) {
    const model = this.layout.getDataModel();
    const unseenNodes = clone(model.vertexMapper, null, true);
    let rootsArray = null;
    if (model.roots != null) {
      const modelRoots = model.roots;
      rootsArray = [];
      for (let i = 0; i < modelRoots.length; i += 1) {
        rootsArray[i] = model.vertexMapper.get(modelRoots[i]);
      }
    }
    model.visit((parent2, node, connectingEdge, layer, seen) => {
      const isAncestor = parent2 != null && parent2.swimlaneIndex === node.swimlaneIndex && node.isAncestor(parent2);
      const reversedOverSwimlane = parent2 != null && connectingEdge != null && parent2.swimlaneIndex < node.swimlaneIndex && connectingEdge.source === node;
      if (isAncestor) {
        connectingEdge.invert();
        remove(connectingEdge, parent2.connectsAsSource);
        node.connectsAsSource.push(connectingEdge);
        parent2.connectsAsTarget.push(connectingEdge);
        remove(connectingEdge, node.connectsAsTarget);
      } else if (reversedOverSwimlane) {
        connectingEdge.invert();
        remove(connectingEdge, parent2.connectsAsTarget);
        node.connectsAsTarget.push(connectingEdge);
        parent2.connectsAsSource.push(connectingEdge);
        remove(connectingEdge, node.connectsAsSource);
      }
      const cellId = CellPath.create(node.cell);
      delete unseenNodes[cellId];
    }, rootsArray, true, null);
  }
}
class SwimlaneLayout extends GraphLayout {
  /**
   * Constructs a new hierarchical layout algorithm.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   * @param orientation Optional constant that defines the orientation of this layout. Default is {@link DIRECTION_NORTH}.
   * @param deterministic Optional boolean that specifies if this layout should be deterministic. Default is true.
   */
  constructor(graph, orientation, deterministic = true) {
    super(graph);
    this.parentX = null;
    this.parentY = null;
    this.roots = null;
    this.swimlanes = null;
    this.dummyVertexWidth = 50;
    this.resizeParent = false;
    this.maintainParentLocation = false;
    this.moveParent = false;
    this.parentBorder = 30;
    this.intraCellSpacing = 30;
    this.interRankCellSpacing = 100;
    this.interHierarchySpacing = 60;
    this.parallelEdgeSpacing = 10;
    this.orientation = DIRECTION.NORTH;
    this.fineTuning = true;
    this.tightenToSource = true;
    this.disableEdgeStyle = true;
    this.traverseAncestors = true;
    this.model = null;
    this.edgesCache = new Dictionary();
    this.edgeSourceTermCache = new Dictionary();
    this.edgesTargetTermCache = new Dictionary();
    this.edgeStyle = HierarchicalEdgeStyle.POLYLINE;
    this.orientation = orientation != null ? orientation : DIRECTION.NORTH;
    this.deterministic = deterministic != null ? deterministic : true;
  }
  /**
   * Returns the internal {@link SwimlaneModel} for this layout algorithm.
   */
  getDataModel() {
    return this.model;
  }
  /**
   * Executes the layout for the children of the specified parent.
   *
   * @param parent Parent <Cell> that contains the children to be laid out.
   * @param swimlanes Ordered array of swimlanes to be laid out
   */
  execute(parent, swimlanes = null) {
    this.parent = parent;
    const { model } = this.graph;
    this.edgesCache = new Dictionary();
    this.edgeSourceTermCache = new Dictionary();
    this.edgesTargetTermCache = new Dictionary();
    if (swimlanes == null || swimlanes.length < 1) {
      return;
    }
    if (parent == null) {
      parent = swimlanes[0].getParent();
    }
    this.parentX = null;
    this.parentY = null;
    if (parent !== this.graph.getDataModel().root && parent.isVertex() != null && this.maintainParentLocation) {
      const geo = parent.getGeometry();
      if (geo != null) {
        this.parentX = geo.x;
        this.parentY = geo.y;
      }
    }
    this.swimlanes = swimlanes;
    const dummyVertices = [];
    for (let i = 0; i < swimlanes.length; i += 1) {
      const children = this.graph.getChildCells(swimlanes[i]);
      if (children == null || children.length === 0) {
        const vertex = this.graph.insertVertex(swimlanes[i], null, null, 0, 0, this.dummyVertexWidth, 0);
        dummyVertices.push(vertex);
      }
    }
    model.beginUpdate();
    try {
      this.run(parent);
      if (this.resizeParent && !parent.isCollapsed()) {
        this.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);
      }
      if (this.parentX != null && this.parentY != null) {
        let geo = parent.getGeometry();
        if (geo != null) {
          geo = geo.clone();
          geo.x = this.parentX;
          geo.y = this.parentY;
          model.setGeometry(parent, geo);
        }
      }
      this.graph.removeCells(dummyVertices);
    } finally {
      model.endUpdate();
    }
  }
  /**
   * Updates the bounds of the given array of groups so that it includes
   * all child vertices.
   *
   */
  updateGroupBounds() {
    const cells = [];
    const model = this.model;
    for (const key in model.edgeMapper) {
      const edge = model.edgeMapper[key];
      for (let i = 0; i < edge.edges.length; i += 1) {
        cells.push(edge.edges[i]);
      }
    }
    let layoutBounds = this.graph.getBoundingBoxFromGeometry(cells, true);
    const childBounds = [];
    const swimlanes = this.swimlanes;
    for (let i = 0; i < swimlanes.length; i += 1) {
      const lane = swimlanes[i];
      const geo = lane.getGeometry();
      if (geo != null) {
        const children = this.graph.getChildCells(lane);
        const size = this.graph.isSwimlane(lane) ? this.graph.getStartSize(lane) : new Rectangle();
        const bounds = this.graph.getBoundingBoxFromGeometry(children);
        childBounds[i] = bounds;
        const childrenY = bounds.y + geo.y - size.height - this.parentBorder;
        const maxChildrenY = bounds.y + geo.y + bounds.height;
        if (layoutBounds == null) {
          layoutBounds = new Rectangle(0, childrenY, 0, maxChildrenY - childrenY);
        } else {
          layoutBounds.y = Math.min(layoutBounds.y, childrenY);
          const maxY = Math.max(layoutBounds.y + layoutBounds.height, maxChildrenY);
          layoutBounds.height = maxY - layoutBounds.y;
        }
      }
    }
    for (let i = 0; i < swimlanes.length; i += 1) {
      const lane = swimlanes[i];
      const geo = lane.getGeometry();
      if (geo != null) {
        const children = this.graph.getChildCells(lane);
        const size = this.graph.isSwimlane(lane) ? this.graph.getStartSize(lane) : new Rectangle();
        const newGeo = geo.clone();
        const leftGroupBorder = i === 0 ? this.parentBorder : this.interRankCellSpacing / 2;
        const w = size.width + leftGroupBorder;
        const x = childBounds[i].x - w;
        const y = layoutBounds.y - this.parentBorder;
        newGeo.x += x;
        newGeo.y = y;
        newGeo.width = childBounds[i].width + w + this.interRankCellSpacing / 2;
        newGeo.height = layoutBounds.height + size.height + 2 * this.parentBorder;
        this.graph.model.setGeometry(lane, newGeo);
        this.graph.moveCells(children, -x, geo.y - y);
      }
    }
  }
  /**
   * Returns all visible children in the given parent which do not have
   * incoming edges. If the result is empty then the children with the
   * maximum difference between incoming and outgoing edges are returned.
   * This takes into account edges that are being promoted to the given
   * root due to invisible children or collapsed cells.
   *
   * @param parent <Cell> whose children should be checked.
   * @param vertices array of vertices to limit search to
   */
  findRoots(parent, vertices) {
    const roots = [];
    if (parent != null && vertices != null) {
      const { model } = this.graph;
      let best = null;
      let maxDiff = -1e5;
      for (const i in vertices) {
        const cell = vertices[i];
        if (cell != null && cell.isVertex() && cell.isVisible() && parent.isAncestor(cell)) {
          const conns = this.getEdges(cell);
          let fanOut = 0;
          let fanIn = 0;
          for (let k = 0; k < conns.length; k++) {
            const src = this.getVisibleTerminal(conns[k], true);
            if (src === cell) {
              const other = this.getVisibleTerminal(conns[k], false);
              if (parent.isAncestor(other)) {
                fanOut += 1;
              }
            } else if (parent.isAncestor(src)) {
              fanIn += 1;
            }
          }
          if (fanIn === 0 && fanOut > 0) {
            roots.push(cell);
          }
          const diff = fanOut - fanIn;
          if (diff > maxDiff) {
            maxDiff = diff;
            best = cell;
          }
        }
      }
      if (roots.length === 0 && best != null) {
        roots.push(best);
      }
    }
    return roots;
  }
  /**
   * Returns the connected edges for the given cell.
   *
   * @param cell <Cell> whose edges should be returned.
   */
  getEdges(cell) {
    const cachedEdges = this.edgesCache.get(cell);
    if (cachedEdges != null) {
      return cachedEdges;
    }
    let edges = [];
    const isCollapsed = cell.isCollapsed();
    const childCount = cell.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      const child = cell.getChildAt(i);
      if (this.isPort(child)) {
        edges = edges.concat(child.getEdges(true, true));
      } else if (isCollapsed || !child.isVisible()) {
        edges = edges.concat(child.getEdges(true, true));
      }
    }
    edges = edges.concat(cell.getEdges(true, true));
    const result = [];
    for (let i = 0; i < edges.length; i += 1) {
      const source = this.getVisibleTerminal(edges[i], true);
      const target = this.getVisibleTerminal(edges[i], false);
      if (source === target || source !== target && (target === cell && (this.parent == null || this.graph.isValidAncestor(source, this.parent, this.traverseAncestors)) || source === cell && (this.parent == null || this.graph.isValidAncestor(target, this.parent, this.traverseAncestors)))) {
        result.push(edges[i]);
      }
    }
    this.edgesCache.put(cell, result);
    return result;
  }
  /**
   * Helper function to return visible terminal for edge allowing for ports
   *
   * @param edge <Cell> whose edges should be returned.
   * @param source Boolean that specifies whether the source or target terminal is to be returned
   */
  getVisibleTerminal(edge, source) {
    let terminalCache = this.edgesTargetTermCache;
    if (source) {
      terminalCache = this.edgeSourceTermCache;
    }
    const term = terminalCache.get(edge);
    if (term != null) {
      return term;
    }
    const state = this.graph.view.getState(edge);
    let terminal = state != null ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);
    if (terminal == null) {
      terminal = state != null ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);
    }
    if (terminal != null) {
      if (this.isPort(terminal)) {
        terminal = terminal.getParent();
      }
      terminalCache.put(edge, terminal);
    }
    return terminal;
  }
  /**
   * The API method used to exercise the layout upon the graph description
   * and produce a separate description of the vertex position and edge
   * routing changes made. It runs each stage of the layout that has been
   * created.
   */
  run(parent) {
    const hierarchyVertices = [];
    const allVertexSet = {};
    if (this.swimlanes != null && this.swimlanes.length > 0 && parent != null) {
      const filledVertexSet = {};
      for (let i = 0; i < this.swimlanes.length; i += 1) {
        this.filterDescendants(this.swimlanes[i], filledVertexSet);
      }
      this.roots = [];
      let filledVertexSetEmpty = true;
      for (const key in filledVertexSet) {
        if (filledVertexSet[key] != null) {
          filledVertexSetEmpty = false;
          break;
        }
      }
      let laneCounter = 0;
      while (!filledVertexSetEmpty && laneCounter < this.swimlanes.length) {
        const candidateRoots = this.findRoots(this.swimlanes[laneCounter], filledVertexSet);
        if (candidateRoots.length === 0) {
          laneCounter++;
          continue;
        }
        for (let i = 0; i < candidateRoots.length; i += 1) {
          const vertexSet = Object();
          hierarchyVertices.push(vertexSet);
          this.traverse({
            vertex: candidateRoots[i],
            directed: true,
            edge: null,
            allVertices: allVertexSet,
            currentComp: vertexSet,
            hierarchyVertices,
            filledVertexSet,
            swimlaneIndex: laneCounter,
            func: null,
            visited: null
          });
        }
        for (let i = 0; i < candidateRoots.length; i += 1) {
          this.roots.push(candidateRoots[i]);
        }
        filledVertexSetEmpty = true;
        for (const key in filledVertexSet) {
          if (filledVertexSet[key] != null) {
            filledVertexSetEmpty = false;
            break;
          }
        }
      }
    } else {
      const roots = this.roots;
      for (let i = 0; i < roots.length; i += 1) {
        const vertexSet = Object();
        hierarchyVertices.push(vertexSet);
        this.traverse({
          vertex: roots[i],
          directed: true,
          edge: null,
          allVertices: allVertexSet,
          currentComp: vertexSet,
          hierarchyVertices,
          filledVertexSet: null,
          swimlaneIndex: i,
          func: null,
          visited: null
        });
      }
    }
    const tmp = [];
    for (const key in allVertexSet) {
      tmp.push(allVertexSet[key]);
    }
    this.model = new SwimlaneModel(this, tmp, this.roots, parent, this.tightenToSource);
    this.cycleStage(parent);
    this.layeringStage();
    this.crossingStage(parent);
    this.placementStage(0, parent);
  }
  /**
   * Creates an array of descendant cells
   */
  filterDescendants(cell, result) {
    const { model } = this.graph;
    if (cell.isVertex() && cell !== this.parent && cell.getParent() !== this.parent && cell.isVisible()) {
      result[ObjectIdentity.get(cell)] = cell;
    }
    if (this.traverseAncestors || cell === this.parent && cell.isVisible()) {
      const childCount = cell.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        const child = cell.getChildAt(i);
        if (!this.isPort(child)) {
          this.filterDescendants(child, result);
        }
      }
    }
  }
  /**
   * Returns true if the given cell is a "port", that is, when connecting to
   * it, its parent is the connecting vertex in terms of graph traversal
   *
   * @param cell <Cell> that represents the port.
   */
  isPort(cell) {
    if (cell.geometry.relative) {
      return true;
    }
    return false;
  }
  /**
   * Returns the edges between the given source and target. This takes into
   * account collapsed and invisible cells and ports.
   *
   * source -
   * target -
   * directed -
   */
  getEdgesBetween(source, target, directed = false) {
    const edges = this.getEdges(source);
    const result = [];
    for (let i = 0; i < edges.length; i += 1) {
      const src = this.getVisibleTerminal(edges[i], true);
      const trg = this.getVisibleTerminal(edges[i], false);
      if (src === source && trg === target || !directed && src === target && trg === source) {
        result.push(edges[i]);
      }
    }
    return result;
  }
  /**
   * Traverses the (directed) graph invoking the given function for each
   * visited vertex and edge. The function is invoked with the current vertex
   * and the incoming edge as a parameter. This implementation makes sure
   * each vertex is only visited once. The function may return false if the
   * traversal should stop at the given vertex.
   *
   * @param vertex <Cell> that represents the vertex where the traversal starts.
   * @param directed boolean indicating if edges should only be traversed
   * from source to target. Default is true.
   * @param edge Optional <Cell> that represents the incoming edge. This is
   * null for the first step of the traversal.
   * @param allVertices Array of cell paths for the visited cells.
   * @param swimlaneIndex the laid out order index of the swimlane vertex is contained in
   */
  traverse({ vertex, directed, allVertices, currentComp, hierarchyVertices, filledVertexSet, swimlaneIndex }) {
    if (vertex != null && allVertices != null) {
      const vertexID = ObjectIdentity.get(vertex);
      if (allVertices[vertexID] == null && (filledVertexSet == null ? true : filledVertexSet[vertexID] != null)) {
        if (currentComp[vertexID] == null) {
          currentComp[vertexID] = vertex;
        }
        if (allVertices[vertexID] == null) {
          allVertices[vertexID] = vertex;
        }
        if (filledVertexSet !== null) {
          delete filledVertexSet[vertexID];
        }
        const edges = this.getEdges(vertex);
        for (let i = 0; i < edges.length; i += 1) {
          let otherVertex = this.getVisibleTerminal(edges[i], true);
          const isSource = otherVertex === vertex;
          if (isSource) {
            otherVertex = this.getVisibleTerminal(edges[i], false);
          }
          let otherIndex = 0;
          for (otherIndex = 0; otherIndex < this.swimlanes.length; otherIndex++) {
            if (this.swimlanes[otherIndex].isAncestor(otherVertex)) {
              break;
            }
          }
          if (otherIndex >= this.swimlanes.length) {
            continue;
          }
          if (otherIndex > swimlaneIndex || (!directed || isSource) && otherIndex === swimlaneIndex) {
            currentComp = this.traverse({
              vertex: otherVertex,
              directed,
              edge: edges[i],
              allVertices,
              currentComp,
              hierarchyVertices,
              filledVertexSet,
              swimlaneIndex: otherIndex,
              func: null,
              visited: null
            });
          }
        }
      } else if (currentComp[vertexID] == null) {
        for (let i = 0; i < hierarchyVertices.length; i += 1) {
          const comp = hierarchyVertices[i];
          if (comp[vertexID] != null) {
            for (const key in comp) {
              currentComp[key] = comp[key];
            }
            hierarchyVertices.splice(i, 1);
            return currentComp;
          }
        }
      }
    }
    return currentComp;
  }
  /**
   * Executes the cycle stage using mxMinimumCycleRemover.
   */
  cycleStage(parent) {
    const cycleStage = new SwimlaneOrdering(this);
    cycleStage.execute(parent);
  }
  /**
   * Implements first stage of a Sugiyama layout.
   */
  layeringStage() {
    const model = this.model;
    model.initialRank();
    model.fixRanks();
  }
  /**
   * Executes the crossing stage using mxMedianHybridCrossingReduction.
   */
  crossingStage(parent) {
    const crossingStage = new MedianHybridCrossingReduction(this);
    crossingStage.execute(parent);
  }
  /**
   * Executes the placement stage using mxCoordinateAssignment.
   */
  placementStage(initialX, parent) {
    const placementStage = new CoordinateAssignment(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, initialX, this.parallelEdgeSpacing);
    placementStage.fineTuning = this.fineTuning;
    placementStage.execute(parent);
    return placementStage.limitX + this.interHierarchySpacing;
  }
}
class EditorCodec extends ObjectCodec {
  constructor() {
    const __dummy = void 0;
    super(new Editor(__dummy), [
      "modified",
      "lastSnapshot",
      "ignoredChanges",
      "undoManager",
      "graphContainer",
      "toolbarContainer"
    ]);
  }
  /**
   * Decodes the ui-part of the configuration node by reading
   * a sequence of the following child nodes and attributes
   * and passes the control to the default decoding mechanism:
   *
   * Child Nodes:
   *
   * stylesheet - Adds a CSS stylesheet to the document.
   * resource - Adds the basename of a resource bundle.
   * add - Creates or configures a known UI element.
   *
   * These elements may appear in any order given that the
   * graph UI element is added before the toolbar element
   * (see Known Keys).
   *
   * Attributes:
   *
   * as - Key for the UI element (see below).
   * element - ID for the element in the document.
   * style - CSS style to be used for the element or window.
   * x - X coordinate for the new window.
   * y - Y coordinate for the new window.
   * width - Width for the new window.
   * height - Optional height for the new window.
   * name - Name of the stylesheet (absolute/relative URL).
   * basename - Basename of the resource bundle (see {@link Resources}).
   *
   * The x, y, width and height attributes are used to create a new
   * <MaxWindow> if the element attribute is not specified in an add
   * node. The name and basename are only used in the stylesheet and
   * resource nodes, respectively.
   *
   * Known Keys:
   *
   * graph - Main graph element (see <Editor.setGraphContainer>).
   * title - Title element (see <Editor.setTitleContainer>).
   * toolbar - Toolbar element (see <Editor.setToolbarContainer>).
   * status - Status bar element (see <Editor.setStatusContainer>).
   *
   * Example:
   *
   * ```javascript
   * <ui>
   *   <stylesheet name="css/process.css"/>
   *   <resource basename="resources/app"/>
   *   <add as="graph" element="graph"
   *     style="left:70px;right:20px;top:20px;bottom:40px"/>
   *   <add as="status" element="status"/>
   *   <add as="toolbar" x="10" y="20" width="54"/>
   * </ui>
   * ```
   */
  afterDecode(dec, node, obj) {
    const defaultEdge = node.getAttribute("defaultEdge");
    if (defaultEdge != null) {
      node.removeAttribute("defaultEdge");
      obj.defaultEdge = obj.templates[defaultEdge];
    }
    const defaultGroup = node.getAttribute("defaultGroup");
    if (defaultGroup != null) {
      node.removeAttribute("defaultGroup");
      obj.defaultGroup = obj.templates[defaultGroup];
    }
    return obj;
  }
  /**
   * Overrides decode child to handle special child nodes.
   */
  decodeChild(dec, child, obj) {
    if (child.nodeName === "Array") {
      const role = child.getAttribute("as");
      if (role === "templates") {
        this.decodeTemplates(dec, child, obj);
        return;
      }
    } else if (child.nodeName === "ui") {
      this.decodeUi(dec, child, obj);
      return;
    }
    super.decodeChild.apply(this, [dec, child, obj]);
  }
  /**
   * Decodes the ui elements from the given node.
   */
  decodeUi(dec, node, editor) {
    let tmp = node.firstChild;
    while (tmp != null) {
      if (tmp.nodeName === "add") {
        const as = tmp.getAttribute("as");
        const elt = tmp.getAttribute("element");
        const style = tmp.getAttribute("style");
        let element = null;
        if (elt != null) {
          element = document.getElementById(elt);
          if (element != null && style != null) {
            element.style.cssText += `;${style}`;
          }
        } else {
          const x = parseInt(tmp.getAttribute("x"));
          const y = parseInt(tmp.getAttribute("y"));
          const width = tmp.getAttribute("width") || null;
          const height = tmp.getAttribute("height") || null;
          element = document.createElement("div");
          if (style != null) {
            element.style.cssText = style;
          }
          const wnd = new MaxWindow(translate(as) || as, element, x, y, width ? parseInt(width) : null, height ? parseInt(height) : null, false, true);
          wnd.setVisible(true);
        }
        if (as === "graph") {
          editor.setGraphContainer(element);
        } else if (as === "toolbar") {
          editor.setToolbarContainer(element);
        } else if (as === "title") {
          editor.setTitleContainer(element);
        } else if (as === "status") {
          editor.setStatusContainer(element);
        } else if (as === "map") {
          throw new Error("Unimplemented");
        }
      } else if (tmp.nodeName === "resource") {
        GlobalConfig.i18n.addResource(tmp.getAttribute("basename"));
      } else if (tmp.nodeName === "stylesheet") {
        addLinkToHead("stylesheet", tmp.getAttribute("name"));
      }
      tmp = tmp.nextSibling;
    }
  }
  /**
   * Decodes the cells from the given node as templates.
   */
  decodeTemplates(dec, node, editor) {
    if (editor.templates == null) {
      editor.templates = [];
    }
    const children = getChildNodes(node);
    for (let j = 0; j < children.length; j++) {
      const name = children[j].getAttribute("as");
      let child = children[j].firstChild;
      while (child != null && child.nodeType !== 1) {
        child = child.nextSibling;
      }
      if (child != null) {
        editor.templates[name] = dec.decodeCell(child);
      }
    }
  }
}
class EditorKeyHandlerCodec extends ObjectCodec {
  constructor() {
    super(new EditorKeyHandler());
  }
  /**
   * Returns `null`.
   */
  encode(enc, obj) {
    return null;
  }
  /**
   * Reads a sequence of the following child nodes and attributes:
   *
   * Child Nodes:
   *
   * add - Binds a keystroke to an action name.
   *
   * Attributes:
   *
   * as - Keycode.
   * action - Action name to execute in editor.
   * control - Optional boolean indicating if
   *     the control key must be pressed.
   *
   * Example:
   *
   * ```javascript
   * <EditorKeyHandler as="keyHandler">
   *   <add as="88" control="true" action="cut"/>
   *   <add as="67" control="true" action="copy"/>
   *   <add as="86" control="true" action="paste"/>
   * </EditorKeyHandler>
   * ```
   *
   * The keycodes are for the x, c and v keys.
   *
   * See also: <EditorKeyHandler.bindAction>, http://www.js-examples.com/page/tutorials__key_codes.html
   */
  decode(dec, _node, into) {
    if (into != null) {
      const { editor } = into;
      let node = _node.firstChild;
      while (node != null) {
        if (!this.processInclude(dec, node, into) && node.nodeName === "add") {
          const as = node.getAttribute("as");
          const action = node.getAttribute("action");
          const control = node.getAttribute("control");
          into.bindAction(as, action, control);
        }
        node = node.nextSibling;
      }
    }
    return into;
  }
}
class EditorPopupMenuCodec extends ObjectCodec {
  constructor() {
    super(new EditorPopupMenu());
  }
  /**
   * Returns null.
   */
  encode(_enc, _obj) {
    return null;
  }
  /**
   * Uses the given node as the config for <EditorPopupMenu>.
   */
  decode(dec, node, into) {
    const inc = node.getElementsByTagName("include")[0];
    if (inc != null) {
      this.processInclude(dec, inc, into);
    } else if (into != null) {
      into.config = node;
    }
    return into;
  }
}
class EditorToolbarCodec extends ObjectCodec {
  constructor() {
    super(new EditorToolbar());
  }
  /**
   * Returns `null`.
   */
  encode(_enc, _obj) {
    return null;
  }
  /**
   * Reads a sequence of the following child nodes and attributes:
   *
   * Child Nodes:
   *
   * add - Adds a new item to the toolbar. See below for attributes.
   * separator - Adds a vertical separator. No attributes.
   * hr - Adds a horizontal separator. No attributes.
   * br - Adds a linefeed. No attributes.
   *
   * Attributes:
   *
   * as - Resource key for the label.
   * action - Name of the action to execute in enclosing editor.
   * mode - Mode name (see below).
   * template - Template name for cell insertion.
   * style - Optional style to override the template style.
   * icon - Icon (relative/absolute URL).
   * pressedIcon - Optional icon for pressed state (relative/absolute URL).
   * id - Optional ID to be used for the created DOM element.
   * toggle - Optional 0 or 1 to disable toggling of the element. Default is 1 (true).
   *
   * The action, mode and template attributes are mutually exclusive. The style can only be used with the template attribute.
   * The add node may contain another sequence of add nodes with "as" and action attributes to create a combo box in the toolbar.
   * If the icon is specified then a list of the child node is expected to have its template attribute set and the action is ignored instead.
   *
   * Nodes with a specified template may define a function to be used for inserting the cloned template into the graph.
   * Here is an example of such a node:
   *
   * ```javascript
   * <add as="Swimlane" template="swimlane" icon="images/swimlane.gif"><![CDATA[
   *   function (editor, cell, evt, targetCell)
   *   {
   *     let pt = mxUtils.convertPoint(
   *       editor.graph.container, mxEvent.getClientX(evt),
   *         mxEvent.getClientY(evt));
   *     return editor.addVertex(targetCell, cell, pt.x, pt.y);
   *   }
   * ]]></add>
   * ```
   *
   * In the above function, editor is the enclosing {@link Editor} instance, cell is the clone of the template, evt is the mouse event that represents the
   * drop and targetCell is the cell under the mouse pointer where the drop occurred. The targetCell is retrieved using {@link Graph#getCellAt}.
   *
   * Furthermore, nodes with the mode attribute may define a function to be executed upon selection of the respective toolbar icon. In the
   * example below, the default edge style is set when this specific
   * connect-mode is activated:
   *
   * ```javascript
   * <add as="connect" mode="connect"><![CDATA[
   *   function (editor)
   *   {
   *     if (editor.defaultEdge != null)
   *     {
   *       editor.defaultEdge.style = 'straightEdge';
   *     }
   *   }
   * ]]></add>
   * ```
   *
   * Both functions require {@link allowEval} to be set to `true`.
   *
   * Modes:
   *
   * select - Left mouse button used for rubberband- & cell-selection.
   * connect - Allows connecting vertices by inserting new edges.
   * pan - Disables selection and switches to panning on the left button.
   *
   * Example:
   *
   * To add items to the toolbar:
   *
   * ```javascript
   * <EditorToolbar as="toolbar">
   *   <add as="save" action="save" icon="images/save.gif"/>
   *   <br/><hr/>
   *   <add as="select" mode="select" icon="images/select.gif"/>
   *   <add as="connect" mode="connect" icon="images/connect.gif"/>
   * </EditorToolbar>
   * ```
   */
  decode(dec, _node, into) {
    if (into != null) {
      const editor = into.editor;
      let node = _node.firstChild;
      while (node != null) {
        if (isElement(node)) {
          if (!this.processInclude(dec, node, into)) {
            if (node.nodeName === "separator") {
              into.addSeparator();
            } else if (node.nodeName === "br") {
              into.toolbar.addBreak();
            } else if (node.nodeName === "hr") {
              into.toolbar.addLine();
            } else if (node.nodeName === "add") {
              let as = node.getAttribute("as");
              as = translate(as) || as;
              const icon = node.getAttribute("icon");
              const pressedIcon = node.getAttribute("pressedIcon");
              const action = node.getAttribute("action");
              const mode = node.getAttribute("mode");
              const template = node.getAttribute("template");
              const toggle = node.getAttribute("toggle") != "0";
              const text = getTextContent(node);
              let elt = null;
              let funct;
              if (action != null) {
                elt = into.addItem(as, icon, action, pressedIcon);
              } else if (mode != null) {
                funct = EditorToolbarCodec.allowEval ? doEval(text) : null;
                elt = into.addMode(as, icon, mode, pressedIcon, funct);
              } else if (template != null || text != null && text.length > 0) {
                let cell = template ? editor.templates[template] : null;
                const style = node.getAttribute("style");
                if (cell != null && style != null) {
                  cell = editor.graph.cloneCell(cell);
                  cell.setStyle(style);
                }
                let insertFunction = null;
                if (text != null && text.length > 0 && EditorToolbarCodec.allowEval) {
                  insertFunction = doEval(text);
                }
                elt = into.addPrototype(as, icon, cell, pressedIcon, insertFunction, toggle);
              } else {
                const children = getChildNodes(node);
                if (children.length > 0) {
                  if (icon == null) {
                    const combo = into.addActionCombo(as);
                    for (let i = 0; i < children.length; i += 1) {
                      const child = children[i];
                      if (child.nodeName === "separator") {
                        into.addOption(combo, "---");
                      } else if (child.nodeName === "add") {
                        const lab = child.getAttribute("as");
                        const act = child.getAttribute("action");
                        into.addActionOption(combo, lab, act);
                      }
                    }
                  } else {
                    const select = into.addCombo();
                    const create = () => {
                      const template2 = editor.templates[select.value];
                      if (template2 != null) {
                        const clone2 = template2.clone();
                        const style = select.options[select.selectedIndex].cellStyle;
                        if (style != null) {
                          clone2.setStyle(style);
                        }
                        return clone2;
                      }
                      GlobalConfig.logger.warn(`Template ${template2} not found`);
                      return null;
                    };
                    const img = into.addPrototype(as, icon, create, null, null, toggle);
                    InternalEvent.addListener(select, "change", () => {
                      into.toolbar.selectMode(img, (evt) => {
                        const pt = convertPoint(editor.graph.container, getClientX(evt), getClientY(evt));
                        return editor.addVertex(null, funct(), pt.x, pt.y);
                      });
                      into.toolbar.noReset = false;
                    });
                    for (let i = 0; i < children.length; i += 1) {
                      const child = children[i];
                      if (child.nodeName === "separator") {
                        into.addOption(select, "---");
                      } else if (child.nodeName === "add") {
                        const lab = child.getAttribute("as");
                        const tmp = child.getAttribute("template");
                        const option = into.addOption(select, lab, tmp || template);
                        option.cellStyle = child.getAttribute("style");
                      }
                    }
                  }
                }
              }
              if (elt != null) {
                const id = node.getAttribute("id");
                if (id != null && id.length > 0) {
                  elt.setAttribute("id", id);
                }
              }
            }
          }
        }
        node = node.nextSibling;
      }
    }
    return into;
  }
}
class ChildChangeCodec extends ObjectCodec {
  constructor() {
    const __dummy = void 0;
    super(new ChildChange(__dummy, __dummy, __dummy), ["model", "child", "previousIndex"], ["parent", "previous"]);
  }
  /**
   * Returns `true` for the child attribute if the child cell had a previous parent or if we're reading the
   * child as an attribute rather than a child node, in which case it's always a reference.
   */
  isReference(obj, attr, value, isWrite) {
    if (attr === "child" && (!isWrite || obj.model.contains(obj.previous))) {
      return true;
    }
    return this.idrefs.indexOf(attr) >= 0;
  }
  /**
   * Excludes references to parent or previous if not in the model.
   */
  isExcluded(obj, attr, value, write2) {
    return super.isExcluded(obj, attr, value, write2) || write2 && value != null && (attr === "previous" || attr === "parent") && !obj.model.contains(value);
  }
  /**
   * Encodes the child recursively and adds the result to the given node.
   */
  afterEncode(enc, obj, node) {
    if (this.isReference(obj, "child", obj.child, true)) {
      node.setAttribute("child", enc.getId(obj.child));
    } else {
      enc.encodeCell(obj.child, node);
    }
    return node;
  }
  /**
   * Decodes any child nodes as using the respective codec from the registry.
   */
  beforeDecode(dec, _node, obj) {
    var _a;
    if (isElement(_node.firstChild)) {
      const node = _node.cloneNode(true);
      let tmp = node.firstChild;
      obj.child = dec.decodeCell(tmp, false);
      let tmp2 = tmp.nextSibling;
      tmp.parentNode.removeChild(tmp);
      tmp = tmp2;
      while (tmp) {
        tmp2 = tmp.nextSibling;
        if (isElement(tmp)) {
          const id = tmp.getAttribute("id");
          if (dec.lookup(id) == null) {
            dec.decodeCell(tmp);
          }
        }
        (_a = tmp.parentNode) == null ? void 0 : _a.removeChild(tmp);
        tmp = tmp2;
      }
      return node;
    } else {
      const childRef = _node.getAttribute("child");
      obj.child = dec.getObject(childRef);
      return _node;
    }
  }
  /**
   * Restores object state in the child change.
   */
  afterDecode(dec, node, obj) {
    if (obj.child != null) {
      if (obj.child.parent != null && obj.previous != null && obj.child.parent !== obj.previous) {
        obj.previous = obj.child.parent;
      }
      obj.child.parent = obj.previous;
      obj.previous = obj.parent;
      obj.previousIndex = obj.index;
    }
    return obj;
  }
}
class GenericChangeCodec extends ObjectCodec {
  /**
   *
   * @param obj An instance of the change object.
   * @param variable The field name for the change data.
   */
  constructor(obj, variable) {
    super(obj, ["model", "previous"], ["cell"]);
    this.variable = variable;
  }
  /**
   * Restores the state by assigning the previous value.
   */
  afterDecode(dec, _node, obj) {
    if (isNode(obj.cell)) {
      obj.cell = dec.decodeCell(obj.cell, false);
    }
    obj.previous = obj[this.variable];
    return obj;
  }
}
class GraphCodec extends ObjectCodec {
  constructor() {
    const __dummy = void 0;
    super(new Graph(__dummy), [
      "graphListeners",
      "eventListeners",
      "view",
      "container",
      "cellRenderer",
      "editor",
      "selection"
    ]);
  }
}
class GraphViewCodec extends ObjectCodec {
  constructor() {
    const __dummy = void 0;
    super(new GraphView(__dummy));
  }
  /**
   * Encodes the given {@link GraphView} using {@link encodeCell} starting at the model's root. This returns the
   * top-level graph node of the recursive encoding.
   */
  encode(enc, view) {
    return this.encodeCell(enc, view, view.graph.getDataModel().getRoot());
  }
  /**
   * Recursively encodes the specified cell.
   *
   * Uses layer as the default node name. If the cell's parent is null, then graph is used for the node name.
   * If {@link Cell.isEdge} returns `true` for the cell, then edge is used for the node name, else if {@link Cell.isVertex} returns `true` for the cell,
   * then vertex is used for the node name.
   *
   * {@link Graph.getLabel} is used to create the label attribute for the cell.
   * For graph nodes and vertices the bounds are encoded into x, y, width and height.
   * For edges the points are encoded into a points attribute as a space-separated list of comma-separated coordinate pairs (e.g. x0,y0 x1,y1 ... xn,yn).
   * All values from the cell style are added as attribute values to the node.
   */
  encodeCell(enc, view, cell) {
    let node;
    const model = view.graph.getDataModel();
    const state = view.getState(cell);
    const parent = cell.getParent();
    if (parent == null || state != null) {
      const childCount = cell.getChildCount();
      const geo = cell.getGeometry();
      let name = null;
      if (parent === model.getRoot()) {
        name = "layer";
      } else if (parent == null) {
        name = "graph";
      } else if (cell.isEdge()) {
        name = "edge";
      } else if (childCount > 0 && geo != null) {
        name = "group";
      } else if (cell.isVertex()) {
        name = "vertex";
      }
      if (name != null) {
        node = enc.document.createElement(name);
        const lab = view.graph.getLabel(cell);
        if (lab != null) {
          node.setAttribute("label", view.graph.getLabel(cell));
          if (view.graph.isHtmlLabel(cell)) {
            node.setAttribute("html", true);
          }
        }
        if (parent == null) {
          const bounds = view.getGraphBounds();
          if (bounds != null) {
            node.setAttribute("x", Math.round(bounds.x));
            node.setAttribute("y", Math.round(bounds.y));
            node.setAttribute("width", Math.round(bounds.width));
            node.setAttribute("height", Math.round(bounds.height));
          }
          node.setAttribute("scale", view.scale);
        } else if (state != null && geo != null) {
          for (const i in state.style) {
            let value = state.style[i];
            if (typeof value === "function" && typeof value === "object") {
              value = StyleRegistry.getName(value);
            }
            if (value != null && typeof value !== "function" && typeof value !== "object") {
              node.setAttribute(i, value);
            }
          }
          const abs = state.absolutePoints;
          if (abs != null && abs.length > 0) {
            let pts = `${Math.round(abs[0].x)},${Math.round(abs[0].y)}`;
            for (let i = 1; i < abs.length; i += 1) {
              pts += ` ${Math.round(abs[i].x)},${Math.round(abs[i].y)}`;
            }
            node.setAttribute("points", pts);
          } else {
            node.setAttribute("x", Math.round(state.x));
            node.setAttribute("y", Math.round(state.y));
            node.setAttribute("width", Math.round(state.width));
            node.setAttribute("height", Math.round(state.height));
          }
          const offset = state.absoluteOffset;
          if (offset != null) {
            if (offset.x !== 0) {
              node.setAttribute("dx", Math.round(offset.x));
            }
            if (offset.y !== 0) {
              node.setAttribute("dy", Math.round(offset.y));
            }
          }
        }
        for (let i = 0; i < childCount; i += 1) {
          const childNode = this.encodeCell(enc, view, cell.getChildAt(i));
          if (childNode != null) {
            node.appendChild(childNode);
          }
        }
      }
    }
    return node;
  }
}
class RootChangeCodec extends ObjectCodec {
  constructor() {
    const __dummy = void 0;
    super(new RootChange(__dummy, __dummy), ["model", "previous", "root"]);
  }
  /**
   * Encodes the child recursively.
   */
  afterEncode(enc, obj, node) {
    enc.encodeCell(obj.root, node);
    return node;
  }
  /**
   * Decodes the optional children as cells using the respective decoder.
   */
  beforeDecode(dec, node, obj) {
    var _a, _b;
    if (isElement(node.firstChild)) {
      node = node.cloneNode(true);
      let tmp = node.firstChild;
      obj.root = dec.decodeCell(tmp, false);
      let tmp2 = tmp.nextSibling;
      (_a = tmp.parentNode) == null ? void 0 : _a.removeChild(tmp);
      tmp = tmp2;
      while (tmp != null) {
        tmp2 = tmp.nextSibling;
        dec.decodeCell(tmp);
        (_b = tmp.parentNode) == null ? void 0 : _b.removeChild(tmp);
        tmp = tmp2;
      }
    }
    return node;
  }
  /**
   * Restores the state by assigning the previous value.
   */
  afterDecode(_dec, _node, obj) {
    obj.previous = obj.root;
    return obj;
  }
}
class StylesheetCodec extends ObjectCodec {
  constructor() {
    super(new Stylesheet());
  }
  /**
   * Encodes a stylesheet. See {@link decode} for a description of the format.
   */
  encode(enc, obj) {
    const node = enc.document.createElement(this.getName());
    for (const i in obj.styles) {
      const style = obj.styles[i];
      const styleNode = enc.document.createElement("add");
      if (i != null) {
        styleNode.setAttribute("as", i);
        for (const j in style) {
          const value = this.getStringValue(j, style[j]);
          if (value != null) {
            const entry = enc.document.createElement("add");
            entry.setAttribute("value", value);
            entry.setAttribute("as", j);
            styleNode.appendChild(entry);
          }
        }
        if (styleNode.childNodes.length > 0) {
          node.appendChild(styleNode);
        }
      }
    }
    return node;
  }
  /**
   * Returns the string for encoding the given value.
   */
  getStringValue(key, value) {
    const type = typeof value;
    if (type === "function") {
      value = StyleRegistry.getName(value);
    } else if (type === "object") {
      value = null;
    }
    return value;
  }
  /**
   * Reads a sequence of the following child nodes and attributes:
   *
   * Child Nodes:
   * - `add` - Adds a new style.
   *
   * Attributes:
   * - `as` - Name of the style.
   * - `extend` - Name of the style to inherit from.
   *
   * Each node contains another sequence of add and remove nodes with the following attributes:
   * - `as` - Name of the style (see properties of {@link CellStateStyle}).
   * - `value` - Value for the style.
   *
   * Instead of the value-attribute, one can put Javascript expressions into the node as follows if {@link allowEval} is `true`:
   * <add as="perimeter">Perimeter.RectanglePerimeter</add>
   *
   * A remove node will remove the entry with the name given in the as-attribute from the style.
   *
   * Example:
   *
   * ```javascript
   * <Stylesheet as="stylesheet">
   *   <add as="text">
   *     <add as="fontSize" value="12"/>
   *   </add>
   *   <add as="defaultVertex" extend="text">
   *     <add as="shape" value="rectangle"/>
   *   </add>
   * </Stylesheet>
   * ```
   */
  decode(dec, _node, into) {
    const obj = into || new this.template.constructor();
    const id = _node.getAttribute("id");
    if (id) {
      dec.objects[id] = obj;
    }
    let node = _node.firstChild;
    while (node) {
      if (!this.processInclude(dec, node, obj) && node.nodeName === "add") {
        const as = node.getAttribute("as");
        if (as) {
          const extend = node.getAttribute("extend");
          let style = extend ? clone(obj.styles[extend]) : null;
          if (!style) {
            if (extend) {
              GlobalConfig.logger.warn(`StylesheetCodec.decode: stylesheet ${extend} not found to extend`);
            }
            style = {};
          }
          let entry = node.firstChild;
          while (entry) {
            if (isElement(entry)) {
              const key = entry.getAttribute("as");
              if (entry.nodeName === "add") {
                const text = getTextContent(entry);
                let value = null;
                if (text && StylesheetCodec.allowEval) {
                  value = doEval(text);
                } else {
                  value = entry.getAttribute("value");
                  if (isNumeric(value)) {
                    value = parseFloat(value);
                  }
                }
                if (value) {
                  style[key] = value;
                }
              } else if (entry.nodeName === "remove") {
                delete style[key];
              }
            }
            entry = entry.nextSibling;
          }
          obj.putCellStyle(as, style);
        }
      }
      node = node.nextSibling;
    }
    return obj;
  }
}
StylesheetCodec.allowEval = false;
class TerminalChangeCodec extends ObjectCodec {
  constructor() {
    const __dummy = void 0;
    super(new TerminalChange(__dummy, __dummy, __dummy, __dummy), ["model", "previous"], ["cell", "terminal"]);
  }
  /**
   * Restores the state by assigning the previous value.
   */
  afterDecode(_dec, _node, obj) {
    obj.previous = obj.terminal;
    return obj;
  }
}
const registerGenericChangeCodecs = () => {
  const __dummy = void 0;
  CodecRegistry.register(new GenericChangeCodec(new CellAttributeChange(__dummy, __dummy, __dummy), "value"));
  CodecRegistry.register(new GenericChangeCodec(new CollapseChange(__dummy, __dummy, __dummy), "collapsed"));
  CodecRegistry.register(new GenericChangeCodec(new GeometryChange(__dummy, __dummy, __dummy), "geometry"));
  CodecRegistry.register(new GenericChangeCodec(new StyleChange(__dummy, __dummy, __dummy), "style"));
  CodecRegistry.register(new GenericChangeCodec(new ValueChange(__dummy, __dummy, __dummy), "value"));
  CodecRegistry.register(new GenericChangeCodec(new VisibleChange(__dummy, __dummy, __dummy), "visible"));
};
let isCoreCodecsRegistered = false;
const registerCoreCodecs = (force = false) => {
  if (!isCoreCodecsRegistered || force) {
    CodecRegistry.register(new ChildChangeCodec());
    CodecRegistry.register(new GraphCodec());
    CodecRegistry.register(new GraphViewCodec());
    CodecRegistry.register(new RootChangeCodec());
    CodecRegistry.register(new StylesheetCodec());
    CodecRegistry.register(new TerminalChangeCodec());
    registerGenericChangeCodecs();
    registerModelCodecs(force);
    isCoreCodecsRegistered = true;
  }
};
let isEditorCodecsRegistered = false;
const registerEditorCodecs = (force = false) => {
  if (!isEditorCodecsRegistered || force) {
    registerBaseCodecs(force);
    CodecRegistry.register(new EditorCodec());
    CodecRegistry.register(new EditorKeyHandlerCodec());
    CodecRegistry.register(new EditorPopupMenuCodec());
    CodecRegistry.register(new EditorToolbarCodec());
    isEditorCodecsRegistered = true;
  }
};
const registerAllCodecs = (force = false) => {
  registerCoreCodecs(force);
  registerEditorCodecs(force);
};
const StencilShapeConfig = {
  /**
   * Specifies if the use of eval is allowed for evaluating text content and images.
   * Set this to `true` if stencils can not contain user input.
   *
   * **WARNING**: Enabling this switch carries a possible security risk.
   *
   * @default false
   */
  allowEval: false,
  /**
   * Specifies the default value for the localized attribute of the text element.
   * @default false
   */
  defaultLocalized: false
};
class StencilShape extends Shape {
  constructor(desc) {
    super();
    this.constraints = [];
    this.aspect = "auto";
    this.w0 = 100;
    this.h0 = 100;
    this.bgNode = null;
    this.fgNode = null;
    this.strokeWidthValue = null;
    this.desc = desc;
    this.parseDescription();
    this.parseConstraints();
  }
  /**
   * Reads <w0>, <h0>, <aspect>, <bgNodes> and <fgNodes> from <desc>.
   */
  parseDescription() {
    this.fgNode = this.desc.getElementsByTagName("foreground")[0];
    this.bgNode = this.desc.getElementsByTagName("background")[0];
    this.w0 = Number(this.desc.getAttribute("w") || 100);
    this.h0 = Number(this.desc.getAttribute("h") || 100);
    const aspect = this.desc.getAttribute("aspect");
    this.aspect = aspect ?? "variable";
    const sw = this.desc.getAttribute("strokewidth");
    this.strokeWidthValue = !isNullish(sw) ? sw : "1";
  }
  /**
   * Reads the constraints from {@link desc} into {@link constraints} using {@link parseConstraint}.
   */
  parseConstraints() {
    const conns = this.desc.getElementsByTagName("connections")[0];
    if (conns) {
      const tmp = getChildNodes(conns);
      if (tmp.length > 0) {
        this.constraints = [];
        for (let i = 0; i < tmp.length; i += 1) {
          this.constraints.push(this.parseConstraint(tmp[i]));
        }
      }
    }
  }
  /**
   * Parses the given XML node and returns its {@link ConnectionConstraint}.
   */
  parseConstraint(node) {
    const x = Number(node.getAttribute("x"));
    const y = Number(node.getAttribute("y"));
    const perimeter = node.getAttribute("perimeter") === "1";
    const name = node.getAttribute("name");
    return new ConnectionConstraint(new Point(x, y), perimeter, name);
  }
  /**
   * Gets the given attribute as a text. The return value from <evaluateAttribute>
   * is used as a key to {@link Resources#get} if the localized attribute in the text
   * node is 1 or if <defaultLocalized> is true.
   */
  evaluateTextAttribute(node, attribute, shape) {
    let result = this.evaluateAttribute(node, attribute, shape);
    const loc = node.getAttribute("localized");
    if (StencilShapeConfig.defaultLocalized && !loc || loc === "1") {
      result = translate(result);
    }
    return result;
  }
  /**
   * Gets the attribute for the given name from the given node. If the attribute
   * does not exist then the text content of the node is evaluated and if it is
   * a function it is invoked with <shape> as the only argument and the return
   * value is used as the attribute value to be returned.
   */
  evaluateAttribute(node, attribute, shape) {
    let result = node.getAttribute(attribute);
    if (!result) {
      const text = getTextContent(node);
      if (text && StencilShapeConfig.allowEval) {
        const funct = doEval(text);
        if (typeof funct === "function") {
          result = funct(shape);
        }
      }
    }
    return result;
  }
  /**
   * Draws this stencil inside the given bounds.
   */
  drawShape(canvas, shape, x, y, w, h) {
    var _a, _b, _c;
    const stack = canvas.states.slice();
    const direction = (_a = shape.style) == null ? void 0 : _a.direction;
    const aspect = this.computeAspect(shape, x, y, w, h, direction);
    const minScale = Math.min(aspect.width, aspect.height);
    const sw = this.strokeWidthValue === "inherit" ? ((_b = shape.style) == null ? void 0 : _b.strokeWidth) ?? 1 : Number(this.strokeWidthValue) * minScale;
    canvas.setStrokeWidth(sw);
    if (((_c = shape.style) == null ? void 0 : _c.pointerEvents) ?? false) {
      canvas.setStrokeColor(NONE);
      canvas.rect(x, y, w, h);
      canvas.stroke();
      canvas.setStrokeColor(shape.stroke);
    }
    this.drawChildren(canvas, shape, x, y, w, h, this.bgNode, aspect, false, true);
    this.drawChildren(canvas, shape, x, y, w, h, this.fgNode, aspect, true, !shape.outline || shape.style == null || !(shape.style.backgroundOutline ?? false));
    if (canvas.states.length != stack.length) {
      canvas.states = stack;
    }
  }
  /**
   * Draws this stencil inside the given bounds.
   */
  drawChildren(canvas, shape, x, y, w, h, node, aspect, disableShadow, paint) {
    if (node && w > 0 && h > 0) {
      let tmp = node.firstChild;
      while (tmp) {
        if (isElement(tmp)) {
          this.drawNode(canvas, shape, tmp, aspect, disableShadow, paint);
        }
        tmp = tmp.nextSibling;
      }
    }
  }
  /**
   * Returns a rectangle that contains the offset in x and y and the horizontal
   * and vertical scale in width and height used to draw this shape inside the
   * given {@link Rectangle}.
   *
   * @param shape {@link Shape} to be drawn.
   * @param bounds {@link Rectangle} that should contain the stencil.
   * @param direction Optional direction of the shape to be darwn.
   */
  computeAspect(shape = null, x, y, w, h, direction) {
    let x0 = x;
    let y0 = y;
    let sx = w / this.w0;
    let sy = h / this.h0;
    const inverse = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;
    if (inverse) {
      sy = w / this.h0;
      sx = h / this.w0;
      const delta = (w - h) / 2;
      x0 += delta;
      y0 -= delta;
    }
    if (this.aspect === "fixed") {
      sy = Math.min(sx, sy);
      sx = sy;
      if (inverse) {
        x0 += (h - this.w0 * sx) / 2;
        y0 += (w - this.h0 * sy) / 2;
      } else {
        x0 += (w - this.w0 * sx) / 2;
        y0 += (h - this.h0 * sy) / 2;
      }
    }
    return new Rectangle(x0, y0, sx, sy);
  }
  /**
   * Draws this stencil inside the given bounds.
   */
  drawNode(canvas, shape, node, aspect, disableShadow, paint) {
    var _a, _b;
    const name = node.nodeName;
    const x0 = aspect.x;
    const y0 = aspect.y;
    const sx = aspect.width;
    const sy = aspect.height;
    const minScale = Math.min(sx, sy);
    if (name === "save") {
      canvas.save();
    } else if (name === "restore") {
      canvas.restore();
    } else if (paint) {
      if (name === "path") {
        canvas.begin();
        let parseRegularly = true;
        if (node.getAttribute("rounded") == "1") {
          parseRegularly = false;
          const arcSize = Number(node.getAttribute("arcSize"));
          let pointCount = 0;
          const segs = [];
          let childNode = node.firstChild;
          while (childNode != null) {
            if (isElement(childNode)) {
              const childName = childNode.nodeName;
              if (childName === "move" || childName === "line") {
                if (childName === "move" || segs.length === 0) {
                  segs.push([]);
                }
                segs[segs.length - 1].push(new Point(x0 + Number(childNode.getAttribute("x")) * sx, y0 + Number(childNode.getAttribute("y")) * sy));
                pointCount++;
              } else {
                parseRegularly = true;
                break;
              }
            }
            childNode = childNode.nextSibling;
          }
          if (!parseRegularly && pointCount > 0) {
            for (let i = 0; i < segs.length; i += 1) {
              let close = false;
              const ps = segs[i][0];
              const pe = segs[i][segs[i].length - 1];
              if (ps.x === pe.x && ps.y === pe.y) {
                segs[i].pop();
                close = true;
              }
              this.addPoints(canvas, segs[i], true, arcSize, close);
            }
          } else {
            parseRegularly = true;
          }
        }
        if (parseRegularly) {
          let childNode = node.firstChild;
          while (childNode) {
            if (isElement(childNode)) {
              this.drawNode(canvas, shape, childNode, aspect, disableShadow, paint);
            }
            childNode = childNode.nextSibling;
          }
        }
      } else if (name === "close") {
        canvas.close();
      } else if (name === "move") {
        canvas.moveTo(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy);
      } else if (name === "line") {
        canvas.lineTo(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy);
      } else if (name === "quad") {
        canvas.quadTo(x0 + Number(node.getAttribute("x1")) * sx, y0 + Number(node.getAttribute("y1")) * sy, x0 + Number(node.getAttribute("x2")) * sx, y0 + Number(node.getAttribute("y2")) * sy);
      } else if (name === "curve") {
        canvas.curveTo(x0 + Number(node.getAttribute("x1")) * sx, y0 + Number(node.getAttribute("y1")) * sy, x0 + Number(node.getAttribute("x2")) * sx, y0 + Number(node.getAttribute("y2")) * sy, x0 + Number(node.getAttribute("x3")) * sx, y0 + Number(node.getAttribute("y3")) * sy);
      } else if (name === "arc") {
        canvas.arcTo(Number(node.getAttribute("rx")) * sx, Number(node.getAttribute("ry")) * sy, Number(node.getAttribute("x-axis-rotation")), Boolean(node.getAttribute("large-arc-flag")), Boolean(node.getAttribute("sweep-flag")), x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy);
      } else if (name === "rect") {
        canvas.rect(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, Number(node.getAttribute("w")) * sx, Number(node.getAttribute("h")) * sy);
      } else if (name === "roundrect") {
        let arcsize = Number(node.getAttribute("arcsize"));
        if (arcsize === 0) {
          arcsize = RECTANGLE_ROUNDING_FACTOR * 100;
        }
        const w = Number(node.getAttribute("w")) * sx;
        const h = Number(node.getAttribute("h")) * sy;
        const factor = Number(arcsize) / 100;
        const r = Math.min(w * factor, h * factor);
        canvas.roundrect(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, w, h, r, r);
      } else if (name === "ellipse") {
        canvas.ellipse(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, Number(node.getAttribute("w")) * sx, Number(node.getAttribute("h")) * sy);
      } else if (name === "image") {
        if (!shape.outline) {
          const src = this.evaluateAttribute(node, "src", shape);
          canvas.image(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, Number(node.getAttribute("w")) * sx, Number(node.getAttribute("h")) * sy, src, false, node.getAttribute("flipH") === "1", node.getAttribute("flipV") === "1");
        }
      } else if (name === "text") {
        if (!shape.outline) {
          const str = this.evaluateTextAttribute(node, "str", shape);
          let rotation = node.getAttribute("vertical") == "1" ? -90 : 0;
          if (node.getAttribute("align-shape") === "0") {
            const dr = shape.rotation;
            const flipH = ((_a = shape.style) == null ? void 0 : _a.flipH) ?? false;
            const flipV = ((_b = shape.style) == null ? void 0 : _b.flipV) ?? false;
            if (flipH && flipV) {
              rotation -= dr;
            } else if (flipH || flipV) {
              rotation += dr;
            } else {
              rotation -= dr;
            }
          }
          rotation -= Number(node.getAttribute("rotation"));
          canvas.text(x0 + Number(node.getAttribute("x")) * sx, y0 + Number(node.getAttribute("y")) * sy, 0, 0, str, node.getAttribute("align") || ALIGN.LEFT, node.getAttribute("valign") || ALIGN.TOP, false, "", "auto", false, rotation, TEXT_DIRECTION.AUTO);
        }
      } else if (name === "include-shape") {
        const stencil = StencilShapeRegistry.getStencil(node.getAttribute("name"));
        if (stencil) {
          const x = x0 + Number(node.getAttribute("x")) * sx;
          const y = y0 + Number(node.getAttribute("y")) * sy;
          const w = Number(node.getAttribute("w")) * sx;
          const h = Number(node.getAttribute("h")) * sy;
          stencil.drawShape(canvas, shape, x, y, w, h);
        }
      } else if (name === "fillstroke") {
        canvas.fillAndStroke();
      } else if (name === "fill") {
        canvas.fill();
      } else if (name === "stroke") {
        canvas.stroke();
      } else if (name === "strokewidth") {
        const s = node.getAttribute("fixed") === "1" ? 1 : minScale;
        canvas.setStrokeWidth(Number(node.getAttribute("width")) * s);
      } else if (name === "dashed") {
        canvas.setDashed(node.getAttribute("dashed") === "1");
      } else if (name === "dashpattern") {
        let value = node.getAttribute("pattern");
        if (value != null) {
          const tmp = value.split(" ");
          const pat = [];
          for (let i = 0; i < tmp.length; i += 1) {
            if (tmp[i].length > 0) {
              pat.push(Number(tmp[i]) * minScale);
            }
          }
          value = pat.join(" ");
          canvas.setDashPattern(value);
        }
      } else if (name === "strokecolor") {
        canvas.setStrokeColor(node.getAttribute("color"));
      } else if (name === "linecap") {
        canvas.setLineCap(node.getAttribute("cap"));
      } else if (name === "linejoin") {
        canvas.setLineJoin(node.getAttribute("join"));
      } else if (name === "miterlimit") {
        canvas.setMiterLimit(Number(node.getAttribute("limit")));
      } else if (name === "fillcolor") {
        canvas.setFillColor(node.getAttribute("color"));
      } else if (name === "alpha") {
        canvas.setAlpha(Number(node.getAttribute("alpha")));
      } else if (name === "fillalpha") {
        canvas.setAlpha(Number(node.getAttribute("alpha")));
      } else if (name === "strokealpha") {
        canvas.setAlpha(Number(node.getAttribute("alpha")));
      } else if (name === "fontcolor") {
        canvas.setFontColor(node.getAttribute("color"));
      } else if (name === "fontstyle") {
        canvas.setFontStyle(Number(node.getAttribute("style")));
      } else if (name === "fontfamily") {
        canvas.setFontFamily(node.getAttribute("family"));
      } else if (name === "fontsize") {
        canvas.setFontSize(Number(node.getAttribute("size")) * minScale);
      }
      if (disableShadow && (name === "fillstroke" || name === "fill" || name === "stroke")) {
        disableShadow = false;
        canvas.setShadow(false);
      }
    }
  }
}
function getNavigatorLanguage() {
  return typeof window !== "undefined" ? navigator.language : "en";
}
const values = {
  defaultLanguage: "en",
  language: getNavigatorLanguage(),
  languages: []
};
const originalValues = {};
shallowCopy(values, originalValues);
const resetTranslationsConfig = () => {
  shallowCopy(originalValues, values);
};
const TranslationsConfig = {
  /**
   * Returns whether internationalization is enabled.
   */
  isEnabled() {
    return this.getLanguage() !== "none";
  },
  /**
   * @see setLanguage
   */
  getLanguage() {
    return values.language;
  },
  /**
   * Defines the language of the client, e.g. `en` for english, `de` for german etc.
   *
   * The special value `none` will disable all built-in internationalization and resource loading.
   * See {@link Translations.getSpecialBundle} for handling identifiers with and without a dash.
   *
   * If internationalization is disabled, then the following variables should be overridden to reflect the current language of the system.
   * These variables are cleared when i18n is disabled (the list may not be exhaustive):
   * - {@link Editor.askZoomResource}
   * - {@link Editor.currentFileResource}
   * - {@link Editor.helpResource}
   * - {@link Editor.lastSavedResource}
   * - {@link Editor.outlineResource}
   * - {@link Editor.propertiesResource}
   * - {@link Editor.tasksResource}
   * - {@link ElbowEdgeHandler.doubleClickOrientationResource}
   * - {@link Graph.alreadyConnectedResource}.
   * - {@link Graph.collapseExpandResource}
   * - {@link Graph.containsValidationErrorsResource} and
   * - {@link GraphSelectionModel.doneResource}
   * - {@link GraphSelectionModel.updatingSelectionResource}
   * - {@link GraphView.doneResource}
   * - {@link GraphView.updatingDocumentResource}
   * - {@link GuiConfig.closeResource}
   * - {@link GuiConfig.errorResource}
   *
   * @param value The language to set. If `null` or `undefined`, use the preferred language of the navigator or 'en' as default.
   */
  setLanguage(value) {
    values.language = !isNullish(value) ? value : getNavigatorLanguage();
  },
  /**
   * @see setLanguages
   */
  getLanguages() {
    return values.languages;
  },
  /**
   * Defines the optional array of all supported language extensions.
   * The default language does not have to be part of this list. See {@link Translations.isLanguageSupported}.
   *
   * This is used to avoid unnecessary requests to language files, i.e. if a 404 will be returned.
   * @default empty array
   */
  setLanguages(value) {
    if (!isNullish(value)) {
      values.languages = value;
    }
  },
  /**
   * @see setDefaultLanguage
   */
  getDefaultLanguage() {
    return values.defaultLanguage;
  },
  /**
   * Defines the default language which is used in the common resource files.
   * Any resources for this language will only load the common resource file, but not the language-specific resource file.
   * @default 'en'
   */
  setDefaultLanguage(value) {
    values.defaultLanguage = !isNullish(value) ? value : "en";
  }
};
class Translations {
}
Translations.resources = {};
Translations.extension = ".txt";
Translations.resourcesEncoded = false;
Translations.loadDefaultBundle = true;
Translations.loadSpecialBundle = true;
Translations.isLanguageSupported = (lan) => {
  const languages = TranslationsConfig.getLanguages();
  if (languages) {
    return languages.indexOf(lan) >= 0;
  }
  return true;
};
Translations.getDefaultBundle = (basename, lan) => {
  if (Translations.loadDefaultBundle || !Translations.isLanguageSupported(lan)) {
    return basename + Translations.extension;
  }
  return null;
};
Translations.getSpecialBundle = (basename, lan) => {
  if (!TranslationsConfig.getLanguages() || !Translations.isLanguageSupported(lan)) {
    const dash = lan.indexOf("-");
    if (dash > 0) {
      lan = lan.substring(0, dash);
    }
  }
  if (Translations.loadSpecialBundle && Translations.isLanguageSupported(lan) && lan != TranslationsConfig.getDefaultLanguage()) {
    return `${basename}_${lan}${Translations.extension}`;
  }
  return null;
};
Translations.add = (basename = null, lan = null, callback = null) => {
  var _a;
  lan ?? (lan = ((_a = TranslationsConfig.getLanguage()) == null ? void 0 : _a.toLowerCase()) ?? NONE);
  if (!isNullish(basename) && lan !== NONE) {
    const defaultBundle = Translations.getDefaultBundle(basename, lan);
    const specialBundle = Translations.getSpecialBundle(basename, lan);
    const loadSpecialBundle = () => {
      if (specialBundle != null) {
        if (callback) {
          get(specialBundle, (req) => {
            Translations.parse(req.getText());
            callback();
          }, () => {
            callback();
          });
        } else {
          try {
            const req = load(specialBundle);
            if (req.isReady()) {
              Translations.parse(req.getText());
            }
          } catch (e) {
          }
        }
      } else if (callback != null) {
        callback();
      }
    };
    if (defaultBundle != null) {
      if (callback) {
        get(defaultBundle, (req) => {
          Translations.parse(req.getText());
          loadSpecialBundle();
        }, () => {
          loadSpecialBundle();
        });
      } else {
        try {
          const req = load(defaultBundle);
          if (req.isReady()) {
            Translations.parse(req.getText());
          }
          loadSpecialBundle();
        } catch (e) {
        }
      }
    } else {
      loadSpecialBundle();
    }
  }
};
Translations.parse = (text) => {
  if (text != null) {
    const lines = text.split("\n");
    for (let i = 0; i < lines.length; i += 1) {
      if (lines[i].charAt(0) !== "#") {
        const index = lines[i].indexOf("=");
        if (index > 0) {
          const key = lines[i].substring(0, index);
          let idx = lines[i].length;
          if (lines[i].charCodeAt(idx - 1) === 13) {
            idx--;
          }
          let value = lines[i].substring(index + 1, idx);
          if (Translations.resourcesEncoded) {
            value = value.replace(/\\(?=u[a-fA-F\d]{4})/g, "%");
            Translations.resources[key] = unescape(value);
          } else {
            Translations.resources[key] = value;
          }
        }
      }
    }
  }
};
Translations.get = (key = null, params = null, defaultValue = null) => {
  let value = key ? Translations.resources[key] : null;
  if (isNullish(value)) {
    value = defaultValue;
  }
  if (!isNullish(value) && params) {
    value = Translations.replacePlaceholders(value, params);
  }
  return value;
};
Translations.replacePlaceholders = (value, params) => {
  const result = [];
  let index = null;
  for (let i = 0; i < value.length; i += 1) {
    const c = value.charAt(i);
    if (c === "{") {
      index = "";
    } else if (index != null && c === "}") {
      index = parseInt(index) - 1;
      if (index >= 0 && index < params.length) {
        result.push(params[index]);
      }
      index = null;
    } else if (index != null) {
      index += c;
    } else {
      result.push(c);
    }
  }
  return result.join("");
};
Translations.loadResources = (callback) => {
  Translations.add(`${Client.basePath}/resources/editor`, null, () => {
    Translations.add(`${Client.basePath}/resources/graph`, null, callback);
  });
};
class TranslationsAsI18n {
  isEnabled() {
    return TranslationsConfig.isEnabled();
  }
  get(key, params, defaultValue) {
    return Translations.get(key, params, defaultValue);
  }
  addResource(basename, language, callback) {
    Translations.add(basename, language, callback);
  }
}
class Animation extends EventSource {
  constructor(delay = 20) {
    super();
    this.thread = null;
    this.delay = delay;
  }
  /**
   * Returns true if the animation is running.
   */
  isRunning() {
    return this.thread != null;
  }
  /**
   * Starts the animation by repeatedly invoking updateAnimation.
   */
  startAnimation() {
    if (this.thread == null) {
      this.thread = window.setInterval(this.updateAnimation.bind(this), this.delay);
    }
  }
  /**
   * Hook for subclassers to implement the animation. Invoke stopAnimation
   * when finished, startAnimation to resume. This is called whenever the
   * timer fires and fires an mxEvent.EXECUTE event with no properties.
   */
  updateAnimation() {
    this.fireEvent(new EventObject(InternalEvent.EXECUTE));
  }
  /**
   * Stops the animation by deleting the timer and fires an {@link Event#DONE}.
   */
  stopAnimation() {
    if (this.thread != null) {
      window.clearInterval(this.thread);
      this.thread = null;
      this.fireEvent(new EventObject(InternalEvent.DONE));
    }
  }
}
class Effects {
  /**
   * Asynchronous animated move operation. See also: <Morphing>.
   *
   * @example
   * ```javascript
   * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)
   * {
   *   var changes = evt.getProperty('edit').changes;
   *
   *   if (changes.length < 10)
   *   {
   *     Effects.animateChanges(graph, changes);
   *   }
   * });
   * ```
   *
   * @param graph - {@link Graph} that received the changes.
   * @param changes - Array of changes to be animated.
   * @param done - Optional function argument that is invoked after the
   * last step of the animation.
   */
  static animateChanges(graph, changes, done) {
    const maxStep = 10;
    let step = 0;
    const animate = () => {
      let isRequired = false;
      for (let i = 0; i < changes.length; i += 1) {
        const change = changes[i];
        if (change instanceof GeometryChange || change instanceof TerminalChange || change instanceof ValueChange || change instanceof ChildChange || change instanceof StyleChange) {
          const state = graph.getView().getState(change.cell || change.child, false);
          if (state != null) {
            isRequired = true;
            if (change.constructor !== GeometryChange || change.cell.isEdge()) {
              setOpacity(state.shape.node, 100 * step / maxStep);
            } else {
              const { scale } = graph.getView();
              const geometry = change.geometry;
              const previous = change.previous;
              const dx = (geometry.x - previous.x) * scale;
              const dy = (geometry.y - previous.y) * scale;
              const sx = (geometry.width - previous.width) * scale;
              const sy = (geometry.height - previous.height) * scale;
              if (step === 0) {
                state.x -= dx;
                state.y -= dy;
                state.width -= sx;
                state.height -= sy;
              } else {
                state.x += dx / maxStep;
                state.y += dy / maxStep;
                state.width += sx / maxStep;
                state.height += sy / maxStep;
              }
              graph.cellRenderer.redraw(state);
              Effects.cascadeOpacity(graph, change.cell, 100 * step / maxStep);
            }
          }
        }
      }
      if (step < maxStep && isRequired) {
        step++;
        window.setTimeout(animate, delay);
      } else if (done != null) {
        done();
      }
    };
    const delay = 30;
    animate();
  }
  /**
   * Sets the opacity on the given cell and its descendants.
   *
   * @param graph - {@link Graph} that contains the cells.
   * @param cell - {@link Cell} to set the opacity for.
   * @param opacity - New value for the opacity in %.
   */
  static cascadeOpacity(graph, cell, opacity) {
    const childCount = cell.getChildCount();
    for (let i = 0; i < childCount; i += 1) {
      const child = cell.getChildAt(i);
      const childState = graph.getView().getState(child);
      if (childState != null) {
        setOpacity(childState.shape.node, opacity);
        Effects.cascadeOpacity(graph, child, opacity);
      }
    }
    const edges = cell.getEdges();
    if (edges != null) {
      for (let i = 0; i < edges.length; i += 1) {
        const edgeState = graph.getView().getState(edges[i]);
        if (edgeState != null) {
          setOpacity(edgeState.shape.node, opacity);
        }
      }
    }
  }
  /**
   * Asynchronous fade-out operation.
   */
  static fadeOut(node, from, remove2, step, delay, isEnabled) {
    step = step || 40;
    delay = delay || 30;
    let opacity = from || 100;
    setOpacity(node, opacity);
    if (isEnabled || isEnabled == null) {
      const f = () => {
        opacity = Math.max(opacity - step, 0);
        setOpacity(node, opacity);
        if (opacity > 0) {
          window.setTimeout(f, delay);
        } else {
          node.style.visibility = "hidden";
          if (remove2 && node.parentNode) {
            node.parentNode.removeChild(node);
          }
        }
      };
      window.setTimeout(f, delay);
    } else {
      node.style.visibility = "hidden";
      if (remove2 && node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
  }
}
class CellStatePreview {
  constructor(graph) {
    this.count = 0;
    this.deltas = new Dictionary();
    this.graph = graph;
  }
  /**
   * Returns true if this contains no entries.
   */
  isEmpty() {
    return this.count === 0;
  }
  /**
   *
   * @param {CellState} state
   * @param {number} dx
   * @param {number} dy
   * @param {boolean} add
   * @param {boolean} includeEdges
   * @return {*}  {mxPoint}
   * @memberof mxCellStatePreview
   */
  moveState(state, dx, dy, add = true, includeEdges = true) {
    let delta = this.deltas.get(state.cell);
    if (delta == null) {
      delta = { point: new Point(dx, dy), state };
      this.deltas.put(state.cell, delta);
      this.count++;
    } else if (add) {
      delta.point.x += dx;
      delta.point.y += dy;
    } else {
      delta.point.x = dx;
      delta.point.y = dy;
    }
    if (includeEdges) {
      this.addEdges(state);
    }
    return delta.point;
  }
  /**
   *
   * @param {Function} visitor
   * @memberof mxCellStatePreview
   */
  show(visitor = null) {
    this.deltas.visit((key, delta) => {
      this.translateState(delta.state, delta.point.x, delta.point.y);
    });
    this.deltas.visit((key, delta) => {
      this.revalidateState(delta.state, delta.point.x, delta.point.y, visitor);
    });
  }
  /**
   *
   * @param {CellState} state
   * @param {number} dx
   * @param {number} dy
   * @memberof mxCellStatePreview
   */
  translateState(state, dx, dy) {
    if (state != null) {
      if (state.cell.isVertex()) {
        state.view.updateCellState(state);
        const geo = state.cell.getGeometry();
        if ((dx !== 0 || dy !== 0) && geo != null && (!geo.relative || this.deltas.get(state.cell) != null)) {
          state.x += dx;
          state.y += dy;
        }
      }
      for (const child of state.cell.getChildren()) {
        this.translateState(state.view.getState(child), dx, dy);
      }
    }
  }
  /**
   *
   * @param {CellState} state
   * @param {number} dx
   * @param {number} dy
   * @param {Function} visitor
   * @memberof mxCellStatePreview
   */
  revalidateState(state, dx, dy, visitor = null) {
    if (state.cell.isEdge()) {
      state.view.updateCellState(state);
    }
    const geo = state.cell.getGeometry();
    const pState = state.view.getState(state.cell.getParent());
    if ((dx !== 0 || dy !== 0) && geo != null && geo.relative && state.cell.isVertex() && (pState == null || pState.cell.isVertex() || this.deltas.get(state.cell) != null)) {
      state.x += dx;
      state.y += dy;
    }
    this.graph.cellRenderer.redraw(state);
    if (visitor != null) {
      visitor(state);
    }
    for (const child of state.cell.getChildren()) {
      this.revalidateState(this.graph.view.getState(child), dx, dy, visitor);
    }
  }
  /**
   *
   * @param {CellState} state
   * @memberof mxCellStatePreview
   */
  addEdges(state) {
    const edgeCount = state.cell.getEdgeCount();
    for (let i = 0; i < edgeCount; i += 1) {
      const s = state.view.getState(state.cell.getEdgeAt(i));
      if (s != null) {
        this.moveState(s, 0, 0);
      }
    }
  }
}
class Morphing extends Animation {
  constructor(graph, steps = 6, ease = 1.5, delay) {
    super(delay);
    this.step = 0;
    this.cells = null;
    this.graph = graph;
    this.steps = steps;
    this.ease = ease;
  }
  /**
   * Animation step.
   */
  updateAnimation() {
    super.updateAnimation();
    const move = new CellStatePreview(this.graph);
    if (this.cells != null) {
      for (const cell of this.cells) {
        this.animateCell(cell, move, false);
      }
    } else {
      this.animateCell(this.graph.getDataModel().getRoot(), move, true);
    }
    this.show(move);
    if (move.isEmpty() || this.step++ >= this.steps) {
      this.stopAnimation();
    }
  }
  /**
   * Shows the changes in the given <CellStatePreview>.
   */
  show(move) {
    move.show();
  }
  /**
   * Animates the given cell state using <CellStatePreview.moveState>.
   */
  animateCell(cell, move, recurse = false) {
    const state = this.graph.getView().getState(cell);
    let delta = null;
    if (state != null) {
      delta = this.getDelta(state);
      if (cell.isVertex() && (delta.x != 0 || delta.y != 0)) {
        const translate2 = this.graph.view.getTranslate();
        const scale = this.graph.view.getScale();
        delta.x += translate2.x * scale;
        delta.y += translate2.y * scale;
        move.moveState(state, -delta.x / this.ease, -delta.y / this.ease);
      }
    }
    if (recurse && !this.stopRecursion(state, delta)) {
      const childCount = cell.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        this.animateCell(cell.getChildAt(i), move, recurse);
      }
    }
  }
  /**
   * Returns true if the animation should not recursively find more
   * deltas for children if the given parent state has been animated.
   */
  stopRecursion(state = null, delta = null) {
    return delta != null && (delta.x != 0 || delta.y != 0);
  }
  /**
   * Returns the vector between the current rendered state and the future
   * location of the state after the display will be updated.
   */
  getDelta(state) {
    const origin = this.getOriginForCell(state.cell);
    const translate2 = this.graph.getView().getTranslate();
    const scale = this.graph.getView().getScale();
    const x = state.x / scale - translate2.x;
    const y = state.y / scale - translate2.y;
    return new Point((origin.x - x) * scale, (origin.y - y) * scale);
  }
  /**
   * Returns the top, left corner of the given cell. TODO: Improve performance
   * by using caching inside this method as the result per cell never changes
   * during the lifecycle of this object.
   */
  getOriginForCell(cell = null) {
    let result = null;
    if (cell != null) {
      const parent = cell.getParent();
      const geo = cell.getGeometry();
      result = this.getOriginForCell(parent);
      if (geo != null && parent != null) {
        if (geo.relative) {
          const pgeo = parent.getGeometry();
          if (pgeo != null) {
            result.x += geo.x * pgeo.width;
            result.y += geo.y * pgeo.height;
          }
        } else {
          result.x += geo.x;
          result.y += geo.y;
        }
      }
    }
    if (result == null) {
      const t = this.graph.view.getTranslate();
      result = new Point(-t.x, -t.y);
    }
    return result;
  }
}
class XmlCanvas2D extends AbstractCanvas2D {
  constructor(root) {
    super();
    this.textEnabled = true;
    this.compressed = true;
    this.root = root;
    this.writeDefaults();
  }
  /**
   * Writes the rendering defaults to {@link root}:
   */
  writeDefaults() {
    let elem;
    elem = this.createElement("fontfamily");
    elem.setAttribute("family", DEFAULT_FONTFAMILY);
    this.root.appendChild(elem);
    elem = this.createElement("fontsize");
    elem.setAttribute("size", String(DEFAULT_FONTSIZE));
    this.root.appendChild(elem);
    elem = this.createElement("shadowcolor");
    elem.setAttribute("color", StyleDefaultsConfig.shadowColor);
    this.root.appendChild(elem);
    elem = this.createElement("shadowalpha");
    elem.setAttribute("alpha", String(StyleDefaultsConfig.shadowOpacity));
    this.root.appendChild(elem);
    elem = this.createElement("shadowoffset");
    elem.setAttribute("dx", String(StyleDefaultsConfig.shadowOffsetX));
    elem.setAttribute("dy", String(StyleDefaultsConfig.shadowOffsetY));
    this.root.appendChild(elem);
  }
  /**
   * Returns a formatted number with 2 decimal places.
   */
  format(value) {
    if (typeof value === "string") {
      return parseFloat(parseFloat(value).toFixed(2));
    } else {
      return parseFloat(value.toFixed(2));
    }
  }
  /**
   * Creates the given element using the owner document of {@link root}.
   */
  createElement(name) {
    return this.root.ownerDocument.createElement(name);
  }
  /**
   * Saves the drawing state.
   */
  save() {
    if (this.compressed) {
      super.save();
    }
    this.root.appendChild(this.createElement("save"));
  }
  /**
   * Restores the drawing state.
   */
  restore() {
    if (this.compressed) {
      super.restore();
    }
    this.root.appendChild(this.createElement("restore"));
  }
  /**
   * Scales the output.
   *
   * @param scale Number that represents the scale where 1 is equal to 100%.
   */
  scale(value) {
    const elem = this.createElement("scale");
    elem.setAttribute("scale", String(value));
    this.root.appendChild(elem);
  }
  /**
   * Translates the output.
   *
   * @param dx Number that specifies the horizontal translation.
   * @param dy Number that specifies the vertical translation.
   */
  translate(dx, dy) {
    const elem = this.createElement("translate");
    elem.setAttribute("dx", String(this.format(dx)));
    elem.setAttribute("dy", String(this.format(dy)));
    this.root.appendChild(elem);
  }
  /**
   * Rotates and/or flips the output around a given center. (Note: Due to
   * limitations in VML, the rotation cannot be concatenated.)
   *
   * @param theta Number that represents the angle of the rotation (in degrees).
   * @param flipH Boolean indicating if the output should be flipped horizontally.
   * @param flipV Boolean indicating if the output should be flipped vertically.
   * @param cx Number that represents the x-coordinate of the rotation center.
   * @param cy Number that represents the y-coordinate of the rotation center.
   */
  rotate(theta, flipH, flipV, cx, cy) {
    const elem = this.createElement("rotate");
    if (theta !== 0 || flipH || flipV) {
      elem.setAttribute("theta", String(this.format(theta)));
      elem.setAttribute("flipH", flipH ? "1" : "0");
      elem.setAttribute("flipV", flipV ? "1" : "0");
      elem.setAttribute("cx", String(this.format(cx)));
      elem.setAttribute("cy", String(this.format(cy)));
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current alpha.
   *
   * @param value Number that represents the new alpha. Possible values are between
   * 1 (opaque) and 0 (transparent).
   */
  setAlpha(value) {
    if (this.compressed) {
      if (this.state.alpha === value) {
        return;
      }
      super.setAlpha(value);
    }
    const elem = this.createElement("alpha");
    elem.setAttribute("alpha", String(this.format(value)));
    this.root.appendChild(elem);
  }
  /**
   * Sets the current fill alpha.
   *
   * @param value Number that represents the new fill alpha. Possible values are between
   * 1 (opaque) and 0 (transparent).
   */
  setFillAlpha(value) {
    if (this.compressed) {
      if (this.state.fillAlpha === value) {
        return;
      }
      super.setFillAlpha(value);
    }
    const elem = this.createElement("fillalpha");
    elem.setAttribute("alpha", String(this.format(value)));
    this.root.appendChild(elem);
  }
  /**
   * Sets the current stroke alpha.
   *
   * @param value Number that represents the new stroke alpha. Possible values are between
   * 1 (opaque) and 0 (transparent).
   */
  setStrokeAlpha(value) {
    if (this.compressed) {
      if (this.state.strokeAlpha === value) {
        return;
      }
      super.setStrokeAlpha(value);
    }
    const elem = this.createElement("strokealpha");
    elem.setAttribute("alpha", String(this.format(value)));
    this.root.appendChild(elem);
  }
  /**
   * Sets the current fill color.
   *
   * @param value Hexadecimal representation of the color or 'none'.
   */
  setFillColor(value = null) {
    if (value === NONE) {
      value = null;
    }
    if (this.compressed) {
      if (this.state.fillColor === value) {
        return;
      }
      super.setFillColor(value);
    }
    const elem = this.createElement("fillcolor");
    elem.setAttribute("color", value != null ? value : NONE);
    this.root.appendChild(elem);
  }
  /**
   * Sets the gradient. Note that the coordinates may be ignored by some implementations.
   *
   * @param color1 Hexadecimal representation of the start color.
   * @param color2 Hexadecimal representation of the end color.
   * @param x X-coordinate of the gradient region.
   * @param y y-coordinate of the gradient region.
   * @param w Width of the gradient region.
   * @param h Height of the gradient region.
   * @param direction One of {@link Constants#DIRECTION_NORTH}, {@link Constants#DIRECTION_EAST},
   * {@link Constants#DIRECTION_SOUTH} or {@link Constants#DIRECTION_WEST}.
   * @param alpha1 Optional alpha of the start color. Default is 1. Possible values
   * are between 1 (opaque) and 0 (transparent).
   * @param alpha2 Optional alpha of the end color. Default is 1. Possible values
   * are between 1 (opaque) and 0 (transparent).
   */
  setGradient(color1, color2, x, y, w, h, direction, alpha1 = 1, alpha2 = 1) {
    if (color1 != null && color2 != null) {
      super.setGradient(color1, color2, x, y, w, h, direction, alpha1, alpha2);
      const elem = this.createElement("gradient");
      elem.setAttribute("c1", color1);
      elem.setAttribute("c2", color2);
      elem.setAttribute("x", String(this.format(x)));
      elem.setAttribute("y", String(this.format(y)));
      elem.setAttribute("w", String(this.format(w)));
      elem.setAttribute("h", String(this.format(h)));
      if (direction != null) {
        elem.setAttribute("direction", direction);
      }
      if (alpha1 != null) {
        elem.setAttribute("alpha1", String(alpha1));
      }
      if (alpha2 != null) {
        elem.setAttribute("alpha2", String(alpha2));
      }
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current stroke color.
   *
   * @param value Hexadecimal representation of the color or 'none'.
   */
  setStrokeColor(value = null) {
    if (value === NONE) {
      value = null;
    }
    if (this.compressed) {
      if (this.state.strokeColor === value) {
        return;
      }
      super.setStrokeColor(value);
    }
    const elem = this.createElement("strokecolor");
    elem.setAttribute("color", value != null ? value : NONE);
    this.root.appendChild(elem);
  }
  /**
   * Sets the current stroke width.
   *
   * @param value Numeric representation of the stroke width.
   */
  setStrokeWidth(value) {
    if (this.compressed) {
      if (this.state.strokeWidth === value) {
        return;
      }
      super.setStrokeWidth(value);
    }
    const elem = this.createElement("strokewidth");
    elem.setAttribute("width", String(this.format(value)));
    this.root.appendChild(elem);
  }
  /**
   * Enables or disables dashed lines.
   *
   * @param value Boolean that specifies if dashed lines should be enabled.
   * @param value Boolean that specifies if the stroke width should be ignored
   * for the dash pattern.
   * @default false
   */
  setDashed(value, fixDash) {
    if (this.compressed) {
      if (this.state.dashed === value) {
        return;
      }
      super.setDashed(value, fixDash);
    }
    const elem = this.createElement("dashed");
    elem.setAttribute("dashed", value ? "1" : "0");
    if (fixDash != null) {
      elem.setAttribute("fixDash", fixDash ? "1" : "0");
    }
    this.root.appendChild(elem);
  }
  /**
   * Sets the current dash pattern.
   * @default '3 3'
   *
   * @param value String that represents the dash pattern, which is a sequence of
   * numbers defining the length of the dashes and the length of the spaces
   * between the dashes. The lengths are relative to the line width - a length
   * of 1 is equals to the line width.
   */
  setDashPattern(value) {
    if (this.compressed) {
      if (this.state.dashPattern === value) {
        return;
      }
      super.setDashPattern(value);
    }
    const elem = this.createElement("dashpattern");
    elem.setAttribute("pattern", value);
    this.root.appendChild(elem);
  }
  /**
   * Sets the line cap.
   * @default 'flat' which corresponds to 'butt' in SVG
   *
   * @param value String that represents the line cap. Possible values are flat, round
   * and square.
   */
  setLineCap(value) {
    if (this.compressed) {
      if (this.state.lineCap === value) {
        return;
      }
      super.setLineCap(value);
    }
    const elem = this.createElement("linecap");
    elem.setAttribute("cap", value);
    this.root.appendChild(elem);
  }
  /**
   * Sets the line join.
   * @default 'miter'
   *
   * @param value String that represents the line join. Possible values are miter,
   * round and bevel.
   */
  setLineJoin(value) {
    if (this.compressed) {
      if (this.state.lineJoin === value) {
        return;
      }
      super.setLineJoin(value);
    }
    const elem = this.createElement("linejoin");
    elem.setAttribute("join", value);
    this.root.appendChild(elem);
  }
  /**
   * Sets the miter limit.
   * @default 10
   *
   * @param value Number that represents the miter limit.
   */
  setMiterLimit(value) {
    if (this.compressed) {
      if (this.state.miterLimit === value) {
        return;
      }
      super.setMiterLimit(value);
    }
    const elem = this.createElement("miterlimit");
    elem.setAttribute("limit", String(value));
    this.root.appendChild(elem);
  }
  /**
   * Sets the current font color.
   * @default '#000000'
   *
   * @param value Hexadecimal representation of the color or 'none'.
   */
  setFontColor(value = null) {
    if (this.textEnabled) {
      if (value === NONE) {
        value = null;
      }
      if (this.compressed) {
        if (this.state.fontColor === value) {
          return;
        }
        super.setFontColor(value);
      }
      const elem = this.createElement("fontcolor");
      elem.setAttribute("color", value != null ? value : NONE);
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current font background color.
   *
   * @param value Hexadecimal representation of the color or 'none'.
   */
  setFontBackgroundColor(value = null) {
    if (this.textEnabled) {
      if (value === NONE) {
        value = null;
      }
      if (this.compressed) {
        if (this.state.fontBackgroundColor === value) {
          return;
        }
        super.setFontBackgroundColor(value);
      }
      const elem = this.createElement("fontbackgroundcolor");
      elem.setAttribute("color", value != null ? value : NONE);
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current font border color.
   *
   * @param value Hexadecimal representation of the color or 'none'.
   */
  setFontBorderColor(value = null) {
    if (this.textEnabled) {
      if (value === NONE) {
        value = null;
      }
      if (this.compressed) {
        if (this.state.fontBorderColor === value) {
          return;
        }
        super.setFontBorderColor(value);
      }
      const elem = this.createElement("fontbordercolor");
      elem.setAttribute("color", value != null ? value : NONE);
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current font size.
   * @default {@link mxConstants.DEFAULT_FONTSIZE}
   *
   * @param value Numeric representation of the font size.
   */
  setFontSize(value) {
    if (this.textEnabled) {
      if (this.compressed) {
        if (this.state.fontSize === value) {
          return;
        }
        super.setFontSize(value);
      }
      const elem = this.createElement("fontsize");
      elem.setAttribute("size", String(value));
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current font family.
   * @default {@link mxConstants.DEFAULT_FONTFAMILY}
   *
   * @param value String representation of the font family. This handles the same
   * values as the CSS font-family property.
   */
  setFontFamily(value) {
    if (this.textEnabled) {
      if (this.compressed) {
        if (this.state.fontFamily === value) {
          return;
        }
        super.setFontFamily(value);
      }
      const elem = this.createElement("fontfamily");
      elem.setAttribute("family", value);
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current font style.
   *
   * @param value Numeric representation of the font family. This is the sum of the
   * font styles from {@link mxConstants}.
   */
  setFontStyle(value = 0) {
    if (this.textEnabled) {
      if (value == null) {
        value = 0;
      }
      if (this.compressed) {
        if (this.state.fontStyle === value) {
          return;
        }
        super.setFontStyle(value);
      }
      const elem = this.createElement("fontstyle");
      elem.setAttribute("style", String(value));
      this.root.appendChild(elem);
    }
  }
  /**
   * Enables or disables shadows.
   *
   * @param value Boolean that specifies if shadows should be enabled.
   */
  setShadow(value) {
    if (this.compressed) {
      if (this.state.shadow === value) {
        return;
      }
      super.setShadow(value);
    }
    const elem = this.createElement("shadow");
    elem.setAttribute("enabled", value ? "1" : "0");
    this.root.appendChild(elem);
  }
  setShadowColor(value = null) {
    if (this.compressed) {
      if (value === NONE) {
        value = null;
      }
      if (this.state.shadowColor === value) {
        return;
      }
      super.setShadowColor(value);
    }
    const elem = this.createElement("shadowcolor");
    elem.setAttribute("color", value != null ? value : NONE);
    this.root.appendChild(elem);
  }
  setShadowAlpha(value) {
    if (this.compressed) {
      if (this.state.shadowAlpha === value) {
        return;
      }
      super.setShadowAlpha(value);
    }
    const elem = this.createElement("shadowalpha");
    elem.setAttribute("alpha", String(value));
    this.root.appendChild(elem);
  }
  setShadowOffset(dx, dy) {
    if (this.compressed) {
      if (this.state.shadowDx === dx && this.state.shadowDy === dy) {
        return;
      }
      super.setShadowOffset(dx, dy);
    }
    const elem = this.createElement("shadowoffset");
    elem.setAttribute("dx", String(dx));
    elem.setAttribute("dy", String(dy));
    this.root.appendChild(elem);
  }
  /**
   * Puts a rectangle into the drawing buffer.
   *
   * @param x Number that represents the x-coordinate of the rectangle.
   * @param y Number that represents the y-coordinate of the rectangle.
   * @param w Number that represents the width of the rectangle.
   * @param h Number that represents the height of the rectangle.
   */
  rect(x, y, w, h) {
    const elem = this.createElement("rect");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    elem.setAttribute("w", String(this.format(w)));
    elem.setAttribute("h", String(this.format(h)));
    this.root.appendChild(elem);
  }
  /**
   * Puts a rounded rectangle into the drawing buffer.
   *
   * @param x Number that represents the x-coordinate of the rectangle.
   * @param y Number that represents the y-coordinate of the rectangle.
   * @param w Number that represents the width of the rectangle.
   * @param h Number that represents the height of the rectangle.
   * @param dx Number that represents the horizontal rounding.
   * @param dy Number that represents the vertical rounding.
   */
  roundrect(x, y, w, h, dx, dy) {
    const elem = this.createElement("roundrect");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    elem.setAttribute("w", String(this.format(w)));
    elem.setAttribute("h", String(this.format(h)));
    elem.setAttribute("dx", String(this.format(dx)));
    elem.setAttribute("dy", String(this.format(dy)));
    this.root.appendChild(elem);
  }
  /**
   * Puts an ellipse into the drawing buffer.
   *
   * @param x Number that represents the x-coordinate of the ellipse.
   * @param y Number that represents the y-coordinate of the ellipse.
   * @param w Number that represents the width of the ellipse.
   * @param h Number that represents the height of the ellipse.
   */
  ellipse(x, y, w, h) {
    const elem = this.createElement("ellipse");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    elem.setAttribute("w", String(this.format(w)));
    elem.setAttribute("h", String(this.format(h)));
    this.root.appendChild(elem);
  }
  /**
   * Paints an image.
   *
   * @param x Number that represents the x-coordinate of the image.
   * @param y Number that represents the y-coordinate of the image.
   * @param w Number that represents the width of the image.
   * @param h Number that represents the height of the image.
   * @param src String that specifies the URL of the image.
   * @param aspect Boolean indicating if the aspect of the image should be preserved.
   * @param flipH Boolean indicating if the image should be flipped horizontally.
   * @param flipV Boolean indicating if the image should be flipped vertically.
   */
  image(x, y, w, h, src, aspect = true, flipH = false, flipV = false) {
    src = this.converter.convert(src);
    const elem = this.createElement("image");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    elem.setAttribute("w", String(this.format(w)));
    elem.setAttribute("h", String(this.format(h)));
    elem.setAttribute("src", src);
    elem.setAttribute("aspect", aspect ? "1" : "0");
    elem.setAttribute("flipH", flipH ? "1" : "0");
    elem.setAttribute("flipV", flipV ? "1" : "0");
    this.root.appendChild(elem);
  }
  updateText() {
    return;
  }
  /**
   * Starts a new path and puts it into the drawing buffer.
   */
  begin() {
    this.root.appendChild(this.createElement("begin"));
    this.lastX = 0;
    this.lastY = 0;
  }
  end() {
    return;
  }
  /**
   * Moves the current path the given point.
   *
   * @param x Number that represents the x-coordinate of the point.
   * @param y Number that represents the y-coordinate of the point.
   */
  moveTo(x, y) {
    const elem = this.createElement("move");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    this.root.appendChild(elem);
    this.lastX = x;
    this.lastY = y;
  }
  /**
   * Draws a line to the given coordinates.
   *
   * @param x Number that represents the x-coordinate of the endpoint.
   * @param y Number that represents the y-coordinate of the endpoint.
   */
  lineTo(x, y) {
    const elem = this.createElement("line");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    this.root.appendChild(elem);
    this.lastX = x;
    this.lastY = y;
  }
  /**
   * Adds a quadratic curve to the current path.
   *
   * @param x1 Number that represents the x-coordinate of the control point.
   * @param y1 Number that represents the y-coordinate of the control point.
   * @param x2 Number that represents the x-coordinate of the endpoint.
   * @param y2 Number that represents the y-coordinate of the endpoint.
   */
  quadTo(x1, y1, x2, y2) {
    const elem = this.createElement("quad");
    elem.setAttribute("x1", String(this.format(x1)));
    elem.setAttribute("y1", String(this.format(y1)));
    elem.setAttribute("x2", String(this.format(x2)));
    elem.setAttribute("y2", String(this.format(y2)));
    this.root.appendChild(elem);
    this.lastX = x2;
    this.lastY = y2;
  }
  /**
   * Adds a bezier curve to the current path.
   *
   * @param x1 Number that represents the x-coordinate of the first control point.
   * @param y1 Number that represents the y-coordinate of the first control point.
   * @param x2 Number that represents the x-coordinate of the second control point.
   * @param y2 Number that represents the y-coordinate of the second control point.
   * @param x3 Number that represents the x-coordinate of the endpoint.
   * @param y3 Number that represents the y-coordinate of the endpoint.
   */
  curveTo(x1, y1, x2, y2, x3, y3) {
    const elem = this.createElement("curve");
    elem.setAttribute("x1", String(this.format(x1)));
    elem.setAttribute("y1", String(this.format(y1)));
    elem.setAttribute("x2", String(this.format(x2)));
    elem.setAttribute("y2", String(this.format(y2)));
    elem.setAttribute("x3", String(this.format(x3)));
    elem.setAttribute("y3", String(this.format(y3)));
    this.root.appendChild(elem);
    this.lastX = x3;
    this.lastY = y3;
  }
  /**
   * Closes the current path.
   */
  close() {
    this.root.appendChild(this.createElement("close"));
  }
  /**
   * Paints the given text. Possible values for format are empty string for
   * plain text and html for HTML markup. Background and border color as well
   * as clipping is not available in plain text labels for VML. HTML labels
   * are not available as part of shapes with no foreignObject support in SVG
   * (eg. IE9, IE10).
   *
   * @param x Number that represents the x-coordinate of the text.
   * @param y Number that represents the y-coordinate of the text.
   * @param w Number that represents the available width for the text or 0 for automatic width.
   * @param h Number that represents the available height for the text or 0 for automatic height.
   * @param str String that specifies the text to be painted.
   * @param align String that represents the horizontal alignment.
   * @param valign String that represents the vertical alignment.
   * @param wrap Boolean that specifies if word-wrapping is enabled. Requires w > 0.
   * @param format Empty string for plain text or 'html' for HTML markup.
   * @param overflow Specifies the overflow behaviour of the label. Requires w > 0 and/or h > 0.
   * @param clip Boolean that specifies if the label should be clipped. Requires w > 0 and/or h > 0.
   * @param rotation Number that specifies the angle of the rotation around the anchor point of the text.
   * @param dir Optional string that specifies the text direction. Possible values are rtl and ltr.
   */
  text(x, y, w, h, str, align = null, valign = null, wrap = null, format = null, overflow = null, clip = null, rotation = null, dir = null) {
    if (this.textEnabled && str != null) {
      if (isNode(str)) {
        str = getOuterHtml(str);
      }
      const elem = this.createElement("text");
      elem.setAttribute("x", String(this.format(x)));
      elem.setAttribute("y", String(this.format(y)));
      elem.setAttribute("w", String(this.format(w)));
      elem.setAttribute("h", String(this.format(h)));
      elem.setAttribute("str", str);
      if (align != null) {
        elem.setAttribute("align", align);
      }
      if (valign != null) {
        elem.setAttribute("valign", valign);
      }
      elem.setAttribute("wrap", wrap ? "1" : "0");
      if (format == null) {
        format = "";
      }
      elem.setAttribute("format", format);
      if (overflow != null) {
        elem.setAttribute("overflow", overflow);
      }
      if (clip != null) {
        elem.setAttribute("clip", clip ? "1" : "0");
      }
      if (rotation != null) {
        elem.setAttribute("rotation", String(rotation));
      }
      if (dir != null) {
        elem.setAttribute("dir", dir);
      }
      this.root.appendChild(elem);
    }
  }
  /**
   * Paints the outline of the current drawing buffer.
   */
  stroke() {
    this.root.appendChild(this.createElement("stroke"));
  }
  /**
   * Fills the current drawing buffer.
   */
  fill() {
    this.root.appendChild(this.createElement("fill"));
  }
  /**
   * Fills the current drawing buffer and its outline.
   */
  fillAndStroke() {
    this.root.appendChild(this.createElement("fillstroke"));
  }
}
const linkAction = (parent, text, editor, action, pad = 0) => {
  return link(parent, text, () => {
    editor.execute(action);
  }, pad);
};
const linkInvoke = (parent, text, editor, functName, arg, pad = 0) => {
  return link(parent, text, () => {
    editor[functName](arg);
  }, pad);
};
const link = (parent, text, funct, pad = 0) => {
  const a = document.createElement("span");
  a.style.color = "blue";
  a.style.textDecoration = "underline";
  a.style.cursor = "pointer";
  a.style.paddingLeft = `${pad}px`;
  InternalEvent.addListener(a, "click", funct);
  write(a, text);
  if (parent != null) {
    parent.appendChild(a);
  }
  return a;
};
const button = (label, funct, doc = null) => {
  doc = doc != null ? doc : document;
  const button2 = doc.createElement("button");
  write(button2, label);
  InternalEvent.addListener(button2, "click", (evt) => {
    funct(evt);
  });
  return button2;
};
const domHelpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  button,
  link,
  linkAction,
  linkInvoke
}, Symbol.toStringTag, { value: "Module" }));
class MaxLogAsLogger {
  enter(message) {
    return MaxLog.enter(message);
  }
  leave(message, baseTimestamp) {
    MaxLog.leave(message, baseTimestamp);
  }
  show() {
    MaxLog.show();
  }
  info(message) {
    MaxLog.writeln(message);
  }
  debug(message) {
    MaxLog.debug(message);
  }
  error(message, ...optionalParams) {
    const args = optionalParams == null ? void 0 : optionalParams.map((param) => String(param));
    MaxLog.writeln(`[ERROR] ${message}`, ...args);
  }
  trace(message) {
    MaxLog.trace(message);
  }
  warn(message) {
    MaxLog.warn(message);
  }
}
class ImageBundle {
  constructor(alt = false) {
    this.images = {};
    this.alt = alt;
  }
  /**
   * Adds the specified entry to the map. The entry is an object with a value and
   * fallback property as specified in the arguments.
   */
  putImage(key, value, fallback) {
    this.images[key] = { value, fallback };
  }
  /**
   * Returns the value for the given key. This returns the value
   * or fallback, depending on <alt>. The fallback is returned if
   * <alt> is true, the value is returned otherwise.
   */
  getImage(key) {
    let result = null;
    if (key) {
      const img = this.images[key];
      if (img) {
        result = this.alt ? img.fallback : img.value;
      }
    }
    return result;
  }
}
class ImageExport {
  constructor() {
    this.includeOverlays = false;
  }
  /**
   * Draws the given state and all its descendants to the given canvas.
   */
  drawState(state, canvas) {
    if (state) {
      this.visitStatesRecursive(state, canvas, this.drawCellState.bind(this));
      if (this.includeOverlays) {
        this.visitStatesRecursive(state, canvas, this.drawOverlays.bind(this));
      }
    }
  }
  /**
   * Visits the given state and all its descendants to the given canvas recursively.
   */
  visitStatesRecursive(state, canvas, visitor) {
    if (state) {
      visitor(state, canvas);
      const graph = state.view.graph;
      const childCount = state.cell.getChildCount();
      for (let i = 0; i < childCount; i += 1) {
        const childState = graph.view.getState(state.cell.getChildAt(i));
        if (childState)
          this.visitStatesRecursive(childState, canvas, visitor);
      }
    }
  }
  /**
   * Returns the link for the given cell state and canvas. This returns null.
   */
  getLinkForCellState(_state, _canvas) {
    return null;
  }
  /**
   * Draws the given state to the given canvas.
   */
  drawCellState(state, canvas) {
    const link2 = this.getLinkForCellState(state, canvas);
    if (link2) {
      canvas.setLink(link2);
    }
    this.drawShape(state, canvas);
    this.drawText(state, canvas);
    if (link2) {
      canvas.setLink(null);
    }
  }
  /**
   * Draws the shape of the given state.
   */
  drawShape(state, canvas) {
    if (state.shape instanceof Shape && state.shape.checkBounds()) {
      canvas.save();
      state.shape.beforePaint(canvas);
      state.shape.paint(canvas);
      state.shape.afterPaint(canvas);
      canvas.restore();
    }
  }
  /**
   * Draws the text of the given state.
   */
  drawText(state, canvas) {
    if (state.text && state.text.checkBounds()) {
      canvas.save();
      state.text.beforePaint(canvas);
      state.text.paint(canvas);
      state.text.afterPaint(canvas);
      canvas.restore();
    }
  }
  /**
   * Draws the overlays for the given state. This is called if <includeOverlays>
   * is true.
   */
  drawOverlays(state, canvas) {
    if (state.overlays != null) {
      state.overlays.visit((_id, shape) => {
        if (shape instanceof Shape) {
          shape.paint(canvas);
        }
      });
    }
  }
}
class AutoSaveManager extends EventSource {
  constructor(graph) {
    super();
    this.graph = null;
    this.autoSaveDelay = 10;
    this.autoSaveThrottle = 2;
    this.autoSaveThreshold = 5;
    this.ignoredChanges = 0;
    this.lastSnapshot = 0;
    this.enabled = true;
    this.changeHandler = (sender, evt) => {
      if (this.isEnabled()) {
        this.graphModelChanged(evt.getProperty("edit").changes);
      }
    };
    this.setGraph(graph);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates <enabled>.
   *
   * @param enabled - Boolean that specifies the new enabled state.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * Sets the graph that the layouts operate on.
   */
  setGraph(graph) {
    if (this.graph != null) {
      this.graph.getDataModel().removeListener(this.changeHandler);
    }
    this.graph = graph;
    if (this.graph != null) {
      this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);
    }
  }
  /**
   * Empty hook that is called if the graph should be saved.
   */
  save() {
  }
  /**
   * Invoked when the graph model has changed.
   */
  graphModelChanged(changes) {
    const now = (/* @__PURE__ */ new Date()).getTime();
    const dt = (now - this.lastSnapshot) / 1e3;
    if (dt > this.autoSaveDelay || this.ignoredChanges >= this.autoSaveThreshold && dt > this.autoSaveThrottle) {
      this.save();
      this.reset();
    } else {
      this.ignoredChanges++;
    }
  }
  /**
   * Resets all counters.
   */
  reset() {
    this.lastSnapshot = (/* @__PURE__ */ new Date()).getTime();
    this.ignoredChanges = 0;
  }
  /**
   * Removes all handlers from the {@link graph} and deletes the reference to it.
   */
  destroy() {
    this.setGraph(null);
  }
}
class Multiplicity {
  constructor(source, type, attr, value, min, max, validNeighbors, countError, typeError, validNeighborsAllowed = true) {
    this.validNeighborsAllowed = true;
    this.source = source;
    this.type = type;
    this.attr = attr;
    this.value = value;
    this.min = min ?? 0;
    this.max = max ?? Number.MAX_VALUE;
    this.validNeighbors = validNeighbors;
    this.countError = translate(countError) || countError;
    this.typeError = translate(typeError) || typeError;
    this.validNeighborsAllowed = validNeighborsAllowed;
  }
  /**
   * Checks the multiplicity for the given arguments and returns the error
   * for the given connection or null if the multiplicity does not apply.
   *
   * @param graph Reference to the enclosing {@link graph} instance.
   * @param edge {@link mxCell} that represents the edge to validate.
   * @param source {@link mxCell} that represents the source terminal.
   * @param target {@link mxCell} that represents the target terminal.
   * @param sourceOut Number of outgoing edges from the source terminal.
   * @param targetIn Number of incoming edges for the target terminal.
   */
  check(graph, edge, source, target, sourceOut, targetIn) {
    let error2 = "";
    if (this.source && this.checkTerminal(graph, source, edge) || !this.source && this.checkTerminal(graph, target, edge)) {
      if (this.countError != null && (this.source && (this.max === 0 || sourceOut >= this.max) || !this.source && (this.max === 0 || targetIn >= this.max))) {
        error2 += `${this.countError}
`;
      }
      if (this.validNeighbors != null && this.typeError != null && this.validNeighbors.length > 0) {
        const isValid = this.checkNeighbors(graph, edge, source, target);
        if (!isValid) {
          error2 += `${this.typeError}
`;
        }
      }
    }
    return error2.length > 0 ? error2 : null;
  }
  /**
   * Checks if there are any valid neighbours in {@link validNeighbors}. This is only
   * called if {@link validNeighbors} is a non-empty array.
   */
  checkNeighbors(graph, edge, source, target) {
    const sourceValue = source.getValue();
    const targetValue = target.getValue();
    let isValid = !this.validNeighborsAllowed;
    const valid = this.validNeighbors;
    for (let j = 0; j < valid.length; j++) {
      if (this.source && this.checkType(graph, targetValue, valid[j])) {
        isValid = this.validNeighborsAllowed;
        break;
      } else if (!this.source && this.checkType(graph, sourceValue, valid[j])) {
        isValid = this.validNeighborsAllowed;
        break;
      }
    }
    return isValid;
  }
  /**
   * Checks the given terminal cell and returns true if this rule applies. The
   * given cell is the source or target of the given edge, depending on
   * {@link source}. This implementation uses {@link checkType} on the terminal's value.
   */
  checkTerminal(graph, edge, terminal) {
    const value = (terminal == null ? void 0 : terminal.getValue()) ?? null;
    return this.checkType(graph, value, this.type, this.attr, this.value);
  }
  /**
   * Checks the type of the given value.
   */
  checkType(graph, value, type, attr, attrValue) {
    if (value != null) {
      if (typeof value !== "string" && "nodeType" in value && !Number.isNaN(value.nodeType)) {
        return isNode(value, type, attr, attrValue);
      }
      return value === type;
    }
    return false;
  }
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var mimeTypes = {};
const require$$0 = {
  "application/1d-interleaved-parityfec": { "source": "iana" },
  "application/3gpdash-qoe-report+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/3gpp-ims+xml": { "source": "iana", "compressible": true },
  "application/3gpphal+json": { "source": "iana", "compressible": true },
  "application/3gpphalforms+json": { "source": "iana", "compressible": true },
  "application/a2l": { "source": "iana" },
  "application/ace+cbor": { "source": "iana" },
  "application/ace+json": { "source": "iana", "compressible": true },
  "application/ace-groupcomm+cbor": { "source": "iana" },
  "application/ace-trl+cbor": { "source": "iana" },
  "application/activemessage": { "source": "iana" },
  "application/activity+json": { "source": "iana", "compressible": true },
  "application/aif+cbor": { "source": "iana" },
  "application/aif+json": { "source": "iana", "compressible": true },
  "application/alto-cdni+json": { "source": "iana", "compressible": true },
  "application/alto-cdnifilter+json": { "source": "iana", "compressible": true },
  "application/alto-costmap+json": { "source": "iana", "compressible": true },
  "application/alto-costmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-directory+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcost+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true },
  "application/alto-endpointprop+json": { "source": "iana", "compressible": true },
  "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true },
  "application/alto-error+json": { "source": "iana", "compressible": true },
  "application/alto-networkmap+json": { "source": "iana", "compressible": true },
  "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-propmap+json": { "source": "iana", "compressible": true },
  "application/alto-propmapparams+json": { "source": "iana", "compressible": true },
  "application/alto-tips+json": { "source": "iana", "compressible": true },
  "application/alto-tipsparams+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamcontrol+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamparams+json": { "source": "iana", "compressible": true },
  "application/aml": { "source": "iana" },
  "application/andrew-inset": { "source": "iana", "extensions": ["ez"] },
  "application/appinstaller": { "compressible": false, "extensions": ["appinstaller"] },
  "application/applefile": { "source": "iana" },
  "application/applixware": { "source": "apache", "extensions": ["aw"] },
  "application/appx": { "compressible": false, "extensions": ["appx"] },
  "application/appxbundle": { "compressible": false, "extensions": ["appxbundle"] },
  "application/at+jwt": { "source": "iana" },
  "application/atf": { "source": "iana" },
  "application/atfx": { "source": "iana" },
  "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] },
  "application/atomcat+xml": { "source": "iana", "compressible": true, "extensions": ["atomcat"] },
  "application/atomdeleted+xml": { "source": "iana", "compressible": true, "extensions": ["atomdeleted"] },
  "application/atomicmail": { "source": "iana" },
  "application/atomsvc+xml": { "source": "iana", "compressible": true, "extensions": ["atomsvc"] },
  "application/atsc-dwd+xml": { "source": "iana", "compressible": true, "extensions": ["dwd"] },
  "application/atsc-dynamic-event-message": { "source": "iana" },
  "application/atsc-held+xml": { "source": "iana", "compressible": true, "extensions": ["held"] },
  "application/atsc-rdt+json": { "source": "iana", "compressible": true },
  "application/atsc-rsat+xml": { "source": "iana", "compressible": true, "extensions": ["rsat"] },
  "application/atxml": { "source": "iana" },
  "application/auth-policy+xml": { "source": "iana", "compressible": true },
  "application/automationml-aml+xml": { "source": "iana", "compressible": true, "extensions": ["aml"] },
  "application/automationml-amlx+zip": { "source": "iana", "compressible": false, "extensions": ["amlx"] },
  "application/bacnet-xdd+zip": { "source": "iana", "compressible": false },
  "application/batch-smtp": { "source": "iana" },
  "application/bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/beep+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/bufr": { "source": "iana" },
  "application/c2pa": { "source": "iana" },
  "application/calendar+json": { "source": "iana", "compressible": true },
  "application/calendar+xml": { "source": "iana", "compressible": true, "extensions": ["xcs"] },
  "application/call-completion": { "source": "iana" },
  "application/cals-1840": { "source": "iana" },
  "application/captive+json": { "source": "iana", "compressible": true },
  "application/cbor": { "source": "iana" },
  "application/cbor-seq": { "source": "iana" },
  "application/cccex": { "source": "iana" },
  "application/ccmp+xml": { "source": "iana", "compressible": true },
  "application/ccxml+xml": { "source": "iana", "compressible": true, "extensions": ["ccxml"] },
  "application/cda+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/cdfx+xml": { "source": "iana", "compressible": true, "extensions": ["cdfx"] },
  "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] },
  "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] },
  "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] },
  "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] },
  "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] },
  "application/cdni": { "source": "iana" },
  "application/ce+cbor": { "source": "iana" },
  "application/cea": { "source": "iana" },
  "application/cea-2018+xml": { "source": "iana", "compressible": true },
  "application/cellml+xml": { "source": "iana", "compressible": true },
  "application/cfw": { "source": "iana" },
  "application/cid-edhoc+cbor-seq": { "source": "iana" },
  "application/city+json": { "source": "iana", "compressible": true },
  "application/city+json-seq": { "source": "iana" },
  "application/clr": { "source": "iana" },
  "application/clue+xml": { "source": "iana", "compressible": true },
  "application/clue_info+xml": { "source": "iana", "compressible": true },
  "application/cms": { "source": "iana" },
  "application/cnrp+xml": { "source": "iana", "compressible": true },
  "application/coap-eap": { "source": "iana" },
  "application/coap-group+json": { "source": "iana", "compressible": true },
  "application/coap-payload": { "source": "iana" },
  "application/commonground": { "source": "iana" },
  "application/concise-problem-details+cbor": { "source": "iana" },
  "application/conference-info+xml": { "source": "iana", "compressible": true },
  "application/cose": { "source": "iana" },
  "application/cose-key": { "source": "iana" },
  "application/cose-key-set": { "source": "iana" },
  "application/cose-x509": { "source": "iana" },
  "application/cpl+xml": { "source": "iana", "compressible": true, "extensions": ["cpl"] },
  "application/csrattrs": { "source": "iana" },
  "application/csta+xml": { "source": "iana", "compressible": true },
  "application/cstadata+xml": { "source": "iana", "compressible": true },
  "application/csvm+json": { "source": "iana", "compressible": true },
  "application/cu-seeme": { "source": "apache", "extensions": ["cu"] },
  "application/cwl": { "source": "iana", "extensions": ["cwl"] },
  "application/cwl+json": { "source": "iana", "compressible": true },
  "application/cwl+yaml": { "source": "iana" },
  "application/cwt": { "source": "iana" },
  "application/cybercash": { "source": "iana" },
  "application/dart": { "compressible": true },
  "application/dash+xml": { "source": "iana", "compressible": true, "extensions": ["mpd"] },
  "application/dash-patch+xml": { "source": "iana", "compressible": true, "extensions": ["mpp"] },
  "application/dashdelta": { "source": "iana" },
  "application/davmount+xml": { "source": "iana", "compressible": true, "extensions": ["davmount"] },
  "application/dca-rft": { "source": "iana" },
  "application/dcd": { "source": "iana" },
  "application/dec-dx": { "source": "iana" },
  "application/dialog-info+xml": { "source": "iana", "compressible": true },
  "application/dicom": { "source": "iana", "extensions": ["dcm"] },
  "application/dicom+json": { "source": "iana", "compressible": true },
  "application/dicom+xml": { "source": "iana", "compressible": true },
  "application/dii": { "source": "iana" },
  "application/dit": { "source": "iana" },
  "application/dns": { "source": "iana" },
  "application/dns+json": { "source": "iana", "compressible": true },
  "application/dns-message": { "source": "iana" },
  "application/docbook+xml": { "source": "apache", "compressible": true, "extensions": ["dbk"] },
  "application/dots+cbor": { "source": "iana" },
  "application/dpop+jwt": { "source": "iana" },
  "application/dskpp+xml": { "source": "iana", "compressible": true },
  "application/dssc+der": { "source": "iana", "extensions": ["dssc"] },
  "application/dssc+xml": { "source": "iana", "compressible": true, "extensions": ["xdssc"] },
  "application/dvcs": { "source": "iana" },
  "application/eat+cwt": { "source": "iana" },
  "application/eat+jwt": { "source": "iana" },
  "application/eat-bun+cbor": { "source": "iana" },
  "application/eat-bun+json": { "source": "iana", "compressible": true },
  "application/eat-ucs+cbor": { "source": "iana" },
  "application/eat-ucs+json": { "source": "iana", "compressible": true },
  "application/ecmascript": { "source": "apache", "compressible": true, "extensions": ["ecma"] },
  "application/edhoc+cbor-seq": { "source": "iana" },
  "application/edi-consent": { "source": "iana" },
  "application/edi-x12": { "source": "iana", "compressible": false },
  "application/edifact": { "source": "iana", "compressible": false },
  "application/efi": { "source": "iana" },
  "application/elm+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/elm+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.cap+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/emergencycalldata.comment+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.control+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.deviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.ecall.msd": { "source": "iana" },
  "application/emergencycalldata.legacyesn+json": { "source": "iana", "compressible": true },
  "application/emergencycalldata.providerinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.serviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.subscriberinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.veds+xml": { "source": "iana", "compressible": true },
  "application/emma+xml": { "source": "iana", "compressible": true, "extensions": ["emma"] },
  "application/emotionml+xml": { "source": "iana", "compressible": true, "extensions": ["emotionml"] },
  "application/encaprtp": { "source": "iana" },
  "application/entity-statement+jwt": { "source": "iana" },
  "application/epp+xml": { "source": "iana", "compressible": true },
  "application/epub+zip": { "source": "iana", "compressible": false, "extensions": ["epub"] },
  "application/eshop": { "source": "iana" },
  "application/exi": { "source": "iana", "extensions": ["exi"] },
  "application/expect-ct-report+json": { "source": "iana", "compressible": true },
  "application/express": { "source": "iana", "extensions": ["exp"] },
  "application/fastinfoset": { "source": "iana" },
  "application/fastsoap": { "source": "iana" },
  "application/fdf": { "source": "iana", "extensions": ["fdf"] },
  "application/fdt+xml": { "source": "iana", "compressible": true, "extensions": ["fdt"] },
  "application/fhir+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fhir+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fido.trusted-apps+json": { "compressible": true },
  "application/fits": { "source": "iana" },
  "application/flexfec": { "source": "iana" },
  "application/font-sfnt": { "source": "iana" },
  "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] },
  "application/font-woff": { "source": "iana", "compressible": false },
  "application/framework-attributes+xml": { "source": "iana", "compressible": true },
  "application/geo+json": { "source": "iana", "compressible": true, "extensions": ["geojson"] },
  "application/geo+json-seq": { "source": "iana" },
  "application/geopackage+sqlite3": { "source": "iana" },
  "application/geopose+json": { "source": "iana", "compressible": true },
  "application/geoxacml+json": { "source": "iana", "compressible": true },
  "application/geoxacml+xml": { "source": "iana", "compressible": true },
  "application/gltf-buffer": { "source": "iana" },
  "application/gml+xml": { "source": "iana", "compressible": true, "extensions": ["gml"] },
  "application/gnap-binding-jws": { "source": "iana" },
  "application/gnap-binding-jwsd": { "source": "iana" },
  "application/gnap-binding-rotation-jws": { "source": "iana" },
  "application/gnap-binding-rotation-jwsd": { "source": "iana" },
  "application/gpx+xml": { "source": "apache", "compressible": true, "extensions": ["gpx"] },
  "application/grib": { "source": "iana" },
  "application/gxf": { "source": "apache", "extensions": ["gxf"] },
  "application/gzip": { "source": "iana", "compressible": false, "extensions": ["gz"] },
  "application/h224": { "source": "iana" },
  "application/held+xml": { "source": "iana", "compressible": true },
  "application/hjson": { "extensions": ["hjson"] },
  "application/hl7v2+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/http": { "source": "iana" },
  "application/hyperstudio": { "source": "iana", "extensions": ["stk"] },
  "application/ibe-key-request+xml": { "source": "iana", "compressible": true },
  "application/ibe-pkg-reply+xml": { "source": "iana", "compressible": true },
  "application/ibe-pp-data": { "source": "iana" },
  "application/iges": { "source": "iana" },
  "application/im-iscomposing+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/index": { "source": "iana" },
  "application/index.cmd": { "source": "iana" },
  "application/index.obj": { "source": "iana" },
  "application/index.response": { "source": "iana" },
  "application/index.vnd": { "source": "iana" },
  "application/inkml+xml": { "source": "iana", "compressible": true, "extensions": ["ink", "inkml"] },
  "application/iotp": { "source": "iana" },
  "application/ipfix": { "source": "iana", "extensions": ["ipfix"] },
  "application/ipp": { "source": "iana" },
  "application/isup": { "source": "iana" },
  "application/its+xml": { "source": "iana", "compressible": true, "extensions": ["its"] },
  "application/java-archive": { "source": "iana", "compressible": false, "extensions": ["jar", "war", "ear"] },
  "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] },
  "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] },
  "application/javascript": { "source": "apache", "charset": "UTF-8", "compressible": true, "extensions": ["js"] },
  "application/jf2feed+json": { "source": "iana", "compressible": true },
  "application/jose": { "source": "iana" },
  "application/jose+json": { "source": "iana", "compressible": true },
  "application/jrd+json": { "source": "iana", "compressible": true },
  "application/jscalendar+json": { "source": "iana", "compressible": true },
  "application/jscontact+json": { "source": "iana", "compressible": true },
  "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] },
  "application/json-patch+json": { "source": "iana", "compressible": true },
  "application/json-seq": { "source": "iana" },
  "application/json5": { "extensions": ["json5"] },
  "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] },
  "application/jsonpath": { "source": "iana" },
  "application/jwk+json": { "source": "iana", "compressible": true },
  "application/jwk-set+json": { "source": "iana", "compressible": true },
  "application/jwk-set+jwt": { "source": "iana" },
  "application/jwt": { "source": "iana" },
  "application/kpml-request+xml": { "source": "iana", "compressible": true },
  "application/kpml-response+xml": { "source": "iana", "compressible": true },
  "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] },
  "application/lgr+xml": { "source": "iana", "compressible": true, "extensions": ["lgr"] },
  "application/link-format": { "source": "iana" },
  "application/linkset": { "source": "iana" },
  "application/linkset+json": { "source": "iana", "compressible": true },
  "application/load-control+xml": { "source": "iana", "compressible": true },
  "application/logout+jwt": { "source": "iana" },
  "application/lost+xml": { "source": "iana", "compressible": true, "extensions": ["lostxml"] },
  "application/lostsync+xml": { "source": "iana", "compressible": true },
  "application/lpf+zip": { "source": "iana", "compressible": false },
  "application/lxf": { "source": "iana" },
  "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] },
  "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] },
  "application/macwriteii": { "source": "iana" },
  "application/mads+xml": { "source": "iana", "compressible": true, "extensions": ["mads"] },
  "application/manifest+json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] },
  "application/marc": { "source": "iana", "extensions": ["mrc"] },
  "application/marcxml+xml": { "source": "iana", "compressible": true, "extensions": ["mrcx"] },
  "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] },
  "application/mathml+xml": { "source": "iana", "compressible": true, "extensions": ["mathml"] },
  "application/mathml-content+xml": { "source": "iana", "compressible": true },
  "application/mathml-presentation+xml": { "source": "iana", "compressible": true },
  "application/mbms-associated-procedure-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-deregister+xml": { "source": "iana", "compressible": true },
  "application/mbms-envelope+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-protection-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-reception-report+xml": { "source": "iana", "compressible": true },
  "application/mbms-register+xml": { "source": "iana", "compressible": true },
  "application/mbms-register-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-schedule+xml": { "source": "iana", "compressible": true },
  "application/mbms-user-service-description+xml": { "source": "iana", "compressible": true },
  "application/mbox": { "source": "iana", "extensions": ["mbox"] },
  "application/media-policy-dataset+xml": { "source": "iana", "compressible": true, "extensions": ["mpf"] },
  "application/media_control+xml": { "source": "iana", "compressible": true },
  "application/mediaservercontrol+xml": { "source": "iana", "compressible": true, "extensions": ["mscml"] },
  "application/merge-patch+json": { "source": "iana", "compressible": true },
  "application/metalink+xml": { "source": "apache", "compressible": true, "extensions": ["metalink"] },
  "application/metalink4+xml": { "source": "iana", "compressible": true, "extensions": ["meta4"] },
  "application/mets+xml": { "source": "iana", "compressible": true, "extensions": ["mets"] },
  "application/mf4": { "source": "iana" },
  "application/mikey": { "source": "iana" },
  "application/mipc": { "source": "iana" },
  "application/missing-blocks+cbor-seq": { "source": "iana" },
  "application/mmt-aei+xml": { "source": "iana", "compressible": true, "extensions": ["maei"] },
  "application/mmt-usd+xml": { "source": "iana", "compressible": true, "extensions": ["musd"] },
  "application/mods+xml": { "source": "iana", "compressible": true, "extensions": ["mods"] },
  "application/moss-keys": { "source": "iana" },
  "application/moss-signature": { "source": "iana" },
  "application/mosskey-data": { "source": "iana" },
  "application/mosskey-request": { "source": "iana" },
  "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] },
  "application/mp4": { "source": "iana", "extensions": ["mp4", "mpg4", "mp4s", "m4p"] },
  "application/mpeg4-generic": { "source": "iana" },
  "application/mpeg4-iod": { "source": "iana" },
  "application/mpeg4-iod-xmt": { "source": "iana" },
  "application/mrb-consumer+xml": { "source": "iana", "compressible": true },
  "application/mrb-publish+xml": { "source": "iana", "compressible": true },
  "application/msc-ivr+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msc-mixer+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msix": { "compressible": false, "extensions": ["msix"] },
  "application/msixbundle": { "compressible": false, "extensions": ["msixbundle"] },
  "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] },
  "application/mud+json": { "source": "iana", "compressible": true },
  "application/multipart-core": { "source": "iana" },
  "application/mxf": { "source": "iana", "extensions": ["mxf"] },
  "application/n-quads": { "source": "iana", "extensions": ["nq"] },
  "application/n-triples": { "source": "iana", "extensions": ["nt"] },
  "application/nasdata": { "source": "iana" },
  "application/news-checkgroups": { "source": "iana", "charset": "US-ASCII" },
  "application/news-groupinfo": { "source": "iana", "charset": "US-ASCII" },
  "application/news-transmission": { "source": "iana" },
  "application/nlsml+xml": { "source": "iana", "compressible": true },
  "application/node": { "source": "iana", "extensions": ["cjs"] },
  "application/nss": { "source": "iana" },
  "application/oauth-authz-req+jwt": { "source": "iana" },
  "application/oblivious-dns-message": { "source": "iana" },
  "application/ocsp-request": { "source": "iana" },
  "application/ocsp-response": { "source": "iana" },
  "application/octet-stream": { "source": "iana", "compressible": true, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { "source": "iana", "extensions": ["oda"] },
  "application/odm+xml": { "source": "iana", "compressible": true },
  "application/odx": { "source": "iana" },
  "application/oebps-package+xml": { "source": "iana", "compressible": true, "extensions": ["opf"] },
  "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] },
  "application/ohttp-keys": { "source": "iana" },
  "application/omdoc+xml": { "source": "apache", "compressible": true, "extensions": ["omdoc"] },
  "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg", "one", "onea"] },
  "application/opc-nodeset+xml": { "source": "iana", "compressible": true },
  "application/oscore": { "source": "iana" },
  "application/oxps": { "source": "iana", "extensions": ["oxps"] },
  "application/p21": { "source": "iana" },
  "application/p21+zip": { "source": "iana", "compressible": false },
  "application/p2p-overlay+xml": { "source": "iana", "compressible": true, "extensions": ["relo"] },
  "application/parityfec": { "source": "iana" },
  "application/passport": { "source": "iana" },
  "application/patch-ops-error+xml": { "source": "iana", "compressible": true, "extensions": ["xer"] },
  "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] },
  "application/pdx": { "source": "iana" },
  "application/pem-certificate-chain": { "source": "iana" },
  "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] },
  "application/pgp-keys": { "source": "iana", "extensions": ["asc"] },
  "application/pgp-signature": { "source": "iana", "extensions": ["sig", "asc"] },
  "application/pics-rules": { "source": "apache", "extensions": ["prf"] },
  "application/pidf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pidf-diff+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pkcs10": { "source": "iana", "extensions": ["p10"] },
  "application/pkcs12": { "source": "iana" },
  "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] },
  "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] },
  "application/pkcs8": { "source": "iana", "extensions": ["p8"] },
  "application/pkcs8-encrypted": { "source": "iana" },
  "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] },
  "application/pkix-cert": { "source": "iana", "extensions": ["cer"] },
  "application/pkix-crl": { "source": "iana", "extensions": ["crl"] },
  "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] },
  "application/pkixcmp": { "source": "iana", "extensions": ["pki"] },
  "application/pls+xml": { "source": "iana", "compressible": true, "extensions": ["pls"] },
  "application/poc-settings+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { "source": "iana", "compressible": true },
  "application/private-token-issuer-directory": { "source": "iana" },
  "application/private-token-request": { "source": "iana" },
  "application/private-token-response": { "source": "iana" },
  "application/problem+json": { "source": "iana", "compressible": true },
  "application/problem+xml": { "source": "iana", "compressible": true },
  "application/provenance+xml": { "source": "iana", "compressible": true, "extensions": ["provx"] },
  "application/provided-claims+jwt": { "source": "iana" },
  "application/prs.alvestrand.titrax-sheet": { "source": "iana" },
  "application/prs.cww": { "source": "iana", "extensions": ["cww"] },
  "application/prs.cyn": { "source": "iana", "charset": "7-BIT" },
  "application/prs.hpub+zip": { "source": "iana", "compressible": false },
  "application/prs.implied-document+xml": { "source": "iana", "compressible": true },
  "application/prs.implied-executable": { "source": "iana" },
  "application/prs.implied-object+json": { "source": "iana", "compressible": true },
  "application/prs.implied-object+json-seq": { "source": "iana" },
  "application/prs.implied-object+yaml": { "source": "iana" },
  "application/prs.implied-structure": { "source": "iana" },
  "application/prs.mayfile": { "source": "iana" },
  "application/prs.nprend": { "source": "iana" },
  "application/prs.plucker": { "source": "iana" },
  "application/prs.rdf-xml-crypt": { "source": "iana" },
  "application/prs.vcfbzip2": { "source": "iana" },
  "application/prs.xsf+xml": { "source": "iana", "compressible": true, "extensions": ["xsf"] },
  "application/pskc+xml": { "source": "iana", "compressible": true, "extensions": ["pskcxml"] },
  "application/pvd+json": { "source": "iana", "compressible": true },
  "application/qsig": { "source": "iana" },
  "application/raml+yaml": { "compressible": true, "extensions": ["raml"] },
  "application/raptorfec": { "source": "iana" },
  "application/rdap+json": { "source": "iana", "compressible": true },
  "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf", "owl"] },
  "application/reginfo+xml": { "source": "iana", "compressible": true, "extensions": ["rif"] },
  "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] },
  "application/remote-printing": { "source": "apache" },
  "application/reputon+json": { "source": "iana", "compressible": true },
  "application/resolve-response+jwt": { "source": "iana" },
  "application/resource-lists+xml": { "source": "iana", "compressible": true, "extensions": ["rl"] },
  "application/resource-lists-diff+xml": { "source": "iana", "compressible": true, "extensions": ["rld"] },
  "application/rfc+xml": { "source": "iana", "compressible": true },
  "application/riscos": { "source": "iana" },
  "application/rlmi+xml": { "source": "iana", "compressible": true },
  "application/rls-services+xml": { "source": "iana", "compressible": true, "extensions": ["rs"] },
  "application/route-apd+xml": { "source": "iana", "compressible": true, "extensions": ["rapd"] },
  "application/route-s-tsid+xml": { "source": "iana", "compressible": true, "extensions": ["sls"] },
  "application/route-usd+xml": { "source": "iana", "compressible": true, "extensions": ["rusd"] },
  "application/rpki-checklist": { "source": "iana" },
  "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] },
  "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] },
  "application/rpki-publication": { "source": "iana" },
  "application/rpki-roa": { "source": "iana", "extensions": ["roa"] },
  "application/rpki-signed-tal": { "source": "iana" },
  "application/rpki-updown": { "source": "iana" },
  "application/rsd+xml": { "source": "apache", "compressible": true, "extensions": ["rsd"] },
  "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] },
  "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "application/rtploopback": { "source": "iana" },
  "application/rtx": { "source": "iana" },
  "application/samlassertion+xml": { "source": "iana", "compressible": true },
  "application/samlmetadata+xml": { "source": "iana", "compressible": true },
  "application/sarif+json": { "source": "iana", "compressible": true },
  "application/sarif-external-properties+json": { "source": "iana", "compressible": true },
  "application/sbe": { "source": "iana" },
  "application/sbml+xml": { "source": "iana", "compressible": true, "extensions": ["sbml"] },
  "application/scaip+xml": { "source": "iana", "compressible": true },
  "application/scim+json": { "source": "iana", "compressible": true },
  "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] },
  "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] },
  "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] },
  "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] },
  "application/sdp": { "source": "iana", "extensions": ["sdp"] },
  "application/secevent+jwt": { "source": "iana" },
  "application/senml+cbor": { "source": "iana" },
  "application/senml+json": { "source": "iana", "compressible": true },
  "application/senml+xml": { "source": "iana", "compressible": true, "extensions": ["senmlx"] },
  "application/senml-etch+cbor": { "source": "iana" },
  "application/senml-etch+json": { "source": "iana", "compressible": true },
  "application/senml-exi": { "source": "iana" },
  "application/sensml+cbor": { "source": "iana" },
  "application/sensml+json": { "source": "iana", "compressible": true },
  "application/sensml+xml": { "source": "iana", "compressible": true, "extensions": ["sensmlx"] },
  "application/sensml-exi": { "source": "iana" },
  "application/sep+xml": { "source": "iana", "compressible": true },
  "application/sep-exi": { "source": "iana" },
  "application/session-info": { "source": "iana" },
  "application/set-payment": { "source": "iana" },
  "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] },
  "application/set-registration": { "source": "iana" },
  "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] },
  "application/sgml": { "source": "iana" },
  "application/sgml-open-catalog": { "source": "iana" },
  "application/shf+xml": { "source": "iana", "compressible": true, "extensions": ["shf"] },
  "application/sieve": { "source": "iana", "extensions": ["siv", "sieve"] },
  "application/simple-filter+xml": { "source": "iana", "compressible": true },
  "application/simple-message-summary": { "source": "iana" },
  "application/simplesymbolcontainer": { "source": "iana" },
  "application/sipc": { "source": "iana" },
  "application/slate": { "source": "iana" },
  "application/smil": { "source": "apache" },
  "application/smil+xml": { "source": "iana", "compressible": true, "extensions": ["smi", "smil"] },
  "application/smpte336m": { "source": "iana" },
  "application/soap+fastinfoset": { "source": "iana" },
  "application/soap+xml": { "source": "iana", "compressible": true },
  "application/sparql-query": { "source": "iana", "extensions": ["rq"] },
  "application/sparql-results+xml": { "source": "iana", "compressible": true, "extensions": ["srx"] },
  "application/spdx+json": { "source": "iana", "compressible": true },
  "application/spirits-event+xml": { "source": "iana", "compressible": true },
  "application/sql": { "source": "iana", "extensions": ["sql"] },
  "application/srgs": { "source": "iana", "extensions": ["gram"] },
  "application/srgs+xml": { "source": "iana", "compressible": true, "extensions": ["grxml"] },
  "application/sru+xml": { "source": "iana", "compressible": true, "extensions": ["sru"] },
  "application/ssdl+xml": { "source": "apache", "compressible": true, "extensions": ["ssdl"] },
  "application/sslkeylogfile": { "source": "iana" },
  "application/ssml+xml": { "source": "iana", "compressible": true, "extensions": ["ssml"] },
  "application/st2110-41": { "source": "iana" },
  "application/stix+json": { "source": "iana", "compressible": true },
  "application/stratum": { "source": "iana" },
  "application/swid+cbor": { "source": "iana" },
  "application/swid+xml": { "source": "iana", "compressible": true, "extensions": ["swidtag"] },
  "application/tamp-apex-update": { "source": "iana" },
  "application/tamp-apex-update-confirm": { "source": "iana" },
  "application/tamp-community-update": { "source": "iana" },
  "application/tamp-community-update-confirm": { "source": "iana" },
  "application/tamp-error": { "source": "iana" },
  "application/tamp-sequence-adjust": { "source": "iana" },
  "application/tamp-sequence-adjust-confirm": { "source": "iana" },
  "application/tamp-status-query": { "source": "iana" },
  "application/tamp-status-response": { "source": "iana" },
  "application/tamp-update": { "source": "iana" },
  "application/tamp-update-confirm": { "source": "iana" },
  "application/tar": { "compressible": true },
  "application/taxii+json": { "source": "iana", "compressible": true },
  "application/td+json": { "source": "iana", "compressible": true },
  "application/tei+xml": { "source": "iana", "compressible": true, "extensions": ["tei", "teicorpus"] },
  "application/tetra_isi": { "source": "iana" },
  "application/thraud+xml": { "source": "iana", "compressible": true, "extensions": ["tfi"] },
  "application/timestamp-query": { "source": "iana" },
  "application/timestamp-reply": { "source": "iana" },
  "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] },
  "application/tlsrpt+gzip": { "source": "iana" },
  "application/tlsrpt+json": { "source": "iana", "compressible": true },
  "application/tm+json": { "source": "iana", "compressible": true },
  "application/tnauthlist": { "source": "iana" },
  "application/toc+cbor": { "source": "iana" },
  "application/token-introspection+jwt": { "source": "iana" },
  "application/toml": { "source": "iana", "compressible": true, "extensions": ["toml"] },
  "application/trickle-ice-sdpfrag": { "source": "iana" },
  "application/trig": { "source": "iana", "extensions": ["trig"] },
  "application/trust-chain+json": { "source": "iana", "compressible": true },
  "application/trust-mark+jwt": { "source": "iana" },
  "application/trust-mark-delegation+jwt": { "source": "iana" },
  "application/ttml+xml": { "source": "iana", "compressible": true, "extensions": ["ttml"] },
  "application/tve-trigger": { "source": "iana" },
  "application/tzif": { "source": "iana" },
  "application/tzif-leap": { "source": "iana" },
  "application/ubjson": { "compressible": false, "extensions": ["ubj"] },
  "application/uccs+cbor": { "source": "iana" },
  "application/ujcs+json": { "source": "iana", "compressible": true },
  "application/ulpfec": { "source": "iana" },
  "application/urc-grpsheet+xml": { "source": "iana", "compressible": true },
  "application/urc-ressheet+xml": { "source": "iana", "compressible": true, "extensions": ["rsheet"] },
  "application/urc-targetdesc+xml": { "source": "iana", "compressible": true, "extensions": ["td"] },
  "application/urc-uisocketdesc+xml": { "source": "iana", "compressible": true },
  "application/vc": { "source": "iana" },
  "application/vc+cose": { "source": "iana" },
  "application/vc+jwt": { "source": "iana" },
  "application/vcard+json": { "source": "iana", "compressible": true },
  "application/vcard+xml": { "source": "iana", "compressible": true },
  "application/vemmi": { "source": "iana" },
  "application/vividence.scriptfile": { "source": "apache" },
  "application/vnd.1000minds.decision-model+xml": { "source": "iana", "compressible": true, "extensions": ["1km"] },
  "application/vnd.1ob": { "source": "iana" },
  "application/vnd.3gpp-prose+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3a+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ach+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc8+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gnas": { "source": "iana" },
  "application/vnd.3gpp.5gsa2x": { "source": "iana" },
  "application/vnd.3gpp.5gsa2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gsv2x": { "source": "iana" },
  "application/vnd.3gpp.5gsv2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.bsf+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.crs+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.current-location-discovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gmop+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gtpc": { "source": "iana" },
  "application/vnd.3gpp.interworking-data": { "source": "iana" },
  "application/vnd.3gpp.lpp": { "source": "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-msgstore-ctrl-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-payload": { "source": "iana" },
  "application/vnd.3gpp.mcdata-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-floor-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-signed+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-regroup+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mid-call+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ngap": { "source": "iana" },
  "application/vnd.3gpp.pfcp": { "source": "iana" },
  "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] },
  "application/vnd.3gpp.pinapp-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.s1ap": { "source": "iana" },
  "application/vnd.3gpp.seal-group-doc+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-network-qos-management-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-ue-config-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-unicast-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.seal-user-profile-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.sms": { "source": "iana" },
  "application/vnd.3gpp.sms+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ussd+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.v2x": { "source": "iana" },
  "application/vnd.3gpp.vae-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.sms": { "source": "iana" },
  "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { "source": "iana" },
  "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] },
  "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] },
  "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] },
  "application/vnd.acm.addressxfer+json": { "source": "iana", "compressible": true },
  "application/vnd.acm.chatbot+json": { "source": "iana", "compressible": true },
  "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] },
  "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "compressible": false, "extensions": ["air"] },
  "application/vnd.adobe.flash.movie": { "source": "iana" },
  "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] },
  "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { "source": "iana" },
  "application/vnd.adobe.xdp+xml": { "source": "iana", "compressible": true, "extensions": ["xdp"] },
  "application/vnd.adobe.xfdf": { "source": "apache", "extensions": ["xfdf"] },
  "application/vnd.aether.imp": { "source": "iana" },
  "application/vnd.afpc.afplinedata": { "source": "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
  "application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
  "application/vnd.afpc.foca-charset": { "source": "iana" },
  "application/vnd.afpc.foca-codedfont": { "source": "iana" },
  "application/vnd.afpc.foca-codepage": { "source": "iana" },
  "application/vnd.afpc.modca": { "source": "iana" },
  "application/vnd.afpc.modca-cmtable": { "source": "iana" },
  "application/vnd.afpc.modca-formdef": { "source": "iana" },
  "application/vnd.afpc.modca-mediummap": { "source": "iana" },
  "application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
  "application/vnd.afpc.modca-overlay": { "source": "iana" },
  "application/vnd.afpc.modca-pagesegment": { "source": "iana" },
  "application/vnd.age": { "source": "iana", "extensions": ["age"] },
  "application/vnd.ah-barcode": { "source": "apache" },
  "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] },
  "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] },
  "application/vnd.amadeus+json": { "source": "iana", "compressible": true },
  "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { "source": "iana" },
  "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] },
  "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] },
  "application/vnd.amundsen.maze+xml": { "source": "iana", "compressible": true },
  "application/vnd.android.ota": { "source": "iana" },
  "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] },
  "application/vnd.anki": { "source": "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] },
  "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] },
  "application/vnd.apache.arrow.file": { "source": "iana" },
  "application/vnd.apache.arrow.stream": { "source": "iana" },
  "application/vnd.apache.parquet": { "source": "iana" },
  "application/vnd.apache.thrift.binary": { "source": "iana" },
  "application/vnd.apache.thrift.compact": { "source": "iana" },
  "application/vnd.apache.thrift.json": { "source": "iana" },
  "application/vnd.apexlang": { "source": "iana" },
  "application/vnd.api+json": { "source": "iana", "compressible": true },
  "application/vnd.aplextor.warrp+json": { "source": "iana", "compressible": true },
  "application/vnd.apothekende.reservation+json": { "source": "iana", "compressible": true },
  "application/vnd.apple.installer+xml": { "source": "iana", "compressible": true, "extensions": ["mpkg"] },
  "application/vnd.apple.keynote": { "source": "iana", "extensions": ["key"] },
  "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] },
  "application/vnd.apple.numbers": { "source": "iana", "extensions": ["numbers"] },
  "application/vnd.apple.pages": { "source": "iana", "extensions": ["pages"] },
  "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] },
  "application/vnd.arastra.swi": { "source": "apache" },
  "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] },
  "application/vnd.artisan+json": { "source": "iana", "compressible": true },
  "application/vnd.artsquare": { "source": "iana" },
  "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] },
  "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] },
  "application/vnd.autodesk.fbx": { "extensions": ["fbx"] },
  "application/vnd.autopackage": { "source": "iana" },
  "application/vnd.avalon+json": { "source": "iana", "compressible": true },
  "application/vnd.avistar+xml": { "source": "iana", "compressible": true },
  "application/vnd.balsamiq.bmml+xml": { "source": "iana", "compressible": true, "extensions": ["bmml"] },
  "application/vnd.balsamiq.bmpr": { "source": "iana" },
  "application/vnd.banana-accounting": { "source": "iana" },
  "application/vnd.bbf.usp.error": { "source": "iana" },
  "application/vnd.bbf.usp.msg": { "source": "iana" },
  "application/vnd.bbf.usp.msg+json": { "source": "iana", "compressible": true },
  "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true },
  "application/vnd.belightsoft.lhzd+zip": { "source": "iana", "compressible": false },
  "application/vnd.belightsoft.lhzl+zip": { "source": "iana", "compressible": false },
  "application/vnd.bint.med-content": { "source": "iana" },
  "application/vnd.biopax.rdf+xml": { "source": "iana", "compressible": true },
  "application/vnd.blink-idb-value-wrapper": { "source": "iana" },
  "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { "source": "iana" },
  "application/vnd.bluetooth.le.oob": { "source": "iana" },
  "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] },
  "application/vnd.bpf": { "source": "iana" },
  "application/vnd.bpf3": { "source": "iana" },
  "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] },
  "application/vnd.byu.uapi+json": { "source": "iana", "compressible": true },
  "application/vnd.bzip3": { "source": "iana" },
  "application/vnd.c3voc.schedule+xml": { "source": "iana", "compressible": true },
  "application/vnd.cab-jscript": { "source": "iana" },
  "application/vnd.canon-cpdl": { "source": "iana" },
  "application/vnd.canon-lips": { "source": "iana" },
  "application/vnd.capasystems-pg+json": { "source": "iana", "compressible": true },
  "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
  "application/vnd.century-systems.tcp_stream": { "source": "iana" },
  "application/vnd.chemdraw+xml": { "source": "iana", "compressible": true, "extensions": ["cdxml"] },
  "application/vnd.chess-pgn": { "source": "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] },
  "application/vnd.ciedi": { "source": "iana" },
  "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { "source": "iana" },
  "application/vnd.citationstyles.style+xml": { "source": "iana", "compressible": true, "extensions": ["csl"] },
  "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] },
  "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] },
  "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] },
  "application/vnd.cncf.helm.chart.content.v1.tar+gzip": { "source": "iana" },
  "application/vnd.cncf.helm.chart.provenance.v1.prov": { "source": "iana" },
  "application/vnd.cncf.helm.config.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.coffeescript": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
  "application/vnd.collection+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.doc+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.next+json": { "source": "iana", "compressible": true },
  "application/vnd.comicbook+zip": { "source": "iana", "compressible": false },
  "application/vnd.comicbook-rar": { "source": "iana" },
  "application/vnd.commerce-battelle": { "source": "iana" },
  "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] },
  "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true },
  "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] },
  "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] },
  "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] },
  "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { "source": "iana", "compressible": true, "extensions": ["wbs"] },
  "application/vnd.cryptii.pipe+json": { "source": "iana", "compressible": true },
  "application/vnd.crypto-shade-file": { "source": "iana" },
  "application/vnd.cryptomator.encrypted": { "source": "iana" },
  "application/vnd.cryptomator.vault": { "source": "iana" },
  "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] },
  "application/vnd.ctct.ws+xml": { "source": "iana", "compressible": true },
  "application/vnd.cups-pdf": { "source": "iana" },
  "application/vnd.cups-postscript": { "source": "iana" },
  "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] },
  "application/vnd.cups-raster": { "source": "iana" },
  "application/vnd.cups-raw": { "source": "iana" },
  "application/vnd.curl": { "source": "iana" },
  "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] },
  "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { "source": "iana", "compressible": true },
  "application/vnd.cybank": { "source": "iana" },
  "application/vnd.cyclonedx+json": { "source": "iana", "compressible": true },
  "application/vnd.cyclonedx+xml": { "source": "iana", "compressible": true },
  "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana", "compressible": false },
  "application/vnd.d3m-dataset": { "source": "iana" },
  "application/vnd.d3m-problem": { "source": "iana" },
  "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] },
  "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] },
  "application/vnd.datalog": { "source": "iana" },
  "application/vnd.datapackage+json": { "source": "iana", "compressible": true },
  "application/vnd.dataresource+json": { "source": "iana", "compressible": true },
  "application/vnd.dbf": { "source": "iana", "extensions": ["dbf"] },
  "application/vnd.dcmp+xml": { "source": "iana", "compressible": true, "extensions": ["dcmp"] },
  "application/vnd.debian.binary-package": { "source": "iana" },
  "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { "source": "iana", "compressible": true, "extensions": ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] },
  "application/vnd.desmume.movie": { "source": "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
  "application/vnd.dm.delegation+xml": { "source": "iana", "compressible": true },
  "application/vnd.dna": { "source": "iana", "extensions": ["dna"] },
  "application/vnd.document+json": { "source": "iana", "compressible": true },
  "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] },
  "application/vnd.dolby.mobile.1": { "source": "iana" },
  "application/vnd.dolby.mobile.2": { "source": "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
  "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] },
  "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] },
  "application/vnd.drive+json": { "source": "iana", "compressible": true },
  "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] },
  "application/vnd.dtg.local": { "source": "iana" },
  "application/vnd.dtg.local.flash": { "source": "iana" },
  "application/vnd.dtg.local.html": { "source": "iana" },
  "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.dvbj": { "source": "iana" },
  "application/vnd.dvb.esgcontainer": { "source": "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
  "application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
  "application/vnd.dvb.ipdcroaming": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-container+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-generic+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-init+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.pfr": { "source": "iana" },
  "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] },
  "application/vnd.dxr": { "source": "iana" },
  "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] },
  "application/vnd.dzr": { "source": "iana" },
  "application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
  "application/vnd.ecdis-update": { "source": "iana" },
  "application/vnd.ecip.rlp": { "source": "iana" },
  "application/vnd.eclipse.ditto+json": { "source": "iana", "compressible": true },
  "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] },
  "application/vnd.ecowin.filerequest": { "source": "iana" },
  "application/vnd.ecowin.fileupdate": { "source": "iana" },
  "application/vnd.ecowin.series": { "source": "iana" },
  "application/vnd.ecowin.seriesrequest": { "source": "iana" },
  "application/vnd.ecowin.seriesupdate": { "source": "iana" },
  "application/vnd.efi.img": { "source": "iana" },
  "application/vnd.efi.iso": { "source": "iana" },
  "application/vnd.eln+zip": { "source": "iana", "compressible": false },
  "application/vnd.emclient.accessrequest+xml": { "source": "iana", "compressible": true },
  "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] },
  "application/vnd.enphase.envoy": { "source": "iana" },
  "application/vnd.eprints.data+xml": { "source": "iana", "compressible": true },
  "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] },
  "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] },
  "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] },
  "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] },
  "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] },
  "application/vnd.ericsson.quickcall": { "source": "iana" },
  "application/vnd.erofs": { "source": "iana" },
  "application/vnd.espass-espass+zip": { "source": "iana", "compressible": false },
  "application/vnd.eszigno3+xml": { "source": "iana", "compressible": true, "extensions": ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.asic-e+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.asic-s+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.cug+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvcommand+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvservice+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsync+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mcid+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mheg5": { "source": "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.pstn+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.sci+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.simservs+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.timestamp-token": { "source": "iana" },
  "application/vnd.etsi.tsl+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.tsl.der": { "source": "iana" },
  "application/vnd.eu.kasparian.car+json": { "source": "iana", "compressible": true },
  "application/vnd.eudora.data": { "source": "iana" },
  "application/vnd.evolv.ecig.profile": { "source": "iana" },
  "application/vnd.evolv.ecig.settings": { "source": "iana" },
  "application/vnd.evolv.ecig.theme": { "source": "iana" },
  "application/vnd.exstream-empower+zip": { "source": "iana", "compressible": false },
  "application/vnd.exstream-package": { "source": "iana" },
  "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] },
  "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] },
  "application/vnd.f-secure.mobile": { "source": "iana" },
  "application/vnd.familysearch.gedcom+zip": { "source": "iana", "compressible": false },
  "application/vnd.fastcopy-disk-image": { "source": "iana" },
  "application/vnd.fdf": { "source": "apache", "extensions": ["fdf"] },
  "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] },
  "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] },
  "application/vnd.fdsn.stationxml+xml": { "source": "iana", "charset": "XML-BASED", "compressible": true },
  "application/vnd.ffsns": { "source": "iana" },
  "application/vnd.ficlab.flb+zip": { "source": "iana", "compressible": false },
  "application/vnd.filmit.zfc": { "source": "iana" },
  "application/vnd.fints": { "source": "iana" },
  "application/vnd.firemonkeys.cloudcell": { "source": "iana" },
  "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] },
  "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] },
  "application/vnd.font-fontforge-sfd": { "source": "iana" },
  "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] },
  "application/vnd.freelog.comic": { "source": "iana" },
  "application/vnd.frogans.fnc": { "source": "apache", "extensions": ["fnc"] },
  "application/vnd.frogans.ltf": { "source": "apache", "extensions": ["ltf"] },
  "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { "source": "iana", "compressible": true },
  "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] },
  "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] },
  "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] },
  "application/vnd.fujixerox.art-ex": { "source": "iana" },
  "application/vnd.fujixerox.art4": { "source": "iana" },
  "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] },
  "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { "source": "iana" },
  "application/vnd.fujixerox.hbpl": { "source": "iana" },
  "application/vnd.fut-misnet": { "source": "iana" },
  "application/vnd.futoin+cbor": { "source": "iana" },
  "application/vnd.futoin+json": { "source": "iana", "compressible": true },
  "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] },
  "application/vnd.ga4gh.passport+jwt": { "source": "iana" },
  "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] },
  "application/vnd.genozip": { "source": "iana" },
  "application/vnd.gentics.grd+json": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.catmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.ebuild": { "source": "iana" },
  "application/vnd.gentoo.eclass": { "source": "iana" },
  "application/vnd.gentoo.gpkg": { "source": "iana" },
  "application/vnd.gentoo.manifest": { "source": "iana" },
  "application/vnd.gentoo.pkgmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.gentoo.xpak": { "source": "iana" },
  "application/vnd.geo+json": { "source": "apache", "compressible": true },
  "application/vnd.geocube+xml": { "source": "apache", "compressible": true },
  "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] },
  "application/vnd.geogebra.pinboard": { "source": "iana" },
  "application/vnd.geogebra.slides": { "source": "iana", "extensions": ["ggs"] },
  "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] },
  "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] },
  "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] },
  "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] },
  "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] },
  "application/vnd.gerber": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
  "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] },
  "application/vnd.gnu.taler.exchange+json": { "source": "iana", "compressible": true },
  "application/vnd.gnu.taler.merchant+json": { "source": "iana", "compressible": true },
  "application/vnd.google-apps.audio": {},
  "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] },
  "application/vnd.google-apps.drawing": { "compressible": false, "extensions": ["gdraw"] },
  "application/vnd.google-apps.drive-sdk": { "compressible": false },
  "application/vnd.google-apps.file": {},
  "application/vnd.google-apps.folder": { "compressible": false },
  "application/vnd.google-apps.form": { "compressible": false, "extensions": ["gform"] },
  "application/vnd.google-apps.fusiontable": {},
  "application/vnd.google-apps.jam": { "compressible": false, "extensions": ["gjam"] },
  "application/vnd.google-apps.mail-layout": {},
  "application/vnd.google-apps.map": { "compressible": false, "extensions": ["gmap"] },
  "application/vnd.google-apps.photo": {},
  "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] },
  "application/vnd.google-apps.script": { "compressible": false, "extensions": ["gscript"] },
  "application/vnd.google-apps.shortcut": {},
  "application/vnd.google-apps.site": { "compressible": false, "extensions": ["gsite"] },
  "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] },
  "application/vnd.google-apps.unknown": {},
  "application/vnd.google-apps.video": {},
  "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] },
  "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { "source": "apache", "compressible": true },
  "application/vnd.gov.sk.e-form+zip": { "source": "iana", "compressible": false },
  "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana", "compressible": true, "extensions": ["xdcf"] },
  "application/vnd.gpxsee.map+xml": { "source": "iana", "compressible": true },
  "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] },
  "application/vnd.gridmp": { "source": "iana" },
  "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] },
  "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] },
  "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] },
  "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] },
  "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] },
  "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] },
  "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] },
  "application/vnd.hal+json": { "source": "iana", "compressible": true },
  "application/vnd.hal+xml": { "source": "iana", "compressible": true, "extensions": ["hal"] },
  "application/vnd.handheld-entertainment+xml": { "source": "iana", "compressible": true, "extensions": ["zmm"] },
  "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] },
  "application/vnd.hc+json": { "source": "iana", "compressible": true },
  "application/vnd.hcl-bireports": { "source": "iana" },
  "application/vnd.hdt": { "source": "iana" },
  "application/vnd.heroku+json": { "source": "iana", "compressible": true },
  "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] },
  "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] },
  "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] },
  "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] },
  "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] },
  "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] },
  "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] },
  "application/vnd.hsl": { "source": "iana" },
  "application/vnd.httphone": { "source": "iana" },
  "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] },
  "application/vnd.hyper+json": { "source": "iana", "compressible": true },
  "application/vnd.hyper-item+json": { "source": "iana", "compressible": true },
  "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true },
  "application/vnd.hzn-3d-crossword": { "source": "iana" },
  "application/vnd.ibm.afplinedata": { "source": "apache" },
  "application/vnd.ibm.electronic-media": { "source": "iana" },
  "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] },
  "application/vnd.ibm.modcap": { "source": "apache", "extensions": ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] },
  "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] },
  "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] },
  "application/vnd.ieee.1905": { "source": "iana" },
  "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] },
  "application/vnd.imagemeter.folder+zip": { "source": "iana", "compressible": false },
  "application/vnd.imagemeter.image+zip": { "source": "iana", "compressible": false },
  "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] },
  "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] },
  "application/vnd.ims.imsccv1p1": { "source": "iana" },
  "application/vnd.ims.imsccv1p2": { "source": "iana" },
  "application/vnd.ims.imsccv1p3": { "source": "iana" },
  "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true },
  "application/vnd.informedcontrol.rms+xml": { "source": "iana", "compressible": true },
  "application/vnd.informix-visionary": { "source": "apache" },
  "application/vnd.infotech.project": { "source": "iana" },
  "application/vnd.infotech.project+xml": { "source": "iana", "compressible": true },
  "application/vnd.innopath.wamp.notification": { "source": "iana" },
  "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] },
  "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] },
  "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] },
  "application/vnd.intertrust.digibox": { "source": "iana" },
  "application/vnd.intertrust.nncp": { "source": "iana" },
  "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] },
  "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] },
  "application/vnd.ipfs.ipns-record": { "source": "iana" },
  "application/vnd.ipld.car": { "source": "iana" },
  "application/vnd.ipld.dag-cbor": { "source": "iana" },
  "application/vnd.ipld.dag-json": { "source": "iana" },
  "application/vnd.ipld.raw": { "source": "iana" },
  "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.packageitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.planningitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] },
  "application/vnd.irepository.package+xml": { "source": "iana", "compressible": true, "extensions": ["irp"] },
  "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] },
  "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] },
  "application/vnd.iso11783-10+zip": { "source": "iana", "compressible": false },
  "application/vnd.jam": { "source": "iana", "extensions": ["jam"] },
  "application/vnd.japannet-directory-service": { "source": "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-payment-wakeup": { "source": "iana" },
  "application/vnd.japannet-registration": { "source": "iana" },
  "application/vnd.japannet-registration-wakeup": { "source": "iana" },
  "application/vnd.japannet-setstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-verification": { "source": "iana" },
  "application/vnd.japannet-verification-wakeup": { "source": "iana" },
  "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] },
  "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] },
  "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] },
  "application/vnd.jsk.isdn-ngn": { "source": "iana" },
  "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] },
  "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] },
  "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] },
  "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] },
  "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] },
  "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] },
  "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] },
  "application/vnd.kdl": { "source": "iana" },
  "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] },
  "application/vnd.keyman.kmp+zip": { "source": "iana", "compressible": false },
  "application/vnd.keyman.kmx": { "source": "iana" },
  "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] },
  "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] },
  "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] },
  "application/vnd.las": { "source": "iana" },
  "application/vnd.las.las+json": { "source": "iana", "compressible": true },
  "application/vnd.las.las+xml": { "source": "iana", "compressible": true, "extensions": ["lasxml"] },
  "application/vnd.laszip": { "source": "iana" },
  "application/vnd.ldev.productlicensing": { "source": "iana" },
  "application/vnd.leap+json": { "source": "iana", "compressible": true },
  "application/vnd.liberty-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "compressible": true, "extensions": ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { "source": "iana", "compressible": false },
  "application/vnd.loom": { "source": "iana" },
  "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] },
  "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] },
  "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] },
  "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] },
  "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] },
  "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] },
  "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] },
  "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { "source": "iana", "extensions": ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.conftoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.license+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.mdcf": { "source": "iana" },
  "application/vnd.mason+json": { "source": "iana", "compressible": true },
  "application/vnd.maxar.archive.3tz+zip": { "source": "iana", "compressible": false },
  "application/vnd.maxmind.maxmind-db": { "source": "iana" },
  "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] },
  "application/vnd.mdl": { "source": "iana" },
  "application/vnd.mdl-mbsdf": { "source": "iana" },
  "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] },
  "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] },
  "application/vnd.medicalholodeck.recordxr": { "source": "iana" },
  "application/vnd.meridian-slingshot": { "source": "iana" },
  "application/vnd.mermaid": { "source": "iana" },
  "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] },
  "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] },
  "application/vnd.micro+json": { "source": "iana", "compressible": true },
  "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] },
  "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] },
  "application/vnd.microsoft.portable-executable": { "source": "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
  "application/vnd.miele+json": { "source": "iana", "compressible": true },
  "application/vnd.mif": { "source": "iana", "extensions": ["mif"] },
  "application/vnd.minisoft-hp3000-save": { "source": "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
  "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] },
  "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] },
  "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] },
  "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] },
  "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] },
  "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] },
  "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] },
  "application/vnd.modl": { "source": "iana" },
  "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] },
  "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] },
  "application/vnd.motorola.flexsuite": { "source": "iana" },
  "application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
  "application/vnd.motorola.flexsuite.fis": { "source": "iana" },
  "application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
  "application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
  "application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
  "application/vnd.motorola.flexsuite.wem": { "source": "iana" },
  "application/vnd.motorola.iprm": { "source": "iana" },
  "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] },
  "application/vnd.ms-3mfdocument": { "source": "iana" },
  "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] },
  "application/vnd.ms-asf": { "source": "iana" },
  "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] },
  "application/vnd.ms-color.iccprofile": { "source": "apache" },
  "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] },
  "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] },
  "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] },
  "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] },
  "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] },
  "application/vnd.ms-office.activex+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] },
  "application/vnd.ms-opentype": { "source": "apache", "compressible": true },
  "application/vnd.ms-outlook": { "compressible": false, "extensions": ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
  "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] },
  "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-printing.printticket+xml": { "source": "apache", "compressible": true },
  "application/vnd.ms-printschematicket+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { "source": "iana" },
  "application/vnd.ms-visio.viewer": { "extensions": ["vdx"] },
  "application/vnd.ms-windows.devicepairing": { "source": "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
  "application/vnd.ms-windows.printerpairing": { "source": "iana" },
  "application/vnd.ms-windows.wsd.oob": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] },
  "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] },
  "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] },
  "application/vnd.msa-disk-image": { "source": "iana" },
  "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] },
  "application/vnd.msgpack": { "source": "iana" },
  "application/vnd.msign": { "source": "iana" },
  "application/vnd.multiad.creator": { "source": "iana" },
  "application/vnd.multiad.creator.cif": { "source": "iana" },
  "application/vnd.music-niff": { "source": "iana" },
  "application/vnd.musician": { "source": "iana", "extensions": ["mus"] },
  "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] },
  "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { "source": "iana", "compressible": true },
  "application/vnd.nato.bindingdataobject+cbor": { "source": "iana" },
  "application/vnd.nato.bindingdataobject+json": { "source": "iana", "compressible": true },
  "application/vnd.nato.bindingdataobject+xml": { "source": "iana", "compressible": true, "extensions": ["bdo"] },
  "application/vnd.nato.openxmlformats-package.iepd+zip": { "source": "iana", "compressible": false },
  "application/vnd.ncd.control": { "source": "iana" },
  "application/vnd.ncd.reference": { "source": "iana" },
  "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true },
  "application/vnd.nebumind.line": { "source": "iana" },
  "application/vnd.nervana": { "source": "iana" },
  "application/vnd.netfpx": { "source": "iana" },
  "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] },
  "application/vnd.nimn": { "source": "iana" },
  "application/vnd.nintendo.nitro.rom": { "source": "iana" },
  "application/vnd.nintendo.snes.rom": { "source": "iana" },
  "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] },
  "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] },
  "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] },
  "application/vnd.nokia.catalogs": { "source": "iana" },
  "application/vnd.nokia.conml+wbxml": { "source": "iana" },
  "application/vnd.nokia.conml+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.iptv.config+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.isds-radio-presets": { "source": "iana" },
  "application/vnd.nokia.landmark+wbxml": { "source": "iana" },
  "application/vnd.nokia.landmark+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.landmarkcollection+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.n-gage.ac+xml": { "source": "iana", "compressible": true, "extensions": ["ac"] },
  "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { "source": "apache", "extensions": ["n-gage"] },
  "application/vnd.nokia.ncd": { "source": "iana" },
  "application/vnd.nokia.pcd+wbxml": { "source": "iana" },
  "application/vnd.nokia.pcd+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] },
  "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] },
  "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] },
  "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] },
  "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] },
  "application/vnd.ntt-local.content-share": { "source": "iana" },
  "application/vnd.ntt-local.file-transfer": { "source": "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
  "application/vnd.oai.workflows": { "source": "iana" },
  "application/vnd.oai.workflows+json": { "source": "iana", "compressible": true },
  "application/vnd.oai.workflows+yaml": { "source": "iana" },
  "application/vnd.oasis.opendocument.base": { "source": "iana" },
  "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] },
  "application/vnd.oasis.opendocument.database": { "source": "apache", "extensions": ["odb"] },
  "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] },
  "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] },
  "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] },
  "application/vnd.oasis.opendocument.text-master-template": { "source": "iana" },
  "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] },
  "application/vnd.obn": { "source": "iana" },
  "application/vnd.ocf+cbor": { "source": "iana" },
  "application/vnd.oci.image.manifest.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
  "application/vnd.oipf.dae.svg+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.dae.xhtml+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.pae.gem": { "source": "iana" },
  "application/vnd.oipf.spdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.spdlist+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.ueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.userprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] },
  "application/vnd.oma-scws-config": { "source": "iana" },
  "application/vnd.oma-scws-http-request": { "source": "iana" },
  "application/vnd.oma-scws-http-response": { "source": "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.drm-trigger+xml": { "source": "apache", "compressible": true },
  "application/vnd.oma.bcast.imd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.ltkm": { "source": "iana" },
  "application/vnd.oma.bcast.notification+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
  "application/vnd.oma.bcast.sgboot": { "source": "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sgdu": { "source": "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "apache", "compressible": true },
  "application/vnd.oma.bcast.sprov+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.stkm": { "source": "iana" },
  "application/vnd.oma.cab-address-book+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-feature-handler+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-pcc+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-subs-invite+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-user-prefs+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.dcd": { "source": "iana" },
  "application/vnd.oma.dcdc": { "source": "iana" },
  "application/vnd.oma.dd2+xml": { "source": "iana", "compressible": true, "extensions": ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.group-usage-list+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+cbor": { "source": "iana" },
  "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+tlv": { "source": "iana" },
  "application/vnd.oma.pal+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.final-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.groups+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.push": { "source": "iana" },
  "application/vnd.oma.scidm.messages+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.xcap-directory+xml": { "source": "iana", "compressible": true },
  "application/vnd.omads-email+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-file+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-folder+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omaloc-supl-init": { "source": "iana" },
  "application/vnd.onepager": { "source": "iana" },
  "application/vnd.onepagertamp": { "source": "iana" },
  "application/vnd.onepagertamx": { "source": "iana" },
  "application/vnd.onepagertat": { "source": "iana" },
  "application/vnd.onepagertatp": { "source": "iana" },
  "application/vnd.onepagertatx": { "source": "iana" },
  "application/vnd.onvif.metadata": { "source": "iana" },
  "application/vnd.openblox.game+xml": { "source": "iana", "compressible": true, "extensions": ["obgx"] },
  "application/vnd.openblox.game-binary": { "source": "iana" },
  "application/vnd.openeye.oeb": { "source": "iana" },
  "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { "source": "iana", "compressible": true, "extensions": ["osm"] },
  "application/vnd.opentimestamps.ots": { "source": "iana" },
  "application/vnd.openvpi.dspx+json": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "iana", "extensions": ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "iana", "extensions": ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "iana", "extensions": ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana", "compressible": true },
  "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true },
  "application/vnd.orange.indata": { "source": "iana" },
  "application/vnd.osa.netdeploy": { "source": "iana" },
  "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] },
  "application/vnd.osgi.bundle": { "source": "iana" },
  "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] },
  "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] },
  "application/vnd.otps.ct-kip+xml": { "source": "iana", "compressible": true },
  "application/vnd.oxli.countgraph": { "source": "iana" },
  "application/vnd.pagerduty+json": { "source": "iana", "compressible": true },
  "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { "source": "iana" },
  "application/vnd.paos.xml": { "source": "iana" },
  "application/vnd.patentdive": { "source": "iana" },
  "application/vnd.patientecommsdoc": { "source": "iana" },
  "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] },
  "application/vnd.pcos": { "source": "iana" },
  "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] },
  "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] },
  "application/vnd.piaccess.application-licence": { "source": "iana" },
  "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] },
  "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { "source": "iana", "compressible": true },
  "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] },
  "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] },
  "application/vnd.powerbuilder6-s": { "source": "iana" },
  "application/vnd.powerbuilder7": { "source": "iana" },
  "application/vnd.powerbuilder7-s": { "source": "iana" },
  "application/vnd.powerbuilder75": { "source": "iana" },
  "application/vnd.powerbuilder75-s": { "source": "iana" },
  "application/vnd.preminet": { "source": "iana" },
  "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] },
  "application/vnd.procrate.brushset": { "extensions": ["brushset"] },
  "application/vnd.procreate.brush": { "extensions": ["brush"] },
  "application/vnd.procreate.dream": { "extensions": ["drm"] },
  "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] },
  "application/vnd.psfs": { "source": "iana" },
  "application/vnd.pt.mundusmundi": { "source": "iana" },
  "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] },
  "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] },
  "application/vnd.pwg-multiplexed": { "source": "iana" },
  "application/vnd.pwg-xhtml-print+xml": { "source": "iana", "compressible": true, "extensions": ["xhtm"] },
  "application/vnd.qualcomm.brew-app-res": { "source": "iana" },
  "application/vnd.quarantainenet": { "source": "iana" },
  "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { "source": "iana" },
  "application/vnd.radisys.moml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana", "compressible": true },
  "application/vnd.rainstor.data": { "source": "iana" },
  "application/vnd.rapid": { "source": "iana" },
  "application/vnd.rar": { "source": "iana", "extensions": ["rar"] },
  "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] },
  "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { "source": "iana", "compressible": true, "extensions": ["musicxml"] },
  "application/vnd.relpipe": { "source": "iana" },
  "application/vnd.renlearn.rlprint": { "source": "iana" },
  "application/vnd.resilient.logic": { "source": "iana" },
  "application/vnd.restful+json": { "source": "iana", "compressible": true },
  "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] },
  "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] },
  "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] },
  "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] },
  "application/vnd.route66.link66+xml": { "source": "iana", "compressible": true, "extensions": ["link66"] },
  "application/vnd.rs-274x": { "source": "iana" },
  "application/vnd.ruckus.download": { "source": "iana" },
  "application/vnd.s3sms": { "source": "iana" },
  "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] },
  "application/vnd.sar": { "source": "iana" },
  "application/vnd.sbm.cid": { "source": "iana" },
  "application/vnd.sbm.mid2": { "source": "iana" },
  "application/vnd.scribus": { "source": "iana" },
  "application/vnd.sealed.3df": { "source": "iana" },
  "application/vnd.sealed.csf": { "source": "iana" },
  "application/vnd.sealed.doc": { "source": "iana" },
  "application/vnd.sealed.eml": { "source": "iana" },
  "application/vnd.sealed.mht": { "source": "iana" },
  "application/vnd.sealed.net": { "source": "iana" },
  "application/vnd.sealed.ppt": { "source": "iana" },
  "application/vnd.sealed.tiff": { "source": "iana" },
  "application/vnd.sealed.xls": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.html": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
  "application/vnd.seemail": { "source": "iana", "extensions": ["see"] },
  "application/vnd.seis+json": { "source": "iana", "compressible": true },
  "application/vnd.sema": { "source": "iana", "extensions": ["sema"] },
  "application/vnd.semd": { "source": "iana", "extensions": ["semd"] },
  "application/vnd.semf": { "source": "iana", "extensions": ["semf"] },
  "application/vnd.shade-save-file": { "source": "iana" },
  "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] },
  "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] },
  "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] },
  "application/vnd.shootproof+json": { "source": "iana", "compressible": true },
  "application/vnd.shopkick+json": { "source": "iana", "compressible": true },
  "application/vnd.shp": { "source": "iana" },
  "application/vnd.shx": { "source": "iana" },
  "application/vnd.sigrok.session": { "source": "iana" },
  "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] },
  "application/vnd.siren+json": { "source": "iana", "compressible": true },
  "application/vnd.sketchometry": { "source": "iana" },
  "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] },
  "application/vnd.smart.notebook": { "source": "iana" },
  "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] },
  "application/vnd.smintio.portals.archive": { "source": "iana" },
  "application/vnd.snesdev-page-table": { "source": "iana" },
  "application/vnd.software602.filler.form+xml": { "source": "iana", "compressible": true, "extensions": ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
  "application/vnd.solent.sdkm+xml": { "source": "iana", "compressible": true, "extensions": ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] },
  "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] },
  "application/vnd.sqlite3": { "source": "iana" },
  "application/vnd.sss-cod": { "source": "iana" },
  "application/vnd.sss-dtf": { "source": "iana" },
  "application/vnd.sss-ntf": { "source": "iana" },
  "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] },
  "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] },
  "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] },
  "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] },
  "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] },
  "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] },
  "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] },
  "application/vnd.street-stream": { "source": "iana" },
  "application/vnd.sun.wadl+xml": { "source": "iana", "compressible": true, "extensions": ["wadl"] },
  "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] },
  "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] },
  "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] },
  "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] },
  "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] },
  "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] },
  "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] },
  "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] },
  "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] },
  "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] },
  "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] },
  "application/vnd.svd": { "source": "iana", "extensions": ["svd"] },
  "application/vnd.swiftview-ics": { "source": "iana" },
  "application/vnd.sybyl.mol2": { "source": "iana" },
  "application/vnd.sycle+xml": { "source": "iana", "compressible": true },
  "application/vnd.syft+json": { "source": "iana", "compressible": true },
  "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] },
  "application/vnd.syncml+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["bdm"] },
  "application/vnd.syncml.dm+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xdm"] },
  "application/vnd.syncml.dm.notification": { "source": "iana" },
  "application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmddf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmtnds+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.syncml.ds.notification": { "source": "iana" },
  "application/vnd.tableschema+json": { "source": "iana", "compressible": true },
  "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] },
  "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { "source": "iana", "compressible": true },
  "application/vnd.tmd.mediaflex.api+xml": { "source": "iana", "compressible": true },
  "application/vnd.tml": { "source": "iana" },
  "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] },
  "application/vnd.tri.onesource": { "source": "iana" },
  "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] },
  "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] },
  "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] },
  "application/vnd.truedoc": { "source": "iana" },
  "application/vnd.ubisoft.webplayer": { "source": "iana" },
  "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] },
  "application/vnd.uic.osdm+json": { "source": "iana", "compressible": true },
  "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] },
  "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] },
  "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] },
  "application/vnd.uoml+xml": { "source": "iana", "compressible": true, "extensions": ["uoml", "uo"] },
  "application/vnd.uplanet.alert": { "source": "iana" },
  "application/vnd.uplanet.alert-wbxml": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
  "application/vnd.uplanet.cacheop": { "source": "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
  "application/vnd.uplanet.channel": { "source": "iana" },
  "application/vnd.uplanet.channel-wbxml": { "source": "iana" },
  "application/vnd.uplanet.list": { "source": "iana" },
  "application/vnd.uplanet.list-wbxml": { "source": "iana" },
  "application/vnd.uplanet.listcmd": { "source": "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
  "application/vnd.uplanet.signal": { "source": "iana" },
  "application/vnd.uri-map": { "source": "iana" },
  "application/vnd.valve.source.material": { "source": "iana" },
  "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] },
  "application/vnd.vd-study": { "source": "iana" },
  "application/vnd.vectorworks": { "source": "iana" },
  "application/vnd.vel+json": { "source": "iana", "compressible": true },
  "application/vnd.veraison.tsm-report+cbor": { "source": "iana" },
  "application/vnd.veraison.tsm-report+json": { "source": "iana", "compressible": true },
  "application/vnd.verimatrix.vcas": { "source": "iana" },
  "application/vnd.veritone.aion+json": { "source": "iana", "compressible": true },
  "application/vnd.veryant.thin": { "source": "iana" },
  "application/vnd.ves.encrypted": { "source": "iana" },
  "application/vnd.vidsoft.vidconference": { "source": "iana" },
  "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw", "vsdx", "vtx"] },
  "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] },
  "application/vnd.vividence.scriptfile": { "source": "iana" },
  "application/vnd.vocalshaper.vsp4": { "source": "iana" },
  "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] },
  "application/vnd.wap.sic": { "source": "iana" },
  "application/vnd.wap.slc": { "source": "iana" },
  "application/vnd.wap.wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["wbxml"] },
  "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] },
  "application/vnd.wasmflow.wafl": { "source": "iana" },
  "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] },
  "application/vnd.wfa.dpp": { "source": "iana" },
  "application/vnd.wfa.p2p": { "source": "iana" },
  "application/vnd.wfa.wsc": { "source": "iana" },
  "application/vnd.windows.devicepairing": { "source": "iana" },
  "application/vnd.wmc": { "source": "iana" },
  "application/vnd.wmf.bootstrap": { "source": "iana" },
  "application/vnd.wolfram.mathematica": { "source": "iana" },
  "application/vnd.wolfram.mathematica.package": { "source": "iana" },
  "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] },
  "application/vnd.wordlift": { "source": "iana" },
  "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] },
  "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { "source": "iana" },
  "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] },
  "application/vnd.wv.csp+wbxml": { "source": "iana" },
  "application/vnd.wv.csp+xml": { "source": "iana", "compressible": true },
  "application/vnd.wv.ssp+xml": { "source": "iana", "compressible": true },
  "application/vnd.xacml+json": { "source": "iana", "compressible": true },
  "application/vnd.xara": { "source": "iana", "extensions": ["xar"] },
  "application/vnd.xarin.cpj": { "source": "iana" },
  "application/vnd.xecrets-encrypted": { "source": "iana" },
  "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] },
  "application/vnd.xfdl.webform": { "source": "iana" },
  "application/vnd.xmi+xml": { "source": "iana", "compressible": true },
  "application/vnd.xmpie.cpkg": { "source": "iana" },
  "application/vnd.xmpie.dpkg": { "source": "iana" },
  "application/vnd.xmpie.plan": { "source": "iana" },
  "application/vnd.xmpie.ppkg": { "source": "iana" },
  "application/vnd.xmpie.xlim": { "source": "iana" },
  "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] },
  "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] },
  "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "compressible": true, "extensions": ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { "source": "iana" },
  "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] },
  "application/vnd.yamaha.through-ngn": { "source": "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
  "application/vnd.yaoweme": { "source": "iana" },
  "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] },
  "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { "source": "iana", "compressible": true, "extensions": ["zaz"] },
  "application/voicexml+xml": { "source": "iana", "compressible": true, "extensions": ["vxml"] },
  "application/voucher-cms+json": { "source": "iana", "compressible": true },
  "application/voucher-jws+json": { "source": "iana", "compressible": true },
  "application/vp": { "source": "iana" },
  "application/vp+cose": { "source": "iana" },
  "application/vp+jwt": { "source": "iana" },
  "application/vq-rtcpxr": { "source": "iana" },
  "application/wasm": { "source": "iana", "compressible": true, "extensions": ["wasm"] },
  "application/watcherinfo+xml": { "source": "iana", "compressible": true, "extensions": ["wif"] },
  "application/webpush-options+json": { "source": "iana", "compressible": true },
  "application/whoispp-query": { "source": "iana" },
  "application/whoispp-response": { "source": "iana" },
  "application/widget": { "source": "iana", "extensions": ["wgt"] },
  "application/winhlp": { "source": "apache", "extensions": ["hlp"] },
  "application/wita": { "source": "iana" },
  "application/wordperfect5.1": { "source": "iana" },
  "application/wsdl+xml": { "source": "iana", "compressible": true, "extensions": ["wsdl"] },
  "application/wspolicy+xml": { "source": "iana", "compressible": true, "extensions": ["wspolicy"] },
  "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] },
  "application/x-abiword": { "source": "apache", "extensions": ["abw"] },
  "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] },
  "application/x-amf": { "source": "apache" },
  "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] },
  "application/x-arj": { "compressible": false, "extensions": ["arj"] },
  "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] },
  "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] },
  "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] },
  "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] },
  "application/x-blender": { "extensions": ["blend"] },
  "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] },
  "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] },
  "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] },
  "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] },
  "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] },
  "application/x-chat": { "source": "apache", "extensions": ["chat"] },
  "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] },
  "application/x-chrome-extension": { "extensions": ["crx"] },
  "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] },
  "application/x-compress": { "source": "apache" },
  "application/x-compressed": { "extensions": ["rar"] },
  "application/x-conference": { "source": "apache", "extensions": ["nsc"] },
  "application/x-cpio": { "source": "apache", "extensions": ["cpio"] },
  "application/x-csh": { "source": "apache", "extensions": ["csh"] },
  "application/x-deb": { "compressible": false },
  "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] },
  "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] },
  "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { "source": "apache", "extensions": ["wad"] },
  "application/x-dtbncx+xml": { "source": "apache", "compressible": true, "extensions": ["ncx"] },
  "application/x-dtbook+xml": { "source": "apache", "compressible": true, "extensions": ["dtb"] },
  "application/x-dtbresource+xml": { "source": "apache", "compressible": true, "extensions": ["res"] },
  "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] },
  "application/x-envoy": { "source": "apache", "extensions": ["evy"] },
  "application/x-eva": { "source": "apache", "extensions": ["eva"] },
  "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] },
  "application/x-font-dos": { "source": "apache" },
  "application/x-font-framemaker": { "source": "apache" },
  "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] },
  "application/x-font-libgrx": { "source": "apache" },
  "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] },
  "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] },
  "application/x-font-snf": { "source": "apache", "extensions": ["snf"] },
  "application/x-font-speedo": { "source": "apache" },
  "application/x-font-sunos-news": { "source": "apache" },
  "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { "source": "apache" },
  "application/x-freearc": { "source": "apache", "extensions": ["arc"] },
  "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] },
  "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] },
  "application/x-glulx": { "source": "apache", "extensions": ["ulx"] },
  "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] },
  "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] },
  "application/x-gtar": { "source": "apache", "extensions": ["gtar"] },
  "application/x-gzip": { "source": "apache" },
  "application/x-hdf": { "source": "apache", "extensions": ["hdf"] },
  "application/x-httpd-php": { "compressible": true, "extensions": ["php"] },
  "application/x-install-instructions": { "source": "apache", "extensions": ["install"] },
  "application/x-ipynb+json": { "compressible": true, "extensions": ["ipynb"] },
  "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] },
  "application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
  "application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
  "application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
  "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] },
  "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] },
  "application/x-javascript": { "compressible": true },
  "application/x-keepass2": { "extensions": ["kdbx"] },
  "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] },
  "application/x-lua-bytecode": { "extensions": ["luac"] },
  "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] },
  "application/x-makeself": { "source": "nginx", "extensions": ["run"] },
  "application/x-mie": { "source": "apache", "extensions": ["mie"] },
  "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] },
  "application/x-mpegurl": { "compressible": false },
  "application/x-ms-application": { "source": "apache", "extensions": ["application"] },
  "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] },
  "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] },
  "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] },
  "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] },
  "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] },
  "application/x-msbinder": { "source": "apache", "extensions": ["obd"] },
  "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] },
  "application/x-msclip": { "source": "apache", "extensions": ["clp"] },
  "application/x-msdos-program": { "extensions": ["exe"] },
  "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { "source": "apache", "extensions": ["mny"] },
  "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] },
  "application/x-msschedule": { "source": "apache", "extensions": ["scd"] },
  "application/x-msterminal": { "source": "apache", "extensions": ["trm"] },
  "application/x-mswrite": { "source": "apache", "extensions": ["wri"] },
  "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] },
  "application/x-nzb": { "source": "apache", "extensions": ["nzb"] },
  "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] },
  "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] },
  "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] },
  "application/x-pki-message": { "source": "iana" },
  "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] },
  "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] },
  "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] },
  "application/x-sea": { "source": "nginx", "extensions": ["sea"] },
  "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] },
  "application/x-shar": { "source": "apache", "extensions": ["shar"] },
  "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] },
  "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] },
  "application/x-sql": { "source": "apache", "extensions": ["sql"] },
  "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] },
  "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] },
  "application/x-subrip": { "source": "apache", "extensions": ["srt"] },
  "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] },
  "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] },
  "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] },
  "application/x-tads": { "source": "apache", "extensions": ["gam"] },
  "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] },
  "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] },
  "application/x-tex": { "source": "apache", "extensions": ["tex"] },
  "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] },
  "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] },
  "application/x-tgif": { "source": "apache", "extensions": ["obj"] },
  "application/x-ustar": { "source": "apache", "extensions": ["ustar"] },
  "application/x-virtualbox-hdd": { "compressible": true, "extensions": ["hdd"] },
  "application/x-virtualbox-ova": { "compressible": true, "extensions": ["ova"] },
  "application/x-virtualbox-ovf": { "compressible": true, "extensions": ["ovf"] },
  "application/x-virtualbox-vbox": { "compressible": true, "extensions": ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { "compressible": false, "extensions": ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { "compressible": true, "extensions": ["vdi"] },
  "application/x-virtualbox-vhd": { "compressible": true, "extensions": ["vhd"] },
  "application/x-virtualbox-vmdk": { "compressible": true, "extensions": ["vmdk"] },
  "application/x-wais-source": { "source": "apache", "extensions": ["src"] },
  "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] },
  "application/x-www-form-urlencoded": { "source": "iana", "compressible": true },
  "application/x-x509-ca-cert": { "source": "iana", "extensions": ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { "source": "iana" },
  "application/x-x509-next-ca-cert": { "source": "iana" },
  "application/x-xfig": { "source": "apache", "extensions": ["fig"] },
  "application/x-xliff+xml": { "source": "apache", "compressible": true, "extensions": ["xlf"] },
  "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] },
  "application/x-xz": { "source": "apache", "extensions": ["xz"] },
  "application/x-zip-compressed": { "extensions": ["zip"] },
  "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { "source": "iana" },
  "application/xacml+xml": { "source": "iana", "compressible": true },
  "application/xaml+xml": { "source": "apache", "compressible": true, "extensions": ["xaml"] },
  "application/xcap-att+xml": { "source": "iana", "compressible": true, "extensions": ["xav"] },
  "application/xcap-caps+xml": { "source": "iana", "compressible": true, "extensions": ["xca"] },
  "application/xcap-diff+xml": { "source": "iana", "compressible": true, "extensions": ["xdf"] },
  "application/xcap-el+xml": { "source": "iana", "compressible": true, "extensions": ["xel"] },
  "application/xcap-error+xml": { "source": "iana", "compressible": true },
  "application/xcap-ns+xml": { "source": "iana", "compressible": true, "extensions": ["xns"] },
  "application/xcon-conference-info+xml": { "source": "iana", "compressible": true },
  "application/xcon-conference-info-diff+xml": { "source": "iana", "compressible": true },
  "application/xenc+xml": { "source": "iana", "compressible": true, "extensions": ["xenc"] },
  "application/xfdf": { "source": "iana", "extensions": ["xfdf"] },
  "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { "source": "apache", "compressible": true },
  "application/xliff+xml": { "source": "iana", "compressible": true, "extensions": ["xlf"] },
  "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] },
  "application/xml-external-parsed-entity": { "source": "iana" },
  "application/xml-patch+xml": { "source": "iana", "compressible": true },
  "application/xmpp+xml": { "source": "iana", "compressible": true },
  "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] },
  "application/xproc+xml": { "source": "apache", "compressible": true, "extensions": ["xpl"] },
  "application/xslt+xml": { "source": "iana", "compressible": true, "extensions": ["xsl", "xslt"] },
  "application/xspf+xml": { "source": "apache", "compressible": true, "extensions": ["xspf"] },
  "application/xv+xml": { "source": "iana", "compressible": true, "extensions": ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yaml": { "source": "iana" },
  "application/yang": { "source": "iana", "extensions": ["yang"] },
  "application/yang-data+cbor": { "source": "iana" },
  "application/yang-data+json": { "source": "iana", "compressible": true },
  "application/yang-data+xml": { "source": "iana", "compressible": true },
  "application/yang-patch+json": { "source": "iana", "compressible": true },
  "application/yang-patch+xml": { "source": "iana", "compressible": true },
  "application/yang-sid+json": { "source": "iana", "compressible": true },
  "application/yin+xml": { "source": "iana", "compressible": true, "extensions": ["yin"] },
  "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] },
  "application/zip+dotlottie": { "extensions": ["lottie"] },
  "application/zlib": { "source": "iana" },
  "application/zstd": { "source": "iana" },
  "audio/1d-interleaved-parityfec": { "source": "iana" },
  "audio/32kadpcm": { "source": "iana" },
  "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] },
  "audio/3gpp2": { "source": "iana" },
  "audio/aac": { "source": "iana", "extensions": ["adts", "aac"] },
  "audio/ac3": { "source": "iana" },
  "audio/adpcm": { "source": "apache", "extensions": ["adp"] },
  "audio/amr": { "source": "iana", "extensions": ["amr"] },
  "audio/amr-wb": { "source": "iana" },
  "audio/amr-wb+": { "source": "iana" },
  "audio/aptx": { "source": "iana" },
  "audio/asc": { "source": "iana" },
  "audio/atrac-advanced-lossless": { "source": "iana" },
  "audio/atrac-x": { "source": "iana" },
  "audio/atrac3": { "source": "iana" },
  "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] },
  "audio/bv16": { "source": "iana" },
  "audio/bv32": { "source": "iana" },
  "audio/clearmode": { "source": "iana" },
  "audio/cn": { "source": "iana" },
  "audio/dat12": { "source": "iana" },
  "audio/dls": { "source": "iana" },
  "audio/dsr-es201108": { "source": "iana" },
  "audio/dsr-es202050": { "source": "iana" },
  "audio/dsr-es202211": { "source": "iana" },
  "audio/dsr-es202212": { "source": "iana" },
  "audio/dv": { "source": "iana" },
  "audio/dvi4": { "source": "iana" },
  "audio/eac3": { "source": "iana" },
  "audio/encaprtp": { "source": "iana" },
  "audio/evrc": { "source": "iana" },
  "audio/evrc-qcp": { "source": "iana" },
  "audio/evrc0": { "source": "iana" },
  "audio/evrc1": { "source": "iana" },
  "audio/evrcb": { "source": "iana" },
  "audio/evrcb0": { "source": "iana" },
  "audio/evrcb1": { "source": "iana" },
  "audio/evrcnw": { "source": "iana" },
  "audio/evrcnw0": { "source": "iana" },
  "audio/evrcnw1": { "source": "iana" },
  "audio/evrcwb": { "source": "iana" },
  "audio/evrcwb0": { "source": "iana" },
  "audio/evrcwb1": { "source": "iana" },
  "audio/evs": { "source": "iana" },
  "audio/flac": { "source": "iana" },
  "audio/flexfec": { "source": "iana" },
  "audio/fwdred": { "source": "iana" },
  "audio/g711-0": { "source": "iana" },
  "audio/g719": { "source": "iana" },
  "audio/g722": { "source": "iana" },
  "audio/g7221": { "source": "iana" },
  "audio/g723": { "source": "iana" },
  "audio/g726-16": { "source": "iana" },
  "audio/g726-24": { "source": "iana" },
  "audio/g726-32": { "source": "iana" },
  "audio/g726-40": { "source": "iana" },
  "audio/g728": { "source": "iana" },
  "audio/g729": { "source": "iana" },
  "audio/g7291": { "source": "iana" },
  "audio/g729d": { "source": "iana" },
  "audio/g729e": { "source": "iana" },
  "audio/gsm": { "source": "iana" },
  "audio/gsm-efr": { "source": "iana" },
  "audio/gsm-hr-08": { "source": "iana" },
  "audio/ilbc": { "source": "iana" },
  "audio/ip-mr_v2.5": { "source": "iana" },
  "audio/isac": { "source": "apache" },
  "audio/l16": { "source": "iana" },
  "audio/l20": { "source": "iana" },
  "audio/l24": { "source": "iana", "compressible": false },
  "audio/l8": { "source": "iana" },
  "audio/lpc": { "source": "iana" },
  "audio/matroska": { "source": "iana" },
  "audio/melp": { "source": "iana" },
  "audio/melp1200": { "source": "iana" },
  "audio/melp2400": { "source": "iana" },
  "audio/melp600": { "source": "iana" },
  "audio/mhas": { "source": "iana" },
  "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] },
  "audio/midi-clip": { "source": "iana" },
  "audio/mobile-xmf": { "source": "iana", "extensions": ["mxmf"] },
  "audio/mp3": { "compressible": false, "extensions": ["mp3"] },
  "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a", "m4b"] },
  "audio/mp4a-latm": { "source": "iana" },
  "audio/mpa": { "source": "iana" },
  "audio/mpa-robust": { "source": "iana" },
  "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { "source": "iana" },
  "audio/musepack": { "source": "apache" },
  "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { "source": "iana" },
  "audio/parityfec": { "source": "iana" },
  "audio/pcma": { "source": "iana" },
  "audio/pcma-wb": { "source": "iana" },
  "audio/pcmu": { "source": "iana" },
  "audio/pcmu-wb": { "source": "iana" },
  "audio/prs.sid": { "source": "iana" },
  "audio/qcelp": { "source": "iana" },
  "audio/raptorfec": { "source": "iana" },
  "audio/red": { "source": "iana" },
  "audio/rtp-enc-aescm128": { "source": "iana" },
  "audio/rtp-midi": { "source": "iana" },
  "audio/rtploopback": { "source": "iana" },
  "audio/rtx": { "source": "iana" },
  "audio/s3m": { "source": "apache", "extensions": ["s3m"] },
  "audio/scip": { "source": "iana" },
  "audio/silk": { "source": "apache", "extensions": ["sil"] },
  "audio/smv": { "source": "iana" },
  "audio/smv-qcp": { "source": "iana" },
  "audio/smv0": { "source": "iana" },
  "audio/sofa": { "source": "iana" },
  "audio/sp-midi": { "source": "iana" },
  "audio/speex": { "source": "iana" },
  "audio/t140c": { "source": "iana" },
  "audio/t38": { "source": "iana" },
  "audio/telephone-event": { "source": "iana" },
  "audio/tetra_acelp": { "source": "iana" },
  "audio/tetra_acelp_bb": { "source": "iana" },
  "audio/tone": { "source": "iana" },
  "audio/tsvcis": { "source": "iana" },
  "audio/uemclip": { "source": "iana" },
  "audio/ulpfec": { "source": "iana" },
  "audio/usac": { "source": "iana" },
  "audio/vdvi": { "source": "iana" },
  "audio/vmr-wb": { "source": "iana" },
  "audio/vnd.3gpp.iufp": { "source": "iana" },
  "audio/vnd.4sb": { "source": "iana" },
  "audio/vnd.audiokoz": { "source": "iana" },
  "audio/vnd.celp": { "source": "iana" },
  "audio/vnd.cisco.nse": { "source": "iana" },
  "audio/vnd.cmles.radio-events": { "source": "iana" },
  "audio/vnd.cns.anp1": { "source": "iana" },
  "audio/vnd.cns.inf1": { "source": "iana" },
  "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] },
  "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] },
  "audio/vnd.dlna.adts": { "source": "iana" },
  "audio/vnd.dolby.heaac.1": { "source": "iana" },
  "audio/vnd.dolby.heaac.2": { "source": "iana" },
  "audio/vnd.dolby.mlp": { "source": "iana" },
  "audio/vnd.dolby.mps": { "source": "iana" },
  "audio/vnd.dolby.pl2": { "source": "iana" },
  "audio/vnd.dolby.pl2x": { "source": "iana" },
  "audio/vnd.dolby.pl2z": { "source": "iana" },
  "audio/vnd.dolby.pulse.1": { "source": "iana" },
  "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] },
  "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] },
  "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] },
  "audio/vnd.dts.uhd": { "source": "iana" },
  "audio/vnd.dvb.file": { "source": "iana" },
  "audio/vnd.everad.plj": { "source": "iana" },
  "audio/vnd.hns.audio": { "source": "iana" },
  "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { "source": "iana" },
  "audio/vnd.nortel.vbk": { "source": "iana" },
  "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] },
  "audio/vnd.octel.sbc": { "source": "iana" },
  "audio/vnd.presonus.multitrack": { "source": "iana" },
  "audio/vnd.qcelp": { "source": "apache" },
  "audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
  "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] },
  "audio/vnd.rn-realaudio": { "compressible": false },
  "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
  "audio/vnd.vmx.cvsd": { "source": "iana" },
  "audio/vnd.wave": { "compressible": false },
  "audio/vorbis": { "source": "iana", "compressible": false },
  "audio/vorbis-config": { "source": "iana" },
  "audio/wav": { "compressible": false, "extensions": ["wav"] },
  "audio/wave": { "compressible": false, "extensions": ["wav"] },
  "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] },
  "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] },
  "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] },
  "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] },
  "audio/x-flac": { "source": "apache", "extensions": ["flac"] },
  "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] },
  "audio/x-matroska": { "source": "apache", "extensions": ["mka"] },
  "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] },
  "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] },
  "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] },
  "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] },
  "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] },
  "audio/x-tta": { "source": "apache" },
  "audio/x-wav": { "source": "apache", "extensions": ["wav"] },
  "audio/xm": { "source": "apache", "extensions": ["xm"] },
  "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] },
  "chemical/x-cif": { "source": "apache", "extensions": ["cif"] },
  "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] },
  "chemical/x-cml": { "source": "apache", "extensions": ["cml"] },
  "chemical/x-csml": { "source": "apache", "extensions": ["csml"] },
  "chemical/x-pdb": { "source": "apache" },
  "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] },
  "font/collection": { "source": "iana", "extensions": ["ttc"] },
  "font/otf": { "source": "iana", "compressible": true, "extensions": ["otf"] },
  "font/sfnt": { "source": "iana" },
  "font/ttf": { "source": "iana", "compressible": true, "extensions": ["ttf"] },
  "font/woff": { "source": "iana", "extensions": ["woff"] },
  "font/woff2": { "source": "iana", "extensions": ["woff2"] },
  "image/aces": { "source": "iana", "extensions": ["exr"] },
  "image/apng": { "source": "iana", "compressible": false, "extensions": ["apng"] },
  "image/avci": { "source": "iana", "extensions": ["avci"] },
  "image/avcs": { "source": "iana", "extensions": ["avcs"] },
  "image/avif": { "source": "iana", "compressible": false, "extensions": ["avif"] },
  "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp", "dib"] },
  "image/cgm": { "source": "iana", "extensions": ["cgm"] },
  "image/dicom-rle": { "source": "iana", "extensions": ["drle"] },
  "image/dpx": { "source": "iana", "extensions": ["dpx"] },
  "image/emf": { "source": "iana", "extensions": ["emf"] },
  "image/fits": { "source": "iana", "extensions": ["fits"] },
  "image/g3fax": { "source": "iana", "extensions": ["g3"] },
  "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] },
  "image/heic": { "source": "iana", "extensions": ["heic"] },
  "image/heic-sequence": { "source": "iana", "extensions": ["heics"] },
  "image/heif": { "source": "iana", "extensions": ["heif"] },
  "image/heif-sequence": { "source": "iana", "extensions": ["heifs"] },
  "image/hej2k": { "source": "iana", "extensions": ["hej2"] },
  "image/ief": { "source": "iana", "extensions": ["ief"] },
  "image/j2c": { "source": "iana" },
  "image/jaii": { "source": "iana", "extensions": ["jaii"] },
  "image/jais": { "source": "iana", "extensions": ["jais"] },
  "image/jls": { "source": "iana", "extensions": ["jls"] },
  "image/jp2": { "source": "iana", "compressible": false, "extensions": ["jp2", "jpg2"] },
  "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpg", "jpeg", "jpe"] },
  "image/jph": { "source": "iana", "extensions": ["jph"] },
  "image/jphc": { "source": "iana", "extensions": ["jhc"] },
  "image/jpm": { "source": "iana", "compressible": false, "extensions": ["jpm", "jpgm"] },
  "image/jpx": { "source": "iana", "compressible": false, "extensions": ["jpx", "jpf"] },
  "image/jxl": { "source": "iana", "extensions": ["jxl"] },
  "image/jxr": { "source": "iana", "extensions": ["jxr"] },
  "image/jxra": { "source": "iana", "extensions": ["jxra"] },
  "image/jxrs": { "source": "iana", "extensions": ["jxrs"] },
  "image/jxs": { "source": "iana", "extensions": ["jxs"] },
  "image/jxsc": { "source": "iana", "extensions": ["jxsc"] },
  "image/jxsi": { "source": "iana", "extensions": ["jxsi"] },
  "image/jxss": { "source": "iana", "extensions": ["jxss"] },
  "image/ktx": { "source": "iana", "extensions": ["ktx"] },
  "image/ktx2": { "source": "iana", "extensions": ["ktx2"] },
  "image/naplps": { "source": "iana" },
  "image/pjpeg": { "compressible": false, "extensions": ["jfif"] },
  "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] },
  "image/prs.btif": { "source": "iana", "extensions": ["btif", "btf"] },
  "image/prs.pti": { "source": "iana", "extensions": ["pti"] },
  "image/pwg-raster": { "source": "iana" },
  "image/sgi": { "source": "apache", "extensions": ["sgi"] },
  "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] },
  "image/t38": { "source": "iana", "extensions": ["t38"] },
  "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tif", "tiff"] },
  "image/tiff-fx": { "source": "iana", "extensions": ["tfx"] },
  "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] },
  "image/vnd.airzip.accelerator.azv": { "source": "iana", "extensions": ["azv"] },
  "image/vnd.clip": { "source": "iana" },
  "image/vnd.cns.inf2": { "source": "iana" },
  "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] },
  "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] },
  "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] },
  "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] },
  "image/vnd.fst": { "source": "iana", "extensions": ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] },
  "image/vnd.globalgraphics.pgb": { "source": "iana" },
  "image/vnd.microsoft.icon": { "source": "iana", "compressible": true, "extensions": ["ico"] },
  "image/vnd.mix": { "source": "iana" },
  "image/vnd.mozilla.apng": { "source": "iana" },
  "image/vnd.ms-dds": { "compressible": true, "extensions": ["dds"] },
  "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] },
  "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] },
  "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] },
  "image/vnd.pco.b16": { "source": "iana", "extensions": ["b16"] },
  "image/vnd.radiance": { "source": "iana" },
  "image/vnd.sealed.png": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
  "image/vnd.svf": { "source": "iana" },
  "image/vnd.tencent.tap": { "source": "iana", "extensions": ["tap"] },
  "image/vnd.valve.source.texture": { "source": "iana", "extensions": ["vtf"] },
  "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] },
  "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] },
  "image/vnd.zbrush.pcx": { "source": "iana", "extensions": ["pcx"] },
  "image/webp": { "source": "iana", "extensions": ["webp"] },
  "image/wmf": { "source": "iana", "extensions": ["wmf"] },
  "image/x-3ds": { "source": "apache", "extensions": ["3ds"] },
  "image/x-adobe-dng": { "extensions": ["dng"] },
  "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] },
  "image/x-cmx": { "source": "apache", "extensions": ["cmx"] },
  "image/x-emf": { "source": "iana" },
  "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] },
  "image/x-jng": { "source": "nginx", "extensions": ["jng"] },
  "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] },
  "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] },
  "image/x-pcx": { "source": "apache", "extensions": ["pcx"] },
  "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] },
  "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] },
  "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] },
  "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] },
  "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] },
  "image/x-rgb": { "source": "apache", "extensions": ["rgb"] },
  "image/x-tga": { "source": "apache", "extensions": ["tga"] },
  "image/x-wmf": { "source": "iana" },
  "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] },
  "image/x-xcf": { "compressible": false },
  "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] },
  "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] },
  "message/bhttp": { "source": "iana" },
  "message/cpim": { "source": "iana" },
  "message/delivery-status": { "source": "iana" },
  "message/disposition-notification": { "source": "iana", "extensions": ["disposition-notification"] },
  "message/external-body": { "source": "iana" },
  "message/feedback-report": { "source": "iana" },
  "message/global": { "source": "iana", "extensions": ["u8msg"] },
  "message/global-delivery-status": { "source": "iana", "extensions": ["u8dsn"] },
  "message/global-disposition-notification": { "source": "iana", "extensions": ["u8mdn"] },
  "message/global-headers": { "source": "iana", "extensions": ["u8hdr"] },
  "message/http": { "source": "iana", "compressible": false },
  "message/imdn+xml": { "source": "iana", "compressible": true },
  "message/mls": { "source": "iana" },
  "message/news": { "source": "apache" },
  "message/ohttp-req": { "source": "iana" },
  "message/ohttp-res": { "source": "iana" },
  "message/partial": { "source": "iana", "compressible": false },
  "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime", "mht", "mhtml"] },
  "message/s-http": { "source": "apache" },
  "message/sip": { "source": "iana" },
  "message/sipfrag": { "source": "iana" },
  "message/tracking-status": { "source": "iana" },
  "message/vnd.si.simp": { "source": "apache" },
  "message/vnd.wfa.wsc": { "source": "iana", "extensions": ["wsc"] },
  "model/3mf": { "source": "iana", "extensions": ["3mf"] },
  "model/e57": { "source": "iana" },
  "model/gltf+json": { "source": "iana", "compressible": true, "extensions": ["gltf"] },
  "model/gltf-binary": { "source": "iana", "compressible": true, "extensions": ["glb"] },
  "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] },
  "model/jt": { "source": "iana", "extensions": ["jt"] },
  "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] },
  "model/mtl": { "source": "iana", "extensions": ["mtl"] },
  "model/obj": { "source": "iana", "extensions": ["obj"] },
  "model/prc": { "source": "iana", "extensions": ["prc"] },
  "model/step": { "source": "iana", "extensions": ["step", "stp", "stpnc", "p21", "210"] },
  "model/step+xml": { "source": "iana", "compressible": true, "extensions": ["stpx"] },
  "model/step+zip": { "source": "iana", "compressible": false, "extensions": ["stpz"] },
  "model/step-xml+zip": { "source": "iana", "compressible": false, "extensions": ["stpxz"] },
  "model/stl": { "source": "iana", "extensions": ["stl"] },
  "model/u3d": { "source": "iana", "extensions": ["u3d"] },
  "model/vnd.bary": { "source": "iana", "extensions": ["bary"] },
  "model/vnd.cld": { "source": "iana", "extensions": ["cld"] },
  "model/vnd.collada+xml": { "source": "iana", "compressible": true, "extensions": ["dae"] },
  "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] },
  "model/vnd.flatland.3dml": { "source": "iana" },
  "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] },
  "model/vnd.gs-gdl": { "source": "apache" },
  "model/vnd.gs.gdl": { "source": "iana" },
  "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] },
  "model/vnd.moml+xml": { "source": "iana", "compressible": true },
  "model/vnd.mts": { "source": "iana", "extensions": ["mts"] },
  "model/vnd.opengex": { "source": "iana", "extensions": ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { "source": "iana", "extensions": ["x_b"] },
  "model/vnd.parasolid.transmit.text": { "source": "iana", "extensions": ["x_t"] },
  "model/vnd.pytha.pyox": { "source": "iana", "extensions": ["pyo", "pyox"] },
  "model/vnd.rosette.annotated-data-model": { "source": "iana" },
  "model/vnd.sap.vds": { "source": "iana", "extensions": ["vds"] },
  "model/vnd.usda": { "source": "iana", "extensions": ["usda"] },
  "model/vnd.usdz+zip": { "source": "iana", "compressible": false, "extensions": ["usdz"] },
  "model/vnd.valve.source.compiled-map": { "source": "iana", "extensions": ["bsp"] },
  "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] },
  "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] },
  "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { "source": "iana", "extensions": ["x3db"] },
  "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] },
  "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] },
  "model/x3d-vrml": { "source": "iana", "extensions": ["x3dv"] },
  "multipart/alternative": { "source": "iana", "compressible": false },
  "multipart/appledouble": { "source": "iana" },
  "multipart/byteranges": { "source": "iana" },
  "multipart/digest": { "source": "iana" },
  "multipart/encrypted": { "source": "iana", "compressible": false },
  "multipart/form-data": { "source": "iana", "compressible": false },
  "multipart/header-set": { "source": "iana" },
  "multipart/mixed": { "source": "iana" },
  "multipart/multilingual": { "source": "iana" },
  "multipart/parallel": { "source": "iana" },
  "multipart/related": { "source": "iana", "compressible": false },
  "multipart/report": { "source": "iana" },
  "multipart/signed": { "source": "iana", "compressible": false },
  "multipart/vnd.bint.med-plus": { "source": "iana" },
  "multipart/voice-message": { "source": "iana" },
  "multipart/x-mixed-replace": { "source": "iana" },
  "text/1d-interleaved-parityfec": { "source": "iana" },
  "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] },
  "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] },
  "text/calender": { "compressible": true },
  "text/cmd": { "compressible": true },
  "text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
  "text/cql": { "source": "iana" },
  "text/cql-expression": { "source": "iana" },
  "text/cql-identifier": { "source": "iana" },
  "text/css": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["css"] },
  "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] },
  "text/csv-schema": { "source": "iana" },
  "text/directory": { "source": "iana" },
  "text/dns": { "source": "iana" },
  "text/ecmascript": { "source": "apache" },
  "text/encaprtp": { "source": "iana" },
  "text/enriched": { "source": "iana" },
  "text/fhirpath": { "source": "iana" },
  "text/flexfec": { "source": "iana" },
  "text/fwdred": { "source": "iana" },
  "text/gff3": { "source": "iana" },
  "text/grammar-ref-list": { "source": "iana" },
  "text/hl7v2": { "source": "iana" },
  "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] },
  "text/jade": { "extensions": ["jade"] },
  "text/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js", "mjs"] },
  "text/jcr-cnd": { "source": "iana" },
  "text/jsx": { "compressible": true, "extensions": ["jsx"] },
  "text/less": { "compressible": true, "extensions": ["less"] },
  "text/markdown": { "source": "iana", "compressible": true, "extensions": ["md", "markdown"] },
  "text/mathml": { "source": "nginx", "extensions": ["mml"] },
  "text/mdx": { "compressible": true, "extensions": ["mdx"] },
  "text/mizar": { "source": "iana" },
  "text/n3": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["n3"] },
  "text/parameters": { "source": "iana", "charset": "UTF-8" },
  "text/parityfec": { "source": "iana" },
  "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { "source": "iana", "charset": "UTF-8" },
  "text/prs.fallenstein.rst": { "source": "iana" },
  "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] },
  "text/prs.prop.logic": { "source": "iana" },
  "text/prs.texi": { "source": "iana" },
  "text/raptorfec": { "source": "iana" },
  "text/red": { "source": "iana" },
  "text/rfc822-headers": { "source": "iana" },
  "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] },
  "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "text/rtp-enc-aescm128": { "source": "iana" },
  "text/rtploopback": { "source": "iana" },
  "text/rtx": { "source": "iana" },
  "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] },
  "text/shaclc": { "source": "iana" },
  "text/shex": { "source": "iana", "extensions": ["shex"] },
  "text/slim": { "extensions": ["slim", "slm"] },
  "text/spdx": { "source": "iana", "extensions": ["spdx"] },
  "text/strings": { "source": "iana" },
  "text/stylus": { "extensions": ["stylus", "styl"] },
  "text/t140": { "source": "iana" },
  "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] },
  "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { "source": "iana", "charset": "UTF-8", "extensions": ["ttl"] },
  "text/ulpfec": { "source": "iana" },
  "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] },
  "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] },
  "text/vnd.a": { "source": "iana" },
  "text/vnd.abc": { "source": "iana" },
  "text/vnd.ascii-art": { "source": "iana" },
  "text/vnd.curl": { "source": "iana", "extensions": ["curl"] },
  "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] },
  "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] },
  "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] },
  "text/vnd.debian.copyright": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.dmclientscript": { "source": "iana" },
  "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.exchangeable": { "source": "iana" },
  "text/vnd.familysearch.gedcom": { "source": "iana", "extensions": ["ged"] },
  "text/vnd.ficlab.flt": { "source": "iana" },
  "text/vnd.fly": { "source": "iana", "extensions": ["fly"] },
  "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] },
  "text/vnd.gml": { "source": "iana" },
  "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] },
  "text/vnd.hans": { "source": "iana" },
  "text/vnd.hgl": { "source": "iana" },
  "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] },
  "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] },
  "text/vnd.iptc.newsml": { "source": "iana" },
  "text/vnd.iptc.nitf": { "source": "iana" },
  "text/vnd.latex-z": { "source": "iana" },
  "text/vnd.motorola.reflex": { "source": "iana" },
  "text/vnd.ms-mediapackage": { "source": "iana" },
  "text/vnd.net2phone.commcenter.command": { "source": "iana" },
  "text/vnd.radisys.msml-basic-layout": { "source": "iana" },
  "text/vnd.senx.warpscript": { "source": "iana" },
  "text/vnd.si.uricatalogue": { "source": "apache" },
  "text/vnd.sosi": { "source": "iana" },
  "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "charset": "UTF-8", "extensions": ["jad"] },
  "text/vnd.trolltech.linguist": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.vcf": { "source": "iana" },
  "text/vnd.wap.si": { "source": "iana" },
  "text/vnd.wap.sl": { "source": "iana" },
  "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] },
  "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] },
  "text/vnd.zoo.kcl": { "source": "iana" },
  "text/vtt": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] },
  "text/wgsl": { "source": "iana", "extensions": ["wgsl"] },
  "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] },
  "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { "source": "nginx", "extensions": ["htc"] },
  "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { "compressible": true },
  "text/x-handlebars-template": { "extensions": ["hbs"] },
  "text/x-java-source": { "source": "apache", "extensions": ["java"] },
  "text/x-jquery-tmpl": { "compressible": true },
  "text/x-lua": { "extensions": ["lua"] },
  "text/x-markdown": { "compressible": true, "extensions": ["mkd"] },
  "text/x-nfo": { "source": "apache", "extensions": ["nfo"] },
  "text/x-opml": { "source": "apache", "extensions": ["opml"] },
  "text/x-org": { "compressible": true, "extensions": ["org"] },
  "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] },
  "text/x-processing": { "compressible": true, "extensions": ["pde"] },
  "text/x-sass": { "extensions": ["sass"] },
  "text/x-scss": { "extensions": ["scss"] },
  "text/x-setext": { "source": "apache", "extensions": ["etx"] },
  "text/x-sfv": { "source": "apache", "extensions": ["sfv"] },
  "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] },
  "text/x-uuencode": { "source": "apache", "extensions": ["uu"] },
  "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] },
  "text/x-vcard": { "source": "apache", "extensions": ["vcf"] },
  "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] },
  "text/xml-external-parsed-entity": { "source": "iana" },
  "text/yaml": { "compressible": true, "extensions": ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { "source": "iana" },
  "video/3gpp": { "source": "iana", "extensions": ["3gp", "3gpp"] },
  "video/3gpp-tt": { "source": "iana" },
  "video/3gpp2": { "source": "iana", "extensions": ["3g2"] },
  "video/av1": { "source": "iana" },
  "video/bmpeg": { "source": "iana" },
  "video/bt656": { "source": "iana" },
  "video/celb": { "source": "iana" },
  "video/dv": { "source": "iana" },
  "video/encaprtp": { "source": "iana" },
  "video/evc": { "source": "iana" },
  "video/ffv1": { "source": "iana" },
  "video/flexfec": { "source": "iana" },
  "video/h261": { "source": "iana", "extensions": ["h261"] },
  "video/h263": { "source": "iana", "extensions": ["h263"] },
  "video/h263-1998": { "source": "iana" },
  "video/h263-2000": { "source": "iana" },
  "video/h264": { "source": "iana", "extensions": ["h264"] },
  "video/h264-rcdo": { "source": "iana" },
  "video/h264-svc": { "source": "iana" },
  "video/h265": { "source": "iana" },
  "video/h266": { "source": "iana" },
  "video/iso.segment": { "source": "iana", "extensions": ["m4s"] },
  "video/jpeg": { "source": "iana", "extensions": ["jpgv"] },
  "video/jpeg2000": { "source": "iana" },
  "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] },
  "video/jxsv": { "source": "iana" },
  "video/lottie+json": { "source": "iana", "compressible": true },
  "video/matroska": { "source": "iana" },
  "video/matroska-3d": { "source": "iana" },
  "video/mj2": { "source": "iana", "extensions": ["mj2", "mjp2"] },
  "video/mp1s": { "source": "iana" },
  "video/mp2p": { "source": "iana" },
  "video/mp2t": { "source": "iana", "extensions": ["ts", "m2t", "m2ts", "mts"] },
  "video/mp4": { "source": "iana", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { "source": "iana" },
  "video/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { "source": "iana" },
  "video/mpv": { "source": "iana" },
  "video/nv": { "source": "iana" },
  "video/ogg": { "source": "iana", "compressible": false, "extensions": ["ogv"] },
  "video/parityfec": { "source": "iana" },
  "video/pointer": { "source": "iana" },
  "video/quicktime": { "source": "iana", "compressible": false, "extensions": ["qt", "mov"] },
  "video/raptorfec": { "source": "iana" },
  "video/raw": { "source": "iana" },
  "video/rtp-enc-aescm128": { "source": "iana" },
  "video/rtploopback": { "source": "iana" },
  "video/rtx": { "source": "iana" },
  "video/scip": { "source": "iana" },
  "video/smpte291": { "source": "iana" },
  "video/smpte292m": { "source": "iana" },
  "video/ulpfec": { "source": "iana" },
  "video/vc1": { "source": "iana" },
  "video/vc2": { "source": "iana" },
  "video/vnd.cctv": { "source": "iana" },
  "video/vnd.dece.hd": { "source": "iana", "extensions": ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { "source": "iana", "extensions": ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { "source": "iana" },
  "video/vnd.dece.pd": { "source": "iana", "extensions": ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { "source": "iana", "extensions": ["uvs", "uvvs"] },
  "video/vnd.dece.video": { "source": "iana", "extensions": ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { "source": "iana" },
  "video/vnd.directv.mpeg-tts": { "source": "iana" },
  "video/vnd.dlna.mpeg-tts": { "source": "iana" },
  "video/vnd.dvb.file": { "source": "iana", "extensions": ["dvb"] },
  "video/vnd.fvt": { "source": "iana", "extensions": ["fvt"] },
  "video/vnd.hns.video": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.ttsavc": { "source": "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
  "video/vnd.motorola.video": { "source": "iana" },
  "video/vnd.motorola.videop": { "source": "iana" },
  "video/vnd.mpegurl": { "source": "iana", "extensions": ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { "source": "iana", "extensions": ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
  "video/vnd.nokia.mp4vr": { "source": "iana" },
  "video/vnd.nokia.videovoip": { "source": "iana" },
  "video/vnd.objectvideo": { "source": "iana" },
  "video/vnd.planar": { "source": "iana" },
  "video/vnd.radgamettools.bink": { "source": "iana" },
  "video/vnd.radgamettools.smacker": { "source": "apache" },
  "video/vnd.sealed.mpeg1": { "source": "iana" },
  "video/vnd.sealed.mpeg4": { "source": "iana" },
  "video/vnd.sealed.swf": { "source": "iana" },
  "video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
  "video/vnd.uvvu.mp4": { "source": "iana", "extensions": ["uvu", "uvvu"] },
  "video/vnd.vivo": { "source": "iana", "extensions": ["viv"] },
  "video/vnd.youtube.yt": { "source": "iana" },
  "video/vp8": { "source": "iana" },
  "video/vp9": { "source": "iana" },
  "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] },
  "video/x-f4v": { "source": "apache", "extensions": ["f4v"] },
  "video/x-fli": { "source": "apache", "extensions": ["fli"] },
  "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] },
  "video/x-m4v": { "source": "apache", "extensions": ["m4v"] },
  "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] },
  "video/x-mng": { "source": "apache", "extensions": ["mng"] },
  "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] },
  "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] },
  "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] },
  "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] },
  "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] },
  "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] },
  "video/x-msvideo": { "source": "apache", "extensions": ["avi"] },
  "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] },
  "video/x-smv": { "source": "apache", "extensions": ["smv"] },
  "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] },
  "x-shader/x-fragment": { "compressible": true },
  "x-shader/x-vertex": { "compressible": true }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb;
var hasRequiredMimeDb;
function requireMimeDb() {
  if (hasRequiredMimeDb) return mimeDb;
  hasRequiredMimeDb = 1;
  mimeDb = require$$0;
  return mimeDb;
}
var mimeScore;
var hasRequiredMimeScore;
function requireMimeScore() {
  if (hasRequiredMimeScore) return mimeScore;
  hasRequiredMimeScore = 1;
  var FACET_SCORES = {
    "prs.": 100,
    "x-": 200,
    "x.": 300,
    "vnd.": 400,
    default: 900
  };
  var SOURCE_SCORES = {
    nginx: 10,
    apache: 20,
    iana: 40,
    default: 30
    // definitions added by `jshttp/mime-db` project?
  };
  var TYPE_SCORES = {
    // prefer application/xml over text/xml
    // prefer application/rtf over text/rtf
    application: 1,
    // prefer font/woff over application/font-woff
    font: 2,
    default: 0
  };
  mimeScore = function mimeScore2(mimeType, source = "default") {
    if (mimeType === "application/octet-stream") {
      return 0;
    }
    const [type, subtype] = mimeType.split("/");
    const facet = subtype.replace(/(\.|x-).*/, "$1");
    const facetScore = FACET_SCORES[facet] || FACET_SCORES.default;
    const sourceScore = SOURCE_SCORES[source] || SOURCE_SCORES.default;
    const typeScore = TYPE_SCORES[type] || TYPE_SCORES.default;
    const lengthScore = 1 - mimeType.length / 100;
    return facetScore + sourceScore + typeScore + lengthScore;
  };
  return mimeScore;
}
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMimeTypes;
function requireMimeTypes() {
  if (hasRequiredMimeTypes) return mimeTypes;
  hasRequiredMimeTypes = 1;
  (function(exports2) {
    var db = requireMimeDb();
    var extname = require$$1.extname;
    var mimeScore2 = requireMimeScore();
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    exports2._extensionConflicts = [];
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime2 = match && db[match[1].toLowerCase()];
      if (mime2 && mime2.charset) {
        return mime2.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime2 = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime2) {
        return false;
      }
      if (mime2.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime2);
        if (charset2) mime2 += "; charset=" + charset2.toLowerCase();
      }
      return mime2;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().slice(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime2 = db[type];
        var exts = mime2.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          types[extension2] = _preferredType(extension2, types[extension2], type);
          const legacyType = _preferredTypeLegacy(
            extension2,
            types[extension2],
            type
          );
          if (legacyType !== types[extension2]) {
            exports2._extensionConflicts.push([extension2, legacyType, types[extension2]]);
          }
        }
      });
    }
    function _preferredType(ext, type0, type1) {
      var score0 = type0 ? mimeScore2(type0, db[type0].source) : 0;
      var score1 = type1 ? mimeScore2(type1, db[type1].source) : 0;
      return score0 > score1 ? type0 : type1;
    }
    function _preferredTypeLegacy(ext, type0, type1) {
      var _a;
      var SOURCE_RANK = ["nginx", "apache", void 0, "iana"];
      var score0 = type0 ? SOURCE_RANK.indexOf(db[type0].source) : 0;
      var score1 = type1 ? SOURCE_RANK.indexOf(db[type1].source) : 0;
      if (exports2.types[extension] !== "application/octet-stream" && (score0 > score1 || score0 === score1 && ((_a = exports2.types[extension]) == null ? void 0 : _a.slice(0, 12)) === "application/")) {
        return type0;
      }
      return score0 > score1 ? type0 : type1;
    }
  })(mimeTypes);
  return mimeTypes;
}
var mimeTypesExports = requireMimeTypes();
const mime = /* @__PURE__ */ getDefaultExportFromCjs(mimeTypesExports);
const inlineImage = async (image) => {
  let path = image.getAttribute("xlink:href") ?? "";
  let isFile = false;
  try {
    const url = new URL(path);
    isFile = url.protocol === "file:";
  } catch (_e) {
  }
  if (isFile) {
    path = path.slice(7);
  } else {
    throw new Error(
      `Can't inline "${path}".  Currently only file:// urls are supported.`
    );
  }
  const buffer = await fsp.readFile(path);
  const content = buffer.toString("base64");
  const mimeType = mime.lookup(path);
  const contentType = mimeType ? mimeType : "";
  const newUrl = `data:${contentType};base64, ${content}`;
  image.setAttribute("xlink:href", newUrl);
};
const maxGraphToSvg = async (graph, options) => {
  const container = graph.container;
  const orig = container.innerHTML;
  const inlineImages = (options ?? { inlineImages: false }).inlineImages ?? false;
  if (inlineImages) {
    const images = Array.from(container.querySelectorAll("image"));
    for (const image of images) {
      await inlineImage(image);
    }
  }
  const svg = container.firstElementChild;
  svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  svg.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
  const xml = [
    `<?xml version="1.0" standalone="no"?>`,
    `<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">`,
    container.innerHTML
  ].join("\n");
  container.innerHTML = orig;
  return xml;
};
exports.AbstractCanvas2D = AbstractCanvas2D;
exports.ActorShape = ActorShape;
exports.Animation = Animation;
exports.ArrowConnectorShape = ArrowConnectorShape;
exports.ArrowShape = ArrowShape;
exports.AutoSaveManager = AutoSaveManager;
exports.Cell = Cell;
exports.CellAttributeChange = CellAttributeChange;
exports.CellCodec = CellCodec;
exports.CellEditorHandler = CellEditorHandler;
exports.CellHighlight = CellHighlight;
exports.CellMarker = CellMarker;
exports.CellOverlay = CellOverlay;
exports.CellPath = CellPath;
exports.CellRenderer = CellRenderer;
exports.CellState = CellState;
exports.CellStatePreview = CellStatePreview;
exports.CellTracker = CellTracker;
exports.ChildChange = ChildChange;
exports.ChildChangeCodec = ChildChangeCodec;
exports.CircleLayout = CircleLayout;
exports.Client = Client;
exports.Clipboard = Clipboard;
exports.CloudShape = CloudShape;
exports.Codec = Codec;
exports.CodecRegistry = CodecRegistry;
exports.CollapseChange = CollapseChange;
exports.CompactTreeLayout = CompactTreeLayout;
exports.CompositeLayout = CompositeLayout;
exports.ConnectionConstraint = ConnectionConstraint;
exports.ConnectionHandler = ConnectionHandler;
exports.ConnectorShape = ConnectorShape;
exports.ConsoleLogger = ConsoleLogger;
exports.ConstraintHandler = ConstraintHandler;
exports.CoordinateAssignment = CoordinateAssignment;
exports.CurrentRootChange = CurrentRootChange;
exports.CylinderShape = CylinderShape;
exports.Dictionary = Dictionary;
exports.DomHelpers = domHelpers;
exports.DoubleEllipseShape = DoubleEllipseShape;
exports.DragSource = DragSource;
exports.EdgeHandler = EdgeHandler;
exports.EdgeHandlerConfig = EdgeHandlerConfig;
exports.EdgeLabelLayout = EdgeLabelLayout;
exports.EdgeSegmentHandler = EdgeSegmentHandler;
exports.EdgeStyle = EdgeStyle;
exports.Editor = Editor;
exports.EditorCodec = EditorCodec;
exports.EditorKeyHandler = EditorKeyHandler;
exports.EditorKeyHandlerCodec = EditorKeyHandlerCodec;
exports.EditorPopupMenu = EditorPopupMenu;
exports.EditorPopupMenuCodec = EditorPopupMenuCodec;
exports.EditorToolbar = EditorToolbar;
exports.EditorToolbarCodec = EditorToolbarCodec;
exports.Effects = Effects;
exports.ElbowEdgeHandler = ElbowEdgeHandler;
exports.EllipseShape = EllipseShape;
exports.EntityRelationConnectorConfig = EntityRelationConnectorConfig;
exports.EventObject = EventObject;
exports.EventSource = EventSource;
exports.FastOrganicLayout = MxFastOrganicLayout;
exports.FitPlugin = FitPlugin;
exports.GenericChangeCodec = GenericChangeCodec;
exports.Geometry = Geometry;
exports.GeometryChange = GeometryChange;
exports.GlobalConfig = GlobalConfig;
exports.Graph = Graph;
exports.GraphAbstractHierarchyCell = GraphAbstractHierarchyCell;
exports.GraphCodec = GraphCodec;
exports.GraphDataModel = GraphDataModel;
exports.GraphHierarchyEdge = GraphHierarchyEdge;
exports.GraphHierarchyModel = GraphHierarchyModel;
exports.GraphHierarchyNode = GraphHierarchyNode;
exports.GraphLayout = GraphLayout;
exports.GraphView = GraphView;
exports.GraphViewCodec = GraphViewCodec;
exports.Guide = Guide;
exports.HandleConfig = HandleConfig;
exports.HexagonShape = HexagonShape;
exports.HierarchicalEdgeStyle = HierarchicalEdgeStyle;
exports.HierarchicalLayout = HierarchicalLayout;
exports.HierarchicalLayoutStage = HierarchicalLayoutStage;
exports.ImageBox = ImageBox;
exports.ImageBundle = ImageBundle;
exports.ImageExport = ImageExport;
exports.ImageShape = ImageShape;
exports.InternalEvent = InternalEvent;
exports.InternalMouseEvent = InternalMouseEvent;
exports.KeyHandler = KeyHandler;
exports.LabelShape = LabelShape;
exports.LayoutManager = LayoutManager;
exports.LineShape = LineShape;
exports.ManhattanConnectorConfig = ManhattanConnectorConfig;
exports.MarkerShape = MarkerShape;
exports.MaxForm = MaxForm;
exports.MaxLog = MaxLog;
exports.MaxLogAsLogger = MaxLogAsLogger;
exports.MaxPopupMenu = MaxPopupMenu;
exports.MaxToolbar = MaxToolbar;
exports.MaxWindow = MaxWindow;
exports.MaxXmlRequest = MaxXmlRequest;
exports.MedianHybridCrossingReduction = MedianHybridCrossingReduction;
exports.MinimumCycleRemover = MinimumCycleRemover;
exports.ModelCodec = ModelCodec;
exports.ModelXmlSerializer = ModelXmlSerializer;
exports.Morphing = Morphing;
exports.Multiplicity = Multiplicity;
exports.NoOpI18n = NoOpI18n;
exports.NoOpLogger = NoOpLogger;
exports.ObjectCodec = ObjectCodec;
exports.ObjectIdentity = ObjectIdentity;
exports.OrthogonalConnectorConfig = OrthogonalConnectorConfig;
exports.Outline = Outline;
exports.PanningHandler = PanningHandler;
exports.PanningManager = PanningManager;
exports.ParallelEdgeLayout = ParallelEdgeLayout;
exports.PartitionLayout = PartitionLayout;
exports.Perimeter = Perimeter;
exports.Point = Point;
exports.PolylineShape = PolylineShape;
exports.PopupMenuHandler = PopupMenuHandler;
exports.PrintPreview = PrintPreview;
exports.RadialTreeLayout = RadialTreeLayout;
exports.Rectangle = Rectangle;
exports.RectangleShape = RectangleShape;
exports.RhombusShape = RhombusShape;
exports.RootChange = RootChange;
exports.RootChangeCodec = RootChangeCodec;
exports.RubberBandHandler = RubberBandHandler;
exports.SelectionCellsHandler = SelectionCellsHandler;
exports.SelectionChange = SelectionChange;
exports.SelectionHandler = SelectionHandler;
exports.Shape = Shape;
exports.StackLayout = StackLayout;
exports.StencilShape = StencilShape;
exports.StencilShapeConfig = StencilShapeConfig;
exports.StencilShapeRegistry = StencilShapeRegistry;
exports.StyleChange = StyleChange;
exports.StyleDefaultsConfig = StyleDefaultsConfig;
exports.StyleRegistry = StyleRegistry;
exports.Stylesheet = Stylesheet;
exports.StylesheetCodec = StylesheetCodec;
exports.SvgCanvas2D = SvgCanvas2D;
exports.SwimlaneLayout = SwimlaneLayout;
exports.SwimlaneManager = SwimlaneManager;
exports.SwimlaneModel = SwimlaneModel;
exports.SwimlaneOrdering = SwimlaneOrdering;
exports.SwimlaneShape = SwimlaneShape;
exports.TemporaryCellStates = TemporaryCellStates;
exports.TerminalChange = TerminalChange;
exports.TerminalChangeCodec = TerminalChangeCodec;
exports.TextShape = TextShape;
exports.TooltipHandler = TooltipHandler;
exports.Translations = Translations;
exports.TranslationsAsI18n = TranslationsAsI18n;
exports.TranslationsConfig = TranslationsConfig;
exports.TriangleShape = TriangleShape;
exports.UndoManager = UndoManager;
exports.UndoableEdit = UndoableEdit;
exports.UrlConverter = UrlConverter;
exports.ValueChange = ValueChange;
exports.VertexHandle = VertexHandle;
exports.VertexHandler = VertexHandler;
exports.VertexHandlerConfig = VertexHandlerConfig;
exports.VisibleChange = VisibleChange;
exports.XmlCanvas2D = XmlCanvas2D;
exports.cellArrayUtils = cellArrayUtils;
exports.cloneUtils = cloneUtils;
exports.constants = Constants;
exports.domUtils = domUtils;
exports.eventUtils = EventUtils;
exports.gestureUtils = gestureUtils;
exports.getDefaultPlugins = getDefaultPlugins;
exports.guiUtils = guiUtils;
exports.mathUtils = mathUtils;
exports.maxGraphToSvg = maxGraphToSvg;
exports.mxCellCodec = mxCellCodec;
exports.mxGeometryCodec = mxGeometryCodec;
exports.printUtils = printUtils;
exports.registerAllCodecs = registerAllCodecs;
exports.registerCoreCodecs = registerCoreCodecs;
exports.registerEditorCodecs = registerEditorCodecs;
exports.registerModelCodecs = registerModelCodecs;
exports.requestUtils = requestUtils;
exports.resetEdgeHandlerConfig = resetEdgeHandlerConfig;
exports.resetEntityRelationConnectorConfig = resetEntityRelationConnectorConfig;
exports.resetHandleConfig = resetHandleConfig;
exports.resetManhattanConnectorConfig = resetManhattanConnectorConfig;
exports.resetOrthogonalConnectorConfig = resetOrthogonalConnectorConfig;
exports.resetStyleDefaultsConfig = resetStyleDefaultsConfig;
exports.resetTranslationsConfig = resetTranslationsConfig;
exports.resetVertexHandlerConfig = resetVertexHandlerConfig;
exports.stringUtils = StringUtils;
exports.styleUtils = styleUtils;
exports.xmlUtils = xmlUtils;
//# sourceMappingURL=index.js.map
